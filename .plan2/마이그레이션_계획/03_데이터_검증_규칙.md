# 03. 데이터 검증 규칙

**작성일**: 2025년 1월
**문서 목적**: Excel → Supabase 마이그레이션 시 데이터 무결성 보장

---

## 📋 검증 단계 Overview

```
Phase 1: 기본 검증 (필수 필드, 타입)
    ↓
Phase 2: 참조 무결성 (FK 관계)
    ↓
Phase 3: 비즈니스 로직 (계산, 상태)
    ↓
Phase 4: 통계 검증 (레코드 수, 합계)
```

---

## 1️⃣ Phase 1: 기본 데이터 검증

### 1.1 필수 필드 검증

**companies 테이블**
```typescript
const validateCompanyRequired = (row: CompanyRow): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (!row.company_code?.trim()) {
    errors.push({
      table: 'companies',
      field: 'company_code',
      value: row.company_code,
      error: 'REQUIRED_FIELD_MISSING',
      message: '거래처 코드는 필수입니다'
    });
  }

  if (!row.company_name?.trim()) {
    errors.push({
      table: 'companies',
      field: 'company_name',
      value: row.company_name,
      error: 'REQUIRED_FIELD_MISSING',
      message: '거래처명은 필수입니다'
    });
  }

  if (!row.company_type) {
    errors.push({
      table: 'companies',
      field: 'company_type',
      value: row.company_type,
      error: 'REQUIRED_FIELD_MISSING',
      message: '거래처 유형은 필수입니다'
    });
  }

  return errors;
};
```

**items 테이블**
```typescript
const validateItemRequired = (row: ItemRow): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (!row.item_code?.trim()) {
    errors.push({
      table: 'items',
      field: 'item_code',
      value: row.item_code,
      error: 'REQUIRED_FIELD_MISSING',
      message: '품목 코드는 필수입니다'
    });
  }

  if (!row.item_name?.trim()) {
    errors.push({
      table: 'items',
      field: 'item_name',
      value: row.item_name,
      error: 'REQUIRED_FIELD_MISSING',
      message: '품명은 필수입니다'
    });
  }

  if (!row.category) {
    errors.push({
      table: 'items',
      field: 'category',
      value: row.category,
      error: 'REQUIRED_FIELD_MISSING',
      message: '품목 분류는 필수입니다'
    });
  }

  if (!row.unit?.trim()) {
    errors.push({
      table: 'items',
      field: 'unit',
      value: row.unit,
      error: 'REQUIRED_FIELD_MISSING',
      message: '단위는 필수입니다'
    });
  }

  return errors;
};
```

### 1.2 Enum 값 검증

**company_type 검증**
```typescript
const VALID_COMPANY_TYPES = ['고객사', '공급사', '협력사', '기타'] as const;

const validateCompanyType = (value: string): boolean => {
  return VALID_COMPANY_TYPES.includes(value as any);
};

// Excel 매핑 시 변환
const normalizeCompanyType = (excelValue: string): string => {
  const mapping: Record<string, string> = {
    '고객': '고객사',
    '공급': '공급사',
    '협력': '협력사',
    'CUSTOMER': '고객사',
    'SUPPLIER': '공급사',
    'PARTNER': '협력사',
    'OTHER': '기타'
  };

  return mapping[excelValue] || excelValue;
};
```

**item_category 검증**
```typescript
const VALID_ITEM_CATEGORIES = [
  '원자재',
  '부자재',
  '반제품',
  '제품',
  '상품'
] as const;

const validateItemCategory = (value: string): boolean => {
  return VALID_ITEM_CATEGORIES.includes(value as any);
};

// Excel 매핑 시 변환
const normalizeItemCategory = (excelValue: string): string => {
  const mapping: Record<string, string> = {
    '원재료': '원자재',
    '자재': '원자재',
    '부품': '부자재',
    '반제': '반제품',
    '완제품': '제품',
    '제품품': '제품',
    '상품품': '상품'
  };

  return mapping[excelValue] || excelValue;
};
```

**transaction_type 검증**
```typescript
const VALID_TRANSACTION_TYPES = [
  '입고',
  '출고',
  '생산입고',
  '생산출고',
  '이동',
  '조정'
] as const;

const validateTransactionType = (value: string): boolean => {
  return VALID_TRANSACTION_TYPES.includes(value as any);
};
```

### 1.3 데이터 타입 검증

**숫자 필드 검증**
```typescript
const validateNumericField = (
  value: any,
  fieldName: string,
  options: {
    min?: number;
    max?: number;
    allowNegative?: boolean;
    decimalPlaces?: number;
  } = {}
): ValidationError | null => {
  // null/undefined 허용 여부는 필수 필드 검증에서 처리
  if (value === null || value === undefined) return null;

  const num = parseFloat(value);

  if (isNaN(num)) {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_NUMBER',
      message: `${fieldName}은(는) 숫자여야 합니다`
    };
  }

  if (options.min !== undefined && num < options.min) {
    return {
      field: fieldName,
      value: num,
      error: 'VALUE_TOO_SMALL',
      message: `${fieldName}은(는) ${options.min} 이상이어야 합니다`
    };
  }

  if (options.max !== undefined && num > options.max) {
    return {
      field: fieldName,
      value: num,
      error: 'VALUE_TOO_LARGE',
      message: `${fieldName}은(는) ${options.max} 이하여야 합니다`
    };
  }

  if (!options.allowNegative && num < 0) {
    return {
      field: fieldName,
      value: num,
      error: 'NEGATIVE_NOT_ALLOWED',
      message: `${fieldName}은(는) 음수가 될 수 없습니다`
    };
  }

  if (options.decimalPlaces !== undefined) {
    const decimals = (num.toString().split('.')[1] || '').length;
    if (decimals > options.decimalPlaces) {
      return {
        field: fieldName,
        value: num,
        error: 'TOO_MANY_DECIMALS',
        message: `${fieldName}은(는) 소수점 ${options.decimalPlaces}자리까지만 허용됩니다`
      };
    }
  }

  return null;
};

// 사용 예시
const errors: ValidationError[] = [];

// 두께: 0.01 ~ 100mm, 소수점 2자리
const thicknessError = validateNumericField(row.thickness, '두께', {
  min: 0.01,
  max: 100,
  allowNegative: false,
  decimalPlaces: 2
});
if (thicknessError) errors.push(thicknessError);

// 수량: 0 이상, 소수점 3자리
const quantityError = validateNumericField(row.quantity, '수량', {
  min: 0,
  allowNegative: false,
  decimalPlaces: 3
});
if (quantityError) errors.push(quantityError);

// 단가: 0 이상, 소수점 2자리
const priceError = validateNumericField(row.price, '단가', {
  min: 0,
  allowNegative: false,
  decimalPlaces: 2
});
if (priceError) errors.push(priceError);
```

**날짜 필드 검증**
```typescript
const validateDateField = (
  value: any,
  fieldName: string,
  options: {
    minDate?: Date;
    maxDate?: Date;
    allowFuture?: boolean;
  } = {}
): ValidationError | null => {
  if (value === null || value === undefined) return null;

  let date: Date;

  if (value instanceof Date) {
    date = value;
  } else if (typeof value === 'string') {
    date = new Date(value);
  } else if (typeof value === 'number') {
    // Excel serial date number
    date = new Date((value - 25569) * 86400 * 1000);
  } else {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_DATE_FORMAT',
      message: `${fieldName}의 날짜 형식이 올바르지 않습니다`
    };
  }

  if (isNaN(date.getTime())) {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_DATE',
      message: `${fieldName}은(는) 유효한 날짜여야 합니다`
    };
  }

  if (options.minDate && date < options.minDate) {
    return {
      field: fieldName,
      value: date,
      error: 'DATE_TOO_EARLY',
      message: `${fieldName}은(는) ${options.minDate.toISOString().split('T')[0]} 이후여야 합니다`
    };
  }

  if (options.maxDate && date > options.maxDate) {
    return {
      field: fieldName,
      value: date,
      error: 'DATE_TOO_LATE',
      message: `${fieldName}은(는) ${options.maxDate.toISOString().split('T')[0]} 이전이어야 합니다`
    };
  }

  if (!options.allowFuture && date > new Date()) {
    return {
      field: fieldName,
      value: date,
      error: 'FUTURE_DATE_NOT_ALLOWED',
      message: `${fieldName}은(는) 미래 날짜가 될 수 없습니다`
    };
  }

  return null;
};
```

### 1.4 문자열 길이 및 형식 검증

```typescript
const validateStringField = (
  value: any,
  fieldName: string,
  options: {
    minLength?: number;
    maxLength?: number;
    pattern?: RegExp;
    allowEmpty?: boolean;
  } = {}
): ValidationError | null => {
  if (value === null || value === undefined) return null;

  const str = String(value).trim();

  if (!options.allowEmpty && str.length === 0) {
    return {
      field: fieldName,
      value: value,
      error: 'EMPTY_STRING',
      message: `${fieldName}은(는) 비어있을 수 없습니다`
    };
  }

  if (options.minLength !== undefined && str.length < options.minLength) {
    return {
      field: fieldName,
      value: str,
      error: 'STRING_TOO_SHORT',
      message: `${fieldName}은(는) 최소 ${options.minLength}자 이상이어야 합니다`
    };
  }

  if (options.maxLength !== undefined && str.length > options.maxLength) {
    return {
      field: fieldName,
      value: str,
      error: 'STRING_TOO_LONG',
      message: `${fieldName}은(는) 최대 ${options.maxLength}자까지 허용됩니다`
    };
  }

  if (options.pattern && !options.pattern.test(str)) {
    return {
      field: fieldName,
      value: str,
      error: 'PATTERN_MISMATCH',
      message: `${fieldName}의 형식이 올바르지 않습니다`
    };
  }

  return null;
};

// 사용 예시
const businessNumberError = validateStringField(
  row.business_number,
  '사업자번호',
  {
    pattern: /^\d{3}-\d{2}-\d{5}$/,
    maxLength: 12
  }
);

const phoneError = validateStringField(
  row.phone,
  '전화번호',
  {
    pattern: /^0\d{1,2}-\d{3,4}-\d{4}$/,
    maxLength: 13
  }
);
```

---

## 2️⃣ Phase 2: 참조 무결성 검증

### 2.1 Foreign Key 존재 여부 검증

**supplier_id (items → companies)**
```typescript
const validateSupplierFK = async (
  itemRows: ItemRow[],
  companiesMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of itemRows) {
    if (!row.supplier_code) continue; // nullable field

    const companyId = companiesMap.get(row.supplier_code);

    if (!companyId) {
      errors.push({
        table: 'items',
        field: 'supplier_id',
        value: row.supplier_code,
        error: 'FK_NOT_FOUND',
        message: `공급사 코드 '${row.supplier_code}'를 companies 테이블에서 찾을 수 없습니다`,
        rowData: {
          item_code: row.item_code,
          item_name: row.item_name
        }
      });
    }
  }

  return errors;
};
```

**parent_item_id & child_item_id (bom → items)**
```typescript
const validateBomFK = async (
  bomRows: BomRow[],
  itemsMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of bomRows) {
    // parent_item_id 검증
    const parentId = itemsMap.get(row.parent_item_code);
    if (!parentId) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id',
        value: row.parent_item_code,
        error: 'FK_NOT_FOUND',
        message: `부모 품목 코드 '${row.parent_item_code}'를 items 테이블에서 찾을 수 없습니다`,
        rowData: {
          parent_item_name: row.parent_item_name,
          child_item_code: row.child_item_code
        }
      });
    }

    // child_item_id 검증
    const childId = itemsMap.get(row.child_item_code);
    if (!childId) {
      errors.push({
        table: 'bom',
        field: 'child_item_id',
        value: row.child_item_code,
        error: 'FK_NOT_FOUND',
        message: `자식 품목 코드 '${row.child_item_code}'를 items 테이블에서 찾을 수 없습니다`,
        rowData: {
          parent_item_code: row.parent_item_code,
          child_item_name: row.child_item_name
        }
      });
    }

    // 순환 참조 방지 (parent === child)
    if (row.parent_item_code === row.child_item_code) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id',
        value: row.parent_item_code,
        error: 'CIRCULAR_REFERENCE',
        message: `품목이 자기 자신을 자식으로 참조할 수 없습니다: ${row.parent_item_code}`,
        rowData: row
      });
    }
  }

  return errors;
};
```

**item_id (inventory_transactions → items)**
```typescript
const validateInventoryTransactionFK = async (
  transactionRows: InventoryTransactionRow[],
  itemsMap: Map<string, number>,
  companiesMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of transactionRows) {
    // item_id 검증 (필수)
    const itemId = itemsMap.get(row.item_code);
    if (!itemId) {
      errors.push({
        table: 'inventory_transactions',
        field: 'item_id',
        value: row.item_code,
        error: 'FK_NOT_FOUND',
        message: `품목 코드 '${row.item_code}'를 items 테이블에서 찾을 수 없습니다`,
        rowData: {
          transaction_date: row.transaction_date,
          quantity: row.quantity
        }
      });
    }

    // company_id 검증 (nullable)
    if (row.company_code) {
      const companyId = companiesMap.get(row.company_code);
      if (!companyId) {
        errors.push({
          table: 'inventory_transactions',
          field: 'company_id',
          value: row.company_code,
          error: 'FK_NOT_FOUND',
          message: `거래처 코드 '${row.company_code}'를 companies 테이블에서 찾을 수 없습니다`,
          rowData: {
            item_code: row.item_code,
            transaction_date: row.transaction_date
          }
        });
      }
    }
  }

  return errors;
};
```

### 2.2 중복 키 검증

**company_code 중복 검사**
```typescript
const validateCompanyCodeUnique = (rows: CompanyRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const codeMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const code = row.company_code?.trim().toUpperCase();
    if (!code) return;

    if (codeMap.has(code)) {
      errors.push({
        table: 'companies',
        field: 'company_code',
        value: code,
        error: 'DUPLICATE_KEY',
        message: `거래처 코드 '${code}'가 중복되었습니다`,
        rowData: {
          row_number: index + 1,
          first_occurrence: codeMap.get(code)! + 1,
          company_name: row.company_name
        }
      });
    } else {
      codeMap.set(code, index);
    }
  });

  return errors;
};
```

**item_code 중복 검사**
```typescript
const validateItemCodeUnique = (rows: ItemRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const codeMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const code = row.item_code?.trim().toUpperCase();
    if (!code) return;

    if (codeMap.has(code)) {
      errors.push({
        table: 'items',
        field: 'item_code',
        value: code,
        error: 'DUPLICATE_KEY',
        message: `품목 코드 '${code}'가 중복되었습니다`,
        rowData: {
          row_number: index + 1,
          first_occurrence: codeMap.get(code)! + 1,
          item_name: row.item_name
        }
      });
    } else {
      codeMap.set(code, index);
    }
  });

  return errors;
};
```

**BOM 중복 관계 검사**
```typescript
const validateBomUnique = (rows: BomRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const relationMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const key = `${row.parent_item_code}|${row.child_item_code}`;

    if (relationMap.has(key)) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id, child_item_id',
        value: key,
        error: 'DUPLICATE_BOM_RELATION',
        message: `BOM 관계가 중복되었습니다: ${row.parent_item_code} → ${row.child_item_code}`,
        rowData: {
          row_number: index + 1,
          first_occurrence: relationMap.get(key)! + 1
        }
      });
    } else {
      relationMap.set(key, index);
    }
  });

  return errors;
};
```

---

## 3️⃣ Phase 3: 비즈니스 로직 검증

### 3.1 COIL Specs 계산 검증

```typescript
interface CoilSpecCalculation {
  thickness: number;
  width: number;
  length: number;
  density: number;
  sep_factor: number;
  kg_unit_price: number;
}

const validateCoilSpecCalculations = (
  row: CoilSpecCalculation
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // 1. EA중량 계산
  const expectedWeightPerPiece =
    (row.density * row.length * row.width * row.thickness) /
    1_000_000 /
    row.sep_factor;

  const calculatedWeightPerPiece = row.weight_per_piece;
  const weightDiff = Math.abs(expectedWeightPerPiece - calculatedWeightPerPiece);

  if (weightDiff > 0.001) {
    errors.push({
      table: 'coil_specs',
      field: 'weight_per_piece',
      value: calculatedWeightPerPiece,
      error: 'CALCULATION_MISMATCH',
      message: `EA중량 계산이 일치하지 않습니다. 예상: ${expectedWeightPerPiece.toFixed(6)}, 실제: ${calculatedWeightPerPiece}`,
      rowData: {
        item_code: row.item_code,
        formula: `(${row.density} × ${row.length} × ${row.width} × ${row.thickness}) / 1,000,000 / ${row.sep_factor}`
      }
    });
  }

  // 2. EA단가 계산
  const expectedPieceUnitPrice = row.kg_unit_price * expectedWeightPerPiece;
  const calculatedPieceUnitPrice = row.piece_unit_price;
  const priceDiff = Math.abs(expectedPieceUnitPrice - calculatedPieceUnitPrice);

  if (priceDiff > 0.01) {
    errors.push({
      table: 'coil_specs',
      field: 'piece_unit_price',
      value: calculatedPieceUnitPrice,
      error: 'CALCULATION_MISMATCH',
      message: `EA단가 계산이 일치하지 않습니다. 예상: ${expectedPieceUnitPrice.toFixed(2)}, 실제: ${calculatedPieceUnitPrice}`,
      rowData: {
        item_code: row.item_code,
        kg_unit_price: row.kg_unit_price,
        weight_per_piece: expectedWeightPerPiece
      }
    });
  }

  // 3. 물리적 제약 검증
  if (row.sep_factor <= 0 || row.sep_factor > 100) {
    errors.push({
      table: 'coil_specs',
      field: 'sep_factor',
      value: row.sep_factor,
      error: 'INVALID_VALUE',
      message: `SEP 값이 유효 범위(0 < SEP ≤ 100)를 벗어났습니다`
    });
  }

  if (row.density <= 0 || row.density > 20) {
    errors.push({
      table: 'coil_specs',
      field: 'density',
      value: row.density,
      error: 'INVALID_VALUE',
      message: `비중 값이 유효 범위(0 < 비중 ≤ 20)를 벗어났습니다`
    });
  }

  return errors;
};
```

### 3.2 Scrap Tracking 계산 검증

```typescript
interface ScrapCalculation {
  production_quantity: number;
  scrap_weight_per_unit: number;
  scrap_unit_price: number;
  scrap_revenue: number;
}

const validateScrapCalculations = (
  row: ScrapCalculation
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // 스크랩금액 = 실적수량 × 스크랩중량 × 스크랩단가
  const expectedRevenue =
    row.production_quantity *
    row.scrap_weight_per_unit *
    row.scrap_unit_price;

  const diff = Math.abs(expectedRevenue - row.scrap_revenue);

  if (diff > 0.01) {
    errors.push({
      table: 'scrap_tracking',
      field: 'scrap_revenue',
      value: row.scrap_revenue,
      error: 'CALCULATION_MISMATCH',
      message: `스크랩금액 계산이 일치하지 않습니다. 예상: ${expectedRevenue.toFixed(2)}, 실제: ${row.scrap_revenue}`,
      rowData: {
        production_quantity: row.production_quantity,
        scrap_weight_per_unit: row.scrap_weight_per_unit,
        scrap_unit_price: row.scrap_unit_price,
        formula: `${row.production_quantity} × ${row.scrap_weight_per_unit} × ${row.scrap_unit_price}`
      }
    });
  }

  return errors;
};
```

### 3.3 Price Master 유효성 검증

```typescript
interface PriceMasterValidation {
  item_id: number;
  effective_date: Date;
  expiry_date?: Date;
  unit_price: number;
}

const validatePriceMaster = (rows: PriceMasterValidation[]): ValidationError[] => {
  const errors: ValidationError[] = [];

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];

    // 1. 유효기간 검증 (effective_date < expiry_date)
    if (row.expiry_date && row.effective_date >= row.expiry_date) {
      errors.push({
        table: 'price_master',
        field: 'expiry_date',
        value: row.expiry_date,
        error: 'INVALID_DATE_RANGE',
        message: `만료일이 시작일보다 이르거나 같습니다`,
        rowData: {
          item_id: row.item_id,
          effective_date: row.effective_date,
          expiry_date: row.expiry_date
        }
      });
    }

    // 2. 같은 품목의 가격 기간 중복 검증
    for (let j = i + 1; j < rows.length; j++) {
      const other = rows[j];

      if (row.item_id !== other.item_id) continue;

      const rowEnd = row.expiry_date || new Date('9999-12-31');
      const otherEnd = other.expiry_date || new Date('9999-12-31');

      // 기간 겹침 체크
      const overlap =
        row.effective_date <= otherEnd &&
        other.effective_date <= rowEnd;

      if (overlap) {
        errors.push({
          table: 'price_master',
          field: 'effective_date',
          value: row.effective_date,
          error: 'OVERLAPPING_PRICE_PERIOD',
          message: `같은 품목의 가격 기간이 중복됩니다`,
          rowData: {
            item_id: row.item_id,
            period1: `${row.effective_date} ~ ${rowEnd}`,
            period2: `${other.effective_date} ~ ${otherEnd}`
          }
        });
      }
    }

    // 3. 단가 음수 검증
    if (row.unit_price < 0) {
      errors.push({
        table: 'price_master',
        field: 'unit_price',
        value: row.unit_price,
        error: 'NEGATIVE_PRICE',
        message: `단가는 음수가 될 수 없습니다`,
        rowData: {
          item_id: row.item_id
        }
      });
    }
  }

  return errors;
};
```

### 3.4 재고 수량 검증

```typescript
const validateInventoryQuantity = (
  transactions: InventoryTransactionRow[]
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // 품목별로 그룹화
  const itemTransactions = new Map<string, InventoryTransactionRow[]>();

  for (const tx of transactions) {
    const list = itemTransactions.get(tx.item_code) || [];
    list.push(tx);
    itemTransactions.set(tx.item_code, list);
  }

  // 각 품목별 재고 추적
  for (const [itemCode, txList] of itemTransactions) {
    // 날짜순 정렬
    txList.sort((a, b) =>
      new Date(a.transaction_date).getTime() - new Date(b.transaction_date).getTime()
    );

    let runningStock = 0;

    for (const tx of txList) {
      // 거래 유형에 따라 재고 증감
      if (tx.transaction_type === '입고' || tx.transaction_type === '생산입고') {
        runningStock += tx.quantity;
      } else if (tx.transaction_type === '출고' || tx.transaction_type === '생산출고') {
        runningStock -= tx.quantity;
      } else if (tx.transaction_type === '조정') {
        runningStock = tx.quantity; // 조정은 절대값 설정
      }

      // 음수 재고 검증
      if (runningStock < 0) {
        errors.push({
          table: 'inventory_transactions',
          field: 'quantity',
          value: tx.quantity,
          error: 'NEGATIVE_STOCK',
          message: `거래 후 재고가 음수가 됩니다`,
          rowData: {
            item_code: itemCode,
            transaction_date: tx.transaction_date,
            transaction_type: tx.transaction_type,
            running_stock: runningStock
          }
        });
      }
    }
  }

  return errors;
};
```

---

## 4️⃣ Phase 4: 통계 검증

### 4.1 레코드 수 검증

```typescript
interface RecordCountValidation {
  expectedCounts: {
    companies: number;
    items: number;
    bom: number;
    coil_specs: number;
    price_master: number;
    scrap_tracking: number;
    inventory_transactions: number;
    purchase_transactions: number;
    sales_transactions: number;
  };
}

const validateRecordCounts = async (
  supabase: SupabaseClient,
  expected: RecordCountValidation['expectedCounts']
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const [table, expectedCount] of Object.entries(expected)) {
    const { count, error } = await supabase
      .from(table)
      .select('*', { count: 'exact', head: true });

    if (error) {
      errors.push({
        table,
        field: 'record_count',
        error: 'QUERY_ERROR',
        message: `레코드 수 조회 실패: ${error.message}`
      });
      continue;
    }

    if (count !== expectedCount) {
      errors.push({
        table,
        field: 'record_count',
        value: count,
        error: 'COUNT_MISMATCH',
        message: `레코드 수가 예상과 다릅니다. 예상: ${expectedCount}, 실제: ${count}`,
        rowData: {
          difference: count! - expectedCount
        }
      });
    }
  }

  return errors;
};
```

### 4.2 합계 검증 (금액, 수량)

```typescript
interface AggregateValidation {
  table: string;
  field: string;
  expectedSum: number;
  tolerance?: number;
}

const validateAggregates = async (
  supabase: SupabaseClient,
  validations: AggregateValidation[]
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const validation of validations) {
    const { data, error } = await supabase
      .from(validation.table)
      .select(validation.field);

    if (error) {
      errors.push({
        table: validation.table,
        field: validation.field,
        error: 'QUERY_ERROR',
        message: `합계 조회 실패: ${error.message}`
      });
      continue;
    }

    const actualSum = data.reduce(
      (sum, row) => sum + (row[validation.field] || 0),
      0
    );

    const tolerance = validation.tolerance || 0.01;
    const diff = Math.abs(actualSum - validation.expectedSum);

    if (diff > tolerance) {
      errors.push({
        table: validation.table,
        field: validation.field,
        value: actualSum,
        error: 'SUM_MISMATCH',
        message: `합계가 예상과 다릅니다. 예상: ${validation.expectedSum.toFixed(2)}, 실제: ${actualSum.toFixed(2)}`,
        rowData: {
          difference: diff.toFixed(2),
          tolerance: tolerance
        }
      });
    }
  }

  return errors;
};

// 사용 예시
const aggregateValidations: AggregateValidation[] = [
  {
    table: 'inventory_transactions',
    field: 'quantity',
    expectedSum: 125430.5,
    tolerance: 1.0
  },
  {
    table: 'purchase_transactions',
    field: 'total_amount',
    expectedSum: 45_678_900,
    tolerance: 100
  },
  {
    table: 'scrap_tracking',
    field: 'scrap_revenue',
    expectedSum: 2_345_678,
    tolerance: 100
  }
];
```

### 4.3 참조 무결성 통계 (Orphan 레코드)

```typescript
const validateOrphanRecords = async (
  supabase: SupabaseClient
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  // 1. items.supplier_id → companies.company_id
  const { data: orphanSuppliers, error: err1 } = await supabase.rpc(
    'find_orphan_suppliers',
    {}
  );

  if (orphanSuppliers && orphanSuppliers.length > 0) {
    errors.push({
      table: 'items',
      field: 'supplier_id',
      error: 'ORPHAN_FK',
      message: `${orphanSuppliers.length}개의 품목이 존재하지 않는 공급사를 참조합니다`,
      rowData: {
        orphan_count: orphanSuppliers.length,
        sample_items: orphanSuppliers.slice(0, 5)
      }
    });
  }

  // 2. bom.parent_item_id → items.item_id
  const { data: orphanParents, error: err2 } = await supabase.rpc(
    'find_orphan_bom_parents',
    {}
  );

  if (orphanParents && orphanParents.length > 0) {
    errors.push({
      table: 'bom',
      field: 'parent_item_id',
      error: 'ORPHAN_FK',
      message: `${orphanParents.length}개의 BOM이 존재하지 않는 부모 품목을 참조합니다`,
      rowData: {
        orphan_count: orphanParents.length,
        sample_boms: orphanParents.slice(0, 5)
      }
    });
  }

  // 3. bom.child_item_id → items.item_id
  const { data: orphanChildren, error: err3 } = await supabase.rpc(
    'find_orphan_bom_children',
    {}
  );

  if (orphanChildren && orphanChildren.length > 0) {
    errors.push({
      table: 'bom',
      field: 'child_item_id',
      error: 'ORPHAN_FK',
      message: `${orphanChildren.length}개의 BOM이 존재하지 않는 자식 품목을 참조합니다`,
      rowData: {
        orphan_count: orphanChildren.length,
        sample_boms: orphanChildren.slice(0, 5)
      }
    });
  }

  return errors;
};

// Supabase SQL 함수 (미리 생성 필요)
/*
CREATE OR REPLACE FUNCTION find_orphan_suppliers()
RETURNS TABLE (
  item_id INT,
  item_code TEXT,
  item_name TEXT,
  supplier_id INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT i.item_id, i.item_code, i.item_name, i.supplier_id
  FROM items i
  LEFT JOIN companies c ON i.supplier_id = c.company_id
  WHERE i.supplier_id IS NOT NULL AND c.company_id IS NULL;
END;
$$ LANGUAGE plpgsql;
*/
```

---

## 5️⃣ 검증 실행 워크플로우

### 5.1 전체 검증 오케스트레이터

```typescript
interface ValidationReport {
  summary: {
    totalErrors: number;
    errorsByPhase: Record<string, number>;
    errorsByTable: Record<string, number>;
    criticalErrors: number;
  };
  errors: ValidationError[];
  timestamp: string;
}

const runFullValidation = async (
  excelData: ParsedExcelData,
  supabase: SupabaseClient
): Promise<ValidationReport> => {
  const allErrors: ValidationError[] = [];
  const startTime = Date.now();

  console.log('🔍 Phase 1: 기본 데이터 검증 시작...');

  // Phase 1: 기본 검증
  const phase1Errors = [
    ...validateCompanyRequired(excelData.companies),
    ...validateItemRequired(excelData.items),
    ...validateCompanyCodeUnique(excelData.companies),
    ...validateItemCodeUnique(excelData.items),
    ...validateBomUnique(excelData.bom)
  ];

  allErrors.push(...phase1Errors.map(e => ({ ...e, phase: 'Phase 1' })));
  console.log(`  ✅ Phase 1 완료: ${phase1Errors.length}개 오류 발견`);

  // Phase 2: 참조 무결성
  console.log('🔍 Phase 2: 참조 무결성 검증 시작...');

  const companiesMap = new Map(
    excelData.companies.map(c => [c.company_code, c.company_id])
  );
  const itemsMap = new Map(
    excelData.items.map(i => [i.item_code, i.item_id])
  );

  const phase2Errors = [
    ...(await validateSupplierFK(excelData.items, companiesMap)),
    ...(await validateBomFK(excelData.bom, itemsMap)),
    ...(await validateInventoryTransactionFK(
      excelData.inventory_transactions,
      itemsMap,
      companiesMap
    ))
  ];

  allErrors.push(...phase2Errors.map(e => ({ ...e, phase: 'Phase 2' })));
  console.log(`  ✅ Phase 2 완료: ${phase2Errors.length}개 오류 발견`);

  // Phase 3: 비즈니스 로직
  console.log('🔍 Phase 3: 비즈니스 로직 검증 시작...');

  const phase3Errors = [
    ...excelData.coil_specs.flatMap(validateCoilSpecCalculations),
    ...excelData.scrap_tracking.flatMap(validateScrapCalculations),
    ...validatePriceMaster(excelData.price_master),
    ...validateInventoryQuantity(excelData.inventory_transactions)
  ];

  allErrors.push(...phase3Errors.map(e => ({ ...e, phase: 'Phase 3' })));
  console.log(`  ✅ Phase 3 완료: ${phase3Errors.length}개 오류 발견`);

  // Phase 4: 통계 검증
  console.log('🔍 Phase 4: 통계 검증 시작...');

  const expectedCounts = {
    companies: excelData.companies.length,
    items: excelData.items.length,
    bom: excelData.bom.length,
    coil_specs: excelData.coil_specs.length,
    price_master: excelData.price_master.length,
    scrap_tracking: excelData.scrap_tracking.length,
    inventory_transactions: excelData.inventory_transactions.length,
    purchase_transactions: excelData.purchase_transactions.length,
    sales_transactions: excelData.sales_transactions.length
  };

  const phase4Errors = [
    ...(await validateRecordCounts(supabase, expectedCounts)),
    ...(await validateAggregates(supabase, aggregateValidations)),
    ...(await validateOrphanRecords(supabase))
  ];

  allErrors.push(...phase4Errors.map(e => ({ ...e, phase: 'Phase 4' })));
  console.log(`  ✅ Phase 4 완료: ${phase4Errors.length}개 오류 발견`);

  const duration = Date.now() - startTime;
  console.log(`\n⏱️ 전체 검증 완료: ${(duration / 1000).toFixed(1)}초`);

  // 보고서 생성
  const report: ValidationReport = {
    summary: {
      totalErrors: allErrors.length,
      errorsByPhase: allErrors.reduce((acc, err) => {
        acc[err.phase] = (acc[err.phase] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      errorsByTable: allErrors.reduce((acc, err) => {
        acc[err.table] = (acc[err.table] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      criticalErrors: allErrors.filter(e =>
        ['FK_NOT_FOUND', 'DUPLICATE_KEY', 'REQUIRED_FIELD_MISSING'].includes(e.error)
      ).length
    },
    errors: allErrors,
    timestamp: new Date().toISOString()
  };

  return report;
};
```

### 5.2 검증 리포트 생성

```typescript
const generateValidationReport = (report: ValidationReport): string => {
  const lines: string[] = [];

  lines.push('# 데이터 검증 리포트\n');
  lines.push(`**생성 일시**: ${report.timestamp}\n`);
  lines.push('---\n');

  // 요약
  lines.push('## 📊 검증 요약\n');
  lines.push(`- **총 오류 수**: ${report.summary.totalErrors}개`);
  lines.push(`- **치명적 오류**: ${report.summary.criticalErrors}개\n`);

  // Phase별 오류
  lines.push('### Phase별 오류 분포\n');
  for (const [phase, count] of Object.entries(report.summary.errorsByPhase)) {
    lines.push(`- ${phase}: ${count}개`);
  }
  lines.push('');

  // 테이블별 오류
  lines.push('### 테이블별 오류 분포\n');
  for (const [table, count] of Object.entries(report.summary.errorsByTable)) {
    lines.push(`- ${table}: ${count}개`);
  }
  lines.push('\n---\n');

  // 오류 상세
  if (report.errors.length > 0) {
    lines.push('## 🚨 오류 상세 내역\n');

    // Phase별로 그룹화
    const errorsByPhase = report.errors.reduce((acc, err) => {
      if (!acc[err.phase]) acc[err.phase] = [];
      acc[err.phase].push(err);
      return acc;
    }, {} as Record<string, ValidationError[]>);

    for (const [phase, errors] of Object.entries(errorsByPhase)) {
      lines.push(`### ${phase}\n`);

      errors.forEach((err, idx) => {
        lines.push(`#### ${idx + 1}. ${err.table}.${err.field}`);
        lines.push(`- **오류 코드**: \`${err.error}\``);
        lines.push(`- **메시지**: ${err.message}`);
        if (err.value !== undefined) {
          lines.push(`- **값**: ${JSON.stringify(err.value)}`);
        }
        if (err.rowData) {
          lines.push(`- **행 데이터**:`);
          lines.push('```json');
          lines.push(JSON.stringify(err.rowData, null, 2));
          lines.push('```');
        }
        lines.push('');
      });
    }
  } else {
    lines.push('## ✅ 검증 통과\n');
    lines.push('모든 검증 항목을 통과했습니다.\n');
  }

  return lines.join('\n');
};
```

---

## 6️⃣ 검증 실패 시 조치 사항

### Critical Errors (마이그레이션 중단)
- `REQUIRED_FIELD_MISSING`: 필수 필드 누락
- `FK_NOT_FOUND`: 참조 키 미존재
- `DUPLICATE_KEY`: 중복 키
- `CIRCULAR_REFERENCE`: 순환 참조

**조치**: 즉시 마이그레이션 중단하고 Excel 데이터 수정 후 재시도

### Warning Errors (계속 진행 가능, 확인 필요)
- `CALCULATION_MISMATCH`: 계산 불일치 (0.01 이하)
- `COUNT_MISMATCH`: 레코드 수 차이 (±5 이내)
- `SUM_MISMATCH`: 합계 차이 (tolerance 내)

**조치**: 로그에 기록하고 마이그레이션 완료 후 검토

---

**문서 완료** | 다음: [04_마이그레이션_실행_매뉴얼.md](./04_마이그레이션_실행_매뉴얼.md)
