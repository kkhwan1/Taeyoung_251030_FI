# 03. ë°ì´í„° ê²€ì¦ ê·œì¹™

**ì‘ì„±ì¼**: 2025ë…„ 1ì›”
**ë¬¸ì„œ ëª©ì **: Excel â†’ Supabase ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œ ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥

---

## ğŸ“‹ ê²€ì¦ ë‹¨ê³„ Overview

```
Phase 1: ê¸°ë³¸ ê²€ì¦ (í•„ìˆ˜ í•„ë“œ, íƒ€ì…)
    â†“
Phase 2: ì°¸ì¡° ë¬´ê²°ì„± (FK ê´€ê³„)
    â†“
Phase 3: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ê³„ì‚°, ìƒíƒœ)
    â†“
Phase 4: í†µê³„ ê²€ì¦ (ë ˆì½”ë“œ ìˆ˜, í•©ê³„)
```

---

## 1ï¸âƒ£ Phase 1: ê¸°ë³¸ ë°ì´í„° ê²€ì¦

### 1.1 í•„ìˆ˜ í•„ë“œ ê²€ì¦

**companies í…Œì´ë¸”**
```typescript
const validateCompanyRequired = (row: CompanyRow): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (!row.company_code?.trim()) {
    errors.push({
      table: 'companies',
      field: 'company_code',
      value: row.company_code,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'ê±°ë˜ì²˜ ì½”ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  if (!row.company_name?.trim()) {
    errors.push({
      table: 'companies',
      field: 'company_name',
      value: row.company_name,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'ê±°ë˜ì²˜ëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  if (!row.company_type) {
    errors.push({
      table: 'companies',
      field: 'company_type',
      value: row.company_type,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'ê±°ë˜ì²˜ ìœ í˜•ì€ í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  return errors;
};
```

**items í…Œì´ë¸”**
```typescript
const validateItemRequired = (row: ItemRow): ValidationError[] => {
  const errors: ValidationError[] = [];

  if (!row.item_code?.trim()) {
    errors.push({
      table: 'items',
      field: 'item_code',
      value: row.item_code,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'í’ˆëª© ì½”ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  if (!row.item_name?.trim()) {
    errors.push({
      table: 'items',
      field: 'item_name',
      value: row.item_name,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'í’ˆëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  if (!row.category) {
    errors.push({
      table: 'items',
      field: 'category',
      value: row.category,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'í’ˆëª© ë¶„ë¥˜ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  if (!row.unit?.trim()) {
    errors.push({
      table: 'items',
      field: 'unit',
      value: row.unit,
      error: 'REQUIRED_FIELD_MISSING',
      message: 'ë‹¨ìœ„ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤'
    });
  }

  return errors;
};
```

### 1.2 Enum ê°’ ê²€ì¦

**company_type ê²€ì¦**
```typescript
const VALID_COMPANY_TYPES = ['ê³ ê°ì‚¬', 'ê³µê¸‰ì‚¬', 'í˜‘ë ¥ì‚¬', 'ê¸°íƒ€'] as const;

const validateCompanyType = (value: string): boolean => {
  return VALID_COMPANY_TYPES.includes(value as any);
};

// Excel ë§¤í•‘ ì‹œ ë³€í™˜
const normalizeCompanyType = (excelValue: string): string => {
  const mapping: Record<string, string> = {
    'ê³ ê°': 'ê³ ê°ì‚¬',
    'ê³µê¸‰': 'ê³µê¸‰ì‚¬',
    'í˜‘ë ¥': 'í˜‘ë ¥ì‚¬',
    'CUSTOMER': 'ê³ ê°ì‚¬',
    'SUPPLIER': 'ê³µê¸‰ì‚¬',
    'PARTNER': 'í˜‘ë ¥ì‚¬',
    'OTHER': 'ê¸°íƒ€'
  };

  return mapping[excelValue] || excelValue;
};
```

**item_category ê²€ì¦**
```typescript
const VALID_ITEM_CATEGORIES = [
  'ì›ìì¬',
  'ë¶€ìì¬',
  'ë°˜ì œí’ˆ',
  'ì œí’ˆ',
  'ìƒí’ˆ'
] as const;

const validateItemCategory = (value: string): boolean => {
  return VALID_ITEM_CATEGORIES.includes(value as any);
};

// Excel ë§¤í•‘ ì‹œ ë³€í™˜
const normalizeItemCategory = (excelValue: string): string => {
  const mapping: Record<string, string> = {
    'ì›ì¬ë£Œ': 'ì›ìì¬',
    'ìì¬': 'ì›ìì¬',
    'ë¶€í’ˆ': 'ë¶€ìì¬',
    'ë°˜ì œ': 'ë°˜ì œí’ˆ',
    'ì™„ì œí’ˆ': 'ì œí’ˆ',
    'ì œí’ˆí’ˆ': 'ì œí’ˆ',
    'ìƒí’ˆí’ˆ': 'ìƒí’ˆ'
  };

  return mapping[excelValue] || excelValue;
};
```

**transaction_type ê²€ì¦**
```typescript
const VALID_TRANSACTION_TYPES = [
  'ì…ê³ ',
  'ì¶œê³ ',
  'ìƒì‚°ì…ê³ ',
  'ìƒì‚°ì¶œê³ ',
  'ì´ë™',
  'ì¡°ì •'
] as const;

const validateTransactionType = (value: string): boolean => {
  return VALID_TRANSACTION_TYPES.includes(value as any);
};
```

### 1.3 ë°ì´í„° íƒ€ì… ê²€ì¦

**ìˆ«ì í•„ë“œ ê²€ì¦**
```typescript
const validateNumericField = (
  value: any,
  fieldName: string,
  options: {
    min?: number;
    max?: number;
    allowNegative?: boolean;
    decimalPlaces?: number;
  } = {}
): ValidationError | null => {
  // null/undefined í—ˆìš© ì—¬ë¶€ëŠ” í•„ìˆ˜ í•„ë“œ ê²€ì¦ì—ì„œ ì²˜ë¦¬
  if (value === null || value === undefined) return null;

  const num = parseFloat(value);

  if (isNaN(num)) {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_NUMBER',
      message: `${fieldName}ì€(ëŠ”) ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (options.min !== undefined && num < options.min) {
    return {
      field: fieldName,
      value: num,
      error: 'VALUE_TOO_SMALL',
      message: `${fieldName}ì€(ëŠ”) ${options.min} ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (options.max !== undefined && num > options.max) {
    return {
      field: fieldName,
      value: num,
      error: 'VALUE_TOO_LARGE',
      message: `${fieldName}ì€(ëŠ”) ${options.max} ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (!options.allowNegative && num < 0) {
    return {
      field: fieldName,
      value: num,
      error: 'NEGATIVE_NOT_ALLOWED',
      message: `${fieldName}ì€(ëŠ”) ìŒìˆ˜ê°€ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`
    };
  }

  if (options.decimalPlaces !== undefined) {
    const decimals = (num.toString().split('.')[1] || '').length;
    if (decimals > options.decimalPlaces) {
      return {
        field: fieldName,
        value: num,
        error: 'TOO_MANY_DECIMALS',
        message: `${fieldName}ì€(ëŠ”) ì†Œìˆ˜ì  ${options.decimalPlaces}ìë¦¬ê¹Œì§€ë§Œ í—ˆìš©ë©ë‹ˆë‹¤`
      };
    }
  }

  return null;
};

// ì‚¬ìš© ì˜ˆì‹œ
const errors: ValidationError[] = [];

// ë‘ê»˜: 0.01 ~ 100mm, ì†Œìˆ˜ì  2ìë¦¬
const thicknessError = validateNumericField(row.thickness, 'ë‘ê»˜', {
  min: 0.01,
  max: 100,
  allowNegative: false,
  decimalPlaces: 2
});
if (thicknessError) errors.push(thicknessError);

// ìˆ˜ëŸ‰: 0 ì´ìƒ, ì†Œìˆ˜ì  3ìë¦¬
const quantityError = validateNumericField(row.quantity, 'ìˆ˜ëŸ‰', {
  min: 0,
  allowNegative: false,
  decimalPlaces: 3
});
if (quantityError) errors.push(quantityError);

// ë‹¨ê°€: 0 ì´ìƒ, ì†Œìˆ˜ì  2ìë¦¬
const priceError = validateNumericField(row.price, 'ë‹¨ê°€', {
  min: 0,
  allowNegative: false,
  decimalPlaces: 2
});
if (priceError) errors.push(priceError);
```

**ë‚ ì§œ í•„ë“œ ê²€ì¦**
```typescript
const validateDateField = (
  value: any,
  fieldName: string,
  options: {
    minDate?: Date;
    maxDate?: Date;
    allowFuture?: boolean;
  } = {}
): ValidationError | null => {
  if (value === null || value === undefined) return null;

  let date: Date;

  if (value instanceof Date) {
    date = value;
  } else if (typeof value === 'string') {
    date = new Date(value);
  } else if (typeof value === 'number') {
    // Excel serial date number
    date = new Date((value - 25569) * 86400 * 1000);
  } else {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_DATE_FORMAT',
      message: `${fieldName}ì˜ ë‚ ì§œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤`
    };
  }

  if (isNaN(date.getTime())) {
    return {
      field: fieldName,
      value: value,
      error: 'INVALID_DATE',
      message: `${fieldName}ì€(ëŠ”) ìœ íš¨í•œ ë‚ ì§œì—¬ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (options.minDate && date < options.minDate) {
    return {
      field: fieldName,
      value: date,
      error: 'DATE_TOO_EARLY',
      message: `${fieldName}ì€(ëŠ”) ${options.minDate.toISOString().split('T')[0]} ì´í›„ì—¬ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (options.maxDate && date > options.maxDate) {
    return {
      field: fieldName,
      value: date,
      error: 'DATE_TOO_LATE',
      message: `${fieldName}ì€(ëŠ”) ${options.maxDate.toISOString().split('T')[0]} ì´ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (!options.allowFuture && date > new Date()) {
    return {
      field: fieldName,
      value: date,
      error: 'FUTURE_DATE_NOT_ALLOWED',
      message: `${fieldName}ì€(ëŠ”) ë¯¸ë˜ ë‚ ì§œê°€ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`
    };
  }

  return null;
};
```

### 1.4 ë¬¸ìì—´ ê¸¸ì´ ë° í˜•ì‹ ê²€ì¦

```typescript
const validateStringField = (
  value: any,
  fieldName: string,
  options: {
    minLength?: number;
    maxLength?: number;
    pattern?: RegExp;
    allowEmpty?: boolean;
  } = {}
): ValidationError | null => {
  if (value === null || value === undefined) return null;

  const str = String(value).trim();

  if (!options.allowEmpty && str.length === 0) {
    return {
      field: fieldName,
      value: value,
      error: 'EMPTY_STRING',
      message: `${fieldName}ì€(ëŠ”) ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`
    };
  }

  if (options.minLength !== undefined && str.length < options.minLength) {
    return {
      field: fieldName,
      value: str,
      error: 'STRING_TOO_SHORT',
      message: `${fieldName}ì€(ëŠ”) ìµœì†Œ ${options.minLength}ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤`
    };
  }

  if (options.maxLength !== undefined && str.length > options.maxLength) {
    return {
      field: fieldName,
      value: str,
      error: 'STRING_TOO_LONG',
      message: `${fieldName}ì€(ëŠ”) ìµœëŒ€ ${options.maxLength}ìê¹Œì§€ í—ˆìš©ë©ë‹ˆë‹¤`
    };
  }

  if (options.pattern && !options.pattern.test(str)) {
    return {
      field: fieldName,
      value: str,
      error: 'PATTERN_MISMATCH',
      message: `${fieldName}ì˜ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤`
    };
  }

  return null;
};

// ì‚¬ìš© ì˜ˆì‹œ
const businessNumberError = validateStringField(
  row.business_number,
  'ì‚¬ì—…ìë²ˆí˜¸',
  {
    pattern: /^\d{3}-\d{2}-\d{5}$/,
    maxLength: 12
  }
);

const phoneError = validateStringField(
  row.phone,
  'ì „í™”ë²ˆí˜¸',
  {
    pattern: /^0\d{1,2}-\d{3,4}-\d{4}$/,
    maxLength: 13
  }
);
```

---

## 2ï¸âƒ£ Phase 2: ì°¸ì¡° ë¬´ê²°ì„± ê²€ì¦

### 2.1 Foreign Key ì¡´ì¬ ì—¬ë¶€ ê²€ì¦

**supplier_id (items â†’ companies)**
```typescript
const validateSupplierFK = async (
  itemRows: ItemRow[],
  companiesMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of itemRows) {
    if (!row.supplier_code) continue; // nullable field

    const companyId = companiesMap.get(row.supplier_code);

    if (!companyId) {
      errors.push({
        table: 'items',
        field: 'supplier_id',
        value: row.supplier_code,
        error: 'FK_NOT_FOUND',
        message: `ê³µê¸‰ì‚¬ ì½”ë“œ '${row.supplier_code}'ë¥¼ companies í…Œì´ë¸”ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        rowData: {
          item_code: row.item_code,
          item_name: row.item_name
        }
      });
    }
  }

  return errors;
};
```

**parent_item_id & child_item_id (bom â†’ items)**
```typescript
const validateBomFK = async (
  bomRows: BomRow[],
  itemsMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of bomRows) {
    // parent_item_id ê²€ì¦
    const parentId = itemsMap.get(row.parent_item_code);
    if (!parentId) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id',
        value: row.parent_item_code,
        error: 'FK_NOT_FOUND',
        message: `ë¶€ëª¨ í’ˆëª© ì½”ë“œ '${row.parent_item_code}'ë¥¼ items í…Œì´ë¸”ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        rowData: {
          parent_item_name: row.parent_item_name,
          child_item_code: row.child_item_code
        }
      });
    }

    // child_item_id ê²€ì¦
    const childId = itemsMap.get(row.child_item_code);
    if (!childId) {
      errors.push({
        table: 'bom',
        field: 'child_item_id',
        value: row.child_item_code,
        error: 'FK_NOT_FOUND',
        message: `ìì‹ í’ˆëª© ì½”ë“œ '${row.child_item_code}'ë¥¼ items í…Œì´ë¸”ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        rowData: {
          parent_item_code: row.parent_item_code,
          child_item_name: row.child_item_name
        }
      });
    }

    // ìˆœí™˜ ì°¸ì¡° ë°©ì§€ (parent === child)
    if (row.parent_item_code === row.child_item_code) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id',
        value: row.parent_item_code,
        error: 'CIRCULAR_REFERENCE',
        message: `í’ˆëª©ì´ ìê¸° ìì‹ ì„ ìì‹ìœ¼ë¡œ ì°¸ì¡°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${row.parent_item_code}`,
        rowData: row
      });
    }
  }

  return errors;
};
```

**item_id (inventory_transactions â†’ items)**
```typescript
const validateInventoryTransactionFK = async (
  transactionRows: InventoryTransactionRow[],
  itemsMap: Map<string, number>,
  companiesMap: Map<string, number>
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const row of transactionRows) {
    // item_id ê²€ì¦ (í•„ìˆ˜)
    const itemId = itemsMap.get(row.item_code);
    if (!itemId) {
      errors.push({
        table: 'inventory_transactions',
        field: 'item_id',
        value: row.item_code,
        error: 'FK_NOT_FOUND',
        message: `í’ˆëª© ì½”ë“œ '${row.item_code}'ë¥¼ items í…Œì´ë¸”ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        rowData: {
          transaction_date: row.transaction_date,
          quantity: row.quantity
        }
      });
    }

    // company_id ê²€ì¦ (nullable)
    if (row.company_code) {
      const companyId = companiesMap.get(row.company_code);
      if (!companyId) {
        errors.push({
          table: 'inventory_transactions',
          field: 'company_id',
          value: row.company_code,
          error: 'FK_NOT_FOUND',
          message: `ê±°ë˜ì²˜ ì½”ë“œ '${row.company_code}'ë¥¼ companies í…Œì´ë¸”ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
          rowData: {
            item_code: row.item_code,
            transaction_date: row.transaction_date
          }
        });
      }
    }
  }

  return errors;
};
```

### 2.2 ì¤‘ë³µ í‚¤ ê²€ì¦

**company_code ì¤‘ë³µ ê²€ì‚¬**
```typescript
const validateCompanyCodeUnique = (rows: CompanyRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const codeMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const code = row.company_code?.trim().toUpperCase();
    if (!code) return;

    if (codeMap.has(code)) {
      errors.push({
        table: 'companies',
        field: 'company_code',
        value: code,
        error: 'DUPLICATE_KEY',
        message: `ê±°ë˜ì²˜ ì½”ë“œ '${code}'ê°€ ì¤‘ë³µë˜ì—ˆìŠµë‹ˆë‹¤`,
        rowData: {
          row_number: index + 1,
          first_occurrence: codeMap.get(code)! + 1,
          company_name: row.company_name
        }
      });
    } else {
      codeMap.set(code, index);
    }
  });

  return errors;
};
```

**item_code ì¤‘ë³µ ê²€ì‚¬**
```typescript
const validateItemCodeUnique = (rows: ItemRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const codeMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const code = row.item_code?.trim().toUpperCase();
    if (!code) return;

    if (codeMap.has(code)) {
      errors.push({
        table: 'items',
        field: 'item_code',
        value: code,
        error: 'DUPLICATE_KEY',
        message: `í’ˆëª© ì½”ë“œ '${code}'ê°€ ì¤‘ë³µë˜ì—ˆìŠµë‹ˆë‹¤`,
        rowData: {
          row_number: index + 1,
          first_occurrence: codeMap.get(code)! + 1,
          item_name: row.item_name
        }
      });
    } else {
      codeMap.set(code, index);
    }
  });

  return errors;
};
```

**BOM ì¤‘ë³µ ê´€ê³„ ê²€ì‚¬**
```typescript
const validateBomUnique = (rows: BomRow[]): ValidationError[] => {
  const errors: ValidationError[] = [];
  const relationMap = new Map<string, number>();

  rows.forEach((row, index) => {
    const key = `${row.parent_item_code}|${row.child_item_code}`;

    if (relationMap.has(key)) {
      errors.push({
        table: 'bom',
        field: 'parent_item_id, child_item_id',
        value: key,
        error: 'DUPLICATE_BOM_RELATION',
        message: `BOM ê´€ê³„ê°€ ì¤‘ë³µë˜ì—ˆìŠµë‹ˆë‹¤: ${row.parent_item_code} â†’ ${row.child_item_code}`,
        rowData: {
          row_number: index + 1,
          first_occurrence: relationMap.get(key)! + 1
        }
      });
    } else {
      relationMap.set(key, index);
    }
  });

  return errors;
};
```

---

## 3ï¸âƒ£ Phase 3: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦

### 3.1 COIL Specs ê³„ì‚° ê²€ì¦

```typescript
interface CoilSpecCalculation {
  thickness: number;
  width: number;
  length: number;
  density: number;
  sep_factor: number;
  kg_unit_price: number;
}

const validateCoilSpecCalculations = (
  row: CoilSpecCalculation
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // 1. EAì¤‘ëŸ‰ ê³„ì‚°
  const expectedWeightPerPiece =
    (row.density * row.length * row.width * row.thickness) /
    1_000_000 /
    row.sep_factor;

  const calculatedWeightPerPiece = row.weight_per_piece;
  const weightDiff = Math.abs(expectedWeightPerPiece - calculatedWeightPerPiece);

  if (weightDiff > 0.001) {
    errors.push({
      table: 'coil_specs',
      field: 'weight_per_piece',
      value: calculatedWeightPerPiece,
      error: 'CALCULATION_MISMATCH',
      message: `EAì¤‘ëŸ‰ ê³„ì‚°ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆìƒ: ${expectedWeightPerPiece.toFixed(6)}, ì‹¤ì œ: ${calculatedWeightPerPiece}`,
      rowData: {
        item_code: row.item_code,
        formula: `(${row.density} Ã— ${row.length} Ã— ${row.width} Ã— ${row.thickness}) / 1,000,000 / ${row.sep_factor}`
      }
    });
  }

  // 2. EAë‹¨ê°€ ê³„ì‚°
  const expectedPieceUnitPrice = row.kg_unit_price * expectedWeightPerPiece;
  const calculatedPieceUnitPrice = row.piece_unit_price;
  const priceDiff = Math.abs(expectedPieceUnitPrice - calculatedPieceUnitPrice);

  if (priceDiff > 0.01) {
    errors.push({
      table: 'coil_specs',
      field: 'piece_unit_price',
      value: calculatedPieceUnitPrice,
      error: 'CALCULATION_MISMATCH',
      message: `EAë‹¨ê°€ ê³„ì‚°ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆìƒ: ${expectedPieceUnitPrice.toFixed(2)}, ì‹¤ì œ: ${calculatedPieceUnitPrice}`,
      rowData: {
        item_code: row.item_code,
        kg_unit_price: row.kg_unit_price,
        weight_per_piece: expectedWeightPerPiece
      }
    });
  }

  // 3. ë¬¼ë¦¬ì  ì œì•½ ê²€ì¦
  if (row.sep_factor <= 0 || row.sep_factor > 100) {
    errors.push({
      table: 'coil_specs',
      field: 'sep_factor',
      value: row.sep_factor,
      error: 'INVALID_VALUE',
      message: `SEP ê°’ì´ ìœ íš¨ ë²”ìœ„(0 < SEP â‰¤ 100)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤`
    });
  }

  if (row.density <= 0 || row.density > 20) {
    errors.push({
      table: 'coil_specs',
      field: 'density',
      value: row.density,
      error: 'INVALID_VALUE',
      message: `ë¹„ì¤‘ ê°’ì´ ìœ íš¨ ë²”ìœ„(0 < ë¹„ì¤‘ â‰¤ 20)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤`
    });
  }

  return errors;
};
```

### 3.2 Scrap Tracking ê³„ì‚° ê²€ì¦

```typescript
interface ScrapCalculation {
  production_quantity: number;
  scrap_weight_per_unit: number;
  scrap_unit_price: number;
  scrap_revenue: number;
}

const validateScrapCalculations = (
  row: ScrapCalculation
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // ìŠ¤í¬ë©ê¸ˆì•¡ = ì‹¤ì ìˆ˜ëŸ‰ Ã— ìŠ¤í¬ë©ì¤‘ëŸ‰ Ã— ìŠ¤í¬ë©ë‹¨ê°€
  const expectedRevenue =
    row.production_quantity *
    row.scrap_weight_per_unit *
    row.scrap_unit_price;

  const diff = Math.abs(expectedRevenue - row.scrap_revenue);

  if (diff > 0.01) {
    errors.push({
      table: 'scrap_tracking',
      field: 'scrap_revenue',
      value: row.scrap_revenue,
      error: 'CALCULATION_MISMATCH',
      message: `ìŠ¤í¬ë©ê¸ˆì•¡ ê³„ì‚°ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆìƒ: ${expectedRevenue.toFixed(2)}, ì‹¤ì œ: ${row.scrap_revenue}`,
      rowData: {
        production_quantity: row.production_quantity,
        scrap_weight_per_unit: row.scrap_weight_per_unit,
        scrap_unit_price: row.scrap_unit_price,
        formula: `${row.production_quantity} Ã— ${row.scrap_weight_per_unit} Ã— ${row.scrap_unit_price}`
      }
    });
  }

  return errors;
};
```

### 3.3 Price Master ìœ íš¨ì„± ê²€ì¦

```typescript
interface PriceMasterValidation {
  item_id: number;
  effective_date: Date;
  expiry_date?: Date;
  unit_price: number;
}

const validatePriceMaster = (rows: PriceMasterValidation[]): ValidationError[] => {
  const errors: ValidationError[] = [];

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];

    // 1. ìœ íš¨ê¸°ê°„ ê²€ì¦ (effective_date < expiry_date)
    if (row.expiry_date && row.effective_date >= row.expiry_date) {
      errors.push({
        table: 'price_master',
        field: 'expiry_date',
        value: row.expiry_date,
        error: 'INVALID_DATE_RANGE',
        message: `ë§Œë£Œì¼ì´ ì‹œì‘ì¼ë³´ë‹¤ ì´ë¥´ê±°ë‚˜ ê°™ìŠµë‹ˆë‹¤`,
        rowData: {
          item_id: row.item_id,
          effective_date: row.effective_date,
          expiry_date: row.expiry_date
        }
      });
    }

    // 2. ê°™ì€ í’ˆëª©ì˜ ê°€ê²© ê¸°ê°„ ì¤‘ë³µ ê²€ì¦
    for (let j = i + 1; j < rows.length; j++) {
      const other = rows[j];

      if (row.item_id !== other.item_id) continue;

      const rowEnd = row.expiry_date || new Date('9999-12-31');
      const otherEnd = other.expiry_date || new Date('9999-12-31');

      // ê¸°ê°„ ê²¹ì¹¨ ì²´í¬
      const overlap =
        row.effective_date <= otherEnd &&
        other.effective_date <= rowEnd;

      if (overlap) {
        errors.push({
          table: 'price_master',
          field: 'effective_date',
          value: row.effective_date,
          error: 'OVERLAPPING_PRICE_PERIOD',
          message: `ê°™ì€ í’ˆëª©ì˜ ê°€ê²© ê¸°ê°„ì´ ì¤‘ë³µë©ë‹ˆë‹¤`,
          rowData: {
            item_id: row.item_id,
            period1: `${row.effective_date} ~ ${rowEnd}`,
            period2: `${other.effective_date} ~ ${otherEnd}`
          }
        });
      }
    }

    // 3. ë‹¨ê°€ ìŒìˆ˜ ê²€ì¦
    if (row.unit_price < 0) {
      errors.push({
        table: 'price_master',
        field: 'unit_price',
        value: row.unit_price,
        error: 'NEGATIVE_PRICE',
        message: `ë‹¨ê°€ëŠ” ìŒìˆ˜ê°€ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
        rowData: {
          item_id: row.item_id
        }
      });
    }
  }

  return errors;
};
```

### 3.4 ì¬ê³  ìˆ˜ëŸ‰ ê²€ì¦

```typescript
const validateInventoryQuantity = (
  transactions: InventoryTransactionRow[]
): ValidationError[] => {
  const errors: ValidationError[] = [];

  // í’ˆëª©ë³„ë¡œ ê·¸ë£¹í™”
  const itemTransactions = new Map<string, InventoryTransactionRow[]>();

  for (const tx of transactions) {
    const list = itemTransactions.get(tx.item_code) || [];
    list.push(tx);
    itemTransactions.set(tx.item_code, list);
  }

  // ê° í’ˆëª©ë³„ ì¬ê³  ì¶”ì 
  for (const [itemCode, txList] of itemTransactions) {
    // ë‚ ì§œìˆœ ì •ë ¬
    txList.sort((a, b) =>
      new Date(a.transaction_date).getTime() - new Date(b.transaction_date).getTime()
    );

    let runningStock = 0;

    for (const tx of txList) {
      // ê±°ë˜ ìœ í˜•ì— ë”°ë¼ ì¬ê³  ì¦ê°
      if (tx.transaction_type === 'ì…ê³ ' || tx.transaction_type === 'ìƒì‚°ì…ê³ ') {
        runningStock += tx.quantity;
      } else if (tx.transaction_type === 'ì¶œê³ ' || tx.transaction_type === 'ìƒì‚°ì¶œê³ ') {
        runningStock -= tx.quantity;
      } else if (tx.transaction_type === 'ì¡°ì •') {
        runningStock = tx.quantity; // ì¡°ì •ì€ ì ˆëŒ€ê°’ ì„¤ì •
      }

      // ìŒìˆ˜ ì¬ê³  ê²€ì¦
      if (runningStock < 0) {
        errors.push({
          table: 'inventory_transactions',
          field: 'quantity',
          value: tx.quantity,
          error: 'NEGATIVE_STOCK',
          message: `ê±°ë˜ í›„ ì¬ê³ ê°€ ìŒìˆ˜ê°€ ë©ë‹ˆë‹¤`,
          rowData: {
            item_code: itemCode,
            transaction_date: tx.transaction_date,
            transaction_type: tx.transaction_type,
            running_stock: runningStock
          }
        });
      }
    }
  }

  return errors;
};
```

---

## 4ï¸âƒ£ Phase 4: í†µê³„ ê²€ì¦

### 4.1 ë ˆì½”ë“œ ìˆ˜ ê²€ì¦

```typescript
interface RecordCountValidation {
  expectedCounts: {
    companies: number;
    items: number;
    bom: number;
    coil_specs: number;
    price_master: number;
    scrap_tracking: number;
    inventory_transactions: number;
    purchase_transactions: number;
    sales_transactions: number;
  };
}

const validateRecordCounts = async (
  supabase: SupabaseClient,
  expected: RecordCountValidation['expectedCounts']
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const [table, expectedCount] of Object.entries(expected)) {
    const { count, error } = await supabase
      .from(table)
      .select('*', { count: 'exact', head: true });

    if (error) {
      errors.push({
        table,
        field: 'record_count',
        error: 'QUERY_ERROR',
        message: `ë ˆì½”ë“œ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`
      });
      continue;
    }

    if (count !== expectedCount) {
      errors.push({
        table,
        field: 'record_count',
        value: count,
        error: 'COUNT_MISMATCH',
        message: `ë ˆì½”ë“œ ìˆ˜ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. ì˜ˆìƒ: ${expectedCount}, ì‹¤ì œ: ${count}`,
        rowData: {
          difference: count! - expectedCount
        }
      });
    }
  }

  return errors;
};
```

### 4.2 í•©ê³„ ê²€ì¦ (ê¸ˆì•¡, ìˆ˜ëŸ‰)

```typescript
interface AggregateValidation {
  table: string;
  field: string;
  expectedSum: number;
  tolerance?: number;
}

const validateAggregates = async (
  supabase: SupabaseClient,
  validations: AggregateValidation[]
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  for (const validation of validations) {
    const { data, error } = await supabase
      .from(validation.table)
      .select(validation.field);

    if (error) {
      errors.push({
        table: validation.table,
        field: validation.field,
        error: 'QUERY_ERROR',
        message: `í•©ê³„ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`
      });
      continue;
    }

    const actualSum = data.reduce(
      (sum, row) => sum + (row[validation.field] || 0),
      0
    );

    const tolerance = validation.tolerance || 0.01;
    const diff = Math.abs(actualSum - validation.expectedSum);

    if (diff > tolerance) {
      errors.push({
        table: validation.table,
        field: validation.field,
        value: actualSum,
        error: 'SUM_MISMATCH',
        message: `í•©ê³„ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. ì˜ˆìƒ: ${validation.expectedSum.toFixed(2)}, ì‹¤ì œ: ${actualSum.toFixed(2)}`,
        rowData: {
          difference: diff.toFixed(2),
          tolerance: tolerance
        }
      });
    }
  }

  return errors;
};

// ì‚¬ìš© ì˜ˆì‹œ
const aggregateValidations: AggregateValidation[] = [
  {
    table: 'inventory_transactions',
    field: 'quantity',
    expectedSum: 125430.5,
    tolerance: 1.0
  },
  {
    table: 'purchase_transactions',
    field: 'total_amount',
    expectedSum: 45_678_900,
    tolerance: 100
  },
  {
    table: 'scrap_tracking',
    field: 'scrap_revenue',
    expectedSum: 2_345_678,
    tolerance: 100
  }
];
```

### 4.3 ì°¸ì¡° ë¬´ê²°ì„± í†µê³„ (Orphan ë ˆì½”ë“œ)

```typescript
const validateOrphanRecords = async (
  supabase: SupabaseClient
): Promise<ValidationError[]> => {
  const errors: ValidationError[] = [];

  // 1. items.supplier_id â†’ companies.company_id
  const { data: orphanSuppliers, error: err1 } = await supabase.rpc(
    'find_orphan_suppliers',
    {}
  );

  if (orphanSuppliers && orphanSuppliers.length > 0) {
    errors.push({
      table: 'items',
      field: 'supplier_id',
      error: 'ORPHAN_FK',
      message: `${orphanSuppliers.length}ê°œì˜ í’ˆëª©ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê³µê¸‰ì‚¬ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤`,
      rowData: {
        orphan_count: orphanSuppliers.length,
        sample_items: orphanSuppliers.slice(0, 5)
      }
    });
  }

  // 2. bom.parent_item_id â†’ items.item_id
  const { data: orphanParents, error: err2 } = await supabase.rpc(
    'find_orphan_bom_parents',
    {}
  );

  if (orphanParents && orphanParents.length > 0) {
    errors.push({
      table: 'bom',
      field: 'parent_item_id',
      error: 'ORPHAN_FK',
      message: `${orphanParents.length}ê°œì˜ BOMì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¶€ëª¨ í’ˆëª©ì„ ì°¸ì¡°í•©ë‹ˆë‹¤`,
      rowData: {
        orphan_count: orphanParents.length,
        sample_boms: orphanParents.slice(0, 5)
      }
    });
  }

  // 3. bom.child_item_id â†’ items.item_id
  const { data: orphanChildren, error: err3 } = await supabase.rpc(
    'find_orphan_bom_children',
    {}
  );

  if (orphanChildren && orphanChildren.length > 0) {
    errors.push({
      table: 'bom',
      field: 'child_item_id',
      error: 'ORPHAN_FK',
      message: `${orphanChildren.length}ê°œì˜ BOMì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìì‹ í’ˆëª©ì„ ì°¸ì¡°í•©ë‹ˆë‹¤`,
      rowData: {
        orphan_count: orphanChildren.length,
        sample_boms: orphanChildren.slice(0, 5)
      }
    });
  }

  return errors;
};

// Supabase SQL í•¨ìˆ˜ (ë¯¸ë¦¬ ìƒì„± í•„ìš”)
/*
CREATE OR REPLACE FUNCTION find_orphan_suppliers()
RETURNS TABLE (
  item_id INT,
  item_code TEXT,
  item_name TEXT,
  supplier_id INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT i.item_id, i.item_code, i.item_name, i.supplier_id
  FROM items i
  LEFT JOIN companies c ON i.supplier_id = c.company_id
  WHERE i.supplier_id IS NOT NULL AND c.company_id IS NULL;
END;
$$ LANGUAGE plpgsql;
*/
```

---

## 5ï¸âƒ£ ê²€ì¦ ì‹¤í–‰ ì›Œí¬í”Œë¡œìš°

### 5.1 ì „ì²´ ê²€ì¦ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°

```typescript
interface ValidationReport {
  summary: {
    totalErrors: number;
    errorsByPhase: Record<string, number>;
    errorsByTable: Record<string, number>;
    criticalErrors: number;
  };
  errors: ValidationError[];
  timestamp: string;
}

const runFullValidation = async (
  excelData: ParsedExcelData,
  supabase: SupabaseClient
): Promise<ValidationReport> => {
  const allErrors: ValidationError[] = [];
  const startTime = Date.now();

  console.log('ğŸ” Phase 1: ê¸°ë³¸ ë°ì´í„° ê²€ì¦ ì‹œì‘...');

  // Phase 1: ê¸°ë³¸ ê²€ì¦
  const phase1Errors = [
    ...validateCompanyRequired(excelData.companies),
    ...validateItemRequired(excelData.items),
    ...validateCompanyCodeUnique(excelData.companies),
    ...validateItemCodeUnique(excelData.items),
    ...validateBomUnique(excelData.bom)
  ];

  allErrors.push(...phase1Errors.map(e => ({ ...e, phase: 'Phase 1' })));
  console.log(`  âœ… Phase 1 ì™„ë£Œ: ${phase1Errors.length}ê°œ ì˜¤ë¥˜ ë°œê²¬`);

  // Phase 2: ì°¸ì¡° ë¬´ê²°ì„±
  console.log('ğŸ” Phase 2: ì°¸ì¡° ë¬´ê²°ì„± ê²€ì¦ ì‹œì‘...');

  const companiesMap = new Map(
    excelData.companies.map(c => [c.company_code, c.company_id])
  );
  const itemsMap = new Map(
    excelData.items.map(i => [i.item_code, i.item_id])
  );

  const phase2Errors = [
    ...(await validateSupplierFK(excelData.items, companiesMap)),
    ...(await validateBomFK(excelData.bom, itemsMap)),
    ...(await validateInventoryTransactionFK(
      excelData.inventory_transactions,
      itemsMap,
      companiesMap
    ))
  ];

  allErrors.push(...phase2Errors.map(e => ({ ...e, phase: 'Phase 2' })));
  console.log(`  âœ… Phase 2 ì™„ë£Œ: ${phase2Errors.length}ê°œ ì˜¤ë¥˜ ë°œê²¬`);

  // Phase 3: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  console.log('ğŸ” Phase 3: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦ ì‹œì‘...');

  const phase3Errors = [
    ...excelData.coil_specs.flatMap(validateCoilSpecCalculations),
    ...excelData.scrap_tracking.flatMap(validateScrapCalculations),
    ...validatePriceMaster(excelData.price_master),
    ...validateInventoryQuantity(excelData.inventory_transactions)
  ];

  allErrors.push(...phase3Errors.map(e => ({ ...e, phase: 'Phase 3' })));
  console.log(`  âœ… Phase 3 ì™„ë£Œ: ${phase3Errors.length}ê°œ ì˜¤ë¥˜ ë°œê²¬`);

  // Phase 4: í†µê³„ ê²€ì¦
  console.log('ğŸ” Phase 4: í†µê³„ ê²€ì¦ ì‹œì‘...');

  const expectedCounts = {
    companies: excelData.companies.length,
    items: excelData.items.length,
    bom: excelData.bom.length,
    coil_specs: excelData.coil_specs.length,
    price_master: excelData.price_master.length,
    scrap_tracking: excelData.scrap_tracking.length,
    inventory_transactions: excelData.inventory_transactions.length,
    purchase_transactions: excelData.purchase_transactions.length,
    sales_transactions: excelData.sales_transactions.length
  };

  const phase4Errors = [
    ...(await validateRecordCounts(supabase, expectedCounts)),
    ...(await validateAggregates(supabase, aggregateValidations)),
    ...(await validateOrphanRecords(supabase))
  ];

  allErrors.push(...phase4Errors.map(e => ({ ...e, phase: 'Phase 4' })));
  console.log(`  âœ… Phase 4 ì™„ë£Œ: ${phase4Errors.length}ê°œ ì˜¤ë¥˜ ë°œê²¬`);

  const duration = Date.now() - startTime;
  console.log(`\nâ±ï¸ ì „ì²´ ê²€ì¦ ì™„ë£Œ: ${(duration / 1000).toFixed(1)}ì´ˆ`);

  // ë³´ê³ ì„œ ìƒì„±
  const report: ValidationReport = {
    summary: {
      totalErrors: allErrors.length,
      errorsByPhase: allErrors.reduce((acc, err) => {
        acc[err.phase] = (acc[err.phase] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      errorsByTable: allErrors.reduce((acc, err) => {
        acc[err.table] = (acc[err.table] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      criticalErrors: allErrors.filter(e =>
        ['FK_NOT_FOUND', 'DUPLICATE_KEY', 'REQUIRED_FIELD_MISSING'].includes(e.error)
      ).length
    },
    errors: allErrors,
    timestamp: new Date().toISOString()
  };

  return report;
};
```

### 5.2 ê²€ì¦ ë¦¬í¬íŠ¸ ìƒì„±

```typescript
const generateValidationReport = (report: ValidationReport): string => {
  const lines: string[] = [];

  lines.push('# ë°ì´í„° ê²€ì¦ ë¦¬í¬íŠ¸\n');
  lines.push(`**ìƒì„± ì¼ì‹œ**: ${report.timestamp}\n`);
  lines.push('---\n');

  // ìš”ì•½
  lines.push('## ğŸ“Š ê²€ì¦ ìš”ì•½\n');
  lines.push(`- **ì´ ì˜¤ë¥˜ ìˆ˜**: ${report.summary.totalErrors}ê°œ`);
  lines.push(`- **ì¹˜ëª…ì  ì˜¤ë¥˜**: ${report.summary.criticalErrors}ê°œ\n`);

  // Phaseë³„ ì˜¤ë¥˜
  lines.push('### Phaseë³„ ì˜¤ë¥˜ ë¶„í¬\n');
  for (const [phase, count] of Object.entries(report.summary.errorsByPhase)) {
    lines.push(`- ${phase}: ${count}ê°œ`);
  }
  lines.push('');

  // í…Œì´ë¸”ë³„ ì˜¤ë¥˜
  lines.push('### í…Œì´ë¸”ë³„ ì˜¤ë¥˜ ë¶„í¬\n');
  for (const [table, count] of Object.entries(report.summary.errorsByTable)) {
    lines.push(`- ${table}: ${count}ê°œ`);
  }
  lines.push('\n---\n');

  // ì˜¤ë¥˜ ìƒì„¸
  if (report.errors.length > 0) {
    lines.push('## ğŸš¨ ì˜¤ë¥˜ ìƒì„¸ ë‚´ì—­\n');

    // Phaseë³„ë¡œ ê·¸ë£¹í™”
    const errorsByPhase = report.errors.reduce((acc, err) => {
      if (!acc[err.phase]) acc[err.phase] = [];
      acc[err.phase].push(err);
      return acc;
    }, {} as Record<string, ValidationError[]>);

    for (const [phase, errors] of Object.entries(errorsByPhase)) {
      lines.push(`### ${phase}\n`);

      errors.forEach((err, idx) => {
        lines.push(`#### ${idx + 1}. ${err.table}.${err.field}`);
        lines.push(`- **ì˜¤ë¥˜ ì½”ë“œ**: \`${err.error}\``);
        lines.push(`- **ë©”ì‹œì§€**: ${err.message}`);
        if (err.value !== undefined) {
          lines.push(`- **ê°’**: ${JSON.stringify(err.value)}`);
        }
        if (err.rowData) {
          lines.push(`- **í–‰ ë°ì´í„°**:`);
          lines.push('```json');
          lines.push(JSON.stringify(err.rowData, null, 2));
          lines.push('```');
        }
        lines.push('');
      });
    }
  } else {
    lines.push('## âœ… ê²€ì¦ í†µê³¼\n');
    lines.push('ëª¨ë“  ê²€ì¦ í•­ëª©ì„ í†µê³¼í–ˆìŠµë‹ˆë‹¤.\n');
  }

  return lines.join('\n');
};
```

---

## 6ï¸âƒ£ ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì¡°ì¹˜ ì‚¬í•­

### Critical Errors (ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤‘ë‹¨)
- `REQUIRED_FIELD_MISSING`: í•„ìˆ˜ í•„ë“œ ëˆ„ë½
- `FK_NOT_FOUND`: ì°¸ì¡° í‚¤ ë¯¸ì¡´ì¬
- `DUPLICATE_KEY`: ì¤‘ë³µ í‚¤
- `CIRCULAR_REFERENCE`: ìˆœí™˜ ì°¸ì¡°

**ì¡°ì¹˜**: ì¦‰ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤‘ë‹¨í•˜ê³  Excel ë°ì´í„° ìˆ˜ì • í›„ ì¬ì‹œë„

### Warning Errors (ê³„ì† ì§„í–‰ ê°€ëŠ¥, í™•ì¸ í•„ìš”)
- `CALCULATION_MISMATCH`: ê³„ì‚° ë¶ˆì¼ì¹˜ (0.01 ì´í•˜)
- `COUNT_MISMATCH`: ë ˆì½”ë“œ ìˆ˜ ì°¨ì´ (Â±5 ì´ë‚´)
- `SUM_MISMATCH`: í•©ê³„ ì°¨ì´ (tolerance ë‚´)

**ì¡°ì¹˜**: ë¡œê·¸ì— ê¸°ë¡í•˜ê³  ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ í›„ ê²€í† 

---

**ë¬¸ì„œ ì™„ë£Œ** | ë‹¤ìŒ: [04_ë§ˆì´ê·¸ë ˆì´ì…˜_ì‹¤í–‰_ë§¤ë‰´ì–¼.md](./04_ë§ˆì´ê·¸ë ˆì´ì…˜_ì‹¤í–‰_ë§¤ë‰´ì–¼.md)
