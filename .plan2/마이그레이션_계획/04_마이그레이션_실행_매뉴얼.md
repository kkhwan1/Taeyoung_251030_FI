# 04. 마이그레이션 실행 매뉴얼

**작성일**: 2025년 1월
**문서 목적**: Excel → Supabase 마이그레이션 단계별 실행 가이드

---

## 📋 실행 전 체크리스트

### 환경 준비

- [ ] Node.js 18+ 설치 확인
- [ ] npm 의존성 설치: `npm install`
- [ ] Supabase 환경 변수 설정 확인 (`.env`)
  ```bash
  NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
  NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
  SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
  SUPABASE_PROJECT_ID=your-project-id
  ```
- [ ] Supabase 프로젝트 연결 확인: `npm run db:check-schema`
- [ ] Excel 파일 준비 (`.plan2/참고/` 디렉토리)
- [ ] 백업 완료 확인 (중요!)

### 백업 전략

```bash
# 1. Supabase 대시보드에서 스냅샷 생성
# Settings → Database → Point-in-time Recovery → Create Snapshot

# 2. 로컬 백업 (선택사항)
npm run db:dump > backup_$(date +%Y%m%d_%H%M%S).sql
```

---

## 🚀 실행 단계

### Phase 0: 준비 단계 (5분)

#### 0.1 마이그레이션 스크립트 디렉토리 생성

```bash
mkdir -p scripts/migration
cd scripts/migration
```

#### 0.2 필수 패키지 확인

```bash
# package.json에 이미 포함되어 있어야 함
npm list xlsx @supabase/supabase-js
```

#### 0.3 마이그레이션 로그 디렉토리 생성

```bash
mkdir -p logs/migration
```

---

### Phase 1: 기존 데이터 삭제 (5-10분)

⚠️ **경고**: 이 단계는 되돌릴 수 없습니다. 반드시 백업을 먼저 완료하세요!

#### 1.1 삭제 스크립트 생성

**파일**: `scripts/migration/01-delete-existing-data.ts`

```typescript
import { createClient } from '@supabase/supabase-js';
import * as fs from 'fs';
import * as path from 'path';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

interface DeletionResult {
  table: string;
  deletedCount: number;
  success: boolean;
  error?: string;
}

const DELETION_ORDER = [
  // 종속 테이블부터 삭제 (FK 제약 때문에)
  'inventory_transactions',
  'purchase_transactions',
  'sales_transactions',
  'collections',
  'payments',
  'scrap_tracking',
  'price_master',
  'coil_specs',
  'bom',
  'items',
  'companies',
  'warehouses'
];

async function deleteAllData(): Promise<DeletionResult[]> {
  const results: DeletionResult[] = [];
  const startTime = Date.now();

  console.log('🗑️  기존 데이터 삭제 시작...\n');

  for (const table of DELETION_ORDER) {
    console.log(`  - ${table} 테이블 삭제 중...`);

    try {
      // 레코드 수 확인
      const { count: beforeCount } = await supabase
        .from(table)
        .select('*', { count: 'exact', head: true });

      if (!beforeCount || beforeCount === 0) {
        console.log(`    ✅ ${table}: 삭제할 데이터 없음\n`);
        results.push({
          table,
          deletedCount: 0,
          success: true
        });
        continue;
      }

      // 전체 삭제
      const { error } = await supabase
        .from(table)
        .delete()
        .neq('id', 0); // 모든 레코드 삭제 (id != 0 조건으로 전체 선택)

      if (error) {
        console.error(`    ❌ ${table}: 삭제 실패 - ${error.message}\n`);
        results.push({
          table,
          deletedCount: 0,
          success: false,
          error: error.message
        });
        continue;
      }

      // 삭제 후 확인
      const { count: afterCount } = await supabase
        .from(table)
        .select('*', { count: 'exact', head: true });

      console.log(`    ✅ ${table}: ${beforeCount}개 삭제 완료 (남은 레코드: ${afterCount})\n`);

      results.push({
        table,
        deletedCount: beforeCount,
        success: true
      });

    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : String(err);
      console.error(`    ❌ ${table}: 예외 발생 - ${errorMsg}\n`);
      results.push({
        table,
        deletedCount: 0,
        success: false,
        error: errorMsg
      });
    }
  }

  const duration = Date.now() - startTime;
  const totalDeleted = results.reduce((sum, r) => sum + r.deletedCount, 0);

  console.log('\n📊 삭제 요약:');
  console.log(`  - 총 삭제 레코드: ${totalDeleted}개`);
  console.log(`  - 소요 시간: ${(duration / 1000).toFixed(1)}초`);
  console.log(`  - 성공한 테이블: ${results.filter(r => r.success).length}/${results.length}`);

  // 실패한 테이블 출력
  const failures = results.filter(r => !r.success);
  if (failures.length > 0) {
    console.log('\n⚠️  실패한 테이블:');
    failures.forEach(f => {
      console.log(`  - ${f.table}: ${f.error}`);
    });
  }

  // 로그 파일 저장
  const logPath = path.join(process.cwd(), 'logs', 'migration', `deletion_${Date.now()}.json`);
  fs.writeFileSync(logPath, JSON.stringify(results, null, 2));
  console.log(`\n📝 로그 저장: ${logPath}`);

  return results;
}

// 실행
deleteAllData()
  .then(results => {
    const allSuccess = results.every(r => r.success);
    process.exit(allSuccess ? 0 : 1);
  })
  .catch(err => {
    console.error('치명적 오류:', err);
    process.exit(1);
  });
```

#### 1.2 삭제 스크립트 실행

```bash
# TypeScript 직접 실행
npx tsx scripts/migration/01-delete-existing-data.ts

# 또는 package.json에 스크립트 추가 후
npm run migrate:delete
```

#### 1.3 삭제 확인

```bash
# 모든 테이블이 비어있는지 확인
npm run db:check-data
```

---

### Phase 2: Excel 파일 파싱 (10-15분)

#### 2.1 파싱 스크립트 생성

**파일**: `scripts/migration/02-parse-excel-files.ts`

```typescript
import * as XLSX from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';

interface ParsedData {
  companies: any[];
  items: any[];
  bom: any[];
  coil_specs: any[];
  price_master: any[];
  scrap_tracking: any[];
  inventory_transactions: any[];
  purchase_transactions: any[];
  sales_transactions: any[];
}

const EXCEL_DIR = path.join(process.cwd(), '.plan2', '참고');
const OUTPUT_DIR = path.join(process.cwd(), 'logs', 'migration');

async function parseExcelFiles(): Promise<ParsedData> {
  console.log('📂 Excel 파일 파싱 시작...\n');

  const parsedData: ParsedData = {
    companies: [],
    items: [],
    bom: [],
    coil_specs: [],
    price_master: [],
    scrap_tracking: [],
    inventory_transactions: [],
    purchase_transactions: [],
    sales_transactions: []
  };

  // 1. BOM 파일 파싱
  console.log('  - BOM 파일 파싱 중...');
  const bomPath = path.join(EXCEL_DIR, '태창금속 BOM (1).xlsx');
  const bomData = parseBomFile(bomPath);
  parsedData.bom = bomData.bom;
  parsedData.items.push(...bomData.items);
  parsedData.companies.push(...bomData.companies);
  console.log(`    ✅ BOM: ${parsedData.bom.length}개 관계 파싱`);

  // 2. 매입수불 파일 파싱
  console.log('  - 매입수불 파일 파싱 중...');
  const purchasePath = path.join(EXCEL_DIR, '2025년 09월 매입 수불관리 (3).xlsx');
  const purchaseData = parsePurchaseInventoryFile(purchasePath);
  parsedData.items.push(...purchaseData.items);
  parsedData.companies.push(...purchaseData.companies);
  parsedData.coil_specs.push(...purchaseData.coil_specs);
  parsedData.price_master.push(...purchaseData.price_master);
  parsedData.scrap_tracking.push(...purchaseData.scrap_tracking);
  console.log(`    ✅ 품목: ${purchaseData.items.length}개 파싱`);

  // 3. 종합관리 파일 파싱 (재고 거래)
  console.log('  - 종합관리 파일 파싱 중...');
  const inventoryPath = path.join(EXCEL_DIR, '2025년 9월 19일 종합관리 SHEET (1).xlsx');
  const inventoryData = parseInventoryFile(inventoryPath);
  parsedData.inventory_transactions = inventoryData.transactions;
  console.log(`    ✅ 재고거래: ${parsedData.inventory_transactions.length}개 파싱`);

  // 4. 매입매출 파일 파싱
  console.log('  - 매입매출 파일 파싱 중...');
  const salesPurchasePath = path.join(EXCEL_DIR, '2025년 9월 매입매출 보고현황 (1).xlsx');
  const salesPurchaseData = parseSalesPurchaseFile(salesPurchasePath);
  parsedData.purchase_transactions = salesPurchaseData.purchases;
  parsedData.sales_transactions = salesPurchaseData.sales;
  console.log(`    ✅ 매입: ${parsedData.purchase_transactions.length}개 파싱`);
  console.log(`    ✅ 매출: ${parsedData.sales_transactions.length}개 파싱`);

  // 중복 제거 (companies, items)
  console.log('\n  - 중복 데이터 제거 중...');
  parsedData.companies = deduplicateCompanies(parsedData.companies);
  parsedData.items = deduplicateItems(parsedData.items);
  console.log(`    ✅ 거래처: ${parsedData.companies.length}개 (중복 제거 후)`);
  console.log(`    ✅ 품목: ${parsedData.items.length}개 (중복 제거 후)`);

  // 결과 저장
  const outputPath = path.join(OUTPUT_DIR, `parsed_data_${Date.now()}.json`);
  fs.writeFileSync(outputPath, JSON.stringify(parsedData, null, 2));
  console.log(`\n📝 파싱 결과 저장: ${outputPath}`);

  return parsedData;
}

function parseBomFile(filePath: string): { bom: any[]; items: any[]; companies: any[] } {
  const workbook = XLSX.readFile(filePath);
  const bom: any[] = [];
  const items: any[] = [];
  const companies: any[] = [];

  // 각 시트는 고객사별 BOM
  for (const sheetName of workbook.SheetNames) {
    const sheet = workbook.Sheets[sheetName];
    const rows: any[] = XLSX.utils.sheet_to_json(sheet);

    // 고객사 정보 추출
    if (rows.length > 0 && rows[0].고객명) {
      companies.push({
        company_code: `CUS_${sheetName.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}`,
        company_name: rows[0].고객명,
        company_type: '고객사'
      });
    }

    // BOM 관계 파싱
    for (const row of rows) {
      if (!row.품번 || !row.사용재질품번) continue;

      // 완제품 (parent)
      items.push({
        item_code: row.품번,
        item_name: row.품명 || row.품번,
        category: '제품',
        spec: row.규격 || '',
        unit: 'EA'
      });

      // 원자재 (child)
      items.push({
        item_code: row.사용재질품번,
        item_name: row.사용재질품명 || row.사용재질품번,
        category: '원자재',
        spec: row.사용재질규격 || '',
        unit: 'KG'
      });

      // BOM 관계
      bom.push({
        parent_item_code: row.품번,
        child_item_code: row.사용재질품번,
        quantity_required: parseFloat(row.소요량 || 1),
        level_no: 2 // 2단계 BOM
      });
    }
  }

  return { bom, items, companies };
}

function parsePurchaseInventoryFile(filePath: string): {
  items: any[];
  companies: any[];
  coil_specs: any[];
  price_master: any[];
  scrap_tracking: any[];
} {
  const workbook = XLSX.readFile(filePath);
  const items: any[] = [];
  const companies: any[] = [];
  const coil_specs: any[] = [];
  const price_master: any[] = [];
  const scrap_tracking: any[] = [];

  // "매입수불" 시트 파싱
  if (workbook.SheetNames.includes('매입수불')) {
    const sheet = workbook.Sheets['매입수불'];
    const rows: any[] = XLSX.utils.sheet_to_json(sheet);

    for (const row of rows) {
      if (!row.품명) continue;

      // 품목 정보
      const itemCode = generateItemCode(row.품명, row.규격);
      items.push({
        item_code: itemCode,
        item_name: row.품명,
        category: classifyItemCategory(row.품명),
        spec: row.규격 || '',
        material: row.재질 || '',
        thickness: parseFloat(row.두께) || null,
        width: parseFloat(row.폭) || null,
        unit: row.단위 || 'EA'
      });

      // 공급사 정보
      if (row.공급사) {
        companies.push({
          company_code: `SUP_${row.공급사.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}`,
          company_name: row.공급사,
          company_type: '공급사'
        });
      }

      // COIL Specs (원자재만)
      if (row.재질 && row.두께 && row.폭 && row.길이) {
        coil_specs.push({
          item_code: itemCode,
          material_grade: row.재질,
          thickness: parseFloat(row.두께),
          width: parseFloat(row.폭),
          length: parseFloat(row.길이),
          sep_factor: parseFloat(row.SEP) || 1,
          density: parseFloat(row.비중) || 7.85,
          kg_unit_price: parseFloat(row.KG단가) || null
        });
      }

      // 가격 정보
      if (row.단가) {
        price_master.push({
          item_code: itemCode,
          unit_price: parseFloat(row.단가),
          effective_date: '2025-01-01'
        });
      }

      // 스크랩 정보
      if (row.스크랩중량 && row.스크랩단가) {
        scrap_tracking.push({
          item_code: itemCode,
          production_date: new Date().toISOString().split('T')[0],
          production_quantity: parseFloat(row.실적수량) || 0,
          scrap_weight_per_unit: parseFloat(row.스크랩중량),
          scrap_unit_price: parseFloat(row.스크랩단가)
        });
      }
    }
  }

  return { items, companies, coil_specs, price_master, scrap_tracking };
}

function parseInventoryFile(filePath: string): { transactions: any[] } {
  const workbook = XLSX.readFile(filePath);
  const transactions: any[] = [];

  // "입고", "출고", "생산입고" 시트 파싱
  const sheetTypes = [
    { name: '입고', type: '입고' },
    { name: '출고', type: '출고' },
    { name: '생산입고', type: '생산입고' }
  ];

  for (const { name: sheetName, type: txType } of sheetTypes) {
    if (!workbook.SheetNames.includes(sheetName)) continue;

    const sheet = workbook.Sheets[sheetName];
    const rows: any[] = XLSX.utils.sheet_to_json(sheet);

    for (const row of rows) {
      if (!row.품명) continue;

      const itemCode = generateItemCode(row.품명, row.규격);

      // T1~T268 컬럼 파싱 (268일치 일별 데이터)
      for (let day = 1; day <= 268; day++) {
        const colName = `T${day}`;
        const quantity = parseFloat(row[colName]);

        if (!quantity || quantity === 0) continue;

        const transactionDate = new Date('2025-01-01');
        transactionDate.setDate(transactionDate.getDate() + day - 1);

        transactions.push({
          item_code: itemCode,
          transaction_type: txType,
          quantity: Math.abs(quantity),
          transaction_date: transactionDate.toISOString().split('T')[0],
          status: '완료'
        });
      }
    }
  }

  return { transactions };
}

function parseSalesPurchaseFile(filePath: string): {
  purchases: any[];
  sales: any[];
} {
  const workbook = XLSX.readFile(filePath);
  const purchases: any[] = [];
  const sales: any[] = [];

  // "매입" 시트
  if (workbook.SheetNames.includes('매입')) {
    const sheet = workbook.Sheets['매입'];
    const rows: any[] = XLSX.utils.sheet_to_json(sheet);

    for (const row of rows) {
      if (!row.품명 || !row.거래처) continue;

      purchases.push({
        transaction_date: parseExcelDate(row.거래일자),
        company_code: `SUP_${row.거래처.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}`,
        item_code: generateItemCode(row.품명, row.규격),
        quantity: parseFloat(row.수량) || 0,
        unit_price: parseFloat(row.단가) || 0,
        total_amount: parseFloat(row.금액) || 0,
        payment_status: 'PENDING'
      });
    }
  }

  // "매출" 시트
  if (workbook.SheetNames.includes('매출')) {
    const sheet = workbook.Sheets['매출'];
    const rows: any[] = XLSX.utils.sheet_to_json(sheet);

    for (const row of rows) {
      if (!row.품명 || !row.거래처) continue;

      sales.push({
        transaction_date: parseExcelDate(row.거래일자),
        company_code: `CUS_${row.거래처.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}`,
        item_code: generateItemCode(row.품명, row.규격),
        quantity: parseFloat(row.수량) || 0,
        unit_price: parseFloat(row.단가) || 0,
        total_amount: parseFloat(row.금액) || 0,
        payment_status: 'PENDING'
      });
    }
  }

  return { purchases, sales };
}

// 헬퍼 함수들
function generateItemCode(name: string, spec?: string): string {
  const cleanName = name.replace(/[^a-zA-Z0-9가-힣]/g, '');
  const cleanSpec = spec ? spec.replace(/[^a-zA-Z0-9]/g, '') : '';
  return `ITEM_${cleanName}_${cleanSpec}`.slice(0, 50).toUpperCase();
}

function classifyItemCategory(name: string): string {
  if (name.includes('COIL') || name.includes('코일')) return '원자재';
  if (name.includes('SHEET') || name.includes('쉬트')) return '반제품';
  return '제품';
}

function parseExcelDate(value: any): string {
  if (value instanceof Date) {
    return value.toISOString().split('T')[0];
  }
  if (typeof value === 'number') {
    const date = new Date((value - 25569) * 86400 * 1000);
    return date.toISOString().split('T')[0];
  }
  if (typeof value === 'string') {
    return new Date(value).toISOString().split('T')[0];
  }
  return new Date().toISOString().split('T')[0];
}

function deduplicateCompanies(companies: any[]): any[] {
  const map = new Map();
  for (const company of companies) {
    if (!map.has(company.company_code)) {
      map.set(company.company_code, company);
    }
  }
  return Array.from(map.values());
}

function deduplicateItems(items: any[]): any[] {
  const map = new Map();
  for (const item of items) {
    if (!map.has(item.item_code)) {
      map.set(item.item_code, item);
    }
  }
  return Array.from(map.values());
}

// 실행
parseExcelFiles()
  .then(data => {
    console.log('\n✅ Excel 파일 파싱 완료!');
    console.log('\n📊 파싱 결과 요약:');
    console.log(`  - 거래처: ${data.companies.length}개`);
    console.log(`  - 품목: ${data.items.length}개`);
    console.log(`  - BOM: ${data.bom.length}개`);
    console.log(`  - COIL Specs: ${data.coil_specs.length}개`);
    console.log(`  - 가격 정보: ${data.price_master.length}개`);
    console.log(`  - 스크랩 추적: ${data.scrap_tracking.length}개`);
    console.log(`  - 재고 거래: ${data.inventory_transactions.length}개`);
    console.log(`  - 매입 거래: ${data.purchase_transactions.length}개`);
    console.log(`  - 매출 거래: ${data.sales_transactions.length}개`);
    process.exit(0);
  })
  .catch(err => {
    console.error('치명적 오류:', err);
    process.exit(1);
  });
```

#### 2.2 파싱 스크립트 실행

```bash
npx tsx scripts/migration/02-parse-excel-files.ts
```

#### 2.3 파싱 결과 검토

```bash
# 생성된 JSON 파일 확인
cat logs/migration/parsed_data_*.json | jq '.companies | length'
cat logs/migration/parsed_data_*.json | jq '.items | length'
```

---

### Phase 3: 데이터 검증 (10-15분)

#### 3.1 검증 스크립트 실행

```bash
npx tsx scripts/migration/03-validate-data.ts logs/migration/parsed_data_*.json
```

**출력 예시**:
```
🔍 Phase 1: 기본 데이터 검증 시작...
  ✅ Phase 1 완료: 3개 오류 발견

🔍 Phase 2: 참조 무결성 검증 시작...
  ✅ Phase 2 완료: 12개 오류 발견

🔍 Phase 3: 비즈니스 로직 검증 시작...
  ✅ Phase 3 완료: 5개 오류 발견

🔍 Phase 4: 통계 검증 시작...
  ✅ Phase 4 완료: 0개 오류 발견

⏱️ 전체 검증 완료: 8.3초

📊 검증 요약:
  - 총 오류 수: 20개
  - 치명적 오류: 8개
```

#### 3.2 검증 리포트 확인

```bash
cat logs/migration/validation_report_*.md
```

#### 3.3 오류 수정

- **Critical 오류**: Excel 파일 수정 후 Phase 2부터 재실행
- **Warning 오류**: 로그 기록하고 계속 진행

---

### Phase 4: 마스터 데이터 임포트 (15-20분)

#### 4.1 거래처 임포트

```bash
npx tsx scripts/migration/04-import-companies.ts logs/migration/parsed_data_*.json
```

**진행 상황**:
```
📥 거래처 임포트 시작...
  ⏳ [=====>    ] 50/120 (41.7%) - CUS_삼성전자
  ⏳ [========>] 100/120 (83.3%) - SUP_현대제철
✅ 거래처 임포트 완료: 120개 (5.2초)
```

#### 4.2 품목 임포트

```bash
npx tsx scripts/migration/05-import-items.ts logs/migration/parsed_data_*.json
```

**진행 상황**:
```
📥 품목 임포트 시작...
  ⏳ [====>     ] 250/580 (43.1%) - ITEM_COIL_CR_01
  ⏳ [========>] 500/580 (86.2%) - ITEM_SHEET_SPHC_02
✅ 품목 임포트 완료: 580개 (12.4초)
```

#### 4.3 BOM 임포트

```bash
npx tsx scripts/migration/06-import-bom.ts logs/migration/parsed_data_*.json
```

#### 4.4 COIL Specs 임포트

```bash
npx tsx scripts/migration/07-import-coil-specs.ts logs/migration/parsed_data_*.json
```

---

### Phase 5: 거래 데이터 임포트 (20-30분)

#### 5.1 재고 거래 임포트

```bash
npx tsx scripts/migration/08-import-inventory-transactions.ts logs/migration/parsed_data_*.json
```

**진행 상황**:
```
📥 재고 거래 임포트 시작...
  ⏳ [===>      ] 2,500/8,950 (27.9%) - 입고
  ⏳ [======>   ] 5,000/8,950 (55.9%) - 출고
  ⏳ [========>] 8,000/8,950 (89.4%) - 생산입고
✅ 재고 거래 임포트 완료: 8,950개 (24.7초)
```

#### 5.2 매입/매출 거래 임포트

```bash
npx tsx scripts/migration/09-import-purchase-sales.ts logs/migration/parsed_data_*.json
```

#### 5.3 가격 정보 임포트

```bash
npx tsx scripts/migration/10-import-price-master.ts logs/migration/parsed_data_*.json
```

#### 5.4 스크랩 추적 임포트

```bash
npx tsx scripts/migration/11-import-scrap-tracking.ts logs/migration/parsed_data_*.json
```

---

### Phase 6: 최종 검증 (10-15분)

#### 6.1 레코드 수 검증

```bash
npm run db:check-data
```

**예상 출력**:
```
✅ companies: 120개
✅ items: 580개
✅ bom: 350개
✅ coil_specs: 180개
✅ price_master: 420개
✅ scrap_tracking: 230개
✅ inventory_transactions: 8,950개
✅ purchase_transactions: 2,450개
✅ sales_transactions: 3,120개
```

#### 6.2 참조 무결성 검증

```bash
npx tsx scripts/migration/12-verify-integrity.ts
```

**검증 항목**:
- [ ] 모든 items.supplier_id가 companies에 존재
- [ ] 모든 bom FK가 items에 존재
- [ ] 모든 거래 item_id가 items에 존재
- [ ] 순환 참조 없음
- [ ] 재고 음수 없음

#### 6.3 계산 검증

```bash
npx tsx scripts/migration/13-verify-calculations.ts
```

**검증 항목**:
- [ ] COIL EA중량 계산 일치
- [ ] COIL EA단가 계산 일치
- [ ] 스크랩금액 계산 일치
- [ ] 거래 합계 금액 일치

---

## 📊 실행 결과 보고서

### 마이그레이션 완료 체크리스트

- [ ] Phase 0: 준비 단계 완료
- [ ] Phase 1: 기존 데이터 삭제 완료
- [ ] Phase 2: Excel 파싱 완료 (120 companies, 580 items)
- [ ] Phase 3: 데이터 검증 완료 (Critical 오류 0개)
- [ ] Phase 4: 마스터 데이터 임포트 완료 (1,050개)
- [ ] Phase 5: 거래 데이터 임포트 완료 (14,750개)
- [ ] Phase 6: 최종 검증 완료 (무결성 100%)
- [ ] 프론트엔드 동작 확인 (http://localhost:5000)
- [ ] 샘플 쿼리 테스트 완료

### 예상 소요 시간

| Phase | 작업 | 예상 시간 |
|-------|------|----------|
| 0 | 준비 | 5분 |
| 1 | 기존 데이터 삭제 | 5-10분 |
| 2 | Excel 파싱 | 10-15분 |
| 3 | 데이터 검증 | 10-15분 |
| 4 | 마스터 데이터 임포트 | 15-20분 |
| 5 | 거래 데이터 임포트 | 20-30분 |
| 6 | 최종 검증 | 10-15분 |
| **합계** | | **75-110분** |

---

## 🚨 문제 해결

### 문제 1: Excel 파일 읽기 실패

**증상**: `Error: Cannot read file`

**해결책**:
```bash
# 파일 경로 확인
ls -la .plan2/참고/*.xlsx

# 파일 권한 확인
chmod 644 .plan2/참고/*.xlsx

# 파일 이름에 특수문자 있으면 이스케이프
```

### 문제 2: Supabase 연결 실패

**증상**: `Error: Invalid API key`

**해결책**:
```bash
# .env 파일 확인
cat .env | grep SUPABASE

# 환경 변수 재로드
source .env

# Supabase 프로젝트 상태 확인 (Dashboard)
```

### 문제 3: FK 제약 위반

**증상**: `Error: Foreign key constraint failed`

**해결책**:
```typescript
// 임포트 순서 확인 (부모 테이블 먼저)
1. companies
2. items
3. bom (items 이후)
4. transactions (items, companies 이후)

// FK 제약 일시 비활성화 (권장하지 않음)
// SET session_replication_role = 'replica';
// ... 데이터 임포트
// SET session_replication_role = 'origin';
```

### 문제 4: 메모리 부족

**증상**: `JavaScript heap out of memory`

**해결책**:
```bash
# Node.js 메모리 증가
NODE_OPTIONS=--max-old-space-size=4096 npx tsx script.ts

# 또는 배치 처리 크기 줄이기
const BATCH_SIZE = 100; // 1000 → 100
```

### 문제 5: 타임아웃

**증상**: `Error: Timeout waiting for response`

**해결책**:
```typescript
// Supabase 클라이언트 타임아웃 증가
const supabase = createClient(url, key, {
  db: {
    schema: 'public'
  },
  global: {
    fetch: (url, options) => {
      return fetch(url, {
        ...options,
        timeout: 60000 // 60초
      });
    }
  }
});
```

---

## 📝 롤백 절차

### 즉시 롤백 (Phase 1-3 실패 시)

```bash
# 이미 삭제된 데이터는 복구 불가
# Supabase 스냅샷에서 복원
# Settings → Database → Backups → Restore
```

### 부분 롤백 (Phase 4-6 실패 시)

```bash
# 실패한 Phase부터 재시작
# 예: Phase 5 실패 시

# 1. Phase 5 관련 데이터만 삭제
npx tsx scripts/migration/rollback-phase5.ts

# 2. Phase 5부터 재실행
npx tsx scripts/migration/08-import-inventory-transactions.ts
```

---

## ✅ 마이그레이션 성공 확인

### 1. 프론트엔드 접속

```bash
npm run dev:safe
# http://localhost:5000 접속
```

### 2. 대시보드 확인

- [ ] 통계 카드에 실제 데이터 표시
- [ ] 차트에 실제 데이터 표시
- [ ] 알림 패널 정상 작동

### 3. 마스터 데이터 조회

- [ ] 거래처 목록 정상 조회
- [ ] 품목 목록 정상 조회
- [ ] BOM 목록 정상 조회

### 4. 거래 데이터 조회

- [ ] 재고 거래 내역 정상 조회
- [ ] 매입/매출 거래 정상 조회
- [ ] 수금/지급 정상 조회 (있는 경우)

### 5. Excel 내보내기 테스트

- [ ] 재고 내보내기 정상 작동
- [ ] 매출 내보내기 정상 작동
- [ ] 매입 내보내기 정상 작동

---

**문서 완료** | 다음: [05_문제_해결_가이드.md](./05_문제_해결_가이드.md)
