Review this refined improvement plan for FITaeYoungERP based on your initial analysis:

## Your Priority 1 Critical Warning
> "Continuing to force dynamic rendering with a bloated bundle risks production outages during traffic spikes; address SSG/ISR and bundle hygiene immediately."

## Adjusted Wave Strategy

### Wave 1 (Parallel) - Foundation Layer (8 hours)
**Agent 2** (backend-architect): API Standardization (Your Priority 3)
- Consolidate 128 routes → 60 routes
- Create CRUDHandler base class
- Standardize APIResponse interface
- Centralize error handling

**Agent 3** (architect-reviewer): State Management (Your Priority 4)
- Install Zustand
- Create 4 stores: useAppStore, useUserStore, useFilterStore, useModalStore
- Create 3 contexts: UserContext, FilterContext, ModalContext
- Migrate 25 components from props drilling

**Agent 4** (frontend-developer): Bundle Optimization (Your Priority 1 partial + Priority 5)
- Delete transactionManager.ts (1,617 lines) + query-optimizer.ts (748 lines)
- Expand lazy loading: 4 components → 60 components
- Apply React.memo to 25 components
- **NEW**: Run webpack-bundle-analyzer and generate report
- Target: 500KB → 350KB (30% reduction)

### Wave 2 (Parallel with Dependencies) - Performance Critical Layer (6 hours)
**Agent 1** (frontend-developer): TanStack Query Migration (Your Priority 2)
- Dependencies: Wave 1 API standardization must complete first
- Migrate all 73 manual fetch patterns to useQuery/useMutation
- Implement queryKey hierarchy
- Configure staleTime per domain
- Add optimistic updates

**Agent 5** (architect-reviewer): ISR + SSG Restoration (Your Priority 1 - CRITICAL ELEVATED)
- **EXPANDED SCOPE to address your Critical Warning**:
  - Remove force-dynamic from all pages except dashboard
  - Implement ISR for semi-static pages (items, companies, etc.)
  - Implement SSG for fully static pages (landing, about, etc.)
  - Design cache invalidation strategy
  - Optimize routing and data loading
  - **NEW**: Setup performance budget CI
  - Target: Page load 2.3s → 1.0s (56% improvement)

### Wave 3 (Sequential) - Quality Assurance (4 hours)
**Agent 6** (code-reviewer): Code Quality (Your Priority 3)
- Enable React Strict Mode in next.config.js
- Create single Supabase client factory (browser/server variants)
- Standardize error-handling utilities
- Remove or complete MCP integration
- **NEW**: Full integration testing of Wave 1 & 2 changes
- **NEW**: Performance benchmark comparison (baseline vs. post-optimization)

## Implementation Sequence Alignment

Your recommended sequence:
1. Performance fixes (SSG/ISR, bundle, lazy loading) → Priority 1
2. Data fetching (TanStack Query) → Priority 2
3. API consolidation → Priority 3
4. Code quality (Strict Mode, Supabase) → Priority 3
5. State management (Zustand) → Priority 4
6. Legacy decomposition → Priority 5

Our adjusted Wave sequence:
- **Wave 1**: Addresses Priorities 3, 4, 5 + partial Priority 1 (bundle optimization)
- **Wave 2**: Addresses Priorities 1 (ISR/SSG - CRITICAL) + 2 (TanStack Query)
- **Wave 3**: Addresses Priority 3 (code quality) + integration validation

## Questions for Validation

1. **Critical Warning Resolution**: Does Wave 2 Agent 5's expanded scope properly address your Critical Warning about production outage risks?

2. **Wave Priority**: Should ISR/SSG restoration be moved to Wave 1 instead of Wave 2? Or is current sequence acceptable given:
   - Wave 1 reduces bundle size by 30% (immediate relief)
   - Wave 2 Agent 5 focuses entirely on SSG/ISR (dedicated attention)
   - Dependencies: TanStack Query benefits from standardized APIs (Wave 1 completion)

3. **Parallel Agent Conflicts**: Any conflicts or dependencies between:
   - Wave 1 agents (API, State, Bundle)?
   - Wave 2 agents (TanStack Query, ISR/SSG)?

4. **Missing Critical Items**: Are there any critical tasks missing from this sequence that could cause:
   - Production failures?
   - Performance regressions?
   - Integration issues?

5. **Bundle Optimization Scope**: Is bundle optimization in Wave 1 (legacy removal, lazy loading) sufficient for immediate relief, or should more aggressive performance work happen earlier?

6. **Performance Budget**: Is the target reduction realistic?
   - Bundle: 500KB → 350KB (30%)
   - Page load: 2.3s → 1.0s (56%)
   - Should these targets be adjusted?

7. **Risk Assessment**: What are the highest risks with this sequence?
   - Breaking changes during API standardization?
   - ISR cache invalidation complexity?
   - TanStack Query migration regression?

## Expected Deliverables Post-Waves

**Wave 1 Complete**:
- 68 fewer API routes (128 → 60)
- 150KB bundle reduction (500KB → 350KB)
- 56 additional lazy-loaded components (4 → 60)
- Zustand stores + Context providers operational
- Bundle analyzer report

**Wave 2 Complete**:
- Zero manual fetch patterns (73 → 0)
- 15+ pages using SSG/ISR (0 → 15+)
- Page load time < 1.0s (from 2.3s)
- TanStack Query caching active
- Performance budget CI enforced

**Wave 3 Complete**:
- React Strict Mode enabled
- Unified Supabase client pattern
- Integration tests passing
- Performance metrics validated

## Go/No-Go Decision Request

Based on this adjusted plan:
1. **Go**: Approve plan and proceed to Wave 1 execution
2. **No-Go with Adjustments**: Specify required changes before proceeding
3. **No-Go**: Fundamental issues requiring complete re-planning

Please provide:
- Decision: Go / No-Go with Adjustments / No-Go
- Required adjustments (if any)
- Risk assessment for approved plan
- Any additional recommendations
