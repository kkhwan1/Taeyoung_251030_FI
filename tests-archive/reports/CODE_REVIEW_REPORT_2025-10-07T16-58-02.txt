# ERP 시스템 코드 리뷰 보고서

생성일시: 2025. 10. 8. 오전 1:58:02
프로젝트: ERP_TEST

## 📊 전체 통계

- **총 파일 수**: 180개
### 카테고리별 파일 분포

- **components**: 54개 파일
- **lib**: 26개 파일
- **types**: 4개 파일
- **hooks**: 9개 파일
- **utils**: 6개 파일
- **pages**: 16개 파일
- **middleware**: 4개 파일
- **config**: 1개 파일
- **others**: 60개 파일

## 📁 파일 구조 분석

### COMPONENTS (54개 파일)

- `src\components\admin\ErrorDashboard.tsx`
  - 📏 크기: 12431 문자, 355 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 6개, export: 1개
- `src\components\AdvancedSearch.tsx`
  - 📏 크기: 32017 문자, 872 라인
  - 📝 함수: 15개, 클래스: 0개
  - 📦 import: 5개, export: 1개
- `src\components\BOMForm.tsx`
  - 📏 크기: 13390 문자, 373 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\charts\LowStockAlerts.tsx`
  - 📏 크기: 25356 문자, 669 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\charts\MonthlyInventoryTrends.tsx`
  - 📏 크기: 21580 문자, 618 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\charts\StockLevelsByCategory.tsx`
  - 📏 크기: 19806 문자, 541 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\charts\TopItemsByValue.tsx`
  - 📏 크기: 20387 문자, 567 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\charts\TransactionDistribution.tsx`
  - 📏 크기: 21470 문자, 576 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\CompanyForm.tsx`
  - 📏 크기: 11168 문자, 326 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\CompanySelect.tsx`
  - 📏 크기: 9220 문자, 281 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\ConfirmModal.tsx`
  - 📏 크기: 7250 문자, 223 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\components\dashboard\AlertPanel.tsx`
  - 📏 크기: 16240 문자, 439 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\dashboard\index.ts`
  - 📏 크기: 444 문자, 10 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 0개, export: 5개
- `src\components\dashboard\KPICards.tsx`
  - 📏 크기: 7886 문자, 253 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 4개, export: 2개
- `src\components\dashboard\QuickActionsWidget.tsx`
  - 📏 크기: 4691 문자, 158 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\dashboard\RealTimeDashboard.tsx`
  - 📏 크기: 13924 문자, 415 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 13개, export: 1개
- `src\components\dashboard\RecentActivityWidget.tsx`
  - 📏 크기: 10361 문자, 308 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\dashboard\RefreshControls.tsx`
  - 📏 크기: 3511 문자, 108 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\dashboard\StockChart.tsx`
  - 📏 크기: 13157 문자, 383 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 5개, export: 1개
- `src\components\dashboard\StockStatusWidget.tsx`
  - 📏 크기: 7853 문자, 245 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\dashboard\StockSummaryCard.tsx`
  - 📏 크기: 8119 문자, 257 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\dashboard\TransactionChart.tsx`
  - 📏 크기: 16788 문자, 468 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 5개, export: 1개
- `src\components\DateRangePicker.tsx`
  - 📏 크기: 13857 문자, 428 라인
  - 📝 함수: 15개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\components\demo\ToastDemo.tsx`
  - 📏 크기: 10159 문자, 318 라인
  - 📝 함수: 12개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\ExcelExportButton.tsx`
  - 📏 크기: 9463 문자, 353 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 6개
- `src\components\ItemForm.tsx`
  - 📏 크기: 21923 문자, 693 라인
  - 📝 함수: 13개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\ItemSelect.tsx`
  - 📏 크기: 9928 문자, 304 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 4개, export: 2개
- `src\components\layout\Header.tsx`
  - 📏 크기: 4610 문자, 115 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\layout\MainLayout.tsx`
  - 📏 크기: 2209 문자, 87 라인
  - 📝 함수: 4개, 클래스: 2개
  - 📦 import: 3개, export: 1개
- `src\components\layout\Sidebar.tsx`
  - 📏 크기: 6496 문자, 245 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\Modal.tsx`
  - 📏 크기: 1857 문자, 76 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\components\PrintButton.tsx`
  - 📏 크기: 15601 문자, 522 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 3개, export: 3개
- `src\components\ProductionForm.tsx`
  - 📏 크기: 18497 문자, 495 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\ReceivingForm.tsx`
  - 📏 크기: 12811 문자, 370 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 5개, export: 1개
- `src\components\SearchFilters\CategoryFilter.tsx`
  - 📏 크기: 7339 문자, 219 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 3개
- `src\components\SearchFilters\DateRangeFilter.tsx`
  - 📏 크기: 4806 문자, 151 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\components\SearchFilters\index.ts`
  - 📏 크기: 665 문자, 18 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 0개, export: 8개
- `src\components\SearchFilters\QuickFilters.tsx`
  - 📏 크기: 6392 문자, 254 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 3개, export: 5개
- `src\components\SearchFilters\SavedFilters.tsx`
  - 📏 크기: 13142 문자, 355 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\components\SearchFilters\StatusFilter.tsx`
  - 📏 크기: 6785 문자, 265 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 6개
- `src\components\SearchPresets.tsx`
  - 📏 크기: 14772 문자, 381 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\ShippingForm.tsx`
  - 📏 크기: 21209 문자, 597 라인
  - 📝 함수: 12개, 클래스: 0개
  - 📦 import: 6개, export: 1개
- `src\components\StockAdjustmentForm.tsx`
  - 📏 크기: 7568 문자, 249 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\components\Toast.tsx`
  - 📏 크기: 7458 문자, 242 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\components\ui\alert.tsx`
  - 📏 크기: 1582 문자, 55 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 2개
- `src\components\ui\badge.tsx`
  - 📏 크기: 933 문자, 36 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\components\ui\button.tsx`
  - 📏 크기: 1496 문자, 48 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\components\ui\card.tsx`
  - 📏 크기: 1482 문자, 64 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 4개
- `src\components\ui\LoadingSpinner.tsx`
  - 📏 크기: 4175 문자, 166 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 5개
- `src\components\ui\Skeleton.tsx`
  - 📏 크기: 5027 문자, 184 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 7개
- `src\components\ui\Toast.tsx`
  - 📏 크기: 7458 문자, 242 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\components\ui\VirtualGrid.tsx`
  - 📏 크기: 15339 문자, 432 라인
  - 📝 함수: 3개, 클래스: 1개
  - 📦 import: 4개, export: 3개
- `src\components\ui\VirtualTable.tsx`
  - 📏 크기: 12360 문자, 355 라인
  - 📝 함수: 1개, 클래스: 1개
  - 📦 import: 4개, export: 3개
- `src\components\upload\ExcelUploadModal.tsx`
  - 📏 크기: 11274 문자, 348 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 4개, export: 1개

**components 전체 통계**:
- 총 코드 크기: 575,722 문자
- 총 라인 수: 17,112 라인
- 총 함수 수: 223개
- 총 클래스 수: 4개

### LIB (26개 파일)

- `src\lib\api-error-handler.ts`
  - 📏 크기: 4342 문자, 203 라인
  - 📝 함수: 7개, 클래스: 2개
  - 📦 import: 1개, export: 10개
- `src\lib\auth.ts`
  - 📏 크기: 5361 문자, 195 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 4개, export: 8개
- `src\lib\bom.ts`
  - 📏 크기: 18505 문자, 707 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 2개, export: 8개
- `src\lib\db-health-check.ts`
  - 📏 크기: 10736 문자, 310 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 1개, export: 5개
- `src\lib\db-unified.ts`
  - 📏 크기: 21972 문자, 780 라인
  - 📝 함수: 14개, 클래스: 1개
  - 📦 import: 3개, export: 19개
- `src\lib\error-format.ts`
  - 📏 크기: 11761 문자, 488 라인
  - 📝 함수: 6개, 클래스: 1개
  - 📦 import: 0개, export: 18개
- `src\lib\errorAdapter.ts`
  - 📏 크기: 4418 문자, 203 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 2개, export: 9개
- `src\lib\errorHandler.ts`
  - 📏 크기: 14869 문자, 588 라인
  - 📝 함수: 5개, 클래스: 2개
  - 📦 import: 2개, export: 19개
- `src\lib\errorLogger.ts`
  - 📏 크기: 13431 문자, 450 라인
  - 📝 함수: 1개, 클래스: 4개
  - 📦 import: 2개, export: 7개
- `src\lib\excel-utils.ts`
  - 📏 크기: 1878 문자, 63 라인
  - 📝 함수: 8개, 클래스: 0개
  - 📦 import: 1개, export: 8개
- `src\lib\import-map.ts`
  - 📏 크기: 7673 문자, 232 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 0개, export: 13개
- `src\lib\logger.ts`
  - 📏 크기: 10911 문자, 418 라인
  - 📝 함수: 7개, 클래스: 1개
  - 📦 import: 2개, export: 11개
- `src\lib\middleware.ts`
  - 📏 크기: 5166 문자, 195 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 4개, export: 6개
- `src\lib\monitoring.ts`
  - 📏 크기: 11732 문자, 385 라인
  - 📝 함수: 11개, 클래스: 1개
  - 📦 import: 1개, export: 13개
- `src\lib\pagination.ts`
  - 📏 크기: 2818 문자, 114 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 0개, export: 8개
- `src\lib\query-optimizer.ts`
  - 📏 크기: 19626 문자, 749 라인
  - 📝 함수: 2개, 클래스: 6개
  - 📦 import: 1개, export: 10개
- `src\lib\response.ts`
  - 📏 크기: 2083 문자, 91 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 1개, export: 6개
- `src\lib\serial.ts`
  - 📏 크기: 3173 문자, 126 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 1개, export: 8개
- `src\lib\supabase-admin.ts`
  - 📏 크기: 10955 문자, 410 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 2개, export: 3개
- `src\lib\supabase-mcp.ts`
  - 📏 크기: 4768 문자, 166 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 1개, export: 4개
- `src\lib\supabase.ts`
  - 📏 크기: 24996 문자, 881 라인
  - 📝 함수: 8개, 클래스: 2개
  - 📦 import: 3개, export: 18개
- `src\lib\tax.ts`
  - 📏 크기: 6239 문자, 279 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 0개, export: 16개
- `src\lib\transactionManager.ts`
  - 📏 크기: 52956 문자, 1618 라인
  - 📝 함수: 4개, 클래스: 4개
  - 📦 import: 0개, export: 12개
- `src\lib\validation.ts`
  - 📏 크기: 10336 문자, 262 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 1개, export: 62개
- `src\lib\validationMiddleware.ts`
  - 📏 크기: 9744 문자, 358 라인
  - 📝 함수: 10개, 클래스: 0개
  - 📦 import: 3개, export: 13개
- `src\lib\workflow.ts`
  - 📏 크기: 6616 문자, 267 라인
  - 📝 함수: 10개, 클래스: 0개
  - 📦 import: 1개, export: 14개

**lib 전체 통계**:
- 총 코드 크기: 297,065 문자
- 총 라인 수: 10,538 라인
- 총 함수 수: 170개
- 총 클래스 수: 24개

### TYPES (4개 파일)

- `src\types\auth.ts`
  - 📏 크기: 3492 문자, 100 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 0개, export: 12개
- `src\types\inventory.ts`
  - 📏 크기: 7516 문자, 314 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 0개, export: 37개
- `src\types\supabase.ts`
  - 📏 크기: 28475 문자, 830 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 0개, export: 42개
- `src\types\upload.ts`
  - 📏 크기: 1106 문자, 50 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 0개, export: 8개

**types 전체 통계**:
- 총 코드 크기: 40,589 문자
- 총 라인 수: 1,294 라인
- 총 함수 수: 1개
- 총 클래스 수: 0개

### HOOKS (9개 파일)

- `src\hooks\useAdvancedFilter.tsx`
  - 📏 크기: 13651 문자, 471 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 3개, export: 4개
- `src\hooks\useAdvancedSearch.tsx`
  - 📏 크기: 13461 문자, 470 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 3개, export: 8개
- `src\hooks\useCompanies.ts`
  - 📏 크기: 6736 문자, 243 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 1개, export: 10개
- `src\hooks\useConfirm.tsx`
  - 📏 크기: 4219 문자, 178 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\hooks\useDashboardData.tsx`
  - 📏 크기: 10858 문자, 408 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 2개, export: 11개
- `src\hooks\useItems.ts`
  - 📏 크기: 7524 문자, 273 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 1개, export: 10개
- `src\hooks\useStockStatus.ts`
  - 📏 크기: 7232 문자, 253 라인
  - 📝 함수: 14개, 클래스: 0개
  - 📦 import: 1개, export: 13개
- `src\hooks\useToast.tsx`
  - 📏 크기: 3463 문자, 95 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\hooks\useTransactions.ts`
  - 📏 크기: 10207 문자, 312 라인
  - 📝 함수: 11개, 클래스: 0개
  - 📦 import: 1개, export: 11개

**hooks 전체 통계**:
- 총 코드 크기: 77,351 문자
- 총 라인 수: 2,703 라인
- 총 함수 수: 62개
- 총 클래스 수: 0개

### UTILS (6개 파일)

- `src\utils\chartUtils.d.ts`
  - 📏 크기: 3932 문자, 150 라인
  - 📝 함수: 15개, 클래스: 0개
  - 📦 import: 0개, export: 26개
- `src\utils\chartUtils.js`
  - 📏 크기: 11145 문자, 441 라인
  - 📝 함수: 15개, 클래스: 0개
  - 📦 import: 0개, export: 2개
- `src\utils\chartUtils.ts`
  - 📏 크기: 10492 문자, 390 라인
  - 📝 함수: 13개, 클래스: 0개
  - 📦 import: 1개, export: 17개
- `src\utils\excelExport.ts`
  - 📏 크기: 8580 문자, 286 라인
  - 📝 함수: 11개, 클래스: 0개
  - 📦 import: 1개, export: 7개
- `src\utils\printUtils.ts`
  - 📏 크기: 14457 문자, 503 라인
  - 📝 함수: 17개, 클래스: 0개
  - 📦 import: 0개, export: 18개
- `src\utils\searchUtils.ts`
  - 📏 크기: 8126 문자, 331 라인
  - 📝 함수: 14개, 클래스: 0개
  - 📦 import: 0개, export: 16개

**utils 전체 통계**:
- 총 코드 크기: 56,732 문자
- 총 라인 수: 2,101 라인
- 총 함수 수: 85개
- 총 클래스 수: 0개

### PAGES (16개 파일)

- `src\app\dashboard\page.tsx`
  - 📏 크기: 8601 문자, 245 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 5개, export: 1개
- `src\app\inventory\page.tsx`
  - 📏 크기: 20612 문자, 552 라인
  - 📝 함수: 8개, 클래스: 0개
  - 📦 import: 12개, export: 1개
- `src\app\inventory\receiving\page.tsx`
  - 📏 크기: 619 문자, 22 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\layout.tsx`
  - 📏 크기: 1006 문자, 43 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 7개, export: 2개
- `src\app\login\page.tsx`
  - 📏 크기: 3444 문자, 108 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 8개, export: 1개
- `src\app\master\bom\page.tsx`
  - 📏 크기: 16205 문자, 422 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 9개, export: 1개
- `src\app\master\companies\page.tsx`
  - 📏 크기: 19314 문자, 487 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 9개, export: 1개
- `src\app\master\items\page.tsx`
  - 📏 크기: 23492 문자, 552 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 9개, export: 1개
- `src\app\monitoring\health\page.tsx`
  - 📏 크기: 16545 문자, 404 라인
  - 📝 함수: 3개, 클래스: 1개
  - 📦 import: 2개, export: 1개
- `src\app\monitoring\page.tsx`
  - 📏 크기: 18212 문자, 506 라인
  - 📝 함수: 5개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\page.tsx`
  - 📏 크기: 3138 문자, 60 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\app\stock\current\page.tsx`
  - 📏 크기: 649 문자, 22 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\stock\history\page.tsx`
  - 📏 크기: 16130 문자, 395 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\stock\page.tsx`
  - 📏 크기: 18827 문자, 467 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\app\stock\reports\page.tsx`
  - 📏 크기: 20862 문자, 514 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\toast-demo\page.tsx`
  - 📏 크기: 1990 문자, 59 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개

**pages 전체 통계**:
- 총 코드 크기: 189,646 문자
- 총 라인 수: 4,858 라인
- 총 함수 수: 47개
- 총 클래스 수: 1개

### MIDDLEWARE (4개 파일)

- `src\middleware\cors.ts`
  - 📏 크기: 4866 문자, 177 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 6개
- `src\middleware\error-handler.ts`
  - 📏 크기: 10278 문자, 408 라인
  - 📝 함수: 18개, 클래스: 0개
  - 📦 import: 2개, export: 11개
- `src\middleware\rate-limit.ts`
  - 📏 크기: 9299 문자, 344 라인
  - 📝 함수: 8개, 클래스: 2개
  - 📦 import: 1개, export: 9개
- `src\middleware\security-headers.ts`
  - 📏 크기: 8779 문자, 309 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 1개, export: 7개

**middleware 전체 통계**:
- 총 코드 크기: 33,222 문자
- 총 라인 수: 1,238 라인
- 총 함수 수: 29개
- 총 클래스 수: 2개

### CONFIG (1개 파일)

- `src\config\security.ts`
  - 📏 크기: 8744 문자, 365 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 8개

**config 전체 통계**:
- 총 코드 크기: 8,744 문자
- 총 라인 수: 365 라인
- 총 함수 수: 3개
- 총 클래스 수: 0개

### OTHERS (60개 파일)

- `src\app\api\admin\errors\route.ts`
  - 📏 크기: 3132 문자, 113 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 4개, export: 2개
- `src\app\api\admin\errors\stats\route.ts`
  - 📏 크기: 839 문자, 29 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\alerts\low-stock\route.ts`
  - 📏 크기: 12995 문자, 416 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\auth\login\route.ts`
  - 📏 크기: 2281 문자, 85 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\auth\logout\route.ts`
  - 📏 크기: 726 문자, 36 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\app\api\auth\me\route.ts`
  - 📏 크기: 794 문자, 35 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\bom\explode\route.ts`
  - 📏 크기: 9190 문자, 333 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 4개, export: 2개
- `src\app\api\bom\route.ts`
  - 📏 크기: 9034 문자, 342 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\app\api\companies\route.example.ts`
  - 📏 크기: 10213 문자, 343 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 8개, export: 4개
- `src\app\api\companies\route.ts`
  - 📏 크기: 7734 문자, 290 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\app\api\dashboard\alerts\route.ts`
  - 📏 크기: 4574 문자, 161 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\dashboard\charts\route.ts`
  - 📏 크기: 6938 문자, 225 라인
  - 📝 함수: 9개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\dashboard\stats\route.ts`
  - 📏 크기: 3683 문자, 107 라인
  - 📝 함수: 0개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\app\api\download\template\companies\route.ts`
  - 📏 크기: 3144 문자, 127 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\download\template\items\route.ts`
  - 📏 크기: 2339 문자, 106 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\export\companies\route.ts`
  - 📏 크기: 5638 문자, 175 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\export\inventory\route.ts`
  - 📏 크기: 7180 문자, 227 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\app\api\export\items\route.ts`
  - 📏 크기: 4731 문자, 166 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\export\stock\route.ts`
  - 📏 크기: 7289 문자, 237 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 1개
- `src\app\api\export\[entity]\route.ts`
  - 📏 크기: 12176 문자, 457 라인
  - 📝 함수: 8개, 클래스: 0개
  - 📦 import: 4개, export: 1개
- `src\app\api\health\route.ts`
  - 📏 크기: 8745 문자, 280 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\import\inventory\route.ts`
  - 📏 크기: 8536 문자, 289 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 6개, export: 3개
- `src\app\api\import\[entity]\route.ts`
  - 📏 크기: 8373 문자, 296 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 5개, export: 2개
- `src\app\api\inventory\production\bom-check\route.ts`
  - 📏 크기: 9896 문자, 303 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\inventory\production\route.ts`
  - 📏 크기: 9168 문자, 315 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\app\api\inventory\receiving\route.ts`
  - 📏 크기: 3959 문자, 135 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\app\api\inventory\route.ts`
  - 📏 크기: 10724 문자, 360 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 7개, export: 2개
- `src\app\api\inventory\shipping\route.ts`
  - 📏 크기: 9688 문자, 340 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 2개, export: 4개
- `src\app\api\inventory\shipping\stock-check\route.ts`
  - 📏 크기: 12135 문자, 348 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\inventory\stock\route.ts`
  - 📏 크기: 2735 문자, 101 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\inventory\transactions\route.ts`
  - 📏 크기: 8817 문자, 284 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 5개, export: 2개
- `src\app\api\inventory\transactions\[id]\history\route.ts`
  - 📏 크기: 4899 문자, 160 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\inventory\transactions\[id]\status\route.ts`
  - 📏 크기: 6301 문자, 207 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\inventory\transfers\route.ts`
  - 📏 크기: 6156 문자, 216 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\items\route.ts`
  - 📏 크기: 16640 문자, 520 라인
  - 📝 함수: 17개, 클래스: 0개
  - 📦 import: 4개, export: 4개
- `src\app\api\items\[id]\route.ts`
  - 📏 크기: 7349 문자, 282 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 4개, export: 3개
- `src\app\api\metrics\route.ts`
  - 📏 크기: 11337 문자, 379 라인
  - 📝 함수: 6개, 클래스: 0개
  - 📦 import: 3개, export: 3개
- `src\app\api\migrate\add-safety-stock\route.ts`
  - 📏 크기: 4162 문자, 142 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\app\api\monitoring\route.ts`
  - 📏 크기: 807 문자, 33 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\app\api\reports\daily-report\route.ts`
  - 📏 크기: 6320 문자, 198 라인
  - 📝 함수: 7개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\security-test\route.ts`
  - 📏 크기: 1070 문자, 43 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 1개, export: 3개
- `src\app\api\simple\route.ts`
  - 📏 크기: 473 문자, 18 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\app\api\stock\adjustment\route.ts`
  - 📏 크기: 7711 문자, 266 라인
  - 📝 함수: 3개, 클래스: 0개
  - 📦 import: 2개, export: 2개
- `src\app\api\stock\alerts\route.ts`
  - 📏 크기: 4870 문자, 159 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\stock\current\route.ts`
  - 📏 크기: 1812 문자, 60 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\stock\debug\route.ts`
  - 📏 크기: 2769 문자, 89 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\stock\history\route.ts`
  - 📏 크기: 2299 문자, 71 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\stock\items\route.ts`
  - 📏 크기: 1295 문자, 43 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\stock\reports\route.ts`
  - 📏 크기: 875 문자, 32 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\app\api\stock\route.ts`
  - 📏 크기: 5862 문자, 196 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 3개, export: 2개
- `src\app\api\stock\simple\route.ts`
  - 📏 크기: 3474 문자, 112 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\test\route.ts`
  - 📏 크기: 448 문자, 17 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 1개, export: 1개
- `src\app\api\upload\companies\route.ts`
  - 📏 크기: 7986 문자, 253 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 5개, export: 2개
- `src\app\api\upload\items\route.ts`
  - 📏 크기: 7549 문자, 255 라인
  - 📝 함수: 4개, 클래스: 0개
  - 📦 import: 5개, export: 2개
- `src\app\api\users\route.ts`
  - 📏 크기: 1191 문자, 53 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 2개, export: 1개
- `src\app\api\warehouses\route.ts`
  - 📏 크기: 11939 문자, 428 라인
  - 📝 함수: 10개, 클래스: 0개
  - 📦 import: 4개, export: 4개
- `src\app\api\warehouses\stock\route.ts`
  - 📏 크기: 14167 문자, 455 라인
  - 📝 함수: 11개, 클래스: 0개
  - 📦 import: 4개, export: 3개
- `src\contexts\ThemeContext.tsx`
  - 📏 크기: 1648 문자, 67 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 1개, export: 2개
- `src\contexts\ToastContext.tsx`
  - 📏 크기: 6333 문자, 179 라인
  - 📝 함수: 2개, 클래스: 0개
  - 📦 import: 2개, export: 3개
- `src\providers\QueryProvider.tsx`
  - 📏 크기: 1476 문자, 50 라인
  - 📝 함수: 1개, 클래스: 0개
  - 📦 import: 3개, export: 2개

**others 전체 통계**:
- 총 코드 크기: 356,624 문자
- 총 라인 수: 12,044 라인
- 총 함수 수: 170개
- 총 클래스 수: 0개

## 📄 상세 코드 내용

> 이 섹션에는 모든 소스 파일의 실제 코드 내용이 포함됩니다.


---

### COMPONENTS 코드


#### 📄 src\components\admin\ErrorDashboard.tsx

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useToast } from '@/hooks/useToast';

interface ErrorStats {
  total_errors: number;
  critical_errors: number;
  high_errors: number;
  medium_errors: number;
  low_errors: number;
  unresolved_errors: number;
  today_errors: number;
  last_24h_errors: number;
  top_error_types: Array<{
    error_type: string;
    count: number;
    percentage: number;
  }>;
  error_trend: Array<{
    date: string;
    count: number;
    critical_count: number;
  }>;
}

interface ErrorLog {
  log_id: number;
  error_type: string;
  message: string;
  details?: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  status_code: number;
  timestamp: string;
  request_id?: string;
  user_id?: string;
  resource?: string;
  action?: string;
  resolved: boolean;
  resolved_at?: string;
  resolved_by?: string;
  created_at: string;
}

const severityColors = {
  CRITICAL: 'bg-red-100 text-red-800 border-red-200',
  HIGH: 'bg-orange-100 text-orange-800 border-orange-200',
  MEDIUM: 'bg-yellow-100 text-yellow-800 border-yellow-200',
  LOW: 'bg-blue-100 text-blue-800 border-blue-200'
};

const severityEmojis = {
  CRITICAL: '🚨',
  HIGH: '⚠️',
  MEDIUM: '⚡',
  LOW: 'ℹ️'
};

export default function ErrorDashboard() {
  const [stats, setStats] = useState<ErrorStats | null>(null);
  const [recentErrors, setRecentErrors] = useState<ErrorLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedSeverity, setSelectedSeverity] = useState<string>('');
  const [timeRange, setTimeRange] = useState(7);
  const { addToast } = useToast();

  // 에러 통계 로드
  const loadErrorStats = async () => {
    try {
      const response = await fetch(`/api/admin/errors/stats?days=${timeRange}`);
      const result = await response.json();

      if (result.success) {
        setStats(result.data);
      } else {
        addToast({ type: 'error', title: '에러 통계 로드 실패', message: '에러 통계를 불러오는데 실패했습니다' });
      }
    } catch (error) {
      console.error('Error loading stats:', error);
      addToast({ type: 'error', title: '에러 통계 로드 오류', message: '에러 통계 로드 중 오류가 발생했습니다' });
    }
  };

  // 최근 에러 로그 로드
  const loadRecentErrors = async () => {
    try {
      const params = new URLSearchParams({
        limit: '10',
        ...(selectedSeverity && { severity: selectedSeverity })
      });

      const response = await fetch(`/api/admin/errors?${params}`);
      const result = await response.json();

      if (result.success) {
        setRecentErrors(result.data);
      } else {
        addToast({ type: 'error', title: '최근 에러 로드 실패', message: '최근 에러 로그를 불러오는데 실패했습니다' });
      }
    } catch (error) {
      console.error('Error loading recent errors:', error);
      addToast({ type: 'error', title: '최근 에러 로드 오류', message: '최근 에러 로드 중 오류가 발생했습니다' });
    }
  };

  // 에러 해결 처리
  const resolveError = async (logId: number) => {
    try {
      const response = await fetch('/api/admin/errors', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
          log_id: logId,
          resolved_by: 'admin' // 실제 환경에서는 현재 사용자 ID 사용
        })
      });

      const result = await response.json();

      if (result.success) {
        addToast({ type: 'success', title: '에러 해결 완료', message: '에러가 해결로 표시되었습니다' });
        loadRecentErrors();
        loadErrorStats();
      } else {
        addToast({ type: 'error', title: '에러 해결 실패', message: '에러 해결 처리에 실패했습니다' });
      }
    } catch (error) {
      console.error('Error resolving error:', error);
      addToast({ type: 'error', title: '에러 해결 오류', message: '에러 해결 처리 중 오류가 발생했습니다' });
    }
  };

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      await Promise.all([loadErrorStats(), loadRecentErrors()]);
      setLoading(false);
    };

    loadData();
  }, [timeRange, selectedSeverity]);

  // 자동 새로고침 (30초마다)
  useEffect(() => {
    const interval = setInterval(() => {
      loadErrorStats();
      loadRecentErrors();
    }, 30000);

    return () => clearInterval(interval);
  }, [timeRange, selectedSeverity]);

  if (loading) {
    return (
      <div className="p-6">
        <div className="animate-pulse space-y-4">
          <div className="h-8 bg-gray-200 rounded w-1/4"></div>
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="h-32 bg-gray-200 rounded"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      {/* 헤더 */}
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold text-gray-900">에러 모니터링 대시보드</h1>
        <div className="flex space-x-2">
          <select
            value={timeRange}
            onChange={(e) => setTimeRange(parseInt(e.target.value))}
            className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
          >
            <option value={1}>1일</option>
            <option value={7}>7일</option>
            <option value={30}>30일</option>
            <option value={90}>90일</option>
          </select>
          <Button onClick={() => { loadErrorStats(); loadRecentErrors(); }}>
            새로고침
          </Button>
        </div>
      </div>

      {/* 통계 카드 */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm font-medium text-gray-600">총 에러</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats.total_errors.toLocaleString()}</div>
              <p className="text-xs text-gray-500 mt-1">최근 {timeRange}일</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm font-medium text-gray-600">크리티컬 에러</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-red-600">{stats.critical_errors.toLocaleString()}</div>
              <p className="text-xs text-gray-500 mt-1">즉시 조치 필요</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm font-medium text-gray-600">미해결 에러</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-orange-600">{stats.unresolved_errors.toLocaleString()}</div>
              <p className="text-xs text-gray-500 mt-1">해결 대기 중</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm font-medium text-gray-600">오늘 에러</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-blue-600">{stats.today_errors.toLocaleString()}</div>
              <p className="text-xs text-gray-500 mt-1">24시간: {stats.last_24h_errors.toLocaleString()}</p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* 에러 유형별 통계 */}
      {stats && stats.top_error_types.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>주요 에러 유형</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {stats.top_error_types.slice(0, 5).map((errorType, index) => (
                <div key={errorType.error_type} className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <span className="text-sm font-medium text-gray-900">
                      {index + 1}. {errorType.error_type}
                    </span>
                  </div>
                  <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-600">{errorType.count}회</span>
                    <Badge variant="outline">{errorType.percentage}%</Badge>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* 최근 에러 로그 */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>최근 에러 로그</CardTitle>
            <div className="flex space-x-2">
              <select
                value={selectedSeverity}
                onChange={(e) => setSelectedSeverity(e.target.value)}
                className="px-3 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="">모든 심각도</option>
                <option value="CRITICAL">크리티컬</option>
                <option value="HIGH">높음</option>
                <option value="MEDIUM">보통</option>
                <option value="LOW">낮음</option>
              </select>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {recentErrors.length === 0 ? (
              <p className="text-gray-500 text-center py-4">에러가 없습니다.</p>
            ) : (
              recentErrors.map((error) => (
                <div key={error.log_id} className="border border-gray-200 rounded-lg p-4 space-y-2">
                  <div className="flex items-start justify-between">
                    <div className="flex items-center space-x-2">
                      <span className="text-lg">{severityEmojis[error.severity]}</span>
                      <Badge className={severityColors[error.severity]}>
                        {error.severity}
                      </Badge>
                      <span className="text-sm font-medium">{error.error_type}</span>
                      {error.resolved && <Badge variant="outline" className="bg-green-50 text-green-700">해결됨</Badge>}
                    </div>
                    <div className="flex items-center space-x-2">
                      <span className="text-xs text-gray-500">
                        {new Date(error.created_at).toLocaleString('ko-KR')}
                      </span>
                      {!error.resolved && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => resolveError(error.log_id)}
                        >
                          해결 표시
                        </Button>
                      )}
                    </div>
                  </div>

                  <p className="text-sm text-gray-700">{error.message}</p>

                  <div className="flex items-center space-x-4 text-xs text-gray-500">
                    {error.resource && <span>리소스: {error.resource}</span>}
                    {error.action && <span>액션: {error.action}</span>}
                    {error.user_id && <span>사용자: {error.user_id}</span>}
                    <span>상태코드: {error.status_code}</span>
                  </div>

                  {error.details && (
                    <details className="text-xs">
                      <summary className="cursor-pointer text-gray-600 hover:text-gray-800">
                        상세 정보 보기
                      </summary>
                      <pre className="mt-2 p-2 bg-gray-50 rounded text-xs overflow-x-auto">
                        {typeof error.details === 'string' ? error.details : JSON.stringify(JSON.parse(error.details), null, 2)}
                      </pre>
                    </details>
                  )}
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      {/* 시스템 상태 알림 */}
      {stats && stats.critical_errors > 0 && (
        <Alert className="border-red-200 bg-red-50">
          <AlertDescription className="text-red-800">
            🚨 <strong>{stats.critical_errors}개의 크리티컬 에러</strong>가 발생했습니다. 즉시 조치가 필요합니다.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```


#### 📄 src\components\AdvancedSearch.tsx

```typescript
'use client';

import { useState, useRef, useEffect } from 'react';
import {
  Search, Filter, X, ChevronDown, ChevronUp, RotateCcw,
  Settings, Star, Download, SortAsc, SortDesc
} from 'lucide-react';
import DateRangePicker, { DateRange } from './DateRangePicker';
import SearchPresets from './SearchPresets';
import {
  useAdvancedSearch,
  ItemSearchFilters,
  CompanySearchFilters,
  BOMSearchFilters,
  TransactionSearchFilters,
  BaseSearchFilters
} from '@/hooks/useAdvancedSearch';

// Type definitions for number range inputs
interface NumberRange {
  min: number | null;
  max: number | null;
}

// Props for the AdvancedSearch component
interface AdvancedSearchProps<T extends BaseSearchFilters> {
  entityType: 'items' | 'companies' | 'bom' | 'transactions';
  initialFilters: T;
  onFiltersChange?: (filters: T) => void;
  onSearch?: (filters: T) => Promise<any[]>;
  searchResults?: any[];
  loading?: boolean;
  className?: string;
  placeholder?: string;
  showPresets?: boolean;
  showExport?: boolean;
  sortOptions?: Array<{ value: string; label: string }>;
}

// Filter chip component for displaying active filters
function FilterChip({
  label,
  value,
  onRemove
}: {
  label: string;
  value: string;
  onRemove: () => void;
}) {
  return (
    <div className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs rounded-full">
      <span className="font-medium">{label}:</span>
      <span>{value}</span>
      <button
        onClick={onRemove}
        className="ml-1 hover:bg-blue-200 dark:hover:bg-blue-800 rounded-full p-0.5"
      >
        <X className="w-3 h-3" />
      </button>
    </div>
  );
}

// Number range input component
function NumberRangeInput({
  value,
  onChange,
  placeholder,
  unit = '',
  min,
  max,
  step = 1
}: {
  value: NumberRange;
  onChange: (value: NumberRange) => void;
  placeholder?: { min?: string; max?: string };
  unit?: string;
  min?: number;
  max?: number;
  step?: number;
}) {
  return (
    <div className="flex items-center gap-2">
      <input
        type="number"
        value={value.min || ''}
        onChange={(e) => onChange({ ...value, min: e.target.value ? Number(e.target.value) : null })}
        placeholder={placeholder?.min || '최소값'}
        min={min}
        max={max}
        step={step}
        className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
      />
      <span className="text-gray-500 dark:text-gray-400 text-sm">~</span>
      <input
        type="number"
        value={value.max || ''}
        onChange={(e) => onChange({ ...value, max: e.target.value ? Number(e.target.value) : null })}
        placeholder={placeholder?.max || '최대값'}
        min={min}
        max={max}
        step={step}
        className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
      />
      {unit && <span className="text-gray-500 dark:text-gray-400 text-sm">{unit}</span>}
    </div>
  );
}

// Main AdvancedSearch component
export default function AdvancedSearch<T extends BaseSearchFilters>({
  entityType,
  initialFilters,
  onFiltersChange,
  onSearch,
  searchResults = [],
  loading = false,
  className = '',
  placeholder = '검색어를 입력하세요...',
  showPresets = true,
  showExport = true,
  sortOptions = []
}: AdvancedSearchProps<T>) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [showPresetPanel, setShowPresetPanel] = useState(false);
  const [searchSuggestions, setSearchSuggestions] = useState<string[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const searchInputRef = useRef<HTMLInputElement>(null);

  // Use the advanced search hook
  const {
    filters,
    results,
    loading: searchLoading,
    error,
    searchHistory,
    savedPresets,
    updateFilter,
    updateFilters,
    resetFilters,
    clearFilter,
    executeSearch,
    savePreset,
    loadPreset,
    deletePreset,
    hasActiveFilters,
    getActiveFilterCount
  } = useAdvancedSearch(entityType, initialFilters, onSearch);

  // Update parent component when filters change
  useEffect(() => {
    onFiltersChange?.(filters);
  }, [filters, onFiltersChange]);

  // Generate search suggestions based on search history and current input
  useEffect(() => {
    if (filters.search.trim()) {
      const suggestions = searchHistory
        .filter(term => term.toLowerCase().includes(filters.search.toLowerCase()) && term !== filters.search)
        .slice(0, 5);
      setSearchSuggestions(suggestions);
    } else {
      setSearchSuggestions(searchHistory.slice(0, 5));
    }
  }, [filters.search, searchHistory]);

  // Close suggestions when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (searchInputRef.current && !searchInputRef.current.contains(event.target as Node)) {
        setShowSuggestions(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Handle export search results
  const handleExportResults = () => {
    if (searchResults.length === 0) return;

    const csvContent = generateCSV(searchResults, entityType);
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${entityType}_search_results_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Generate CSV content based on entity type
  const generateCSV = (data: Record<string, any>[], type: string): string => {
    if (data.length === 0) return '';

    const headers = getCSVHeaders(type);
    const rows = data.map(item => headers.map(header => {
      const value = item[header.key];
      if (value === null || value === undefined) return '';
      if (typeof value === 'number') return value.toString();
      if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`;
      return `"${String(value).replace(/"/g, '""')}"`;
    }));

    return [
      headers.map(h => h.label).join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');
  };

  // Get CSV headers based on entity type
  const getCSVHeaders = (type: string) => {
    switch (type) {
      case 'items':
        return [
          { key: 'item_code', label: '품번' },
          { key: 'item_name', label: '품명' },
          { key: 'item_type', label: '타입' },
          { key: 'car_model', label: '차종' },
          { key: 'spec', label: '규격' },
          { key: 'unit', label: '단위' },
          { key: 'current_stock', label: '현재고' },
          { key: 'min_stock_level', label: '최소재고' },
          { key: 'unit_price', label: '단가' }
        ];
      case 'companies':
        return [
          { key: 'company_code', label: '거래처코드' },
          { key: 'company_name', label: '거래처명' },
          { key: 'company_type', label: '타입' },
          { key: 'contact_person', label: '담당자' },
          { key: 'phone', label: '전화번호' },
          { key: 'email', label: '이메일' }
        ];
      default:
        return [];
    }
  };

  // Create a wrapper function that converts the generic updateFilter to the expected signature
  const updateFilterWrapper = (key: string, value: unknown) => {
    updateFilter(key as keyof T, value as T[keyof T]);
  };

  // Render entity-specific filter fields
  const renderEntityFilters = () => {
    switch (entityType) {
      case 'items':
        return renderItemFilters(filters as unknown as ItemSearchFilters, updateFilterWrapper);
      case 'companies':
        return renderCompanyFilters(filters as unknown as CompanySearchFilters, updateFilterWrapper);
      case 'bom':
        return renderBOMFilters(filters as unknown as BOMSearchFilters, updateFilterWrapper);
      case 'transactions':
        return renderTransactionFilters(filters as unknown as TransactionSearchFilters, updateFilterWrapper);
      default:
        return null;
    }
  };

  // Render filter chips for active filters
  const renderFilterChips = () => {
    const chips: React.ReactElement[] = [];

    Object.entries(filters).forEach(([key, value]) => {
      if (key === 'search' || key === 'sortBy' || key === 'sortOrder') return;
      if (value === null || value === undefined || value === '' ||
          (Array.isArray(value) && value.length === 0)) return;

      let displayValue = '';
      let displayLabel = '';

      switch (key) {
        case 'dateRange':
          const range = value as DateRange;
          if (range.startDate || range.endDate) {
            displayLabel = '날짜';
            displayValue = `${range.startDate ? range.startDate.toLocaleDateString('ko-KR') : ''} ~ ${range.endDate ? range.endDate.toLocaleDateString('ko-KR') : ''}`;
          }
          break;
        case 'itemType':
          displayLabel = '품목타입';
          displayValue = value as string;
          break;
        case 'companyType':
          displayLabel = '거래처타입';
          displayValue = value as string;
          break;
        case 'stockLevel':
        case 'priceRange':
        case 'quantityRange':
        case 'amountRange':
          const range_val = value as NumberRange;
          if (range_val.min !== null || range_val.max !== null) {
            displayLabel = key === 'stockLevel' ? '재고수준' :
                          key === 'priceRange' ? '가격범위' :
                          key === 'quantityRange' ? '수량범위' : '금액범위';
            const min = range_val.min !== null ? range_val.min.toLocaleString() : '';
            const max = range_val.max !== null ? range_val.max.toLocaleString() : '';
            displayValue = `${min} ~ ${max}`;
          }
          break;
        case 'isLowStock':
          if (value === true) {
            displayLabel = '상태';
            displayValue = '재고부족';
          }
          break;
        case 'hasMinStock':
          if (value === true) {
            displayLabel = '최소재고';
            displayValue = '설정됨';
          }
          break;
        default:
          if (typeof value === 'string' && value.trim()) {
            displayLabel = key;
            displayValue = value;
          }
          break;
      }

      if (displayValue && displayLabel) {
        chips.push(
          <FilterChip
            key={key}
            label={displayLabel}
            value={displayValue}
            onRemove={() => clearFilter(key as keyof T)}
          />
        );
      }
    });

    return chips;
  };

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 ${className}`}>
      {/* Main Search Bar */}
      <div className="p-4">
        <div className="flex items-center gap-3">
          {/* Search Input */}
          <div className="flex-1 relative">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                ref={searchInputRef}
                type="text"
                value={filters.search}
                onChange={(e) => updateFilter('search' as keyof T, e.target.value as T[keyof T])}
                onFocus={() => setShowSuggestions(true)}
                placeholder={placeholder}
                className="w-full pl-10 pr-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />

              {/* Search Suggestions */}
              {showSuggestions && searchSuggestions.length > 0 && (
                <div className="absolute top-full left-0 right-0 mt-1 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg z-50 max-h-48 overflow-y-auto">
                  {searchSuggestions.map((suggestion, index) => (
                    <button
                      key={index}
                      onClick={() => {
                        updateFilter('search' as keyof T, suggestion as T[keyof T]);
                        setShowSuggestions(false);
                      }}
                      className="w-full px-4 py-2 text-left hover:bg-gray-100 dark:hover:bg-gray-600 text-sm text-gray-900 dark:text-white"
                    >
                      {suggestion}
                    </button>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* Sort Dropdown */}
          {sortOptions.length > 0 && (
            <div className="flex items-center gap-2">
              <select
                value={filters.sortBy}
                onChange={(e) => updateFilter('sortBy' as keyof T, e.target.value as T[keyof T])}
                className="px-3 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {sortOptions.map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
              <button
                onClick={() => updateFilter('sortOrder' as keyof T, (filters.sortOrder === 'asc' ? 'desc' : 'asc') as T[keyof T])}
                className="p-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                title={`정렬 순서: ${filters.sortOrder === 'asc' ? '오름차순' : '내림차순'}`}
              >
                {filters.sortOrder === 'asc' ? <SortAsc className="w-5 h-5" /> : <SortDesc className="w-5 h-5" />}
              </button>
            </div>
          )}

          {/* Filter Toggle */}
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className={`flex items-center gap-2 px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors ${hasActiveFilters ? 'bg-blue-50 dark:bg-blue-900 border-blue-300 dark:border-blue-600' : ''}`}
          >
            <Filter className="w-5 h-5" />
            <span className="hidden sm:inline">필터</span>
            {getActiveFilterCount > 0 && (
              <span className="bg-blue-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
                {getActiveFilterCount}
              </span>
            )}
            {isExpanded ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
          </button>

          {/* Presets Toggle */}
          {showPresets && (
            <button
              onClick={() => setShowPresetPanel(!showPresetPanel)}
              className="flex items-center gap-2 px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
            >
              <Star className="w-5 h-5" />
              <span className="hidden sm:inline">프리셋</span>
            </button>
          )}

          {/* Export Button */}
          {showExport && searchResults.length > 0 && (
            <button
              onClick={handleExportResults}
              className="flex items-center gap-2 px-4 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
              title="검색 결과 내보내기"
            >
              <Download className="w-5 h-5" />
              <span className="hidden sm:inline">내보내기</span>
            </button>
          )}

          {/* Reset Button */}
          {hasActiveFilters && (
            <button
              onClick={resetFilters}
              className="flex items-center gap-2 px-4 py-3 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
              title="모든 필터 초기화"
            >
              <RotateCcw className="w-5 h-5" />
              <span className="hidden sm:inline">초기화</span>
            </button>
          )}
        </div>

        {/* Filter Chips */}
        {hasActiveFilters && (
          <div className="flex flex-wrap gap-2 mt-3">
            {renderFilterChips()}
          </div>
        )}

        {/* Search Results Summary */}
        <div className="flex items-center justify-between mt-3 text-sm text-gray-600 dark:text-gray-400">
          <div>
            {loading || searchLoading ? (
              <span>검색 중...</span>
            ) : (
              <span>
                총 {searchResults.length.toLocaleString()}개 결과
                {hasActiveFilters && ' (필터 적용됨)'}
              </span>
            )}
          </div>
          {error && (
            <div className="text-red-500 dark:text-red-400">
              {error}
            </div>
          )}
        </div>
      </div>

      {/* Advanced Filters Panel */}
      {isExpanded && (
        <div className="border-t border-gray-200 dark:border-gray-700 p-4 bg-gray-50 dark:bg-gray-800">
          {renderEntityFilters()}
        </div>
      )}

      {/* Presets Panel */}
      {showPresetPanel && (
        <div className="border-t border-gray-200 dark:border-gray-700">
          <SearchPresets
            presets={savedPresets}
            onLoadPreset={loadPreset}
            onSavePreset={savePreset}
            onDeletePreset={deletePreset}
            currentFilters={filters}
            hasActiveFilters={hasActiveFilters}
          />
        </div>
      )}
    </div>
  );
}

// Helper functions to render entity-specific filters
function renderItemFilters(filters: ItemSearchFilters, updateFilter: (key: string, value: unknown) => void) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {/* Item Type */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          품목 타입
        </label>
        <select
          value={filters.itemType}
          onChange={(e) => updateFilter('itemType', e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="MATERIAL">자재</option>
          <option value="PRODUCT">제품</option>
          <option value="SCRAP">스크랩</option>
        </select>
      </div>

      {/* Car Model */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          차종
        </label>
        <input
          type="text"
          value={filters.carModel}
          onChange={(e) => updateFilter('carModel', e.target.value)}
          placeholder="차종 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Location */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          위치
        </label>
        <input
          type="text"
          value={filters.location}
          onChange={(e) => updateFilter('location', e.target.value)}
          placeholder="위치 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Stock Level Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          재고 수준
        </label>
        <NumberRangeInput
          value={filters.stockLevel}
          onChange={(value) => updateFilter('stockLevel', value)}
          placeholder={{ min: '최소 재고', max: '최대 재고' }}
          min={0}
        />
      </div>

      {/* Price Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          단가 범위
        </label>
        <NumberRangeInput
          value={filters.priceRange}
          onChange={(value) => updateFilter('priceRange', value)}
          placeholder={{ min: '최소 단가', max: '최대 단가' }}
          unit="원"
          min={0}
        />
      </div>

      {/* Boolean Filters */}
      <div className="space-y-3">
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
          상태 필터
        </label>
        <div className="space-y-2">
          <label className="flex items-center">
            <input
              type="checkbox"
              checked={filters.isLowStock === true}
              onChange={(e) => updateFilter('isLowStock', e.target.checked ? true : null)}
              className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            />
            <span className="ml-2 text-sm text-gray-700 dark:text-gray-300">재고 부족 품목만</span>
          </label>
          <label className="flex items-center">
            <input
              type="checkbox"
              checked={filters.hasMinStock === true}
              onChange={(e) => updateFilter('hasMinStock', e.target.checked ? true : null)}
              className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            />
            <span className="ml-2 text-sm text-gray-700 dark:text-gray-300">최소재고 설정된 품목만</span>
          </label>
        </div>
      </div>
    </div>
  );
}

function renderCompanyFilters(filters: CompanySearchFilters, updateFilter: (key: string, value: unknown) => void) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {/* Company Type */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          거래처 타입
        </label>
        <select
          value={filters.companyType}
          onChange={(e) => updateFilter('companyType', e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="CUSTOMER">고객사</option>
          <option value="SUPPLIER">공급사</option>
          <option value="BOTH">고객사/공급사</option>
        </select>
      </div>

      {/* Region */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          지역
        </label>
        <input
          type="text"
          value={filters.region}
          onChange={(e) => updateFilter('region', e.target.value)}
          placeholder="지역 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Contact Person */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          담당자
        </label>
        <input
          type="text"
          value={filters.contactPerson}
          onChange={(e) => updateFilter('contactPerson', e.target.value)}
          placeholder="담당자명 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Payment Terms */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          결제 조건
        </label>
        <input
          type="text"
          value={filters.paymentTerms}
          onChange={(e) => updateFilter('paymentTerms', e.target.value)}
          placeholder="결제 조건 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Date Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          등록일 범위
        </label>
        <DateRangePicker
          value={filters.dateRange}
          onChange={(value) => updateFilter('dateRange', value)}
          placeholder="날짜 범위 선택"
        />
      </div>

      {/* Active Status */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          활성 상태
        </label>
        <select
          value={filters.isActive === null ? '' : filters.isActive.toString()}
          onChange={(e) => updateFilter('isActive', e.target.value === '' ? null : e.target.value === 'true')}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="true">활성</option>
          <option value="false">비활성</option>
        </select>
      </div>
    </div>
  );
}

function renderBOMFilters(filters: BOMSearchFilters, updateFilter: (key: string, value: unknown) => void) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {/* Parent Item */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          상위 품목
        </label>
        <input
          type="text"
          value={filters.parentItem}
          onChange={(e) => updateFilter('parentItem', e.target.value)}
          placeholder="상위 품목 코드/명"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Child Item */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          하위 품목
        </label>
        <input
          type="text"
          value={filters.childItem}
          onChange={(e) => updateFilter('childItem', e.target.value)}
          placeholder="하위 품목 코드/명"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Hierarchy Level */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          계층 레벨
        </label>
        <input
          type="number"
          value={filters.hierarchyLevel || ''}
          onChange={(e) => updateFilter('hierarchyLevel', e.target.value ? Number(e.target.value) : null)}
          placeholder="계층 레벨"
          min={1}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Quantity Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          수량 범위
        </label>
        <NumberRangeInput
          value={filters.quantityRange}
          onChange={(value) => updateFilter('quantityRange', value)}
          placeholder={{ min: '최소 수량', max: '최대 수량' }}
          min={0}
          step={0.01}
        />
      </div>

      {/* Date Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          등록일 범위
        </label>
        <DateRangePicker
          value={filters.dateRange}
          onChange={(value) => updateFilter('dateRange', value)}
          placeholder="날짜 범위 선택"
        />
      </div>
    </div>
  );
}

function renderTransactionFilters(filters: TransactionSearchFilters, updateFilter: (key: string, value: unknown) => void) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {/* Transaction Type */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          거래 타입
        </label>
        <select
          value={filters.transactionType}
          onChange={(e) => updateFilter('transactionType', e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="입고">입고</option>
          <option value="생산">생산</option>
          <option value="출고">출고</option>
        </select>
      </div>

      {/* Item Code */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          품목 코드
        </label>
        <input
          type="text"
          value={filters.itemCode}
          onChange={(e) => updateFilter('itemCode', e.target.value)}
          placeholder="품목 코드 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Company Code */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          거래처 코드
        </label>
        <input
          type="text"
          value={filters.companyCode}
          onChange={(e) => updateFilter('companyCode', e.target.value)}
          placeholder="거래처 코드 입력"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>

      {/* Amount Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          수량 범위
        </label>
        <NumberRangeInput
          value={filters.amountRange}
          onChange={(value) => updateFilter('amountRange', value)}
          placeholder={{ min: '최소 수량', max: '최대 수량' }}
          min={0}
          step={0.01}
        />
      </div>

      {/* Date Range */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          거래일 범위
        </label>
        <DateRangePicker
          value={filters.dateRange}
          onChange={(value) => updateFilter('dateRange', value)}
          placeholder="날짜 범위 선택"
        />
      </div>

      {/* Status */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          상태
        </label>
        <select
          value={filters.status}
          onChange={(e) => updateFilter('status', e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="completed">완료</option>
          <option value="pending">대기</option>
          <option value="cancelled">취소</option>
        </select>
      </div>
    </div>
  );
}
```


#### 📄 src\components\BOMForm.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Save, Loader2, Search } from 'lucide-react';

interface BOM {
  bom_id?: number;
  parent_item_id: number;
  child_item_id: number;
  parent_item_name?: string;
  child_item_name?: string;
  quantity: number;
  notes?: string;
}

interface Item {
  item_id: number;
  item_code: string;
  item_name: string;
  item_type: 'MATERIAL' | 'PRODUCT' | 'SCRAP';
  unit: string;
}

interface BOMFormProps {
  bom?: BOM | null;
  items: Item[];
  onSubmit: (data: Omit<BOM, 'bom_id' | 'parent_item_name' | 'child_item_name'>) => Promise<void>;
  onCancel: () => void;
}

export default function BOMForm({ bom, items, onSubmit, onCancel }: BOMFormProps) {
  const [formData, setFormData] = useState<Omit<BOM, 'bom_id' | 'parent_item_name' | 'child_item_name'>>({
    parent_item_id: 0,
    child_item_id: 0,
    quantity: 1,
    notes: ''
  });
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [parentSearchTerm, setParentSearchTerm] = useState('');
  const [childSearchTerm, setChildSearchTerm] = useState('');
  const [showParentDropdown, setShowParentDropdown] = useState(false);
  const [showChildDropdown, setShowChildDropdown] = useState(false);
  const [selectedParentItem, setSelectedParentItem] = useState<Item | null>(null);
  const [selectedChildItem, setSelectedChildItem] = useState<Item | null>(null);


  useEffect(() => {
    if (bom) {
      setFormData({
        parent_item_id: bom.parent_item_id,
        child_item_id: bom.child_item_id,
        quantity: bom.quantity,
        notes: bom.notes || ''
      });

      // Find and set selected items
      const parentItem = items.find(item => item.item_id === bom.parent_item_id);
      const childItem = items.find(item => item.item_id === bom.child_item_id);

      if (parentItem) {
        setSelectedParentItem(parentItem);
        setParentSearchTerm(`${parentItem.item_code} - ${parentItem.item_name}`);
      }

      if (childItem) {
        setSelectedChildItem(childItem);
        setChildSearchTerm(`${childItem.item_code} - ${childItem.item_name}`);
      }
    }
  }, [bom, items]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'number' ? (value ? parseFloat(value) : 0) : value
    }));
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleParentSearch = (searchTerm: string) => {
    setParentSearchTerm(searchTerm);
    setShowParentDropdown(true);
    if (!searchTerm) {
      setSelectedParentItem(null);
      setFormData(prev => ({ ...prev, parent_item_id: 0 }));
    }
  };

  const handleChildSearch = (searchTerm: string) => {
    setChildSearchTerm(searchTerm);
    setShowChildDropdown(true);
    if (!searchTerm) {
      setSelectedChildItem(null);
      setFormData(prev => ({ ...prev, child_item_id: 0 }));
    }
  };

  const selectParentItem = (item: Item) => {
    setSelectedParentItem(item);
    setParentSearchTerm(`${item.item_code} - ${item.item_name}`);
    setFormData(prev => ({ ...prev, parent_item_id: item.item_id }));
    setShowParentDropdown(false);
    // Clear error
    if (errors.parent_item_id) {
      setErrors(prev => ({ ...prev, parent_item_id: '' }));
    }
  };

  const selectChildItem = (item: Item) => {
    setSelectedChildItem(item);
    setChildSearchTerm(`${item.item_code} - ${item.item_name}`);
    setFormData(prev => ({
      ...prev,
      child_item_id: item.item_id
    }));
    setShowChildDropdown(false);
    // Clear error
    if (errors.child_item_id) {
      setErrors(prev => ({ ...prev, child_item_id: '' }));
    }
  };

  const filteredParentItems = items.filter(item =>
    item.item_type === 'PRODUCT' &&
    (item.item_code.toLowerCase().includes(parentSearchTerm.toLowerCase()) ||
     item.item_name.toLowerCase().includes(parentSearchTerm.toLowerCase()))
  ).slice(0, 10);

  const filteredChildItems = items.filter(item =>
    item.item_id !== formData.parent_item_id && // Prevent self-referencing
    (item.item_code.toLowerCase().includes(childSearchTerm.toLowerCase()) ||
     item.item_name.toLowerCase().includes(childSearchTerm.toLowerCase()))
  ).slice(0, 10);

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.parent_item_id) {
      newErrors.parent_item_id = '모품목을 선택해주세요';
    }
    if (!formData.child_item_id) {
      newErrors.child_item_id = '자품목을 선택해주세요';
    }
    if (formData.parent_item_id === formData.child_item_id) {
      newErrors.child_item_id = '모품목과 자품목이 같을 수 없습니다';
    }
    if (!formData.quantity || formData.quantity <= 0) {
      newErrors.quantity = '소요량은 0보다 커야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    setLoading(true);
    try {
      await onSubmit(formData);
      // 성공 시 자동으로 모달 닫기
      onCancel();
    } catch (error) {
      // 에러는 상위 컴포넌트에서 처리
      console.error('Error submitting form:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* 모품목 (Parent Item) */}
        <div className="relative">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            모품목 <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <input
              type="text"
              value={parentSearchTerm}
              onChange={(e) => handleParentSearch(e.target.value)}
              onFocus={() => setShowParentDropdown(true)}
              onKeyDown={(e) => {
                if (e.key === 'Escape') {
                  setShowParentDropdown(false);
                } else if (e.key === 'ArrowDown' && filteredParentItems.length > 0) {
                  e.preventDefault();
                  setShowParentDropdown(true);
                }
              }}
              className={`w-full px-4 py-2 pr-10 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.parent_item_id ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
              }`}
              placeholder="모품목을 검색하세요..."
            />
            <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
          </div>

          {showParentDropdown && filteredParentItems.length > 0 && (
            <div className="absolute z-[9999] w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-y-auto">
              {filteredParentItems.map((item) => (
                <button
                  key={item.item_id}
                  type="button"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectParentItem(item);
                  }}
                  className="w-full px-4 py-2 text-left hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:bg-gray-50 dark:focus:bg-gray-700"
                >
                  <div className="text-sm font-medium text-gray-900 dark:text-white">
                    {item.item_code}
                  </div>
                  <div className="text-sm text-gray-600 dark:text-gray-400">
                    {item.item_name}
                  </div>
                </button>
              ))}
            </div>
          )}

          {errors.parent_item_id && (
            <p className="mt-1 text-sm text-red-500">{errors.parent_item_id}</p>
          )}
        </div>

        {/* 자품목 (Child Item) */}
        <div className="relative">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            자품목 <span className="text-red-500">*</span>
          </label>
          <div className="relative">
            <input
              type="text"
              value={childSearchTerm}
              onChange={(e) => handleChildSearch(e.target.value)}
              onFocus={() => setShowChildDropdown(true)}
              onKeyDown={(e) => {
                if (e.key === 'Escape') {
                  setShowChildDropdown(false);
                } else if (e.key === 'ArrowDown' && filteredChildItems.length > 0) {
                  e.preventDefault();
                  setShowChildDropdown(true);
                }
              }}
              className={`w-full px-4 py-2 pr-10 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.child_item_id ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
              }`}
              placeholder="자품목을 검색하세요..."
            />
            <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
          </div>

          {showChildDropdown && filteredChildItems.length > 0 && (
            <div className="absolute z-[9999] w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-y-auto">
              {filteredChildItems.map((item) => (
                <button
                  key={item.item_id}
                  type="button"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectChildItem(item);
                  }}
                  className="w-full px-4 py-2 text-left hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:bg-gray-50 dark:focus:bg-gray-700"
                >
                  <div className="text-sm font-medium text-gray-900 dark:text-white">
                    {item.item_code}
                  </div>
                  <div className="text-sm text-gray-600 dark:text-gray-400">
                    {item.item_name} ({item.item_type})
                  </div>
                </button>
              ))}
            </div>
          )}

          {errors.child_item_id && (
            <p className="mt-1 text-sm text-red-500">{errors.child_item_id}</p>
          )}
        </div>

        {/* 소요량 (Quantity) */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            소요량 <span className="text-red-500">*</span>
          </label>
          <input
            type="number"
            name="quantity"
            value={formData.quantity}
            onChange={handleChange}
            min="0"
            step="0.01"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.quantity ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="1"
          />
          {errors.quantity && (
            <p className="mt-1 text-sm text-red-500">{errors.quantity}</p>
          )}
        </div>

      </div>

      {/* 비고 (Notes) */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          비고
        </label>
        <textarea
          name="notes"
          value={formData.notes}
          onChange={handleChange}
          rows={3}
          className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="추가 정보나 특이사항을 입력하세요..."
        />
      </div>

      {/* Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200 dark:border-gray-700">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading}
          className="flex items-center gap-2 px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              처리중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              {bom ? '수정' : '등록'}
            </>
          )}
        </button>
      </div>

      {/* Click away handlers */}
      {(showParentDropdown || showChildDropdown) && (
        <div
          className="fixed inset-0 z-[9998]"
          onMouseDown={(e) => {
            e.preventDefault();
            e.stopPropagation();
            setShowParentDropdown(false);
            setShowChildDropdown(false);
          }}
        />
      )}
    </form>
  );
}
```


#### 📄 src\components\charts\LowStockAlerts.tsx

```typescript
/**
 * Low Stock Alerts Chart Component
 * Displays low stock alerts with warning indicators and priority levels
 */

import React, { useState, useRef, useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
  ReferenceLine,
  ComposedChart,
  Line,
  Area,
  AreaChart
} from 'recharts';
import {
  AlertTriangle,
  AlertCircle,
  Bell,
  Package,
  Clock,
  TrendingDown,
  Download,
  Printer,
  RefreshCcw,
  Filter,
  CheckCircle,
  XCircle
} from 'lucide-react';
import {
  formatKoreanNumber,
  formatKoreanDate,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  debounce
} from '../../utils/chartUtils';

interface LowStockAlertData {
  item_id: string;
  item_name: string;
  item_code: string;
  category: string;
  currentStock: number;
  minimumStock: number;
  safetyStock: number;
  averageConsumption: number;
  stockoutRisk: number; // 0-100 percentage
  daysUntilStockout: number;
  lastRestockDate: Date;
  supplier: string;
  leadTime: number; // days
  priority: 'critical' | 'high' | 'medium' | 'low';
  alertCreatedAt: Date;
  autoReorderEnabled: boolean;
  estimatedCost: number;
}

interface LowStockAlertsProps {
  data: LowStockAlertData[] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
  onRefresh?: () => void;
  showControls?: boolean;
  height?: number;
  className?: string;
  onItemClick?: (itemId: string) => void;
  onReorderClick?: (itemId: string) => void;
}

type ViewMode = 'chart' | 'list' | 'grid';
type SortBy = 'priority' | 'days' | 'risk' | 'stock' | 'cost';
type PriorityFilter = 'all' | 'critical' | 'high' | 'medium' | 'low';

export const LowStockAlerts: React.FC<LowStockAlertsProps> = ({
  data,
  loading,
  error,
  isDark = false,
  onRefresh,
  showControls = true,
  height = 400,
  className = '',
  onItemClick,
  onReorderClick
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('chart');
  const [sortBy, setSortBy] = useState<SortBy>('priority');
  const [priorityFilter, setPriorityFilter] = useState<PriorityFilter>('all');
  const [showOnlyActionable, setShowOnlyActionable] = useState(false);
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());

  const chartRef = useRef<any>(null);
  const theme = getRechartsTheme(isDark);

  // Priority colors and weights
  const priorityConfig = {
    critical: { color: '#DC2626', weight: 4, bgColor: 'bg-red-100 dark:bg-red-900/20', textColor: 'text-red-800 dark:text-red-200' },
    high: { color: '#EA580C', weight: 3, bgColor: 'bg-orange-100 dark:bg-orange-900/20', textColor: 'text-orange-800 dark:text-orange-200' },
    medium: { color: '#D97706', weight: 2, bgColor: 'bg-amber-100 dark:bg-amber-900/20', textColor: 'text-amber-800 dark:text-amber-200' },
    low: { color: '#65A30D', weight: 1, bgColor: 'bg-lime-100 dark:bg-lime-900/20', textColor: 'text-lime-800 dark:text-lime-200' }
  };

  // Process and filter data
  const processedData = useMemo(() => {
    if (!data) return [];

    let filtered = data;

    // Apply priority filter
    if (priorityFilter !== 'all') {
      filtered = filtered.filter(item => item.priority === priorityFilter);
    }

    // Apply actionable filter
    if (showOnlyActionable) {
      filtered = filtered.filter(item => item.daysUntilStockout <= 30);
    }

    // Sort data
    filtered = filtered.sort((a, b) => {
      switch (sortBy) {
        case 'priority':
          return priorityConfig[b.priority].weight - priorityConfig[a.priority].weight;
        case 'days':
          return a.daysUntilStockout - b.daysUntilStockout;
        case 'risk':
          return b.stockoutRisk - a.stockoutRisk;
        case 'stock':
          return (a.currentStock / a.minimumStock) - (b.currentStock / b.minimumStock);
        case 'cost':
          return b.estimatedCost - a.estimatedCost;
        default:
          return priorityConfig[b.priority].weight - priorityConfig[a.priority].weight;
      }
    });

    return filtered.map(item => ({
      ...item,
      displayName: item.item_name.length > 25 ? `${item.item_name.substring(0, 22)}...` : item.item_name,
      stockRatio: item.minimumStock > 0 ? (item.currentStock / item.minimumStock) : 0,
      urgencyScore: Math.min(100, (100 - item.daysUntilStockout) + item.stockoutRisk),
      color: priorityConfig[item.priority].color
    }));
  }, [data, priorityFilter, showOnlyActionable, sortBy]);

  // Calculate summary statistics
  const alertSummary = useMemo(() => {
    if (!processedData.length) return null;

    const critical = processedData.filter(item => item.priority === 'critical').length;
    const high = processedData.filter(item => item.priority === 'high').length;
    const medium = processedData.filter(item => item.priority === 'medium').length;
    const low = processedData.filter(item => item.priority === 'low').length;
    const immediate = processedData.filter(item => item.daysUntilStockout <= 7).length;
    const shortTerm = processedData.filter(item => item.daysUntilStockout <= 30).length;
    const autoReorderEnabled = processedData.filter(item => item.autoReorderEnabled).length;
    const totalCost = processedData.reduce((sum, item) => sum + item.estimatedCost, 0);

    return {
      total: processedData.length,
      critical,
      high,
      medium,
      low,
      immediate,
      shortTerm,
      autoReorderEnabled,
      totalCost,
      avgDaysUntilStockout: processedData.reduce((sum, item) => sum + item.daysUntilStockout, 0) / processedData.length
    };
  }, [processedData]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;

      return (
        <div
          className="bg-white dark:bg-gray-800 p-4 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg min-w-[300px]"
          style={theme.tooltip.contentStyle}
        >
          <div className="flex items-center space-x-2 mb-3">
            <AlertTriangle
              className={`w-5 h-5 ${
                data.priority === 'critical' ? 'text-red-500'
                : data.priority === 'high' ? 'text-orange-500'
                : data.priority === 'medium' ? 'text-amber-500'
                : 'text-lime-500'
              }`}
            />
            <p className="font-semibold text-gray-900 dark:text-gray-100">
              {data.item_name}
            </p>
          </div>

          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">현재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.currentStock)}개
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">최소재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.minimumStock)}개
                </p>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">재고부족 위험도</p>
                <p className={`font-medium ${
                  data.stockoutRisk >= 80 ? 'text-red-600'
                  : data.stockoutRisk >= 60 ? 'text-orange-600'
                  : data.stockoutRisk >= 40 ? 'text-amber-600'
                  : 'text-green-600'
                }`}>
                  {data.stockoutRisk}%
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">재고 소진까지</p>
                <p className={`font-medium ${
                  data.daysUntilStockout <= 7 ? 'text-red-600'
                  : data.daysUntilStockout <= 30 ? 'text-orange-600'
                  : 'text-green-600'
                }`}>
                  {data.daysUntilStockout}일
                </p>
              </div>
            </div>

            <div className="pt-2 border-t border-gray-200 dark:border-gray-600">
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">공급업체:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.supplier}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">리드타임:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.leadTime}일
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">예상 발주비용:</span>
                <span className="font-medium text-green-600 text-sm">
                  ₩{formatKoreanNumber(data.estimatedCost)}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">자동 재주문:</span>
                <span className={`font-medium text-sm ${
                  data.autoReorderEnabled ? 'text-green-600' : 'text-gray-600'
                }`}>
                  {data.autoReorderEnabled ? '활성화' : '비활성화'}
                </span>
              </div>
            </div>
          </div>
        </div>
      );
    }
    return null;
  };

  // Handle item selection
  const toggleItemSelection = (itemId: string) => {
    const newSelected = new Set(selectedItems);
    if (newSelected.has(itemId)) {
      newSelected.delete(itemId);
    } else {
      newSelected.add(itemId);
    }
    setSelectedItems(newSelected);
  };

  // Handle bar click
  const handleBarClick = (data: any) => {
    if (onItemClick) {
      onItemClick(data.item_id);
    }
    toggleItemSelection(data.item_id);
  };

  // Handle refresh with debounce
  const debouncedRefresh = debounce(() => {
    onRefresh?.();
  }, 1000);

  // Get priority icon
  const getPriorityIcon = (priority: string) => {
    switch (priority) {
      case 'critical':
        return <AlertTriangle className="w-4 h-4 text-red-500" />;
      case 'high':
        return <AlertCircle className="w-4 h-4 text-orange-500" />;
      case 'medium':
        return <Bell className="w-4 h-4 text-amber-500" />;
      default:
        return <Clock className="w-4 h-4 text-lime-500" />;
    }
  };

  if (error) {
    return (
      <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            재고 부족 알림
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <AlertTriangle className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>알림 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                className="mt-3 px-4 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 rounded-lg font-medium transition-colors"
              >
                다시 시도
              </button>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <AlertTriangle className="w-5 h-5 text-red-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            재고 부족 알림
          </h3>
          {alertSummary && (
            <span className={`ml-2 px-2 py-1 rounded-lg text-xs font-medium ${
              alertSummary.critical > 0
                ? 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-300'
                : alertSummary.high > 0
                ? 'bg-orange-100 text-orange-800 dark:bg-orange-900/20 dark:text-orange-300'
                : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
            }`}>
              {alertSummary.total}개 알림
            </span>
          )}
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex items-center space-x-2">
            {/* View Mode */}
            <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
              <button
                onClick={() => setViewMode('chart')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  viewMode === 'chart'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                차트
              </button>
              <button
                onClick={() => setViewMode('list')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  viewMode === 'list'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                목록
              </button>
            </div>

            {/* Priority Filter */}
            <select
              value={priorityFilter}
              onChange={(e) => setPriorityFilter(e.target.value as PriorityFilter)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="all">모든 우선순위</option>
              <option value="critical">긴급</option>
              <option value="high">높음</option>
              <option value="medium">보통</option>
              <option value="low">낮음</option>
            </select>

            {/* Sort By */}
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as SortBy)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="priority">우선순위</option>
              <option value="days">소진일수</option>
              <option value="risk">위험도</option>
              <option value="stock">재고비율</option>
              <option value="cost">발주비용</option>
            </select>

            {/* Actionable Filter */}
            <button
              onClick={() => setShowOnlyActionable(!showOnlyActionable)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                showOnlyActionable
                  ? 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              긴급 조치 필요
            </button>

            {/* Refresh Button */}
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                disabled={loading}
                className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
                title="알림 새로고침"
              >
                <RefreshCcw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </button>
            )}

            {/* Export buttons */}
            <button
              onClick={() => exportChartAsImage(chartRef, '재고부족알림.png')}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="이미지로 내보내기"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              onClick={() => printChart(chartRef)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="인쇄"
            >
              <Printer className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* Content */}
      <div ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-64">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-500"></div>
          </div>
        ) : !processedData.length ? (
          <div className="flex items-center justify-center h-64 text-gray-500">
            <div className="text-center">
              <CheckCircle className="w-12 h-12 mx-auto mb-2 text-green-500 opacity-50" />
              <p className="text-lg font-medium text-green-600">재고 부족 알림이 없습니다</p>
              <p className="text-sm text-gray-400 mt-1">
                모든 품목이 안전 재고 수준을 유지하고 있습니다
              </p>
            </div>
          </div>
        ) : viewMode === 'list' ? (
          <div className="space-y-3 max-h-96 overflow-y-auto">
            {processedData.map((item, index) => (
              <div
                key={item.item_id}
                className={`p-4 border border-gray-200 dark:border-gray-600 rounded-lg cursor-pointer transition-colors ${
                  selectedItems.has(item.item_id)
                    ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
                    : 'hover:bg-gray-50 dark:hover:bg-gray-800'
                } ${priorityConfig[item.priority].bgColor}`}
                onClick={() => handleBarClick(item)}
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    {getPriorityIcon(item.priority)}
                    <div>
                      <p className="font-medium text-gray-900 dark:text-white">
                        {item.item_name}
                      </p>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        {item.item_code} • {item.category}
                      </p>
                    </div>
                  </div>
                  <div className="flex items-center space-x-4 text-sm">
                    <div className="text-center">
                      <p className="text-gray-500 dark:text-gray-400">현재고</p>
                      <p className="font-medium">{formatKoreanNumber(item.currentStock)}개</p>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-500 dark:text-gray-400">소진까지</p>
                      <p className={`font-medium ${
                        item.daysUntilStockout <= 7 ? 'text-red-600'
                        : item.daysUntilStockout <= 30 ? 'text-orange-600'
                        : 'text-green-600'
                      }`}>
                        {item.daysUntilStockout}일
                      </p>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-500 dark:text-gray-400">위험도</p>
                      <p className={`font-medium ${
                        item.stockoutRisk >= 80 ? 'text-red-600'
                        : item.stockoutRisk >= 60 ? 'text-orange-600'
                        : 'text-amber-600'
                      }`}>
                        {item.stockoutRisk}%
                      </p>
                    </div>
                    {onReorderClick && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onReorderClick(item.item_id);
                        }}
                        className="px-3 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors"
                      >
                        재주문
                      </button>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="h-96">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
                <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
                <XAxis
                  dataKey="displayName"
                  tick={{ ...theme.xAxis.tick, fontSize: 11 }}
                  axisLine={theme.xAxis.axisLine}
                  angle={-45}
                  textAnchor="end"
                  height={80}
                  interval={0}
                />
                <YAxis
                  domain={[0, 100]}
                  tick={theme.yAxis.tick}
                  axisLine={theme.yAxis.axisLine}
                  label={{ value: '위험도 (%)', angle: -90, position: 'insideLeft' }}
                />
                <Tooltip content={<CustomTooltip />} />

                <Bar
                  dataKey="stockoutRisk"
                  name="재고부족 위험도"
                  onClick={handleBarClick}
                  cursor="pointer"
                  radius={[2, 2, 0, 0]}
                >
                  {processedData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={selectedItems.has(entry.item_id)
                        ? theme.colors[6]
                        : entry.color
                      }
                      opacity={selectedItems.size === 0 || selectedItems.has(entry.item_id) ? 1 : 0.3}
                    />
                  ))}
                </Bar>

                {/* Reference lines */}
                <ReferenceLine
                  y={80}
                  stroke="#DC2626"
                  strokeDasharray="5 5"
                  label={{ value: "긴급 (80%)", position: "insideTopLeft" }}
                />
                <ReferenceLine
                  y={60}
                  stroke="#EA580C"
                  strokeDasharray="3 3"
                  label={{ value: "높음 (60%)", position: "insideTopLeft" }}
                />
              </BarChart>
            </ResponsiveContainer>
          </div>
        )}
      </div>

      {/* Alert Summary */}
      {!loading && alertSummary && alertSummary.total > 0 && (
        <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">긴급 알림</p>
            <p className="text-lg font-semibold text-red-600">
              {alertSummary.critical}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">7일 내 소진</p>
            <p className="text-lg font-semibold text-orange-600">
              {alertSummary.immediate}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">자동 재주문</p>
            <p className="text-lg font-semibold text-green-600">
              {alertSummary.autoReorderEnabled}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">예상 발주비용</p>
            <p className="text-lg font-semibold text-blue-600">
              ₩{formatKoreanNumber(alertSummary.totalCost)}
            </p>
          </div>
        </div>
      )}

      {/* Selected Items Actions */}
      {selectedItems.size > 0 && (
        <div className="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Filter className="w-4 h-4 text-blue-600" />
              <span className="text-sm text-blue-800 dark:text-blue-300 font-medium">
                {selectedItems.size}개 품목 선택됨
              </span>
            </div>
            <div className="flex items-center space-x-2">
              {onReorderClick && (
                <button
                  onClick={() => {
                    selectedItems.forEach(itemId => onReorderClick(itemId));
                    setSelectedItems(new Set());
                  }}
                  className="px-3 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors"
                >
                  일괄 재주문
                </button>
              )}
              <button
                onClick={() => setSelectedItems(new Set())}
                className="text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200"
              >
                선택 해제
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\charts\MonthlyInventoryTrends.tsx

```typescript
/**
 * Monthly Inventory Trends Chart Component
 * Displays monthly inventory trends with interactive line chart
 */

import React, { useState, useRef, useMemo } from 'react';
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine
} from 'recharts';
import { TrendingUp, Calendar, Download, Printer, Settings, RefreshCcw } from 'lucide-react';
import {
  formatKoreanNumber,
  formatKoreanDate,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  debounce
} from '../../utils/chartUtils';

interface MonthlyTrendsData {
  month: string;
  date: Date;
  총재고량: number;
  입고량: number;
  출고량: number;
  생산량: number;
  재고가치: number;
  회전율: number;
}

interface MonthlyInventoryTrendsProps {
  data: MonthlyTrendsData[] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
  onRefresh?: () => void;
  showControls?: boolean;
  height?: number;
  className?: string;
}

type ChartType = 'line' | 'area';
type MetricType = 'quantity' | 'value' | 'turnover';

export const MonthlyInventoryTrends: React.FC<MonthlyInventoryTrendsProps> = ({
  data,
  loading,
  error,
  isDark = false,
  onRefresh,
  showControls = true,
  height = 400,
  className = ''
}) => {
  const [chartType, setChartType] = useState<ChartType>('line');
  const [selectedMetric, setSelectedMetric] = useState<MetricType>('quantity');
  const [timeRange, setTimeRange] = useState<'3m' | '6m' | '12m'>('6m');
  const [showMovingAverage, setShowMovingAverage] = useState(true);
  const [selectedLines, setSelectedLines] = useState({
    총재고량: true,
    입고량: true,
    출고량: true,
    생산량: false
  });

  const chartRef = useRef<any>(null);
  const theme = getRechartsTheme(isDark);

  // Filter data by time range
  const filteredData = useMemo(() => {
    if (!data) return [];

    const now = new Date();
    const monthsToShow = timeRange === '3m' ? 3 : timeRange === '6m' ? 6 : 12;
    const cutoffDate = new Date(now.getFullYear(), now.getMonth() - monthsToShow + 1, 1);

    return data
      .filter(item => item.date >= cutoffDate)
      .sort((a, b) => a.date.getTime() - b.date.getTime());
  }, [data, timeRange]);

  // Calculate moving averages
  const dataWithMovingAverage = useMemo(() => {
    if (!filteredData.length) return [];

    return filteredData.map((item, index) => {
      const windowSize = 3; // 3-month moving average
      const start = Math.max(0, index - windowSize + 1);
      const window = filteredData.slice(start, index + 1);

      const movingAverage = {
        총재고량_MA: window.reduce((sum, d) => sum + d.총재고량, 0) / window.length,
        입고량_MA: window.reduce((sum, d) => sum + d.입고량, 0) / window.length,
        출고량_MA: window.reduce((sum, d) => sum + d.출고량, 0) / window.length,
        생산량_MA: window.reduce((sum, d) => sum + d.생산량, 0) / window.length,
      };

      return {
        ...item,
        ...movingAverage
      };
    });
  }, [filteredData]);

  // Get display data based on selected metric
  const displayData = useMemo(() => {
    return dataWithMovingAverage.map(item => {
      switch (selectedMetric) {
        case 'value':
          return {
            ...item,
            총재고량: item.재고가치,
            입고량: item.입고량 * 1000, // Assume average unit price
            출고량: item.출고량 * 1000,
            생산량: item.생산량 * 1000,
          };
        case 'turnover':
          return {
            ...item,
            총재고량: item.회전율,
            입고량: item.회전율,
            출고량: item.회전율,
            생산량: item.회전율,
          };
        default:
          return item;
      }
    });
  }, [dataWithMovingAverage, selectedMetric]);

  // Calculate trend statistics
  const trendStats = useMemo(() => {
    if (!displayData.length) return null;

    const latest = displayData[displayData.length - 1];
    const previous = displayData.length > 1 ? displayData[displayData.length - 2] : latest;

    const calculateChange = (current: number, prev: number) => {
      return prev !== 0 ? ((current - prev) / prev * 100) : 0;
    };

    return {
      총재고량변화: calculateChange(latest.총재고량, previous.총재고량),
      입고량변화: calculateChange(latest.입고량, previous.입고량),
      출고량변화: calculateChange(latest.출고량, previous.출고량),
      생산량변화: calculateChange(latest.생산량, previous.생산량),
      평균회전율: displayData.reduce((sum, item) => sum + item.회전율, 0) / displayData.length,
    };
  }, [displayData]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div
          className="bg-white dark:bg-gray-800 p-4 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg min-w-[200px]"
          style={theme.tooltip.contentStyle}
        >
          <p className="font-semibold text-gray-900 dark:text-gray-100 mb-3">
            {label}
          </p>
          <div className="space-y-2">
            {payload.map((entry: any, index: number) => (
              <div key={index} className="flex justify-between items-center">
                <div className="flex items-center">
                  <span
                    className="w-3 h-3 rounded-full mr-2"
                    style={{ backgroundColor: entry.color }}
                  />
                  <span className="text-gray-600 dark:text-gray-400 text-sm">
                    {entry.name}:
                  </span>
                </div>
                <span className="font-medium text-gray-900 dark:text-gray-100">
                  {selectedMetric === 'value'
                    ? `₩${formatKoreanNumber(entry.value)}`
                    : selectedMetric === 'turnover'
                    ? `${entry.value.toFixed(2)}`
                    : `${formatKoreanNumber(entry.value)}개`
                  }
                </span>
              </div>
            ))}
          </div>

          {/* Additional insights */}
          {payload[0]?.payload && (
            <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-600">
              <div className="text-xs text-gray-500 dark:text-gray-400 space-y-1">
                <div className="flex justify-between">
                  <span>재고 회전율:</span>
                  <span>{payload[0].payload.회전율.toFixed(2)}</span>
                </div>
                {selectedMetric === 'quantity' && (
                  <div className="flex justify-between">
                    <span>순 변화:</span>
                    <span className={
                      (payload[0].payload.입고량 + payload[0].payload.생산량 - payload[0].payload.출고량) >= 0
                        ? 'text-green-600' : 'text-red-600'
                    }>
                      {formatKoreanNumber(payload[0].payload.입고량 + payload[0].payload.생산량 - payload[0].payload.출고량)}개
                    </span>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }
    return null;
  };

  // Toggle line visibility
  const toggleLine = (lineKey: keyof typeof selectedLines) => {
    setSelectedLines(prev => ({
      ...prev,
      [lineKey]: !prev[lineKey]
    }));
  };

  // Handle refresh with debounce
  const debouncedRefresh = debounce(() => {
    onRefresh?.();
  }, 1000);

  if (error) {
    return (
      <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            월별 재고 동향
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <TrendingUp className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                className="mt-3 px-4 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 rounded-lg font-medium transition-colors"
              >
                다시 시도
              </button>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <TrendingUp className="w-5 h-5 text-blue-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            월별 재고 동향
          </h3>
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex items-center space-x-2">
            {/* Time Range */}
            <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
              {(['3m', '6m', '12m'] as const).map(range => (
                <button
                  key={range}
                  onClick={() => setTimeRange(range)}
                  className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                    timeRange === range
                      ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                      : 'text-gray-600 dark:text-gray-400'
                  }`}
                >
                  {range === '3m' ? '3개월' : range === '6m' ? '6개월' : '12개월'}
                </button>
              ))}
            </div>

            {/* Metric Type */}
            <select
              value={selectedMetric}
              onChange={(e) => setSelectedMetric(e.target.value as MetricType)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="quantity">수량</option>
              <option value="value">금액</option>
              <option value="turnover">회전율</option>
            </select>

            {/* Chart Type */}
            <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
              <button
                onClick={() => setChartType('line')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  chartType === 'line'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                선형
              </button>
              <button
                onClick={() => setChartType('area')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  chartType === 'area'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                영역
              </button>
            </div>

            {/* Moving Average Toggle */}
            <button
              onClick={() => setShowMovingAverage(!showMovingAverage)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                showMovingAverage
                  ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              이동평균
            </button>

            {/* Refresh Button */}
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                disabled={loading}
                className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
                title="데이터 새로고침"
              >
                <RefreshCcw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </button>
            )}

            {/* Export buttons */}
            <button
              onClick={() => exportChartAsImage(chartRef, '월별재고동향.png')}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="이미지로 내보내기"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              onClick={() => printChart(chartRef)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="인쇄"
            >
              <Printer className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* Line Visibility Controls */}
      <div className="flex items-center space-x-4 mb-4">
        <span className="text-sm text-gray-600 dark:text-gray-400">표시 항목:</span>
        {Object.entries(selectedLines).map(([lineKey, selected]) => (
          <button
            key={lineKey}
            onClick={() => toggleLine(lineKey as keyof typeof selectedLines)}
            className={`flex items-center space-x-2 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
              selected
                ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
            }`}
          >
            <span
              className="w-3 h-3 rounded-full"
              style={{
                backgroundColor: theme.colors[Object.keys(selectedLines).indexOf(lineKey)]
              }}
            />
            <span>{lineKey}</span>
          </button>
        ))}
      </div>

      {/* Chart */}
      <div className="h-96" ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          </div>
        ) : !displayData.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <TrendingUp className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 동향 데이터가 없습니다</p>
            </div>
          </div>
        ) : chartType === 'area' ? (
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={displayData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="month"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
                angle={-45}
                textAnchor="end"
                height={80}
              />
              <YAxis
                tickFormatter={(value) =>
                  selectedMetric === 'value'
                    ? `₩${formatKoreanNumber(value)}`
                    : selectedMetric === 'turnover'
                    ? value.toFixed(1)
                    : formatKoreanNumber(value)
                }
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              {selectedLines.총재고량 && (
                <Area
                  type="monotone"
                  dataKey="총재고량"
                  name="총재고량"
                  stroke={theme.colors[0]}
                  fill={theme.colors[0]}
                  fillOpacity={0.3}
                  strokeWidth={2}
                />
              )}
              {selectedLines.입고량 && (
                <Area
                  type="monotone"
                  dataKey="입고량"
                  name="입고량"
                  stroke={theme.colors[1]}
                  fill={theme.colors[1]}
                  fillOpacity={0.3}
                  strokeWidth={2}
                />
              )}
              {selectedLines.출고량 && (
                <Area
                  type="monotone"
                  dataKey="출고량"
                  name="출고량"
                  stroke={theme.colors[2]}
                  fill={theme.colors[2]}
                  fillOpacity={0.3}
                  strokeWidth={2}
                />
              )}
              {selectedLines.생산량 && (
                <Area
                  type="monotone"
                  dataKey="생산량"
                  name="생산량"
                  stroke={theme.colors[3]}
                  fill={theme.colors[3]}
                  fillOpacity={0.3}
                  strokeWidth={2}
                />
              )}

              {/* Moving averages */}
              {showMovingAverage && selectedLines.총재고량 && (
                <Area
                  type="monotone"
                  dataKey="총재고량_MA"
                  name="총재고량 (이동평균)"
                  stroke={theme.colors[0]}
                  fill="none"
                  strokeWidth={3}
                  strokeDasharray="5 5"
                  fillOpacity={0}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        ) : (
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={displayData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="month"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
                angle={-45}
                textAnchor="end"
                height={80}
              />
              <YAxis
                tickFormatter={(value) =>
                  selectedMetric === 'value'
                    ? `₩${formatKoreanNumber(value)}`
                    : selectedMetric === 'turnover'
                    ? value.toFixed(1)
                    : formatKoreanNumber(value)
                }
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              {selectedLines.총재고량 && (
                <Line
                  type="monotone"
                  dataKey="총재고량"
                  name="총재고량"
                  stroke={theme.colors[0]}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
              {selectedLines.입고량 && (
                <Line
                  type="monotone"
                  dataKey="입고량"
                  name="입고량"
                  stroke={theme.colors[1]}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
              {selectedLines.출고량 && (
                <Line
                  type="monotone"
                  dataKey="출고량"
                  name="출고량"
                  stroke={theme.colors[2]}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
              {selectedLines.생산량 && (
                <Line
                  type="monotone"
                  dataKey="생산량"
                  name="생산량"
                  stroke={theme.colors[3]}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}

              {/* Moving averages */}
              {showMovingAverage && selectedLines.총재고량 && (
                <Line
                  type="monotone"
                  dataKey="총재고량_MA"
                  name="총재고량 (이동평균)"
                  stroke={theme.colors[0]}
                  strokeWidth={3}
                  strokeDasharray="5 5"
                  dot={false}
                />
              )}
            </LineChart>
          </ResponsiveContainer>
        )}
      </div>

      {/* Statistics Summary */}
      {!loading && displayData.length > 0 && trendStats && (
        <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총재고 변화</p>
            <p className={`text-lg font-semibold ${
              trendStats.총재고량변화 >= 0 ? 'text-green-600' : 'text-red-600'
            }`}>
              {trendStats.총재고량변화 >= 0 ? '+' : ''}{trendStats.총재고량변화.toFixed(1)}%
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">입고량 변화</p>
            <p className={`text-lg font-semibold ${
              trendStats.입고량변화 >= 0 ? 'text-green-600' : 'text-red-600'
            }`}>
              {trendStats.입고량변화 >= 0 ? '+' : ''}{trendStats.입고량변화.toFixed(1)}%
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">출고량 변화</p>
            <p className={`text-lg font-semibold ${
              trendStats.출고량변화 >= 0 ? 'text-green-600' : 'text-red-600'
            }`}>
              {trendStats.출고량변화 >= 0 ? '+' : ''}{trendStats.출고량변화.toFixed(1)}%
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">평균 회전율</p>
            <p className="text-lg font-semibold text-gray-900 dark:text-white">
              {trendStats.평균회전율.toFixed(2)}
            </p>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\charts\StockLevelsByCategory.tsx

```typescript
/**
 * Stock Levels by Category Chart Component
 * Displays stock levels grouped by category with interactive bar chart
 */

import React, { useState, useRef, useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine,
  Cell
} from 'recharts';
import { BarChart3, Package, Download, Printer, Filter, RefreshCcw, AlertTriangle } from 'lucide-react';
import {
  formatKoreanNumber,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  debounce,
  getStockLevelColor
} from '../../utils/chartUtils';

interface CategoryStockData {
  category: string;
  현재고: number;
  최소재고: number;
  안전재고: number;
  최대재고: number;
  품목수: number;
  재고가치: number;
  회전율: number;
  부족품목수: number;
  과재고품목수: number;
  재고비율?: number; // Calculated property for stock ratio
}

interface StockLevelsByCategoryProps {
  data: CategoryStockData[] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
  onRefresh?: () => void;
  showControls?: boolean;
  height?: number;
  className?: string;
  onCategoryClick?: (category: string) => void;
}

type ViewMode = 'quantity' | 'value' | 'ratio';
type SortOrder = 'name' | 'current' | 'shortage' | 'turnover';

export const StockLevelsByCategory: React.FC<StockLevelsByCategoryProps> = ({
  data,
  loading,
  error,
  isDark = false,
  onRefresh,
  showControls = true,
  height = 400,
  className = '',
  onCategoryClick
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('quantity');
  const [sortOrder, setSortOrder] = useState<SortOrder>('current');
  const [showSafetyStock, setShowSafetyStock] = useState(true);
  const [showMinimumStock, setShowMinimumStock] = useState(true);
  const [highlightIssues, setHighlightIssues] = useState(true);
  const [selectedCategories, setSelectedCategories] = useState<Set<string>>(new Set());

  const chartRef = useRef<any>(null);
  const theme = getRechartsTheme(isDark);

  // Process and sort data
  const processedData = useMemo(() => {
    if (!data) return [];

    const processed = data.map(item => ({
      ...item,
      재고비율: item.최소재고 > 0 ? (item.현재고 / item.최소재고) : 0,
      재고효율성: item.품목수 > 0 ? ((item.품목수 - item.부족품목수 - item.과재고품목수) / item.품목수 * 100) : 0,
      displayValue: viewMode === 'quantity' ? item.현재고
                   : viewMode === 'value' ? item.재고가치
                   : item.재고비율
    }));

    // Sort data
    processed.sort((a, b) => {
      switch (sortOrder) {
        case 'name':
          return a.category.localeCompare(b.category);
        case 'current':
          return b.현재고 - a.현재고;
        case 'shortage':
          return b.부족품목수 - a.부족품목수;
        case 'turnover':
          return b.회전율 - a.회전율;
        default:
          return 0;
      }
    });

    return processed;
  }, [data, viewMode, sortOrder]);

  // Calculate overall statistics
  const overallStats = useMemo(() => {
    if (!processedData.length) return null;

    const totalItems = processedData.reduce((sum, cat) => sum + cat.품목수, 0);
    const totalShortage = processedData.reduce((sum, cat) => sum + cat.부족품목수, 0);
    const totalOverstock = processedData.reduce((sum, cat) => sum + cat.과재고품목수, 0);
    const totalValue = processedData.reduce((sum, cat) => sum + cat.재고가치, 0);
    const avgTurnover = processedData.reduce((sum, cat) => sum + cat.회전율, 0) / processedData.length;

    return {
      totalCategories: processedData.length,
      totalItems,
      totalShortage,
      totalOverstock,
      totalValue,
      avgTurnover,
      efficiency: totalItems > 0 ? ((totalItems - totalShortage - totalOverstock) / totalItems * 100) : 0
    };
  }, [processedData]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;

      return (
        <div
          className="bg-white dark:bg-gray-800 p-4 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg min-w-[250px]"
          style={theme.tooltip.contentStyle}
        >
          <p className="font-semibold text-gray-900 dark:text-gray-100 mb-3">
            {label}
          </p>

          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">현재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.현재고)}개
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">재고가치</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  ₩{formatKoreanNumber(data.재고가치)}
                </p>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">최소재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.최소재고)}개
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">안전재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.안전재고)}개
                </p>
              </div>
            </div>

            <div className="pt-2 border-t border-gray-200 dark:border-gray-600">
              <div className="grid grid-cols-3 gap-2 text-center">
                <div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">총 품목</p>
                  <p className="font-medium text-blue-600">{data.품목수}개</p>
                </div>
                <div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">부족</p>
                  <p className="font-medium text-red-600">{data.부족품목수}개</p>
                </div>
                <div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">과재고</p>
                  <p className="font-medium text-orange-600">{data.과재고품목수}개</p>
                </div>
              </div>
            </div>

            <div className="pt-2 border-t border-gray-200 dark:border-gray-600">
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">재고 회전율:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100">
                  {data.회전율.toFixed(2)}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">재고 비율:</span>
                <span className={`font-medium ${
                  data.재고비율 < 0.5 ? 'text-red-600'
                  : data.재고비율 < 1 ? 'text-orange-600'
                  : 'text-green-600'
                }`}>
                  {(data.재고비율 * 100).toFixed(1)}%
                </span>
              </div>
            </div>
          </div>
        </div>
      );
    }
    return null;
  };

  // Get bar color based on stock level and issues
  const getBarColor = (entry: any, index: number) => {
    if (highlightIssues) {
      if (entry.부족품목수 > 0) return theme.colors[4]; // Red for shortage
      if (entry.과재고품목수 > entry.품목수 * 0.3) return theme.colors[3]; // Orange for overstock
    }
    return theme.colors[index % theme.colors.length];
  };

  // Handle category selection
  const toggleCategorySelection = (category: string) => {
    const newSelected = new Set(selectedCategories);
    if (newSelected.has(category)) {
      newSelected.delete(category);
    } else {
      newSelected.add(category);
    }
    setSelectedCategories(newSelected);
  };

  // Handle bar click
  const handleBarClick = (data: any) => {
    if (onCategoryClick) {
      onCategoryClick(data.category);
    }
    toggleCategorySelection(data.category);
  };

  // Handle refresh with debounce
  const debouncedRefresh = debounce(() => {
    onRefresh?.();
  }, 1000);

  if (error) {
    return (
      <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            카테고리별 재고 현황
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <BarChart3 className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                className="mt-3 px-4 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 rounded-lg font-medium transition-colors"
              >
                다시 시도
              </button>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <Package className="w-5 h-5 text-green-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            카테고리별 재고 현황
          </h3>
          {overallStats && (
            <span className="ml-2 px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs rounded-lg">
              {overallStats.totalCategories}개 카테고리
            </span>
          )}
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex items-center space-x-2">
            {/* View Mode */}
            <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
              <button
                onClick={() => setViewMode('quantity')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  viewMode === 'quantity'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                수량
              </button>
              <button
                onClick={() => setViewMode('value')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  viewMode === 'value'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                금액
              </button>
              <button
                onClick={() => setViewMode('ratio')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  viewMode === 'ratio'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                비율
              </button>
            </div>

            {/* Sort Order */}
            <select
              value={sortOrder}
              onChange={(e) => setSortOrder(e.target.value as SortOrder)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="current">현재고순</option>
              <option value="shortage">부족품목순</option>
              <option value="turnover">회전율순</option>
              <option value="name">이름순</option>
            </select>

            {/* Options */}
            <button
              onClick={() => setShowSafetyStock(!showSafetyStock)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                showSafetyStock
                  ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              안전재고
            </button>

            <button
              onClick={() => setHighlightIssues(!highlightIssues)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                highlightIssues
                  ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              <AlertTriangle className="w-4 h-4 mr-1" />
              이슈 강조
            </button>

            {/* Refresh Button */}
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                disabled={loading}
                className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
                title="데이터 새로고침"
              >
                <RefreshCcw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </button>
            )}

            {/* Export buttons */}
            <button
              onClick={() => exportChartAsImage(chartRef, '카테고리별재고현황.png')}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="이미지로 내보내기"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              onClick={() => printChart(chartRef)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="인쇄"
            >
              <Printer className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* Chart */}
      <div className="h-96" ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-green-500"></div>
          </div>
        ) : !processedData.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <Package className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 카테고리 데이터가 없습니다</p>
            </div>
          </div>
        ) : (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="category"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
                angle={-45}
                textAnchor="end"
                height={80}
                interval={0}
              />
              <YAxis
                tickFormatter={(value) =>
                  viewMode === 'value'
                    ? `₩${formatKoreanNumber(value)}`
                    : viewMode === 'ratio'
                    ? `${(value * 100).toFixed(0)}%`
                    : formatKoreanNumber(value)
                }
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              <Bar
                dataKey="displayValue"
                name={
                  viewMode === 'quantity' ? '현재고'
                  : viewMode === 'value' ? '재고가치'
                  : '재고비율'
                }
                onClick={handleBarClick}
                cursor="pointer"
                radius={[2, 2, 0, 0]}
              >
                {processedData.map((entry, index) => (
                  <Cell
                    key={`cell-${index}`}
                    fill={selectedCategories.has(entry.category)
                      ? theme.colors[6]
                      : getBarColor(entry, index)
                    }
                    opacity={selectedCategories.size === 0 || selectedCategories.has(entry.category) ? 1 : 0.3}
                  />
                ))}
              </Bar>

              {/* Reference lines for minimum and safety stock */}
              {viewMode === 'quantity' && showMinimumStock && (
                <ReferenceLine
                  y={processedData.reduce((sum, item) => sum + item.최소재고, 0) / processedData.length}
                  stroke={theme.colors[4]}
                  strokeDasharray="5 5"
                  label={{ value: "평균 최소재고", position: "insideTopLeft" }}
                />
              )}

              {viewMode === 'quantity' && showSafetyStock && (
                <ReferenceLine
                  y={processedData.reduce((sum, item) => sum + item.안전재고, 0) / processedData.length}
                  stroke={theme.colors[1]}
                  strokeDasharray="10 5"
                  label={{ value: "평균 안전재고", position: "insideTopLeft" }}
                />
              )}
            </BarChart>
          </ResponsiveContainer>
        )}
      </div>

      {/* Statistics Summary */}
      {!loading && processedData.length > 0 && overallStats && (
        <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 품목 수</p>
            <p className="text-lg font-semibold text-blue-600">
              {formatKoreanNumber(overallStats.totalItems)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">부족 품목</p>
            <p className="text-lg font-semibold text-red-600">
              {formatKoreanNumber(overallStats.totalShortage)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">과재고 품목</p>
            <p className="text-lg font-semibold text-orange-600">
              {formatKoreanNumber(overallStats.totalOverstock)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">재고 효율성</p>
            <p className={`text-lg font-semibold ${
              overallStats.efficiency >= 80 ? 'text-green-600'
              : overallStats.efficiency >= 60 ? 'text-yellow-600'
              : 'text-red-600'
            }`}>
              {overallStats.efficiency.toFixed(1)}%
            </p>
          </div>
        </div>
      )}

      {/* Selected Categories Info */}
      {selectedCategories.size > 0 && (
        <div className="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Filter className="w-4 h-4 text-blue-600" />
              <span className="text-sm text-blue-800 dark:text-blue-300 font-medium">
                선택된 카테고리: {Array.from(selectedCategories).join(', ')}
              </span>
            </div>
            <button
              onClick={() => setSelectedCategories(new Set())}
              className="text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200"
            >
              선택 해제
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\charts\TopItemsByValue.tsx

```typescript
/**
 * Top Items by Value Chart Component
 * Displays top items ranked by value with horizontal bar chart
 */

import React, { useState, useRef, useMemo } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
  ReferenceLine
} from 'recharts';
import { TrendingUp, Package, Download, Printer, RefreshCcw, Crown, Filter } from 'lucide-react';
import {
  formatKoreanNumber,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  debounce
} from '../../utils/chartUtils';

interface TopItemData {
  item_id: string;
  item_name: string;
  item_code: string;
  category: string;
  currentStock: number;
  unitPrice: number;
  totalValue: number;
  monthlyVolume: number;
  turnoverRate: number;
  lastTransactionDate: Date;
  supplier: string;
  stockStatus: 'low' | 'normal' | 'high' | 'overstock';
  rank: number;
}

interface TopItemsByValueProps {
  data: TopItemData[] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
  onRefresh?: () => void;
  showControls?: boolean;
  height?: number;
  className?: string;
  onItemClick?: (itemId: string) => void;
  limit?: number;
}

type SortMetric = 'value' | 'volume' | 'turnover' | 'stock';
type CategoryFilter = 'all' | string;

export const TopItemsByValue: React.FC<TopItemsByValueProps> = ({
  data,
  loading,
  error,
  isDark = false,
  onRefresh,
  showControls = true,
  height = 400,
  className = '',
  onItemClick,
  limit = 10
}) => {
  const [sortMetric, setSortMetric] = useState<SortMetric>('value');
  const [topCount, setTopCount] = useState(limit);
  const [categoryFilter, setCategoryFilter] = useState<CategoryFilter>('all');
  const [showStockStatus, setShowStockStatus] = useState(true);
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());

  const chartRef = useRef<any>(null);
  const theme = getRechartsTheme(isDark);

  // Get available categories
  const categories = useMemo(() => {
    if (!data) return [];
    return [...new Set(data.map(item => item.category))].sort();
  }, [data]);

  // Process and filter data
  const processedData = useMemo(() => {
    if (!data) return [];

    let filtered = data;

    // Apply category filter
    if (categoryFilter !== 'all') {
      filtered = filtered.filter(item => item.category === categoryFilter);
    }

    // Sort by selected metric
    filtered = filtered.sort((a, b) => {
      switch (sortMetric) {
        case 'value':
          return b.totalValue - a.totalValue;
        case 'volume':
          return b.monthlyVolume - a.monthlyVolume;
        case 'turnover':
          return b.turnoverRate - a.turnoverRate;
        case 'stock':
          return b.currentStock - a.currentStock;
        default:
          return b.totalValue - a.totalValue;
      }
    });

    // Take top N items
    const topItems = filtered.slice(0, topCount);

    // Add display value and colors
    return topItems.map((item, index) => ({
      ...item,
      displayName: item.item_name.length > 20
        ? `${item.item_name.substring(0, 17)}...`
        : item.item_name,
      displayValue: sortMetric === 'value' ? item.totalValue
                   : sortMetric === 'volume' ? item.monthlyVolume
                   : sortMetric === 'turnover' ? item.turnoverRate
                   : item.currentStock,
      color: getStatusColor(item.stockStatus),
      rank: index + 1
    }));
  }, [data, sortMetric, topCount, categoryFilter]);

  // Get stock status color
  function getStatusColor(status: string) {
    switch (status) {
      case 'low':
        return theme.colors[4]; // Red
      case 'normal':
        return theme.colors[1]; // Green
      case 'high':
        return theme.colors[0]; // Blue
      case 'overstock':
        return theme.colors[3]; // Orange
      default:
        return theme.colors[5]; // Gray
    }
  }

  // Calculate statistics
  const stats = useMemo(() => {
    if (!processedData.length) return null;

    const totalValue = processedData.reduce((sum, item) => sum + item.totalValue, 0);
    const totalVolume = processedData.reduce((sum, item) => sum + item.monthlyVolume, 0);
    const avgTurnover = processedData.reduce((sum, item) => sum + item.turnoverRate, 0) / processedData.length;
    const topItem = processedData[0];
    const topItemPercentage = data && data.length > 0
      ? (topItem.totalValue / data.reduce((sum, item) => sum + item.totalValue, 0)) * 100
      : 0;

    return {
      totalValue,
      totalVolume,
      avgTurnover,
      topItem: topItem.item_name,
      topItemValue: topItem.totalValue,
      topItemPercentage,
      lowStockCount: processedData.filter(item => item.stockStatus === 'low').length,
      overstockCount: processedData.filter(item => item.stockStatus === 'overstock').length
    };
  }, [processedData, data]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;

      return (
        <div
          className="bg-white dark:bg-gray-800 p-4 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg min-w-[280px]"
          style={theme.tooltip.contentStyle}
        >
          <div className="flex items-center space-x-2 mb-3">
            <Crown className="w-4 h-4 text-yellow-500" />
            <p className="font-semibold text-gray-900 dark:text-gray-100">
              #{data.rank} {data.item_name}
            </p>
          </div>

          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">품목코드</p>
                <p className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.item_code}
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">카테고리</p>
                <p className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.category}
                </p>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">재고가치</p>
                <p className="font-medium text-green-600 text-sm">
                  ₩{formatKoreanNumber(data.totalValue)}
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">현재고</p>
                <p className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {formatKoreanNumber(data.currentStock)}개
                </p>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">단가</p>
                <p className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  ₩{formatKoreanNumber(data.unitPrice)}
                </p>
              </div>
              <div>
                <p className="text-xs text-gray-500 dark:text-gray-400">월 거래량</p>
                <p className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {formatKoreanNumber(data.monthlyVolume)}개
                </p>
              </div>
            </div>

            <div className="pt-2 border-t border-gray-200 dark:border-gray-600">
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">회전율:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.turnoverRate.toFixed(2)}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">재고상태:</span>
                <span className={`font-medium text-sm ${
                  data.stockStatus === 'low' ? 'text-red-600'
                  : data.stockStatus === 'normal' ? 'text-green-600'
                  : data.stockStatus === 'high' ? 'text-blue-600'
                  : 'text-orange-600'
                }`}>
                  {data.stockStatus === 'low' ? '부족'
                   : data.stockStatus === 'normal' ? '정상'
                   : data.stockStatus === 'high' ? '충분'
                   : '과재고'}
                </span>
              </div>
              <div className="flex justify-between items-center">
                <span className="text-xs text-gray-500 dark:text-gray-400">공급업체:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100 text-sm">
                  {data.supplier}
                </span>
              </div>
            </div>
          </div>
        </div>
      );
    }
    return null;
  };

  // Handle bar click
  const handleBarClick = (data: any) => {
    if (onItemClick) {
      onItemClick(data.item_id);
    }

    const newSelected = new Set(selectedItems);
    if (newSelected.has(data.item_id)) {
      newSelected.delete(data.item_id);
    } else {
      newSelected.add(data.item_id);
    }
    setSelectedItems(newSelected);
  };

  // Handle refresh with debounce
  const debouncedRefresh = debounce(() => {
    onRefresh?.();
  }, 1000);

  // Get metric label
  const getMetricLabel = () => {
    switch (sortMetric) {
      case 'value': return '재고가치';
      case 'volume': return '월 거래량';
      case 'turnover': return '회전율';
      case 'stock': return '현재고';
      default: return '재고가치';
    }
  };

  if (error) {
    return (
      <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            상위 품목 (가치별)
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <TrendingUp className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                className="mt-3 px-4 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 rounded-lg font-medium transition-colors"
              >
                다시 시도
              </button>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <Crown className="w-5 h-5 text-yellow-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            상위 품목 ({getMetricLabel()})
          </h3>
          {stats && (
            <span className="ml-2 px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs rounded-lg">
              상위 {topCount}개 품목
            </span>
          )}
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex items-center space-x-2">
            {/* Top Count */}
            <select
              value={topCount}
              onChange={(e) => setTopCount(parseInt(e.target.value))}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value={5}>상위 5개</option>
              <option value={10}>상위 10개</option>
              <option value={20}>상위 20개</option>
              <option value={50}>상위 50개</option>
            </select>

            {/* Sort Metric */}
            <select
              value={sortMetric}
              onChange={(e) => setSortMetric(e.target.value as SortMetric)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="value">재고가치</option>
              <option value="volume">거래량</option>
              <option value="turnover">회전율</option>
              <option value="stock">재고수량</option>
            </select>

            {/* Category Filter */}
            <select
              value={categoryFilter}
              onChange={(e) => setCategoryFilter(e.target.value)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="all">전체 카테고리</option>
              {categories.map(category => (
                <option key={category} value={category}>
                  {category}
                </option>
              ))}
            </select>

            {/* Stock Status Toggle */}
            <button
              onClick={() => setShowStockStatus(!showStockStatus)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                showStockStatus
                  ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              재고상태
            </button>

            {/* Refresh Button */}
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                disabled={loading}
                className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
                title="데이터 새로고침"
              >
                <RefreshCcw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </button>
            )}

            {/* Export buttons */}
            <button
              onClick={() => exportChartAsImage(chartRef, '상위품목가치.png')}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="이미지로 내보내기"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              onClick={() => printChart(chartRef)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="인쇄"
            >
              <Printer className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* Chart */}
      <div className={`h-${Math.max(400, processedData.length * 40)}px`} ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-500"></div>
          </div>
        ) : !processedData.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <Package className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 품목 데이터가 없습니다</p>
              {categoryFilter !== 'all' && (
                <p className="text-sm text-gray-400 mt-1">
                  선택한 카테고리: {categoryFilter}
                </p>
              )}
            </div>
          </div>
        ) : (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={processedData}
              layout="horizontal"
              margin={{ top: 20, right: 30, left: 100, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                type="number"
                tickFormatter={(value) =>
                  sortMetric === 'value'
                    ? `₩${formatKoreanNumber(value)}`
                    : sortMetric === 'turnover'
                    ? value.toFixed(1)
                    : formatKoreanNumber(value)
                }
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
              />
              <YAxis
                type="category"
                dataKey="displayName"
                tick={{ ...theme.yAxis.tick, fontSize: 12 }}
                axisLine={theme.yAxis.axisLine}
                width={80}
              />
              <Tooltip content={<CustomTooltip />} />

              <Bar
                dataKey="displayValue"
                name={getMetricLabel()}
                onClick={handleBarClick}
                cursor="pointer"
                radius={[0, 2, 2, 0]}
              >
                {processedData.map((entry, index) => (
                  <Cell
                    key={`cell-${index}`}
                    fill={selectedItems.has(entry.item_id)
                      ? theme.colors[6]
                      : showStockStatus
                      ? entry.color
                      : theme.colors[0]
                    }
                    opacity={selectedItems.size === 0 || selectedItems.has(entry.item_id) ? 1 : 0.3}
                  />
                ))}
              </Bar>

              {/* Average line */}
              {stats && (
                <ReferenceLine
                  x={sortMetric === 'value' ? stats.totalValue / processedData.length
                     : sortMetric === 'volume' ? stats.totalVolume / processedData.length
                     : sortMetric === 'turnover' ? stats.avgTurnover
                     : processedData.reduce((sum, item) => sum + item.currentStock, 0) / processedData.length}
                  stroke={theme.colors[3]}
                  strokeDasharray="5 5"
                  label={{ value: "평균", position: "insideTopRight" }}
                />
              )}
            </BarChart>
          </ResponsiveContainer>
        )}
      </div>

      {/* Statistics Summary */}
      {!loading && processedData.length > 0 && stats && (
        <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">1위 품목</p>
            <p className="text-sm font-semibold text-yellow-600 truncate">
              {stats.topItem}
            </p>
            <p className="text-xs text-gray-500 dark:text-gray-400">
              ({stats.topItemPercentage.toFixed(1)}%)
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 재고가치</p>
            <p className="text-lg font-semibold text-green-600">
              ₩{formatKoreanNumber(stats.totalValue)}
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">평균 회전율</p>
            <p className="text-lg font-semibold text-blue-600">
              {stats.avgTurnover.toFixed(2)}
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">재고 이슈</p>
            <p className="text-lg font-semibold text-red-600">
              {stats.lowStockCount + stats.overstockCount}개
            </p>
          </div>
        </div>
      )}

      {/* Selected Items Info */}
      {selectedItems.size > 0 && (
        <div className="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Filter className="w-4 h-4 text-yellow-600" />
              <span className="text-sm text-yellow-800 dark:text-yellow-300 font-medium">
                선택된 품목: {selectedItems.size}개
              </span>
            </div>
            <button
              onClick={() => setSelectedItems(new Set())}
              className="text-sm text-yellow-600 hover:text-yellow-800 dark:text-yellow-400 dark:hover:text-yellow-200"
            >
              선택 해제
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\charts\TransactionDistribution.tsx

```typescript
/**
 * Transaction Distribution Chart Component
 * Displays transaction type distribution with interactive pie and donut charts
 */

import React, { useState, useRef, useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Tooltip,
  Legend,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid
} from 'recharts';
import { PieChart as PieChartIcon, BarChart3, Download, Printer, RefreshCcw, Activity } from 'lucide-react';
import {
  formatKoreanNumber,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  debounce,
  getTransactionTypeColor
} from '../../utils/chartUtils';

interface TransactionDistributionData {
  type: string;
  count: number;
  volume: number;
  value: number;
  percentage: number;
  items: number;
  avgPerTransaction: number;
  companies: number;
}

interface TransactionDistributionProps {
  data: TransactionDistributionData[] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
  onRefresh?: () => void;
  showControls?: boolean;
  height?: number;
  className?: string;
  onTypeClick?: (type: string) => void;
}

type ChartType = 'pie' | 'donut' | 'bar';
type MetricType = 'count' | 'volume' | 'value';
type TimeRange = 'today' | 'week' | 'month' | 'quarter';

export const TransactionDistribution: React.FC<TransactionDistributionProps> = ({
  data,
  loading,
  error,
  isDark = false,
  onRefresh,
  showControls = true,
  height = 400,
  className = '',
  onTypeClick
}) => {
  const [chartType, setChartType] = useState<ChartType>('donut');
  const [selectedMetric, setSelectedMetric] = useState<MetricType>('volume');
  const [timeRange, setTimeRange] = useState<TimeRange>('month');
  const [showLabels, setShowLabels] = useState(true);
  const [showLegend, setShowLegend] = useState(true);
  const [selectedTypes, setSelectedTypes] = useState<Set<string>>(new Set());

  const chartRef = useRef<any>(null);
  const theme = getRechartsTheme(isDark);

  // Process data for display
  const processedData = useMemo(() => {
    if (!data) return [];

    return data.map((item, index) => ({
      ...item,
      displayValue: selectedMetric === 'count' ? item.count
                   : selectedMetric === 'volume' ? item.volume
                   : item.value,
      color: getTransactionTypeColor(item.type, isDark),
      id: `${item.type}-${index}`
    })).sort((a, b) => b.displayValue - a.displayValue);
  }, [data, selectedMetric, isDark]);

  // Calculate total and percentages
  const totals = useMemo(() => {
    if (!processedData.length) return null;

    const total = processedData.reduce((sum, item) => sum + item.displayValue, 0);
    const totalCount = processedData.reduce((sum, item) => sum + item.count, 0);
    const totalVolume = processedData.reduce((sum, item) => sum + item.volume, 0);
    const totalValue = processedData.reduce((sum, item) => sum + item.value, 0);

    return {
      total,
      totalCount,
      totalVolume,
      totalValue,
      avgTransaction: totalCount > 0 ? totalVolume / totalCount : 0,
      topType: processedData[0]?.type || '',
      topPercentage: total > 0 ? (processedData[0]?.displayValue || 0) / total * 100 : 0
    };
  }, [processedData]);

  // Custom tooltip for pie charts
  const PieTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0];
      const percentage = totals && totals.total > 0 ? (data.value / totals.total * 100) : 0;

      return (
        <div
          className="bg-white dark:bg-gray-800 p-4 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg min-w-[200px]"
          style={theme.tooltip.contentStyle}
        >
          <div className="flex items-center space-x-2 mb-3">
            <span
              className="w-4 h-4 rounded-full"
              style={{ backgroundColor: data.payload.color }}
            />
            <p className="font-semibold text-gray-900 dark:text-gray-100">
              {data.payload.type}
            </p>
          </div>

          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400 text-sm">거래 건수:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {formatKoreanNumber(data.payload.count)}건
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400 text-sm">거래량:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {formatKoreanNumber(data.payload.volume)}개
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400 text-sm">거래금액:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                ₩{formatKoreanNumber(data.payload.value)}
              </span>
            </div>
            <div className="flex justify-between items-center pt-2 border-t border-gray-200 dark:border-gray-600">
              <span className="text-gray-600 dark:text-gray-400 text-sm">비율:</span>
              <span className="font-medium text-blue-600">
                {percentage.toFixed(1)}%
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400 text-sm">평균 거래량:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {formatKoreanNumber(data.payload.avgPerTransaction)}개
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400 text-sm">거래처 수:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {data.payload.companies}개
              </span>
            </div>
          </div>
        </div>
      );
    }
    return null;
  };

  // Custom label function
  const renderCustomLabel = ({
    cx, cy, midAngle, innerRadius, outerRadius, percent, name
  }: any) => {
    if (!showLabels || percent < 0.05) return null; // Don't show labels for slices < 5%

    const RADIAN = Math.PI / 180;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);

    return (
      <text
        x={x}
        y={y}
        fill={isDark ? '#F9FAFB' : '#1F2937'}
        textAnchor={x > cx ? 'start' : 'end'}
        dominantBaseline="central"
        fontSize="12"
        fontWeight="500"
      >
        {`${name} ${(percent * 100).toFixed(1)}%`}
      </text>
    );
  };

  // Handle sector click
  const handleSectorClick = (data: any) => {
    if (onTypeClick) {
      onTypeClick(data.type);
    }

    const newSelected = new Set(selectedTypes);
    if (newSelected.has(data.type)) {
      newSelected.delete(data.type);
    } else {
      newSelected.add(data.type);
    }
    setSelectedTypes(newSelected);
  };

  // Handle refresh with debounce
  const debouncedRefresh = debounce(() => {
    onRefresh?.();
  }, 1000);

  // Get metric label
  const getMetricLabel = () => {
    switch (selectedMetric) {
      case 'count': return '거래 건수';
      case 'volume': return '거래량';
      case 'value': return '거래금액';
      default: return '거래량';
    }
  };

  if (error) {
    return (
      <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            거래 유형 분포
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <PieChartIcon className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                className="mt-3 px-4 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 rounded-lg font-medium transition-colors"
              >
                다시 시도
              </button>
            )}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <Activity className="w-5 h-5 text-purple-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            거래 유형 분포
          </h3>
          {totals && (
            <span className="ml-2 px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 text-xs rounded-lg">
              총 {formatKoreanNumber(totals.totalCount)}건
            </span>
          )}
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex items-center space-x-2">
            {/* Time Range */}
            <select
              value={timeRange}
              onChange={(e) => setTimeRange(e.target.value as TimeRange)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="today">오늘</option>
              <option value="week">이번 주</option>
              <option value="month">이번 달</option>
              <option value="quarter">이번 분기</option>
            </select>

            {/* Metric Type */}
            <select
              value={selectedMetric}
              onChange={(e) => setSelectedMetric(e.target.value as MetricType)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
            >
              <option value="count">건수</option>
              <option value="volume">수량</option>
              <option value="value">금액</option>
            </select>

            {/* Chart Type */}
            <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
              <button
                onClick={() => setChartType('pie')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  chartType === 'pie'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                파이
              </button>
              <button
                onClick={() => setChartType('donut')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  chartType === 'donut'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                도넛
              </button>
              <button
                onClick={() => setChartType('bar')}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                  chartType === 'bar'
                    ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400'
                }`}
              >
                막대
              </button>
            </div>

            {/* Options */}
            {chartType !== 'bar' && (
              <>
                <button
                  onClick={() => setShowLabels(!showLabels)}
                  className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                    showLabels
                      ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                      : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
                  }`}
                >
                  레이블
                </button>

                <button
                  onClick={() => setShowLegend(!showLegend)}
                  className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                    showLegend
                      ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                      : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
                  }`}
                >
                  범례
                </button>
              </>
            )}

            {/* Refresh Button */}
            {onRefresh && (
              <button
                onClick={debouncedRefresh}
                disabled={loading}
                className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
                title="데이터 새로고침"
              >
                <RefreshCcw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              </button>
            )}

            {/* Export buttons */}
            <button
              onClick={() => exportChartAsImage(chartRef, '거래유형분포.png')}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="이미지로 내보내기"
            >
              <Download className="w-4 h-4" />
            </button>

            <button
              onClick={() => printChart(chartRef)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
              title="인쇄"
            >
              <Printer className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* Chart */}
      <div className="h-96" ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500"></div>
          </div>
        ) : !processedData.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <PieChartIcon className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 거래 데이터가 없습니다</p>
            </div>
          </div>
        ) : chartType === 'bar' ? (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={processedData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="type"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
                angle={-45}
                textAnchor="end"
                height={80}
              />
              <YAxis
                tickFormatter={(value) =>
                  selectedMetric === 'value'
                    ? `₩${formatKoreanNumber(value)}`
                    : formatKoreanNumber(value)
                }
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<PieTooltip />} />

              <Bar
                dataKey="displayValue"
                name={getMetricLabel()}
                onClick={handleSectorClick}
                cursor="pointer"
                radius={[2, 2, 0, 0]}
              >
                {processedData.map((entry, index) => (
                  <Cell
                    key={`cell-${index}`}
                    fill={selectedTypes.has(entry.type)
                      ? theme.colors[6]
                      : entry.color
                    }
                    opacity={selectedTypes.size === 0 || selectedTypes.has(entry.type) ? 1 : 0.3}
                  />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        ) : (
          <div className="flex items-center">
            <div className="flex-1">
              <ResponsiveContainer width="100%" height={384}>
                <PieChart>
                  <Pie
                    data={processedData}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    label={showLabels ? renderCustomLabel : false}
                    outerRadius={chartType === 'donut' ? 120 : 140}
                    innerRadius={chartType === 'donut' ? 60 : 0}
                    fill="#8884d8"
                    dataKey="displayValue"
                    onClick={handleSectorClick}
                    style={{ cursor: 'pointer' }}
                  >
                    {processedData.map((entry, index) => (
                      <Cell
                        key={`cell-${index}`}
                        fill={selectedTypes.has(entry.type)
                          ? theme.colors[6]
                          : entry.color
                        }
                        opacity={selectedTypes.size === 0 || selectedTypes.has(entry.type) ? 1 : 0.3}
                        stroke={selectedTypes.has(entry.type) ? theme.colors[7] : 'none'}
                        strokeWidth={selectedTypes.has(entry.type) ? 2 : 0}
                      />
                    ))}
                  </Pie>
                  <Tooltip content={<PieTooltip />} />
                  {showLegend && (
                    <Legend
                      verticalAlign="middle"
                      align="right"
                      layout="vertical"
                      iconType="circle"
                      wrapperStyle={{
                        paddingLeft: '20px',
                        fontSize: '14px',
                        color: isDark ? '#F9FAFB' : '#1F2937'
                      }}
                    />
                  )}
                </PieChart>
              </ResponsiveContainer>
            </div>

            {/* Center label for donut chart */}
            {chartType === 'donut' && totals && (
              <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="text-center">
                  <p className="text-2xl font-bold text-gray-900 dark:text-white">
                    {selectedMetric === 'value'
                      ? `₩${formatKoreanNumber(totals.total)}`
                      : formatKoreanNumber(totals.total)
                    }
                  </p>
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    총 {getMetricLabel()}
                  </p>
                  {totals.topType && (
                    <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">
                      최다: {totals.topType} ({totals.topPercentage.toFixed(1)}%)
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Statistics Summary */}
      {!loading && processedData.length > 0 && totals && (
        <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 거래건수</p>
            <p className="text-lg font-semibold text-blue-600">
              {formatKoreanNumber(totals.totalCount)}건
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 거래량</p>
            <p className="text-lg font-semibold text-green-600">
              {formatKoreanNumber(totals.totalVolume)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 거래금액</p>
            <p className="text-lg font-semibold text-purple-600">
              ₩{formatKoreanNumber(totals.totalValue)}
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">평균 거래량</p>
            <p className="text-lg font-semibold text-gray-900 dark:text-white">
              {formatKoreanNumber(totals.avgTransaction)}개
            </p>
          </div>
        </div>
      )}

      {/* Selected Types Info */}
      {selectedTypes.size > 0 && (
        <div className="mt-4 p-3 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Activity className="w-4 h-4 text-purple-600" />
              <span className="text-sm text-purple-800 dark:text-purple-300 font-medium">
                선택된 유형: {Array.from(selectedTypes).join(', ')}
              </span>
            </div>
            <button
              onClick={() => setSelectedTypes(new Set())}
              className="text-sm text-purple-600 hover:text-purple-800 dark:text-purple-400 dark:hover:text-purple-200"
            >
              선택 해제
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\CompanyForm.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Save, Loader2 } from 'lucide-react';

interface Company {
  company_id?: number;
  company_name: string;
  company_type: 'CUSTOMER' | 'SUPPLIER' | 'BOTH';
  business_registration_no?: string;
  contact_person?: string;
  phone?: string;
  mobile?: string;
  email?: string;
  address?: string;
  payment_terms?: number;
  notes?: string;
  is_active?: boolean;
}

interface CompanyFormProps {
  company?: Company | null;
  onSubmit: (data: Company) => Promise<void>;
  onCancel: () => void;
}

export default function CompanyForm({ company, onSubmit, onCancel }: CompanyFormProps) {
  const [formData, setFormData] = useState<Company>({
    company_name: '',
    company_type: 'CUSTOMER',
    business_registration_no: '',
    contact_person: '',
    phone: '',
    mobile: '',
    email: '',
    address: '',
    payment_terms: 0,
    notes: '',
    is_active: true
  });
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  useEffect(() => {
    if (company) {
      setFormData(company);
    }
  }, [company]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'number' ? (value ? parseInt(value) : 0) : value
    }));
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.company_name.trim()) {
      newErrors.company_name = '거래처명은 필수입니다';
    }

    if (!formData.company_type) {
      newErrors.company_type = '거래처 타입은 필수입니다';
    }

    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = '올바른 이메일 형식을 입력해주세요';
    }

    if (formData.phone && !/^[\d-]+$/.test(formData.phone)) {
      newErrors.phone = '전화번호는 숫자와 하이픈(-)만 입력 가능합니다';
    }

    if (formData.mobile && !/^[\d-]+$/.test(formData.mobile)) {
      newErrors.mobile = '휴대폰번호는 숫자와 하이픈(-)만 입력 가능합니다';
    }

    if (formData.payment_terms && formData.payment_terms < 0) {
      newErrors.payment_terms = '결제조건은 0 이상이어야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    setLoading(true);
    try {
      await onSubmit(formData);
      // 성공 시 자동으로 모달 닫기
      onCancel();
    } catch (error) {
      // 에러는 상위 컴포넌트에서 처리
      console.error('Error submitting form:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-2 gap-6">
        {/* 거래처명 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            거래처명 <span className="text-red-500">*</span>
          </label>
          <input
            type="text"
            name="company_name"
            value={formData.company_name}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.company_name ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="예: 현대자동차"
          />
          {errors.company_name && (
            <p className="mt-1 text-sm text-red-500">{errors.company_name}</p>
          )}
        </div>

        {/* 거래처 타입 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            거래처 타입 <span className="text-red-500">*</span>
          </label>
          <select
            name="company_type"
            value={formData.company_type}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.company_type ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          >
            <option value="CUSTOMER">고객사</option>
            <option value="SUPPLIER">공급사</option>
            <option value="BOTH">고객사/공급사</option>
          </select>
          {errors.company_type && (
            <p className="mt-1 text-sm text-red-500">{errors.company_type}</p>
          )}
        </div>

        {/* 사업자등록번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            사업자등록번호
          </label>
          <input
            type="text"
            name="business_registration_no"
            value={formData.business_registration_no || ''}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: 123-45-67890"
          />
        </div>

        {/* 담당자 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            담당자
          </label>
          <input
            type="text"
            name="contact_person"
            value={formData.contact_person || ''}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: 홍길동"
          />
        </div>

        {/* 전화번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            전화번호
          </label>
          <input
            type="text"
            name="phone"
            value={formData.phone || ''}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.phone ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="예: 02-1234-5678"
          />
          {errors.phone && (
            <p className="mt-1 text-sm text-red-500">{errors.phone}</p>
          )}
        </div>

        {/* 휴대폰번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            휴대폰번호
          </label>
          <input
            type="text"
            name="mobile"
            value={formData.mobile || ''}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.mobile ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="예: 010-1234-5678"
          />
          {errors.mobile && (
            <p className="mt-1 text-sm text-red-500">{errors.mobile}</p>
          )}
        </div>

        {/* 이메일 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            이메일
          </label>
          <input
            type="email"
            name="email"
            value={formData.email || ''}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.email ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="예: admin@company.com"
          />
          {errors.email && (
            <p className="mt-1 text-sm text-red-500">{errors.email}</p>
          )}
        </div>

        {/* 결제조건 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            결제조건 (일)
          </label>
          <input
            type="number"
            name="payment_terms"
            value={formData.payment_terms}
            onChange={handleChange}
            min="0"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.payment_terms ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="예: 30"
          />
          {errors.payment_terms && (
            <p className="mt-1 text-sm text-red-500">{errors.payment_terms}</p>
          )}
        </div>
      </div>

      {/* 주소 - Full width */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          주소
        </label>
        <input
          type="text"
          name="address"
          value={formData.address || ''}
          onChange={handleChange}
          className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="예: 서울특별시 강남구 테헤란로 123"
        />
      </div>

      {/* 비고 - Full width */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          비고
        </label>
        <textarea
          name="notes"
          value={formData.notes || ''}
          onChange={handleChange}
          rows={3}
          className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 resize-vertical"
          placeholder="추가 메모 사항을 입력하세요"
        />
      </div>

      {/* Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200 dark:border-gray-700">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading}
          className="flex items-center gap-2 px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              처리중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              {company ? '수정' : '등록'}
            </>
          )}
        </button>
      </div>
    </form>
  );
}
```


#### 📄 src\components\CompanySelect.tsx

```typescript
'use client';

import { useState, useEffect, useRef } from 'react';
import { Database } from '@/types/supabase';

// Company type from unified Supabase layer
type Company = Database['public']['Tables']['companies']['Row'];

interface CompanySelectProps {
  value?: number | null;
  onChange: (companyId: number | null, company?: Company | undefined) => void;
  companyType?: 'SUPPLIER' | 'CUSTOMER' | 'OTHER';
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  error?: string;
}

export default function CompanySelect({
  value,
  onChange,
  companyType,
  placeholder = "거래처를 선택하세요",
  disabled = false,
  required = false,
  error
}: CompanySelectProps) {
  const [companies, setCompanies] = useState<Company[]>([]);
  const [search, setSearch] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [selectedCompany, setSelectedCompany] = useState<Company | null>(null);

  const searchInputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // 외부 클릭으로 드롭다운 닫기
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isOpen) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('keydown', handleKeyDown);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen]);

  // 거래처 목록 조회
  const fetchCompanies = async (searchTerm: string = '') => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (companyType) {
        params.append('type', companyType);
      }
      if (searchTerm) {
        params.append('search', searchTerm);
      }

      const response = await fetch(`/api/companies?${params.toString()}`);
      const result = await response.json();

      if (result.success) {
        setCompanies(result.data);
      } else {
        console.error('Failed to fetch companies:', result.error);
        setCompanies([]);
      }
    } catch (error) {
      console.error('Error fetching companies:', error);
      setCompanies([]);
    } finally {
      setLoading(false);
    }
  };

  // 컴포넌트 마운트 시 초기 데이터 로드
  useEffect(() => {
    fetchCompanies();
  }, [companyType]);

  // 검색어 변경 시 거래처 목록 재조회
  useEffect(() => {
    const debounceTimer = setTimeout(() => {
      if (isOpen) {
        fetchCompanies(search);
      }
    }, 300);

    return () => clearTimeout(debounceTimer);
  }, [search, isOpen]);

  // 선택된 값 변경 시 해당 거래처 정보 설정
  useEffect(() => {
    if (value && companies.length > 0) {
      const company = companies.find(c => c.company_id === value);
      setSelectedCompany(company || null);
    } else {
      setSelectedCompany(null);
    }
  }, [value, companies]);

  const handleSelect = (company: Company) => {
    setSelectedCompany(company);
    onChange(company.company_id, company);
    setIsOpen(false);
    setSearch('');
  };

  const handleClear = () => {
    setSelectedCompany(null);
    onChange(null);
    setSearch('');
  };

  const handleToggle = () => {
    if (disabled) return;

    setIsOpen(!isOpen);
    if (!isOpen) {
      // 드롭다운 열 때 검색 입력창에 포커스
      setTimeout(() => {
        searchInputRef.current?.focus();
      }, 100);
    }
  };

  const filteredCompanies = companies.filter(company =>
    company.company_name.toLowerCase().includes(search.toLowerCase()) ||
    (company.business_registration_no && company.business_registration_no.includes(search)) ||
    (company.contact_person && company.contact_person.toLowerCase().includes(search.toLowerCase()))
  );

  return (
    <div className="relative" ref={dropdownRef}>
      {/* 선택된 거래처 표시 / 드롭다운 토글 버튼 */}
      <div
        className={`
          min-h-[40px] px-3 py-2 border rounded-md cursor-pointer
          flex items-center justify-between
          ${disabled
            ? 'bg-gray-100 cursor-not-allowed'
            : 'bg-white hover:border-gray-400'
          }
          ${error
            ? 'border-red-500'
            : isOpen
              ? 'border-blue-500 ring-1 ring-blue-500'
              : 'border-gray-300'
          }
        `}
        onClick={handleToggle}
      >
        <div className="flex-1 min-w-0">
          {selectedCompany ? (
            <div className="flex items-center justify-between">
              <div className="truncate">
                <span className="font-medium">{selectedCompany.company_name}</span>
                {selectedCompany.business_registration_no && (
                  <span className="text-sm text-gray-500 ml-2">
                    ({selectedCompany.business_registration_no})
                  </span>
                )}
              </div>
              <button
                type="button"
                onClick={(e) => {
                  e.stopPropagation();
                  handleClear();
                }}
                className="ml-2 text-gray-400 hover:text-gray-600"
                disabled={disabled}
              >
                ✕
              </button>
            </div>
          ) : (
            <span className="text-gray-500">{placeholder}</span>
          )}
        </div>

        <div className="ml-2 text-gray-400">
          {isOpen ? '▲' : '▼'}
        </div>
      </div>

      {/* 에러 메시지 */}
      {error && (
        <p className="mt-1 text-sm text-red-500">{error}</p>
      )}

      {/* 드롭다운 목록 */}
      {isOpen && (
        <div className="absolute z-[9999] w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-hidden">
          {/* 검색 입력창 */}
          <div className="p-2 border-b border-gray-200 dark:border-gray-600">
            <input
              ref={searchInputRef}
              type="text"
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="거래처명, 사업자번호, 담당자로 검색..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Escape') {
                  setIsOpen(false);
                }
              }}
            />
          </div>

          {/* 거래처 목록 */}
          <div className="max-h-48 overflow-y-auto">
            {loading ? (
              <div className="p-3 text-center text-gray-500 dark:text-gray-400">검색 중...</div>
            ) : filteredCompanies.length > 0 ? (
              filteredCompanies.map((company) => (
                <div
                  key={company.company_id}
                  className="px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 border-b border-gray-100 dark:border-gray-600 last:border-b-0"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleSelect(company);
                  }}
                >
                  <div className="font-medium text-gray-900 dark:text-white">{company.company_name}</div>
                  <div className="text-sm text-gray-600 dark:text-gray-400 flex items-center gap-2">
                    {company.business_registration_no && (
                      <span>사업자: {company.business_registration_no}</span>
                    )}
                    {company.contact_person && (
                      <span>담당자: {company.contact_person}</span>
                    )}
                    {company.phone && (
                      <span>전화: {company.phone}</span>
                    )}
                  </div>
                  {company.company_type && (
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      <span className={`
                        px-2 py-0.5 rounded-full text-xs
                        ${company.company_type === '공급사'
                          ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
                          : company.company_type === '고객사'
                          ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                          : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200'
                        }
                      `}>
                        {company.company_type === '공급사' ? '공급업체' :
                         company.company_type === '고객사' ? '고객사' : '기타'}
                      </span>
                    </div>
                  )}
                </div>
              ))
            ) : (
              <div className="p-3 text-center text-gray-500 dark:text-gray-400">
                {search ? '검색 결과가 없습니다.' : '등록된 거래처가 없습니다.'}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```


#### 📄 src\components\ConfirmModal.tsx

```typescript
'use client';

import { useEffect, useRef } from 'react';
import { X, AlertTriangle, Trash2, AlertCircle } from 'lucide-react';

export type ConfirmType = 'delete' | 'warning' | 'danger';

interface ConfirmModalProps {
  isOpen: boolean;
  onConfirm: () => void;
  onCancel: () => void;
  type?: ConfirmType;
  title?: string;
  message?: string;
  confirmText?: string;
  cancelText?: string;
  loading?: boolean;
  children?: React.ReactNode;
}

const ConfirmModal: React.FC<ConfirmModalProps> = ({
  isOpen,
  onConfirm,
  onCancel,
  type = 'warning',
  title,
  message,
  confirmText,
  cancelText = '취소',
  loading = false,
  children
}) => {
  const confirmButtonRef = useRef<HTMLButtonElement>(null);
  const cancelButtonRef = useRef<HTMLButtonElement>(null);

  // Handle escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && !loading) {
        onCancel();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';

      // Focus management - focus cancel button by default for safety
      setTimeout(() => {
        cancelButtonRef.current?.focus();
      }, 100);
    } else {
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, loading, onCancel]);

  // Handle backdrop click
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !loading) {
      onCancel();
    }
  };

  // Handle confirm action
  const handleConfirm = () => {
    if (!loading) {
      onConfirm();
    }
  };

  // Handle cancel action
  const handleCancel = () => {
    if (!loading) {
      onCancel();
    }
  };

  // Get configuration based on type
  const getTypeConfig = () => {
    switch (type) {
      case 'delete':
        return {
          icon: <Trash2 className="w-6 h-6" />,
          iconBgColor: 'bg-red-100 dark:bg-red-900/20',
          iconTextColor: 'text-red-600 dark:text-red-400',
          buttonBgColor: 'bg-red-600 hover:bg-red-700 focus:ring-red-500',
          defaultTitle: '삭제 확인',
          defaultMessage: '정말 삭제하시겠습니까?',
          defaultConfirmText: '삭제'
        };
      case 'danger':
        return {
          icon: <AlertCircle className="w-6 h-6" />,
          iconBgColor: 'bg-red-100 dark:bg-red-900/20',
          iconTextColor: 'text-red-600 dark:text-red-400',
          buttonBgColor: 'bg-red-600 hover:bg-red-700 focus:ring-red-500',
          defaultTitle: '위험한 작업',
          defaultMessage: '이 작업을 계속하시겠습니까?',
          defaultConfirmText: '계속'
        };
      case 'warning':
      default:
        return {
          icon: <AlertTriangle className="w-6 h-6" />,
          iconBgColor: 'bg-yellow-100 dark:bg-yellow-900/20',
          iconTextColor: 'text-yellow-600 dark:text-yellow-400',
          buttonBgColor: 'bg-yellow-600 hover:bg-yellow-700 focus:ring-yellow-500',
          defaultTitle: '확인 필요',
          defaultMessage: '이 작업을 진행하시겠습니까?',
          defaultConfirmText: '확인'
        };
    }
  };

  if (!isOpen) return null;

  const config = getTypeConfig();
  const finalTitle = title || config.defaultTitle;
  const finalMessage = message || config.defaultMessage;
  const finalConfirmText = confirmText || config.defaultConfirmText;

  return (
    <div
      className="fixed inset-0 z-[10001] overflow-y-auto"
      role="dialog"
      aria-modal="true"
      aria-labelledby="confirm-modal-title"
      aria-describedby="confirm-modal-description"
    >
      <div className="flex min-h-full items-center justify-center p-4">
        {/* Backdrop */}
        <div
          className="fixed inset-0 bg-black bg-opacity-50 transition-opacity"
          onClick={handleBackdropClick}
          aria-hidden="true"
        />

        {/* Modal */}
        <div className="relative bg-white dark:bg-gray-900 rounded-lg shadow-xl w-full max-w-md transform transition-all">
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
            <div className="flex items-center gap-3">
              <div className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center ${config.iconBgColor}`}>
                <span className={config.iconTextColor}>
                  {config.icon}
                </span>
              </div>
              <h2
                id="confirm-modal-title"
                className="text-lg font-semibold text-gray-900 dark:text-white"
              >
                {finalTitle}
              </h2>
            </div>
            <button
              onClick={handleCancel}
              disabled={loading}
              className="text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="모달 닫기"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6">
            {children ? (
              children
            ) : (
              <div>
                <p
                  id="confirm-modal-description"
                  className="text-gray-700 dark:text-gray-300 mb-4"
                >
                  {finalMessage}
                </p>
                {type === 'delete' && (
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    이 작업은 되돌릴 수 없습니다.
                  </p>
                )}
              </div>
            )}
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-3 p-6 bg-gray-50 dark:bg-gray-800 rounded-b-lg">
            <button
              ref={cancelButtonRef}
              onClick={handleCancel}
              disabled={loading}
              className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              {cancelText}
            </button>
            <button
              ref={confirmButtonRef}
              onClick={handleConfirm}
              disabled={loading}
              className={`px-4 py-2 text-sm font-medium text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors ${config.buttonBgColor} ${loading ? 'cursor-not-allowed' : ''}`}
            >
              {loading ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  처리중...
                </div>
              ) : (
                finalConfirmText
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ConfirmModal;
```


#### 📄 src\components\dashboard\AlertPanel.tsx

```typescript
/**
 * Alert Panel Component
 * Low stock alerts and system notifications
 */

import React, { useState } from 'react';
import { AlertCircle, Package, Clock, ChevronRight, Filter, Search, Bell, AlertTriangle } from 'lucide-react';
import { formatKoreanNumber, formatKoreanDate } from '../../utils/chartUtils';
import type { AlertData } from '../../hooks/useDashboardData';

interface AlertPanelProps {
  data: AlertData | null;
  loading: boolean;
  error: string | null;
}

type AlertFilter = 'all' | '위험' | '주의';
type AlertSort = 'status' | 'name' | 'ratio' | 'date';

export const AlertPanel: React.FC<AlertPanelProps> = ({
  data,
  loading,
  error
}) => {
  const [activeTab, setActiveTab] = useState<'stock' | 'transactions'>('stock');
  const [stockFilter, setStockFilter] = useState<AlertFilter>('all');
  const [stockSort, setStockSort] = useState<AlertSort>('status');
  const [searchTerm, setSearchTerm] = useState('');

  // Filter and sort low stock items
  const filteredStockItems = React.useMemo(() => {
    if (!data?.lowStockItems) return [];

    let items = [...data.lowStockItems];

    // Apply status filter
    if (stockFilter !== 'all') {
      items = items.filter(item => item.status === stockFilter);
    }

    // Apply search filter
    if (searchTerm) {
      items = items.filter(item =>
        item.item_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.item_code.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    // Apply sorting
    items.sort((a, b) => {
      switch (stockSort) {
        case 'status':
          if (a.status === b.status) {
            const ratioA = a.minimum_stock > 0 ? a.current_stock / a.minimum_stock : 0;
            const ratioB = b.minimum_stock > 0 ? b.current_stock / b.minimum_stock : 0;
            return ratioA - ratioB;
          }
          return a.status === '위험' ? -1 : 1;

        case 'name':
          return a.item_name.localeCompare(b.item_name);

        case 'ratio':
          const ratioA = a.minimum_stock > 0 ? a.current_stock / a.minimum_stock : 0;
          const ratioB = b.minimum_stock > 0 ? b.current_stock / b.minimum_stock : 0;
          return ratioA - ratioB;

        default:
          return 0;
      }
    });

    return items;
  }, [data?.lowStockItems, stockFilter, stockSort, searchTerm]);

  // Get alert counts
  const alertCounts = React.useMemo(() => {
    if (!data?.lowStockItems) return { total: 0, critical: 0, warning: 0 };

    const critical = data.lowStockItems.filter(item => item.status === '위험').length;
    const warning = data.lowStockItems.filter(item => item.status === '주의').length;

    return {
      total: data.lowStockItems.length,
      critical,
      warning
    };
  }, [data?.lowStockItems]);

  if (error) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            알림 패널
          </h3>
        </div>
        <div className="flex items-center justify-center h-32 text-red-500">
          <div className="text-center">
            <AlertCircle className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p className="text-sm">알림 데이터 로드 실패</p>
            <p className="text-xs text-gray-500 mt-1">{error}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg shadow-sm">
      {/* Header */}
      <div className="p-6 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <Bell className="w-5 h-5 text-orange-500" />
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
              알림 패널
            </h3>
            {alertCounts.total > 0 && (
              <span className="px-2 py-1 bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300 text-xs font-medium rounded-full">
                {alertCounts.total}
              </span>
            )}
          </div>

          {/* Alert Summary */}
          <div className="flex items-center space-x-4">
            {alertCounts.critical > 0 && (
              <div className="flex items-center space-x-1 text-red-600">
                <AlertTriangle className="w-4 h-4" />
                <span className="text-sm font-medium">{alertCounts.critical}</span>
              </div>
            )}
            {alertCounts.warning > 0 && (
              <div className="flex items-center space-x-1 text-orange-600">
                <AlertCircle className="w-4 h-4" />
                <span className="text-sm font-medium">{alertCounts.warning}</span>
              </div>
            )}
          </div>
        </div>

        {/* Tabs */}
        <div className="flex space-x-1 mt-4 bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
          <button
            onClick={() => setActiveTab('stock')}
            className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
              activeTab === 'stock'
                ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                : 'text-gray-600 dark:text-gray-400'
            }`}
          >
            재고 부족 ({alertCounts.total})
          </button>
          <button
            onClick={() => setActiveTab('transactions')}
            className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
              activeTab === 'transactions'
                ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                : 'text-gray-600 dark:text-gray-400'
            }`}
          >
            최근 거래 ({data?.recentTransactions?.length || 0})
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="p-6">
        {activeTab === 'stock' ? (
          <StockAlertsTab
            items={filteredStockItems}
            loading={loading}
            filter={stockFilter}
            sort={stockSort}
            searchTerm={searchTerm}
            onFilterChange={setStockFilter}
            onSortChange={setStockSort}
            onSearchChange={setSearchTerm}
          />
        ) : (
          <TransactionAlertsTab
            transactions={data?.recentTransactions || []}
            loading={loading}
          />
        )}
      </div>
    </div>
  );
};

// Stock Alerts Tab Component
interface StockAlertsTabProps {
  items: AlertData['lowStockItems'];
  loading: boolean;
  filter: AlertFilter;
  sort: AlertSort;
  searchTerm: string;
  onFilterChange: (filter: AlertFilter) => void;
  onSortChange: (sort: AlertSort) => void;
  onSearchChange: (term: string) => void;
}

const StockAlertsTab: React.FC<StockAlertsTabProps> = ({
  items,
  loading,
  filter,
  sort,
  searchTerm,
  onFilterChange,
  onSortChange,
  onSearchChange
}) => {
  if (loading) {
    return (
      <div className="space-y-3">
        {Array.from({ length: 5 }).map((_, index) => (
          <div key={index} className="animate-pulse">
            <div className="flex items-center space-x-3">
              <div className="w-8 h-8 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
              <div className="flex-1 space-y-2">
                <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4"></div>
                <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-1/2"></div>
              </div>
              <div className="w-16 h-6 bg-gray-200 dark:bg-gray-700 rounded"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        {/* Search */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
          <input
            type="text"
            placeholder="품명 또는 품번 검색..."
            value={searchTerm}
            onChange={(e) => onSearchChange(e.target.value)}
            className="pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm w-full sm:w-64"
          />
        </div>

        <div className="flex items-center space-x-2">
          {/* Filter */}
          <select
            value={filter}
            onChange={(e) => onFilterChange(e.target.value as AlertFilter)}
            className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
          >
            <option value="all">전체</option>
            <option value="위험">위험</option>
            <option value="주의">주의</option>
          </select>

          {/* Sort */}
          <select
            value={sort}
            onChange={(e) => onSortChange(e.target.value as AlertSort)}
            className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
          >
            <option value="status">상태순</option>
            <option value="ratio">재고율순</option>
            <option value="name">품명순</option>
          </select>
        </div>
      </div>

      {/* Stock Items */}
      <div className="space-y-2 max-h-80 overflow-y-auto">
        {items.length === 0 ? (
          <div className="flex items-center justify-center py-8 text-gray-500">
            <div className="text-center">
              <Package className="w-8 h-8 mx-auto mb-2 opacity-50" />
              <p className="text-sm">
                {searchTerm ? '검색 결과가 없습니다' : '재고 부족 품목이 없습니다'}
              </p>
            </div>
          </div>
        ) : (
          items.map((item) => {
            const ratio = item.minimum_stock > 0 ? (item.current_stock / item.minimum_stock) : 0;

            return (
              <div
                key={item.item_id}
                className={`flex items-center space-x-3 p-3 rounded-lg border transition-colors hover:bg-gray-50 dark:hover:bg-gray-800 ${
                  item.status === '위험'
                    ? 'border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/20'
                    : 'border-orange-200 dark:border-orange-800 bg-orange-50 dark:bg-orange-900/20'
                }`}
              >
                {/* Status Icon */}
                <div className={`p-2 rounded-full ${
                  item.status === '위험'
                    ? 'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-400'
                    : 'bg-orange-100 dark:bg-orange-900 text-orange-600 dark:text-orange-400'
                }`}>
                  {item.status === '위험' ? (
                    <AlertTriangle className="w-4 h-4" />
                  ) : (
                    <AlertCircle className="w-4 h-4" />
                  )}
                </div>

                {/* Item Info */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center space-x-2">
                    <p className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate">
                      {item.item_name}
                    </p>
                    <span className="text-xs text-gray-500 dark:text-gray-400">
                      {item.item_code}
                    </span>
                  </div>
                  <div className="flex items-center space-x-4 mt-1">
                    <span className="text-xs text-gray-600 dark:text-gray-400">
                      현재: <span className="font-medium">{formatKoreanNumber(item.current_stock)}</span>
                    </span>
                    <span className="text-xs text-gray-600 dark:text-gray-400">
                      최소: <span className="font-medium">{formatKoreanNumber(item.minimum_stock)}</span>
                    </span>
                    <span className={`text-xs font-medium ${
                      ratio < 0.5 ? 'text-red-600' : 'text-orange-600'
                    }`}>
                      {(ratio * 100).toFixed(1)}%
                    </span>
                  </div>
                </div>

                {/* Status Badge */}
                <span className={`px-2 py-1 text-xs font-semibold rounded-full ${
                  item.status === '위험'
                    ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300'
                    : 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300'
                }`}>
                  {item.status}
                </span>

                {/* Action */}
                <ChevronRight className="w-4 h-4 text-gray-400" />
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};

// Transaction Alerts Tab Component
interface TransactionAlertsTabProps {
  transactions: AlertData['recentTransactions'];
  loading: boolean;
}

const TransactionAlertsTab: React.FC<TransactionAlertsTabProps> = ({
  transactions,
  loading
}) => {
  if (loading) {
    return (
      <div className="space-y-3">
        {Array.from({ length: 5 }).map((_, index) => (
          <div key={index} className="animate-pulse">
            <div className="flex items-center space-x-3">
              <div className="w-8 h-8 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
              <div className="flex-1 space-y-2">
                <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4"></div>
                <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-1/2"></div>
              </div>
              <div className="w-16 h-6 bg-gray-200 dark:bg-gray-700 rounded"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <div className="space-y-2 max-h-80 overflow-y-auto">
      {transactions.length === 0 ? (
        <div className="flex items-center justify-center py-8 text-gray-500">
          <div className="text-center">
            <Clock className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p className="text-sm">최근 거래 내역이 없습니다</p>
          </div>
        </div>
      ) : (
        transactions.map((transaction) => (
          <div
            key={transaction.transaction_id}
            className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
          >
            {/* Type Badge */}
            <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
              transaction.transaction_type === '입고'
                ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300'
                : transaction.transaction_type === '출고'
                ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300'
            }`}>
              {transaction.transaction_type}
            </span>

            {/* Transaction Info */}
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate">
                {transaction.item_name}
              </p>
              <div className="flex items-center space-x-4 mt-1">
                <span className="text-xs text-gray-600 dark:text-gray-400">
                  수량: <span className="font-medium">{formatKoreanNumber(transaction.quantity)}</span>
                </span>
                <span className="text-xs text-gray-600 dark:text-gray-400">
                  {formatKoreanDate(transaction.transaction_date)}
                </span>
              </div>
            </div>

            {/* Status */}
            <span className={`px-2 py-1 text-xs font-semibold rounded-full ${
              transaction.status === '완료'
                ? 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                : 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300'
            }`}>
              {transaction.status}
            </span>
          </div>
        ))
      )}
    </div>
  );
};
```


#### 📄 src\components\dashboard\index.ts

```typescript
// Dashboard widgets exports
export { default as StockStatusWidget } from './StockStatusWidget';
export { default as RecentActivityWidget } from './RecentActivityWidget';
export { default as QuickActionsWidget } from './QuickActionsWidget';
export { default as StockSummaryCard } from './StockSummaryCard';

// Re-export common types if needed
export type {
  // Add any shared types here if needed in the future
} from '../../types/inventory';
```


#### 📄 src\components\dashboard\KPICards.tsx

```typescript
/**
 * KPI Cards Component
 * Displays key performance indicators with Korean formatting
 */

import React from 'react';
import { Package, Users, TrendingUp, AlertCircle, ArrowUp, ArrowDown, Minus } from 'lucide-react';
import { formatKoreanNumber } from '../../utils/chartUtils';
import type { DashboardStats } from '../../hooks/useDashboardData';

interface KPICardsProps {
  stats: DashboardStats | null;
  loading: boolean;
  error: string | null;
}

export const KPICards: React.FC<KPICardsProps> = ({
  stats,
  loading,
  error
}) => {
  if (error) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <div className="col-span-full bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
          <div className="flex items-center space-x-2">
            <AlertCircle className="w-5 h-5 text-red-500" />
            <span className="text-red-700 dark:text-red-300 font-medium">데이터 로드 실패</span>
          </div>
          <p className="text-red-600 dark:text-red-400 text-sm mt-1">{error}</p>
        </div>
      </div>
    );
  }

  const kpiData = [
    {
      title: '총 품목수',
      value: stats?.totalItems || 0,
      change: stats?.trends.items || 0,
      icon: <Package className="w-6 h-6" />,
      bgColor: 'bg-blue-500',
      unit: '개'
    },
    {
      title: '활성 거래처',
      value: stats?.activeCompanies || 0,
      change: stats?.trends.companies || 0,
      icon: <Users className="w-6 h-6" />,
      bgColor: 'bg-green-500',
      unit: '개사'
    },
    {
      title: '월 입출고량',
      value: stats?.monthlyVolume || 0,
      change: stats?.trends.volume || 0,
      icon: <TrendingUp className="w-6 h-6" />,
      bgColor: 'bg-purple-500',
      unit: '개',
      isPercentage: true
    },
    {
      title: '재고 부족 품목',
      value: stats?.lowStockItems || 0,
      change: stats?.trends.lowStock || 0,
      icon: <AlertCircle className="w-6 h-6" />,
      bgColor: 'bg-red-500',
      unit: '개'
    }
  ];

  const formatChangeValue = (change: number, isPercentage: boolean = false) => {
    if (change === 0) return '0';

    const absChange = Math.abs(change);
    if (isPercentage) {
      return `${change > 0 ? '+' : ''}${change.toFixed(1)}%`;
    } else {
      return `${change > 0 ? '+' : ''}${formatKoreanNumber(absChange)}`;
    }
  };

  const getChangeIcon = (change: number) => {
    if (change > 0) return <ArrowUp className="w-4 h-4" />;
    if (change < 0) return <ArrowDown className="w-4 h-4" />;
    return <Minus className="w-4 h-4" />;
  };

  const getChangeColor = (change: number, isAlert: boolean = false) => {
    if (change === 0) return 'text-gray-500';

    // For alert items (like low stock), decrease is good, increase is bad
    if (isAlert) {
      return change > 0 ? 'text-red-600' : 'text-green-600';
    }

    // For regular metrics, increase is good, decrease is bad
    return change > 0 ? 'text-green-600' : 'text-red-600';
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {kpiData.map((kpi, index) => (
        <KPICard
          key={index}
          title={kpi.title}
          value={kpi.value}
          change={kpi.change}
          icon={kpi.icon}
          bgColor={kpi.bgColor}
          unit={kpi.unit}
          isPercentage={kpi.isPercentage}
          isAlert={kpi.title.includes('부족')}
          loading={loading}
          formatChangeValue={formatChangeValue}
          getChangeIcon={getChangeIcon}
          getChangeColor={getChangeColor}
        />
      ))}
    </div>
  );
};

// Individual KPI Card Component
interface KPICardProps {
  title: string;
  value: number;
  change: number;
  icon: React.ReactNode;
  bgColor: string;
  unit: string;
  isPercentage?: boolean;
  isAlert?: boolean;
  loading: boolean;
  formatChangeValue: (change: number, isPercentage?: boolean) => string;
  getChangeIcon: (change: number) => React.ReactNode;
  getChangeColor: (change: number, isAlert?: boolean) => string;
}

const KPICard: React.FC<KPICardProps> = ({
  title,
  value,
  change,
  icon,
  bgColor,
  unit,
  isPercentage = false,
  isAlert = false,
  loading,
  formatChangeValue,
  getChangeIcon,
  getChangeColor
}) => {
  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow">
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">
            {title}
          </p>

          {loading ? (
            <div className="mt-2 space-y-2">
              <div className="h-8 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"></div>
              <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded animate-pulse w-2/3"></div>
            </div>
          ) : (
            <>
              <div className="flex items-baseline mt-2">
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  {formatKoreanNumber(value)}
                </p>
                <span className="text-sm text-gray-500 dark:text-gray-400 ml-1">
                  {unit}
                </span>
              </div>

              <div className="flex items-center mt-2">
                <div
                  className={`flex items-center space-x-1 ${getChangeColor(change, isAlert)}`}
                >
                  {getChangeIcon(change)}
                  <span className="text-sm font-medium">
                    {formatChangeValue(change, isPercentage)}
                  </span>
                </div>
                <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
                  전월 대비
                </span>
              </div>
            </>
          )}
        </div>

        <div className={`${bgColor} p-3 rounded-lg text-white ${loading ? 'animate-pulse' : ''}`}>
          {icon}
        </div>
      </div>

      {/* Additional context for specific KPIs */}
      {!loading && (
        <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          {title === '재고 부족 품목' && value > 0 && (
            <div className="flex items-center space-x-2">
              <AlertCircle className="w-4 h-4 text-orange-500" />
              <span className="text-xs text-orange-600 dark:text-orange-400">
                즉시 확인 필요
              </span>
            </div>
          )}

          {title === '월 입출고량' && (
            <div className="text-xs text-gray-500 dark:text-gray-400">
              이번 달 총 거래량
            </div>
          )}

          {title === '총 품목수' && (
            <div className="text-xs text-gray-500 dark:text-gray-400">
              활성 품목 기준
            </div>
          )}

          {title === '활성 거래처' && (
            <div className="text-xs text-gray-500 dark:text-gray-400">
              거래 중인 업체
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Skeleton loader for KPI cards
export const KPICardsSkeleton: React.FC = () => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
          <div className="flex items-center justify-between">
            <div className="flex-1 space-y-3">
              <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 animate-pulse"></div>
              <div className="h-8 bg-gray-200 dark:bg-gray-700 rounded w-1/2 animate-pulse"></div>
              <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-2/3 animate-pulse"></div>
            </div>
            <div className="w-12 h-12 bg-gray-200 dark:bg-gray-700 rounded-lg animate-pulse"></div>
          </div>
        </div>
      ))}
    </div>
  );
};
```


#### 📄 src\components\dashboard\QuickActionsWidget.tsx

```typescript
'use client';

import React from 'react';
import { TrendingUp, TrendingDown, Settings, Plus, Package, FileText } from 'lucide-react';

interface QuickAction {
  id: string;
  label: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  bgColor: string;
  hoverColor: string;
  onClick: () => void;
}

interface QuickActionsProps {
  onReceivingClick?: () => void;
  onShippingClick?: () => void;
  onAdjustmentClick?: () => void;
  onProductionClick?: () => void;
  onNewItemClick?: () => void;
  onReportsClick?: () => void;
}

const QuickActionsWidget: React.FC<QuickActionsProps> = ({
  onReceivingClick,
  onShippingClick,
  onAdjustmentClick,
  onProductionClick,
  onNewItemClick,
  onReportsClick
}) => {
  const quickActions: QuickAction[] = [
    {
      id: 'receiving',
      label: '입고 등록',
      description: '새로운 입고 내역을 등록합니다',
      icon: <TrendingUp className="w-6 h-6" />,
      color: 'text-green-600',
      bgColor: 'bg-green-50',
      hoverColor: 'hover:bg-green-100',
      onClick: onReceivingClick || (() => console.log('입고 등록 클릭'))
    },
    {
      id: 'shipping',
      label: '출고 등록',
      description: '새로운 출고 내역을 등록합니다',
      icon: <TrendingDown className="w-6 h-6" />,
      color: 'text-red-600',
      bgColor: 'bg-red-50',
      hoverColor: 'hover:bg-red-100',
      onClick: onShippingClick || (() => console.log('출고 등록 클릭'))
    },
    {
      id: 'production',
      label: '생산 등록',
      description: '생산 입고/출고를 등록합니다',
      icon: <Package className="w-6 h-6" />,
      color: 'text-blue-600',
      bgColor: 'bg-blue-50',
      hoverColor: 'hover:bg-blue-100',
      onClick: onProductionClick || (() => console.log('생산 등록 클릭'))
    },
    {
      id: 'adjustment',
      label: '재고 조정',
      description: '재고 수량을 조정합니다',
      icon: <Settings className="w-6 h-6" />,
      color: 'text-orange-600',
      bgColor: 'bg-orange-50',
      hoverColor: 'hover:bg-orange-100',
      onClick: onAdjustmentClick || (() => console.log('재고 조정 클릭'))
    },
    {
      id: 'new-item',
      label: '품목 등록',
      description: '새로운 품목을 등록합니다',
      icon: <Plus className="w-6 h-6" />,
      color: 'text-purple-600',
      bgColor: 'bg-purple-50',
      hoverColor: 'hover:bg-purple-100',
      onClick: onNewItemClick || (() => console.log('품목 등록 클릭'))
    },
    {
      id: 'reports',
      label: '보고서',
      description: '재고 현황 보고서를 확인합니다',
      icon: <FileText className="w-6 h-6" />,
      color: 'text-indigo-600',
      bgColor: 'bg-indigo-50',
      hoverColor: 'hover:bg-indigo-100',
      onClick: onReportsClick || (() => console.log('보고서 클릭'))
    }
  ];

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-gray-900 flex items-center">
          <Plus className="w-5 h-5 mr-2 text-blue-600" />
          빠른 작업
        </h3>
        <p className="text-sm text-gray-600 mt-1">
          자주 사용하는 기능들을 빠르게 실행할 수 있습니다.
        </p>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        {quickActions.map((action) => (
          <button
            key={action.id}
            onClick={action.onClick}
            className={`
              p-4 rounded-lg border-2 border-transparent transition-all duration-200
              ${action.bgColor} ${action.hoverColor}
              hover:border-gray-200 hover:shadow-md
              focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
              group
            `}
          >
            <div className="flex flex-col items-center text-center space-y-2">
              <div className={`
                p-3 rounded-full transition-transform duration-200
                ${action.bgColor} ${action.color}
                group-hover:scale-110
              `}>
                {action.icon}
              </div>

              <div>
                <h4 className={`font-semibold text-sm ${action.color}`}>
                  {action.label}
                </h4>
                <p className="text-xs text-gray-600 mt-1 leading-4">
                  {action.description}
                </p>
              </div>
            </div>
          </button>
        ))}
      </div>

      <div className="mt-6 pt-4 border-t border-gray-100">
        <div className="flex items-center justify-between text-sm">
          <span className="text-gray-600">
            모든 작업은 실시간으로 재고에 반영됩니다.
          </span>
          <span className="text-xs text-gray-400">
            권한에 따라 일부 기능이 제한될 수 있습니다.
          </span>
        </div>
      </div>
    </div>
  );
};

export default QuickActionsWidget;
```


#### 📄 src\components\dashboard\RealTimeDashboard.tsx

```typescript
/**
 * Real-Time Dashboard Component
 * Main dashboard container with auto-refresh functionality
 */

import React from 'react';
import { RefreshControls } from './RefreshControls';
import { KPICards } from './KPICards';
import { StockChart } from './StockChart';
import { TransactionChart } from './TransactionChart';
import { AlertPanel } from './AlertPanel';
import { MonthlyInventoryTrends } from '../charts/MonthlyInventoryTrends';
import { StockLevelsByCategory } from '../charts/StockLevelsByCategory';
import { TransactionDistribution } from '../charts/TransactionDistribution';
import { TopItemsByValue } from '../charts/TopItemsByValue';
import { LowStockAlerts } from '../charts/LowStockAlerts';
import { useDashboardData, type RefreshInterval } from '../../hooks/useDashboardData';
import { useTheme } from '../../contexts/ThemeContext';

interface RealTimeDashboardProps {
  className?: string;
  initialRefreshInterval?: RefreshInterval;
  autoStart?: boolean;
}

export const RealTimeDashboard: React.FC<RealTimeDashboardProps> = ({
  className = '',
  initialRefreshInterval = '수동',
  autoStart = false
}) => {
  const { theme } = useTheme();
  const isDark = theme === 'dark';

  const {
    data,
    loading,
    error,
    lastUpdated,
    refreshInterval,
    isAutoRefreshEnabled,
    retryCount,
    setRefreshInterval,
    setIsAutoRefreshEnabled,
    refresh
  } = useDashboardData(initialRefreshInterval, autoStart);

  return (
    <div className={`space-y-6 ${className}`}>
      {/* Refresh Controls */}
      <RefreshControls
        refreshInterval={refreshInterval}
        onRefreshIntervalChange={setRefreshInterval}
        isAutoRefreshEnabled={isAutoRefreshEnabled}
        onAutoRefreshToggle={setIsAutoRefreshEnabled}
        onManualRefresh={refresh}
        loading={loading}
        lastUpdated={lastUpdated}
        retryCount={retryCount}
      />

      {/* Global Error Message */}
      {error && !data && (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
          <div className="flex items-center space-x-2">
            <div className="w-2 h-2 bg-red-500 rounded-full"></div>
            <span className="text-red-700 dark:text-red-300 font-medium">
              대시보드 데이터 로드 실패
            </span>
          </div>
          <p className="text-red-600 dark:text-red-400 text-sm mt-1">
            {error}
          </p>
          <button
            onClick={refresh}
            disabled={loading}
            className="mt-2 px-3 py-1 bg-red-100 hover:bg-red-200 dark:bg-red-900 dark:hover:bg-red-800 text-red-800 dark:text-red-300 text-sm rounded-lg font-medium transition-colors disabled:opacity-50"
          >
            {loading ? '재시도 중...' : '다시 시도'}
          </button>
        </div>
      )}

      {/* KPI Cards */}
      <KPICards
        stats={data?.stats || null}
        loading={loading}
        error={error}
      />

      {/* Monthly Trends - Responsive Full Width */}
      <div className="w-full">
        <MonthlyInventoryTrends
          className="h-64 sm:h-80 lg:h-96"
          onRefresh={refresh}
          data={null}
          loading={loading}
          error={error}
        />
      </div>

      {/* Main Analytics Grid - Responsive Layout */}
      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 md:gap-6">
        {/* Stock Levels by Category */}
        <div className="min-h-80">
          <StockLevelsByCategory
            className="h-full"
            onRefresh={refresh}
            data={null}
            loading={loading}
            error={error}
          />
        </div>

        {/* Transaction Distribution */}
        <div className="min-h-80">
          <TransactionDistribution
            className="h-full"
            onRefresh={refresh}
            data={null}
            loading={loading}
            error={error}
          />
        </div>

        {/* Top Items by Value */}
        <div className="min-h-80 md:col-span-2 xl:col-span-1">
          <TopItemsByValue
            className="h-full"
            onRefresh={refresh}
            data={null}
            loading={loading}
            error={error}
          />
        </div>
      </div>

      {/* Legacy Charts Section */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Stock Chart */}
        <StockChart
          data={data?.charts.stocks || null}
          loading={loading}
          error={error}
          isDark={isDark}
        />

        {/* Transaction Chart */}
        <TransactionChart
          data={data?.charts.transactions || null}
          monthlyData={data?.charts.monthlyTrends || null}
          loading={loading}
          error={error}
          isDark={isDark}
        />
      </div>

      {/* Alerts and Analytics - Responsive Layout */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6">
        {/* Low Stock Alerts */}
        <div className="min-h-96">
          <LowStockAlerts
            className="h-full"
            onRefresh={refresh}
            onReorderClick={(itemId: string) => {
              console.log('Reorder requested for item:', itemId);
              // TODO: Implement reorder functionality
            }}
            data={null}
            loading={loading}
            error={error}
          />
        </div>

        {/* Alert Panel and Analytics */}
        <div className="space-y-4 md:space-y-6">
          <AlertPanel
            data={data?.alerts || null}
            loading={loading}
            error={error}
          />

          {/* Additional Analytics Panel */}
          <AnalyticsPanel
            data={data}
            loading={loading}
            error={error}
            isDark={isDark}
          />
        </div>
      </div>

      {/* Performance Metrics Footer */}
      {data && (
        <PerformanceMetrics
          lastUpdated={lastUpdated}
          refreshInterval={refreshInterval}
          retryCount={retryCount}
          loadTime={data ? 'success' : 'error'}
        />
      )}
    </div>
  );
};

// Additional Analytics Panel Component
interface AnalyticsPanelProps {
  data: any;
  loading: boolean;
  error: string | null;
  isDark: boolean;
}

const AnalyticsPanel: React.FC<AnalyticsPanelProps> = ({
  data,
  loading,
  error,
  isDark
}) => {
  if (error || !data) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          분석 요약
        </h3>
        <div className="flex items-center justify-center h-32 text-gray-500">
          <p className="text-sm">분석 데이터를 불러올 수 없습니다</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
          분석 요약
        </h3>
        <div className="space-y-4">
          {Array.from({ length: 4 }).map((_, index) => (
            <div key={index} className="animate-pulse">
              <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  // Calculate additional metrics
  const analytics = React.useMemo(() => {
    if (!data?.charts || !data?.stats) return null;

    const { stocks, transactions } = data.charts;
    const { stats } = data;

    // Stock turnover rate
    const totalStock = stocks?.reduce((sum: number, item: Record<string, any>) => sum + (item.현재고 || 0), 0) || 0;
    const monthlyOutbound = transactions?.reduce((sum: number, item: Record<string, any>) => sum + (item.출고 || 0), 0) || 0;
    const turnoverRate = totalStock > 0 ? (monthlyOutbound / totalStock * 100) : 0;

    // Stock efficiency
    const lowStockCount = stocks?.filter((item: Record<string, any>) => item.현재고 < item.최소재고).length || 0;
    const overStockCount = stocks?.filter((item: Record<string, any>) => item.현재고 > item.안전재고).length || 0;
    const stockEfficiency = stocks?.length > 0 ? ((stocks.length - lowStockCount - overStockCount) / stocks.length * 100) : 0;

    return {
      turnoverRate,
      stockEfficiency,
      lowStockCount,
      overStockCount,
      totalItems: stocks?.length || 0
    };
  }, [data]);

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
      <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
        분석 요약
      </h3>

      {analytics && (
        <div className="space-y-4">
          {/* Stock Efficiency */}
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600 dark:text-gray-400">재고 효율성</span>
            <div className="flex items-center space-x-2">
              <div className="w-20 h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                <div
                  className={`h-full transition-all duration-300 ${
                    analytics.stockEfficiency >= 80
                      ? 'bg-green-500'
                      : analytics.stockEfficiency >= 60
                      ? 'bg-yellow-500'
                      : 'bg-red-500'
                  }`}
                  style={{ width: `${Math.min(analytics.stockEfficiency, 100)}%` }}
                ></div>
              </div>
              <span className="text-sm font-medium text-gray-900 dark:text-white">
                {analytics.stockEfficiency.toFixed(1)}%
              </span>
            </div>
          </div>

          {/* Turnover Rate */}
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600 dark:text-gray-400">재고 회전율</span>
            <span className="text-sm font-medium text-gray-900 dark:text-white">
              {analytics.turnoverRate.toFixed(1)}%
            </span>
          </div>

          {/* Stock Status Distribution */}
          <div className="space-y-2">
            <span className="text-sm text-gray-600 dark:text-gray-400">재고 상태 분포</span>
            <div className="grid grid-cols-3 gap-2 text-xs">
              <div className="text-center">
                <div className="text-red-600 font-medium">{analytics.lowStockCount}</div>
                <div className="text-gray-500">부족</div>
              </div>
              <div className="text-center">
                <div className="text-green-600 font-medium">
                  {analytics.totalItems - analytics.lowStockCount - analytics.overStockCount}
                </div>
                <div className="text-gray-500">적정</div>
              </div>
              <div className="text-center">
                <div className="text-blue-600 font-medium">{analytics.overStockCount}</div>
                <div className="text-gray-500">과재고</div>
              </div>
            </div>
          </div>

          {/* Quick Insights */}
          <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
            <div className="space-y-2">
              {analytics.stockEfficiency < 70 && (
                <div className="flex items-center space-x-2 text-orange-600 dark:text-orange-400">
                  <div className="w-2 h-2 bg-orange-500 rounded-full"></div>
                  <span className="text-xs">재고 관리 개선 필요</span>
                </div>
              )}
              {analytics.turnoverRate > 50 && (
                <div className="flex items-center space-x-2 text-green-600 dark:text-green-400">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span className="text-xs">높은 재고 회전율</span>
                </div>
              )}
              {analytics.lowStockCount > 5 && (
                <div className="flex items-center space-x-2 text-red-600 dark:text-red-400">
                  <div className="w-2 h-2 bg-red-500 rounded-full"></div>
                  <span className="text-xs">재고 보충 필요</span>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Performance Metrics Footer Component
interface PerformanceMetricsProps {
  lastUpdated: Date | null;
  refreshInterval: RefreshInterval;
  retryCount: number;
  loadTime: 'success' | 'error';
}

const PerformanceMetrics: React.FC<PerformanceMetricsProps> = ({
  lastUpdated,
  refreshInterval,
  retryCount,
  loadTime
}) => {
  const [renderTime] = React.useState(() => Date.now());

  return (
    <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
      <div className="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400">
        <div className="flex items-center space-x-4">
          <span>대시보드 성능</span>
          <div className="flex items-center space-x-2">
            <span>렌더링 시간:</span>
            <span className="font-medium">
              {Date.now() - renderTime}ms
            </span>
          </div>
          <div className="flex items-center space-x-2">
            <span>새로고침 주기:</span>
            <span className="font-medium">{refreshInterval}</span>
          </div>
        </div>

        <div className="flex items-center space-x-4">
          {retryCount > 0 && (
            <div className="flex items-center space-x-1 text-orange-600">
              <span>재시도:</span>
              <span className="font-medium">{retryCount}회</span>
            </div>
          )}
          <div className={`flex items-center space-x-1 ${
            loadTime === 'success' ? 'text-green-600' : 'text-red-600'
          }`}>
            <div className={`w-2 h-2 rounded-full ${
              loadTime === 'success' ? 'bg-green-500' : 'bg-red-500'
            }`}></div>
            <span>{loadTime === 'success' ? '정상' : '오류'}</span>
          </div>
        </div>
      </div>
    </div>
  );
};
```


#### 📄 src\components\dashboard\RecentActivityWidget.tsx

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { Clock, TrendingUp, TrendingDown, Package, Building2, RefreshCw } from 'lucide-react';

interface RecentTransaction {
  transaction_id: number;
  transaction_date: string;
  transaction_type: string;
  item_id: number;
  item_code: string;
  item_name: string;
  quantity: number;
  unit_price: number;
  total_amount: number;
  company_id?: number;
  company_name?: string;
  reference_no?: string;
  user_name?: string;
  created_at: string;
}

interface RecentActivityProps {
  limit?: number;
  hoursRange?: number;
}

const getTransactionTypeInfo = (type: string) => {
  switch (type) {
    case '입고':
      return {
        label: '입고',
        icon: <TrendingUp className="w-4 h-4" />,
        color: 'text-green-600',
        bgColor: 'bg-green-50',
        borderColor: 'border-green-200'
      };
    case '출고':
      return {
        label: '출고',
        icon: <TrendingDown className="w-4 h-4" />,
        color: 'text-red-600',
        bgColor: 'bg-red-50',
        borderColor: 'border-red-200'
      };
    case '생산입고':
      return {
        label: '생산입고',
        icon: <Package className="w-4 h-4" />,
        color: 'text-blue-600',
        bgColor: 'bg-blue-50',
        borderColor: 'border-blue-200'
      };
    case '생산출고':
      return {
        label: '생산출고',
        icon: <Package className="w-4 h-4" />,
        color: 'text-purple-600',
        bgColor: 'bg-purple-50',
        borderColor: 'border-purple-200'
      };
    case '조정':
      return {
        label: '재고조정',
        icon: <RefreshCw className="w-4 h-4" />,
        color: 'text-orange-600',
        bgColor: 'bg-orange-50',
        borderColor: 'border-orange-200'
      };
    default:
      return {
        label: type,
        icon: <Package className="w-4 h-4" />,
        color: 'text-gray-600',
        bgColor: 'bg-gray-50',
        borderColor: 'border-gray-200'
      };
  }
};

const formatTimeAgo = (dateString: string): string => {
  const now = new Date();
  const transactionDate = new Date(dateString);
  const diffInMinutes = Math.floor((now.getTime() - transactionDate.getTime()) / (1000 * 60));

  if (diffInMinutes < 1) {
    return '방금 전';
  } else if (diffInMinutes < 60) {
    return `${diffInMinutes}분 전`;
  } else if (diffInMinutes < 1440) { // 24 hours
    const hours = Math.floor(diffInMinutes / 60);
    return `${hours}시간 전`;
  } else {
    const days = Math.floor(diffInMinutes / 1440);
    return `${days}일 전`;
  }
};

const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ko-KR').format(num);
};

const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
};

const RecentActivityWidget: React.FC<RecentActivityProps> = ({
  limit = 10,
  hoursRange = 24
}) => {
  const [transactions, setTransactions] = useState<RecentTransaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchRecentActivity();
  }, [limit, hoursRange]);

  const fetchRecentActivity = async () => {
    try {
      setLoading(true);
      setError(null);

      // Calculate start date for the range
      const endDate = new Date();
      const startDate = new Date(endDate.getTime() - (hoursRange * 60 * 60 * 1000));

      const params = new URLSearchParams({
        limit: limit.toString(),
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0]
      });

      const response = await fetch(`/api/inventory?${params}`);
      const result = await response.json();

      if (result.success) {
        // Handle both direct array and paginated response formats
        const transactionData = Array.isArray(result.data) ? result.data : [];
        setTransactions(transactionData);
      } else {
        throw new Error(result.error || '최근 활동을 불러오는데 실패했습니다.');
      }
    } catch (err) {
      console.error('Error fetching recent activity:', err);
      setError(err instanceof Error ? err.message : '최근 활동을 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = () => {
    fetchRecentActivity();
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 flex items-center">
            <Clock className="w-5 h-5 mr-2 text-blue-600" />
            최근 활동 ({hoursRange}시간)
          </h3>
        </div>
        <div className="space-y-3">
          {[1, 2, 3, 4, 5].map((i) => (
            <div key={i} className="animate-pulse">
              <div className="flex items-center space-x-3 p-3 rounded-lg border">
                <div className="w-8 h-8 bg-gray-200 rounded-full"></div>
                <div className="flex-1">
                  <div className="w-32 h-4 bg-gray-200 rounded mb-1"></div>
                  <div className="w-24 h-3 bg-gray-200 rounded"></div>
                </div>
                <div className="text-right">
                  <div className="w-16 h-4 bg-gray-200 rounded mb-1"></div>
                  <div className="w-12 h-3 bg-gray-200 rounded"></div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 flex items-center">
            <Clock className="w-5 h-5 mr-2 text-blue-600" />
            최근 활동 ({hoursRange}시간)
          </h3>
          <button
            onClick={handleRefresh}
            className="text-sm text-blue-600 hover:text-blue-800 font-medium"
          >
            새로고침
          </button>
        </div>
        <div className="text-center py-8">
          <Clock className="w-12 h-12 text-red-500 mx-auto mb-4" />
          <p className="text-gray-600 mb-4">{error}</p>
          <button
            onClick={handleRefresh}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            다시 시도
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-gray-900 flex items-center">
          <Clock className="w-5 h-5 mr-2 text-blue-600" />
          최근 활동 ({hoursRange}시간)
        </h3>
        <button
          onClick={handleRefresh}
          className="text-sm text-blue-600 hover:text-blue-800 font-medium"
        >
          새로고침
        </button>
      </div>

      {transactions.length === 0 ? (
        <div className="text-center py-8">
          <Clock className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <p className="text-gray-600">최근 {hoursRange}시간 동안의 활동이 없습니다.</p>
        </div>
      ) : (
        <div className="space-y-2 max-h-96 overflow-y-auto">
          {transactions.map((transaction) => {
            const typeInfo = getTransactionTypeInfo(transaction.transaction_type);

            return (
              <div
                key={transaction.transaction_id}
                className={`p-3 rounded-lg border transition-colors ${typeInfo.bgColor} ${typeInfo.borderColor} hover:shadow-sm`}
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3 flex-1 min-w-0">
                    <div className={`flex-shrink-0 p-2 rounded-full ${typeInfo.bgColor}`}>
                      <div className={typeInfo.color}>
                        {typeInfo.icon}
                      </div>
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center space-x-2">
                        <span className={`text-xs font-medium px-2 py-1 rounded-full ${typeInfo.bgColor} ${typeInfo.color}`}>
                          {typeInfo.label}
                        </span>
                        <span className="text-xs text-gray-500">
                          {formatTimeAgo(transaction.created_at)}
                        </span>
                      </div>
                      <p className="text-sm font-medium text-gray-900 truncate mt-1">
                        {transaction.item_name}
                      </p>
                      <div className="flex items-center space-x-4 text-xs text-gray-500">
                        <span>{transaction.item_code}</span>
                        {transaction.company_name && (
                          <span className="flex items-center">
                            <Building2 className="w-3 h-3 mr-1" />
                            {transaction.company_name}
                          </span>
                        )}
                        {transaction.reference_no && (
                          <span>참조: {transaction.reference_no}</span>
                        )}
                      </div>
                    </div>
                  </div>

                  <div className="text-right flex-shrink-0 ml-4">
                    <p className={`text-sm font-semibold ${typeInfo.color}`}>
                      {transaction.transaction_type === '출고' || transaction.transaction_type === '생산출고' ? '-' : '+'}
                      {formatNumber(transaction.quantity)}
                    </p>
                    <p className="text-xs text-gray-600">
                      {formatCurrency(transaction.total_amount)}
                    </p>
                    {transaction.user_name && (
                      <p className="text-xs text-gray-500 mt-1">
                        {transaction.user_name}
                      </p>
                    )}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
};

export default RecentActivityWidget;
```


#### 📄 src\components\dashboard\RefreshControls.tsx

```typescript
/**
 * Refresh Controls Component
 * Auto-refresh settings and manual refresh controls
 */

import React from 'react';
import { RefreshCw, Clock, Pause, Play } from 'lucide-react';
import type { RefreshInterval } from '../../hooks/useDashboardData';
import { REFRESH_INTERVALS } from '../../hooks/useDashboardData';

interface RefreshControlsProps {
  refreshInterval: RefreshInterval;
  onRefreshIntervalChange: (interval: RefreshInterval) => void;
  isAutoRefreshEnabled: boolean;
  onAutoRefreshToggle: (enabled: boolean) => void;
  onManualRefresh: () => void;
  loading: boolean;
  lastUpdated: Date | null;
  retryCount?: number;
}

export const RefreshControls: React.FC<RefreshControlsProps> = ({
  refreshInterval,
  onRefreshIntervalChange,
  isAutoRefreshEnabled,
  onAutoRefreshToggle,
  onManualRefresh,
  loading,
  lastUpdated,
  retryCount = 0
}) => {
  const formatLastUpdated = (date: Date | null) => {
    if (!date) return '업데이트 없음';

    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 60000);
    const seconds = Math.floor((diff % 60000) / 1000);

    if (minutes > 0) {
      return `${minutes}분 ${seconds}초 전`;
    }
    return `${seconds}초 전`;
  };

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg p-4 shadow-sm">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          {/* Manual refresh button only */}
          <button
            onClick={onManualRefresh}
            disabled={loading}
            className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-medium text-sm transition-colors ${
              loading
                ? 'bg-gray-100 text-gray-400 cursor-not-allowed dark:bg-gray-700 dark:text-gray-500'
                : 'bg-blue-100 text-blue-800 hover:bg-blue-200 dark:bg-blue-900 dark:text-blue-300 dark:hover:bg-blue-800'
            }`}
          >
            <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
            <span>{loading ? '데이터 로딩중...' : '데이터 새로고침'}</span>
          </button>
        </div>

        {/* Status information */}
        <div className="flex items-center space-x-4 text-sm">
          {/* Last updated */}
          <div className="flex items-center space-x-2 text-gray-600 dark:text-gray-400">
            <span>마지막 업데이트:</span>
            <span className="font-medium">
              {formatLastUpdated(lastUpdated)}
            </span>
          </div>

          {/* Retry count indicator */}
          {retryCount > 0 && (
            <div className="flex items-center space-x-1 text-orange-600 dark:text-orange-400">
              <span className="w-2 h-2 bg-orange-500 rounded-full"></span>
              <span>재시도 {retryCount}회</span>
            </div>
          )}

          {/* Connection status */}
          <div className="flex items-center space-x-2">
            <div
              className={`w-2 h-2 rounded-full ${
                loading
                  ? 'bg-yellow-500 animate-pulse'
                  : retryCount > 0
                  ? 'bg-orange-500'
                  : 'bg-green-500'
              }`}
            ></div>
            <span className="text-gray-600 dark:text-gray-400">
              {loading
                ? '데이터 로딩중'
                : retryCount > 0
                ? '연결 재시도중'
                : '연결됨'
              }
            </span>
          </div>
        </div>
      </div>

    </div>
  );
};
```


#### 📄 src\components\dashboard\StockChart.tsx

```typescript
/**
 * Stock Chart Component
 * Visualizes stock levels with bar and line charts
 */

import React, { useState, useRef } from 'react';
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine
} from 'recharts';
import { BarChart3, TrendingUp, Download, Printer, Settings } from 'lucide-react';
import {
  formatKoreanNumber,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  getStockLevelColor
} from '../../utils/chartUtils';
import type { ChartData } from '../../hooks/useDashboardData';

interface StockChartProps {
  data: ChartData['stocks'] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
}

type ChartType = 'bar' | 'line';

export const StockChart: React.FC<StockChartProps> = ({
  data,
  loading,
  error,
  isDark = false
}) => {
  const [chartType, setChartType] = useState<ChartType>('bar');
  const [showSafetyStock, setShowSafetyStock] = useState(true);
  const [sortBy, setSortBy] = useState<'name' | 'current' | 'ratio'>('ratio');
  const chartRef = useRef<any>(null);

  const theme = getRechartsTheme(isDark);

  // Sort and prepare data
  const sortedData = React.useMemo(() => {
    if (!data) return [];

    const sorted = [...data].sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'current':
          return b.현재고 - a.현재고;
        case 'ratio':
          const ratioA = a.최소재고 > 0 ? a.현재고 / a.최소재고 : 0;
          const ratioB = b.최소재고 > 0 ? b.현재고 / b.최소재고 : 0;
          return ratioA - ratioB;
        default:
          return 0;
      }
    });

    // Limit to top 20 items for better visualization
    return sorted.slice(0, 20);
  }, [data, sortBy]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      const ratio = data.최소재고 > 0 ? (data.현재고 / data.최소재고) : 0;

      return (
        <div
          className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg"
          style={theme.tooltip.contentStyle}
        >
          <p className="font-semibold text-gray-900 dark:text-gray-100 mb-2">
            {label}
          </p>
          <p className="text-gray-600 dark:text-gray-400 text-xs mb-2">
            품번: {data.code}
          </p>
          <div className="space-y-1">
            <p className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">현재고:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {formatKoreanNumber(data.현재고)}개
              </span>
            </p>
            <p className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">최소재고:</span>
              <span className="font-medium text-gray-900 dark:text-gray-100">
                {formatKoreanNumber(data.최소재고)}개
              </span>
            </p>
            {showSafetyStock && (
              <p className="flex justify-between">
                <span className="text-gray-600 dark:text-gray-400">안전재고:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(data.안전재고)}개
                </span>
              </p>
            )}
            <p className="flex justify-between pt-1 border-t border-gray-200 dark:border-gray-600">
              <span className="text-gray-600 dark:text-gray-400">재고비율:</span>
              <span
                className={`font-medium ${
                  ratio < 0.5
                    ? 'text-red-600'
                    : ratio < 1
                    ? 'text-orange-600'
                    : 'text-green-600'
                }`}
              >
                {(ratio * 100).toFixed(1)}%
              </span>
            </p>
          </div>
        </div>
      );
    }
    return null;
  };

  // Custom bar color function
  const getBarColor = (entry: any) => {
    return getStockLevelColor(entry.현재고, entry.최소재고, isDark);
  };

  if (error) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            재고 현황 차트
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <BarChart3 className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <BarChart3 className="w-5 h-5 text-blue-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            재고 현황 차트
          </h3>
        </div>

        {/* Controls */}
        <div className="flex items-center space-x-2">
          {/* Chart Type Toggle */}
          <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
            <button
              onClick={() => setChartType('bar')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                chartType === 'bar'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              막대
            </button>
            <button
              onClick={() => setChartType('line')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                chartType === 'line'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              선형
            </button>
          </div>

          {/* Sort Options */}
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as any)}
            className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 text-sm"
          >
            <option value="ratio">재고비율순</option>
            <option value="current">현재고순</option>
            <option value="name">품명순</option>
          </select>

          {/* Options */}
          <button
            onClick={() => setShowSafetyStock(!showSafetyStock)}
            className={`px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
              showSafetyStock
                ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
            }`}
          >
            안전재고
          </button>

          {/* Export buttons */}
          <button
            onClick={() => exportChartAsImage(chartRef, '재고현황차트.png')}
            className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            title="이미지로 내보내기"
          >
            <Download className="w-4 h-4" />
          </button>

          <button
            onClick={() => printChart(chartRef)}
            className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            title="인쇄"
          >
            <Printer className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* Chart */}
      <div className="h-80" ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          </div>
        ) : !sortedData.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <BarChart3 className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 재고 데이터가 없습니다</p>
            </div>
          </div>
        ) : chartType === 'bar' ? (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={sortedData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="name"
                angle={-45}
                textAnchor="end"
                height={80}
                interval={0}
                tick={{ ...theme.xAxis.tick, fontSize: 11 }}
                axisLine={theme.xAxis.axisLine}
              />
              <YAxis
                tickFormatter={formatKoreanNumber}
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              <Bar
                dataKey="현재고"
                name="현재고"
                fill={theme.colors[0]}
                radius={[2, 2, 0, 0]}
              />
              <Bar
                dataKey="최소재고"
                name="최소재고"
                fill={theme.colors[3]}
                radius={[2, 2, 0, 0]}
              />
              {showSafetyStock && (
                <Bar
                  dataKey="안전재고"
                  name="안전재고"
                  fill={theme.colors[1]}
                  radius={[2, 2, 0, 0]}
                />
              )}
            </BarChart>
          </ResponsiveContainer>
        ) : (
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={sortedData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="name"
                angle={-45}
                textAnchor="end"
                height={80}
                interval={0}
                tick={{ ...theme.xAxis.tick, fontSize: 11 }}
                axisLine={theme.xAxis.axisLine}
              />
              <YAxis
                tickFormatter={formatKoreanNumber}
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              <Line
                type="monotone"
                dataKey="현재고"
                name="현재고"
                stroke={theme.colors[0]}
                strokeWidth={2}
                dot={{ r: 4 }}
              />
              <Line
                type="monotone"
                dataKey="최소재고"
                name="최소재고"
                stroke={theme.colors[3]}
                strokeWidth={2}
                strokeDasharray="5 5"
                dot={{ r: 4 }}
              />
              {showSafetyStock && (
                <Line
                  type="monotone"
                  dataKey="안전재고"
                  name="안전재고"
                  stroke={theme.colors[1]}
                  strokeWidth={2}
                  strokeDasharray="10 5"
                  dot={{ r: 4 }}
                />
              )}
            </LineChart>
          </ResponsiveContainer>
        )}
      </div>

      {/* Summary */}
      {!loading && sortedData.length > 0 && (
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 품목</p>
            <p className="text-lg font-semibold text-gray-900 dark:text-white">
              {sortedData.length}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">부족 품목</p>
            <p className="text-lg font-semibold text-red-600">
              {sortedData.filter(item => item.현재고 < item.최소재고).length}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">과재고 품목</p>
            <p className="text-lg font-semibold text-blue-600">
              {sortedData.filter(item => item.현재고 > item.안전재고).length}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">평균 재고율</p>
            <p className="text-lg font-semibold text-gray-900 dark:text-white">
              {(
                sortedData.reduce((sum, item) => {
                  const ratio = item.최소재고 > 0 ? item.현재고 / item.최소재고 : 0;
                  return sum + ratio;
                }, 0) / sortedData.length * 100
              ).toFixed(1)}%
            </p>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\dashboard\StockStatusWidget.tsx

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { AlertTriangle, CheckCircle, XCircle, Package2 } from 'lucide-react';

interface StockItem {
  item_id: number;
  item_code: string;
  item_name: string;
  current_stock: number;
  safety_stock: number;
  unit: string;
  stock_value: number;
  is_low_stock: number;
}

interface StockStatusProps {
  limit?: number;
  showValue?: boolean;
}

interface StockStatusInfo {
  status: 'critical' | 'warning' | 'normal';
  color: string;
  bgColor: string;
  icon: React.ReactNode;
  label: string;
}

const getStockStatus = (currentStock: number, safetyStock: number): StockStatusInfo => {
  if (currentStock === 0) {
    return {
      status: 'critical',
      color: 'text-red-600',
      bgColor: 'bg-red-50',
      icon: <XCircle className="w-4 h-4 text-red-500" />,
      label: '재고없음'
    };
  } else if (currentStock <= safetyStock) {
    return {
      status: 'warning',
      color: 'text-yellow-600',
      bgColor: 'bg-yellow-50',
      icon: <AlertTriangle className="w-4 h-4 text-yellow-500" />,
      label: '부족'
    };
  } else {
    return {
      status: 'normal',
      color: 'text-green-600',
      bgColor: 'bg-green-50',
      icon: <CheckCircle className="w-4 h-4 text-green-500" />,
      label: '정상'
    };
  }
};

const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ko-KR').format(num);
};

const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
};

const StockStatusWidget: React.FC<StockStatusProps> = ({
  limit = 10,
  showValue = false
}) => {
  const [stockItems, setStockItems] = useState<StockItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchStockStatus();
  }, [limit]);

  const fetchStockStatus = async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(`/api/stock/current?limit=${limit}&offset=0`);
      const result = await response.json();

      if (result.success) {
        setStockItems(result.data.items || []);
      } else {
        throw new Error(result.error || '재고 현황을 불러오는데 실패했습니다.');
      }
    } catch (err) {
      console.error('Error fetching stock status:', err);
      setError(err instanceof Error ? err.message : '재고 현황을 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = () => {
    fetchStockStatus();
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 flex items-center">
            <Package2 className="w-5 h-5 mr-2 text-blue-600" />
            재고 현황
          </h3>
        </div>
        <div className="space-y-3">
          {[1, 2, 3, 4, 5].map((i) => (
            <div key={i} className="animate-pulse">
              <div className="flex items-center justify-between p-3 rounded-lg border">
                <div className="flex items-center space-x-3">
                  <div className="w-8 h-8 bg-gray-200 rounded-full"></div>
                  <div>
                    <div className="w-24 h-4 bg-gray-200 rounded mb-1"></div>
                    <div className="w-16 h-3 bg-gray-200 rounded"></div>
                  </div>
                </div>
                <div className="text-right">
                  <div className="w-12 h-4 bg-gray-200 rounded mb-1"></div>
                  <div className="w-8 h-3 bg-gray-200 rounded"></div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 flex items-center">
            <Package2 className="w-5 h-5 mr-2 text-blue-600" />
            재고 현황
          </h3>
          <button
            onClick={handleRefresh}
            className="text-sm text-blue-600 hover:text-blue-800 font-medium"
          >
            새로고침
          </button>
        </div>
        <div className="text-center py-8">
          <XCircle className="w-12 h-12 text-red-500 mx-auto mb-4" />
          <p className="text-gray-600 mb-4">{error}</p>
          <button
            onClick={handleRefresh}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            다시 시도
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-gray-900 flex items-center">
          <Package2 className="w-5 h-5 mr-2 text-blue-600" />
          재고 현황
        </h3>
        <button
          onClick={handleRefresh}
          className="text-sm text-blue-600 hover:text-blue-800 font-medium"
        >
          새로고침
        </button>
      </div>

      {stockItems.length === 0 ? (
        <div className="text-center py-8">
          <Package2 className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <p className="text-gray-600">표시할 재고 정보가 없습니다.</p>
        </div>
      ) : (
        <div className="space-y-2 max-h-96 overflow-y-auto">
          {stockItems.map((item) => {
            const stockStatus = getStockStatus(item.current_stock, item.safety_stock);

            return (
              <div
                key={item.item_id}
                className={`p-3 rounded-lg border transition-colors ${stockStatus.bgColor} border-gray-200 hover:shadow-sm`}
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3 flex-1 min-w-0">
                    <div className="flex-shrink-0">
                      {stockStatus.icon}
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 truncate">
                        {item.item_name}
                      </p>
                      <p className="text-xs text-gray-500 truncate">
                        {item.item_code}
                      </p>
                    </div>
                  </div>

                  <div className="text-right flex-shrink-0 ml-4">
                    <div className="flex items-center space-x-2">
                      <div className="text-right">
                        <p className={`text-sm font-semibold ${stockStatus.color}`}>
                          {formatNumber(item.current_stock)} {item.unit}
                        </p>
                        <p className="text-xs text-gray-500">
                          안전재고: {formatNumber(item.safety_stock)}
                        </p>
                      </div>
                      <div className={`px-2 py-1 rounded-full text-xs font-medium ${stockStatus.bgColor} ${stockStatus.color}`}>
                        {stockStatus.label}
                      </div>
                    </div>

                    {showValue && item.stock_value > 0 && (
                      <p className="text-xs text-gray-600 mt-1">
                        {formatCurrency(item.stock_value)}
                      </p>
                    )}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
};

export default StockStatusWidget;
```


#### 📄 src\components\dashboard\StockSummaryCard.tsx

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { Package, AlertTriangle, CheckCircle, TrendingUp, RefreshCw } from 'lucide-react';

interface StockSummaryData {
  total_items: number;
  low_stock_items: number;
  total_value: number;
  normal_items?: number;
  warning_items?: number;
  critical_items?: number;
}

interface SummaryCard {
  title: string;
  value: string | number;
  subtitle?: string;
  icon: React.ReactNode;
  color: string;
  bgColor: string;
  change?: {
    value: number;
    label: string;
    isPositive: boolean;
  };
}

const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ko-KR').format(num);
};

const formatCurrency = (amount: number): string => {
  if (amount >= 1000000000) {
    return `₩${(amount / 1000000000).toFixed(1)}십억`;
  } else if (amount >= 100000000) {
    return `₩${(amount / 100000000).toFixed(1)}억`;
  } else if (amount >= 10000000) {
    return `₩${(amount / 10000000).toFixed(1)}천만`;
  } else if (amount >= 1000000) {
    return `₩${(amount / 1000000).toFixed(1)}백만`;
  } else if (amount >= 10000) {
    return `₩${(amount / 10000).toFixed(0)}만`;
  } else {
    return `₩${formatNumber(amount)}`;
  }
};

const StockSummaryCard: React.FC = () => {
  const [summaryData, setSummaryData] = useState<StockSummaryData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchSummaryData();
  }, []);

  const fetchSummaryData = async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/stock/current?limit=1000&offset=0');
      const result = await response.json();

      if (result.success) {
        const data = result.data;
        setSummaryData({
          total_items: data.statistics?.total_items || 0,
          low_stock_items: data.statistics?.low_stock_items || 0,
          total_value: data.statistics?.total_value || 0
        });
      } else {
        throw new Error(result.error || '요약 데이터를 불러오는데 실패했습니다.');
      }
    } catch (err) {
      console.error('Error fetching summary data:', err);
      setError(err instanceof Error ? err.message : '요약 데이터를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = () => {
    fetchSummaryData();
  };

  if (loading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
            <div className="animate-pulse">
              <div className="flex items-center justify-between mb-4">
                <div className="w-8 h-8 bg-gray-200 rounded-full"></div>
                <div className="w-4 h-4 bg-gray-200 rounded"></div>
              </div>
              <div className="w-16 h-8 bg-gray-200 rounded mb-2"></div>
              <div className="w-24 h-4 bg-gray-200 rounded"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <div className="text-center py-8">
          <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-4" />
          <p className="text-gray-600 mb-4">{error}</p>
          <button
            onClick={handleRefresh}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            다시 시도
          </button>
        </div>
      </div>
    );
  }

  if (!summaryData) {
    return null;
  }

  const normalItems = summaryData.total_items - summaryData.low_stock_items;
  const lowStockPercentage = summaryData.total_items > 0
    ? Math.round((summaryData.low_stock_items / summaryData.total_items) * 100)
    : 0;

  const summaryCards: SummaryCard[] = [
    {
      title: '전체 품목',
      value: formatNumber(summaryData.total_items),
      subtitle: '등록된 전체 품목 수',
      icon: <Package className="w-6 h-6" />,
      color: 'text-blue-600',
      bgColor: 'bg-blue-50'
    },
    {
      title: '정상 재고',
      value: formatNumber(normalItems),
      subtitle: `전체의 ${100 - lowStockPercentage}%`,
      icon: <CheckCircle className="w-6 h-6" />,
      color: 'text-green-600',
      bgColor: 'bg-green-50',
      change: {
        value: 100 - lowStockPercentage,
        label: '정상 비율',
        isPositive: lowStockPercentage < 20
      }
    },
    {
      title: '부족/경고',
      value: formatNumber(summaryData.low_stock_items),
      subtitle: `전체의 ${lowStockPercentage}%`,
      icon: <AlertTriangle className="w-6 h-6" />,
      color: 'text-red-600',
      bgColor: 'bg-red-50',
      change: {
        value: lowStockPercentage,
        label: '부족 비율',
        isPositive: false
      }
    },
    {
      title: '총 재고 가치',
      value: formatCurrency(summaryData.total_value),
      subtitle: '현재 재고의 총 가치',
      icon: <TrendingUp className="w-6 h-6" />,
      color: 'text-purple-600',
      bgColor: 'bg-purple-50'
    }
  ];

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold text-gray-900">재고 현황 요약</h2>
        <button
          onClick={handleRefresh}
          className="flex items-center space-x-2 text-sm text-blue-600 hover:text-blue-800 font-medium"
        >
          <RefreshCw className="w-4 h-4" />
          <span>새로고침</span>
        </button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {summaryCards.map((card, index) => (
          <div
            key={index}
            className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow"
          >
            <div className="flex items-center justify-between mb-4">
              <div className={`p-2 rounded-lg ${card.bgColor}`}>
                <div className={card.color}>
                  {card.icon}
                </div>
              </div>
              {card.change && (
                <div className={`flex items-center text-xs font-medium ${
                  card.change.isPositive ? 'text-green-600' : 'text-red-600'
                }`}>
                  <TrendingUp className={`w-3 h-3 mr-1 ${
                    !card.change.isPositive ? 'rotate-180' : ''
                  }`} />
                  {card.change.value}%
                </div>
              )}
            </div>

            <div>
              <h3 className="text-2xl font-bold text-gray-900 mb-1">
                {card.value}
              </h3>
              <p className="text-sm font-medium text-gray-600 mb-2">
                {card.title}
              </p>
              <p className="text-xs text-gray-500">
                {card.subtitle}
              </p>
              {card.change && (
                <p className="text-xs text-gray-400 mt-1">
                  {card.change.label}
                </p>
              )}
            </div>
          </div>
        ))}
      </div>

      {/* Additional insights */}
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-green-500 rounded-full"></div>
              <span className="text-sm text-gray-600">정상: {formatNumber(normalItems)}개</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-red-500 rounded-full"></div>
              <span className="text-sm text-gray-600">부족/경고: {formatNumber(summaryData.low_stock_items)}개</span>
            </div>
          </div>
          <div className="text-sm text-gray-500">
            재고 관리 상태: {lowStockPercentage < 10 ? '우수' : lowStockPercentage < 20 ? '양호' : '주의 필요'}
          </div>
        </div>
      </div>
    </div>
  );
};

export default StockSummaryCard;
```


#### 📄 src\components\dashboard\TransactionChart.tsx

```typescript
/**
 * Transaction Chart Component
 * Visualizes transaction trends with area and line charts
 */

import React, { useState, useRef } from 'react';
import {
  AreaChart,
  Area,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from 'recharts';
import { TrendingUp, PieChart as PieChartIcon, Download, Printer, Calendar } from 'lucide-react';
import {
  formatKoreanNumber,
  getRechartsTheme,
  exportChartAsImage,
  printChart,
  getTransactionTypeColor
} from '../../utils/chartUtils';
import type { ChartData } from '../../hooks/useDashboardData';

interface TransactionChartProps {
  data: ChartData['transactions'] | null;
  monthlyData: ChartData['monthlyTrends'] | null;
  loading: boolean;
  error: string | null;
  isDark?: boolean;
}

type ChartType = 'area' | 'line' | 'pie';
type TimeRange = 'daily' | 'monthly';

export const TransactionChart: React.FC<TransactionChartProps> = ({
  data,
  monthlyData,
  loading,
  error,
  isDark = false
}) => {
  const [chartType, setChartType] = useState<ChartType>('area');
  const [timeRange, setTimeRange] = useState<TimeRange>('daily');
  const [selectedTypes, setSelectedTypes] = useState({
    입고: true,
    출고: true,
    생산: true
  });
  const chartRef = useRef<any>(null);

  const theme = getRechartsTheme(isDark);

  // Get current data based on time range
  const currentData = timeRange === 'daily' ? data : monthlyData;

  // Calculate totals for pie chart
  const totals = React.useMemo(() => {
    if (!currentData) return [];

    const sums = currentData.reduce(
      (acc, item) => ({
        입고: acc.입고 + (item.입고 || 0),
        출고: acc.출고 + (item.출고 || 0),
        생산: acc.생산 + (item.생산 || 0)
      }),
      { 입고: 0, 출고: 0, 생산: 0 }
    );

    return [
      { name: '입고', value: sums.입고, color: getTransactionTypeColor('입고', isDark) },
      { name: '출고', value: sums.출고, color: getTransactionTypeColor('출고', isDark) },
      { name: '생산', value: sums.생산, color: getTransactionTypeColor('생산', isDark) }
    ].filter(item => item.value > 0);
  }, [currentData, isDark]);

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div
          className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg"
          style={theme.tooltip.contentStyle}
        >
          <p className="font-semibold text-gray-900 dark:text-gray-100 mb-2">
            {label}
          </p>
          <div className="space-y-1">
            {payload.map((entry: any, index: number) => (
              <p key={index} className="flex justify-between items-center">
                <span className="flex items-center">
                  <span
                    className="w-3 h-3 rounded-full mr-2"
                    style={{ backgroundColor: entry.color }}
                  ></span>
                  {entry.name}:
                </span>
                <span className="font-medium text-gray-900 dark:text-gray-100 ml-2">
                  {formatKoreanNumber(entry.value)}개
                </span>
              </p>
            ))}
            {payload.length > 1 && (
              <p className="flex justify-between pt-1 border-t border-gray-200 dark:border-gray-600">
                <span className="text-gray-600 dark:text-gray-400">총계:</span>
                <span className="font-medium text-gray-900 dark:text-gray-100">
                  {formatKoreanNumber(payload.reduce((sum: number, entry: any) => sum + entry.value, 0))}개
                </span>
              </p>
            )}
          </div>
        </div>
      );
    }
    return null;
  };

  // Pie chart tooltip
  const PieTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0];
      const total = totals.reduce((sum, item) => sum + item.value, 0);
      const percentage = total > 0 ? (data.value / total * 100).toFixed(1) : '0';

      return (
        <div
          className="bg-white dark:bg-gray-800 p-3 border border-gray-200 dark:border-gray-600 rounded-lg shadow-lg"
          style={theme.tooltip.contentStyle}
        >
          <p className="font-semibold text-gray-900 dark:text-gray-100 mb-1">
            {data.name}
          </p>
          <p className="text-gray-600 dark:text-gray-400">
            수량: <span className="font-medium text-gray-900 dark:text-gray-100">
              {formatKoreanNumber(data.value)}개
            </span>
          </p>
          <p className="text-gray-600 dark:text-gray-400">
            비율: <span className="font-medium text-gray-900 dark:text-gray-100">
              {percentage}%
            </span>
          </p>
        </div>
      );
    }
    return null;
  };

  // Toggle transaction type visibility
  const toggleTransactionType = (type: keyof typeof selectedTypes) => {
    setSelectedTypes(prev => ({
      ...prev,
      [type]: !prev[type]
    }));
  };

  if (error) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            거래 동향 차트
          </h3>
        </div>
        <div className="flex items-center justify-center h-64 text-red-500">
          <div className="text-center">
            <TrendingUp className="w-12 h-12 mx-auto mb-2 opacity-50" />
            <p>차트 데이터 로드 실패</p>
            <p className="text-sm text-gray-500 mt-1">{error}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center space-x-2">
          <TrendingUp className="w-5 h-5 text-purple-500" />
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            거래 동향 차트
          </h3>
        </div>

        {/* Controls */}
        <div className="flex items-center space-x-2">
          {/* Time Range Toggle */}
          <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
            <button
              onClick={() => setTimeRange('daily')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                timeRange === 'daily'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              일별
            </button>
            <button
              onClick={() => setTimeRange('monthly')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                timeRange === 'monthly'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              월별
            </button>
          </div>

          {/* Chart Type Toggle */}
          <div className="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
            <button
              onClick={() => setChartType('area')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                chartType === 'area'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              영역
            </button>
            <button
              onClick={() => setChartType('line')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                chartType === 'line'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              선형
            </button>
            <button
              onClick={() => setChartType('pie')}
              className={`px-3 py-1 rounded text-sm font-medium transition-colors ${
                chartType === 'pie'
                  ? 'bg-white dark:bg-gray-600 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              원형
            </button>
          </div>

          {/* Export buttons */}
          <button
            onClick={() => exportChartAsImage(chartRef, '거래동향차트.png')}
            className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            title="이미지로 내보내기"
          >
            <Download className="w-4 h-4" />
          </button>

          <button
            onClick={() => printChart(chartRef)}
            className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            title="인쇄"
          >
            <Printer className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* Transaction Type Filters */}
      {chartType !== 'pie' && (
        <div className="flex items-center space-x-4 mb-4">
          <span className="text-sm text-gray-600 dark:text-gray-400">표시 항목:</span>
          {Object.entries(selectedTypes).map(([type, selected]) => (
            <button
              key={type}
              onClick={() => toggleTransactionType(type as keyof typeof selectedTypes)}
              className={`flex items-center space-x-2 px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                selected
                  ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                  : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400'
              }`}
            >
              <span
                className="w-3 h-3 rounded-full"
                style={{ backgroundColor: getTransactionTypeColor(type, isDark) }}
              ></span>
              <span>{type}</span>
            </button>
          ))}
        </div>
      )}

      {/* Chart */}
      <div className="h-80" ref={chartRef}>
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500"></div>
          </div>
        ) : !currentData?.length ? (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <TrendingUp className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>표시할 거래 데이터가 없습니다</p>
            </div>
          </div>
        ) : chartType === 'pie' ? (
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={totals}
                cx="50%"
                cy="50%"
                labelLine={false}
                label={(props: any) => `${props.name} ${(props.percent * 100).toFixed(1)}%`}
                outerRadius={100}
                fill="#8884d8"
                dataKey="value"
              >
                {totals.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip content={<PieTooltip />} />
            </PieChart>
          </ResponsiveContainer>
        ) : chartType === 'area' ? (
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={currentData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="date"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
              />
              <YAxis
                tickFormatter={formatKoreanNumber}
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              {selectedTypes.입고 && (
                <Area
                  type="monotone"
                  dataKey="입고"
                  stackId="1"
                  stroke={getTransactionTypeColor('입고', isDark)}
                  fill={getTransactionTypeColor('입고', isDark)}
                  fillOpacity={0.6}
                />
              )}
              {selectedTypes.출고 && (
                <Area
                  type="monotone"
                  dataKey="출고"
                  stackId="1"
                  stroke={getTransactionTypeColor('출고', isDark)}
                  fill={getTransactionTypeColor('출고', isDark)}
                  fillOpacity={0.6}
                />
              )}
              {selectedTypes.생산 && (
                <Area
                  type="monotone"
                  dataKey="생산"
                  stackId="1"
                  stroke={getTransactionTypeColor('생산', isDark)}
                  fill={getTransactionTypeColor('생산', isDark)}
                  fillOpacity={0.6}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        ) : (
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={currentData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke={theme.cartesianGrid.stroke} />
              <XAxis
                dataKey="date"
                tick={theme.xAxis.tick}
                axisLine={theme.xAxis.axisLine}
              />
              <YAxis
                tickFormatter={formatKoreanNumber}
                tick={theme.yAxis.tick}
                axisLine={theme.yAxis.axisLine}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />

              {selectedTypes.입고 && (
                <Line
                  type="monotone"
                  dataKey="입고"
                  stroke={getTransactionTypeColor('입고', isDark)}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
              {selectedTypes.출고 && (
                <Line
                  type="monotone"
                  dataKey="출고"
                  stroke={getTransactionTypeColor('출고', isDark)}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
              {selectedTypes.생산 && (
                <Line
                  type="monotone"
                  dataKey="생산"
                  stroke={getTransactionTypeColor('생산', isDark)}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
            </LineChart>
          </ResponsiveContainer>
        )}
      </div>

      {/* Summary */}
      {!loading && currentData && currentData.length > 0 && (
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 입고</p>
            <p className="text-lg font-semibold text-green-600">
              {formatKoreanNumber(totals.find(t => t.name === '입고')?.value || 0)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 출고</p>
            <p className="text-lg font-semibold text-blue-600">
              {formatKoreanNumber(totals.find(t => t.name === '출고')?.value || 0)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">총 생산</p>
            <p className="text-lg font-semibold text-yellow-600">
              {formatKoreanNumber(totals.find(t => t.name === '생산')?.value || 0)}개
            </p>
          </div>
          <div className="text-center">
            <p className="text-xs text-gray-500 dark:text-gray-400">순 증감</p>
            <p className={`text-lg font-semibold ${
              (totals.find(t => t.name === '입고')?.value || 0) +
              (totals.find(t => t.name === '생산')?.value || 0) -
              (totals.find(t => t.name === '출고')?.value || 0) >= 0
                ? 'text-green-600' : 'text-red-600'
            }`}>
              {formatKoreanNumber(
                (totals.find(t => t.name === '입고')?.value || 0) +
                (totals.find(t => t.name === '생산')?.value || 0) -
                (totals.find(t => t.name === '출고')?.value || 0)
              )}개
            </p>
          </div>
        </div>
      )}
    </div>
  );
};
```


#### 📄 src\components\DateRangePicker.tsx

```typescript
'use client';

import { useState, useRef, useEffect } from 'react';
import { Calendar, X, ChevronLeft, ChevronRight } from 'lucide-react';

export interface DateRange {
  startDate: Date | null;
  endDate: Date | null;
}

interface DateRangePickerProps {
  value: DateRange;
  onChange: (range: DateRange) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
  maxDate?: Date;
  minDate?: Date;
}

interface QuickPreset {
  label: string;
  getValue: () => DateRange;
}

// Korean months and day names
const KOREAN_MONTHS = [
  '1월', '2월', '3월', '4월', '5월', '6월',
  '7월', '8월', '9월', '10월', '11월', '12월'
];

const KOREAN_DAYS = ['일', '월', '화', '수', '목', '금', '토'];

// Quick date presets
const QUICK_PRESETS: QuickPreset[] = [
  {
    label: '오늘',
    getValue: () => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const endOfDay = new Date(today);
      endOfDay.setHours(23, 59, 59, 999);
      return { startDate: today, endDate: endOfDay };
    }
  },
  {
    label: '어제',
    getValue: () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(0, 0, 0, 0);
      const endOfDay = new Date(yesterday);
      endOfDay.setHours(23, 59, 59, 999);
      return { startDate: yesterday, endDate: endOfDay };
    }
  },
  {
    label: '이번 주',
    getValue: () => {
      const today = new Date();
      const day = today.getDay();
      const startDate = new Date(today);
      startDate.setDate(today.getDate() - day);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '지난 주',
    getValue: () => {
      const today = new Date();
      const day = today.getDay();
      const startDate = new Date(today);
      startDate.setDate(today.getDate() - day - 7);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '이번 달',
    getValue: () => {
      const today = new Date();
      const startDate = new Date(today.getFullYear(), today.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '지난 달',
    getValue: () => {
      const today = new Date();
      const startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(today.getFullYear(), today.getMonth(), 0);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '최근 3개월',
    getValue: () => {
      const today = new Date();
      const startDate = new Date(today);
      startDate.setMonth(today.getMonth() - 3);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(today);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '최근 6개월',
    getValue: () => {
      const today = new Date();
      const startDate = new Date(today);
      startDate.setMonth(today.getMonth() - 6);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(today);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  },
  {
    label: '올해',
    getValue: () => {
      const today = new Date();
      const startDate = new Date(today.getFullYear(), 0, 1);
      startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(today.getFullYear(), 11, 31);
      endDate.setHours(23, 59, 59, 999);
      return { startDate, endDate };
    }
  }
];

export default function DateRangePicker({
  value,
  onChange,
  placeholder = '날짜 범위 선택',
  className = '',
  disabled = false,
  maxDate,
  minDate
}: DateRangePickerProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [currentMonth, setCurrentMonth] = useState(new Date());
  const [selectingStart, setSelectingStart] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Format date for Korean locale
  const formatDate = (date: Date | null): string => {
    if (!date) return '';
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${year}년 ${month}월 ${day}일`;
  };

  // Format date range display
  const formatDateRange = (): string => {
    if (!value.startDate && !value.endDate) return placeholder;
    if (value.startDate && !value.endDate) {
      return `${formatDate(value.startDate)} ~`;
    }
    if (!value.startDate && value.endDate) {
      return `~ ${formatDate(value.endDate)}`;
    }
    if (value.startDate && value.endDate) {
      return `${formatDate(value.startDate)} ~ ${formatDate(value.endDate)}`;
    }
    return placeholder;
  };

  // Generate calendar days for the current month
  const generateCalendarDays = () => {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDate = new Date(firstDay);
    startDate.setDate(startDate.getDate() - firstDay.getDay());

    const days = [];
    const current = new Date(startDate);

    for (let week = 0; week < 6; week++) {
      for (let day = 0; day < 7; day++) {
        days.push(new Date(current));
        current.setDate(current.getDate() + 1);
      }
    }

    return days;
  };

  // Check if a date is in the current month
  const isCurrentMonth = (date: Date): boolean => {
    return date.getMonth() === currentMonth.getMonth() &&
           date.getFullYear() === currentMonth.getFullYear();
  };

  // Check if a date is today
  const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.toDateString() === today.toDateString();
  };

  // Check if a date is selected (start or end)
  const isSelected = (date: Date): boolean => {
    if (!value.startDate && !value.endDate) return false;

    const dateStr = date.toDateString();
    const startStr = value.startDate?.toDateString();
    const endStr = value.endDate?.toDateString();

    return dateStr === startStr || dateStr === endStr;
  };

  // Check if a date is in the selected range
  const isInRange = (date: Date): boolean => {
    if (!value.startDate || !value.endDate) return false;
    return date >= value.startDate && date <= value.endDate;
  };

  // Check if a date is disabled
  const isDisabled = (date: Date): boolean => {
    if (disabled) return true;
    if (minDate && date < minDate) return true;
    if (maxDate && date > maxDate) return true;
    return false;
  };

  // Handle date selection
  const handleDateSelect = (date: Date) => {
    if (isDisabled(date)) return;

    if (selectingStart || !value.startDate) {
      onChange({ startDate: date, endDate: null });
      setSelectingStart(false);
    } else {
      if (date < value.startDate) {
        onChange({ startDate: date, endDate: value.startDate });
      } else {
        onChange({ startDate: value.startDate, endDate: date });
      }
      setSelectingStart(true);
    }
  };

  // Handle preset selection
  const handlePresetSelect = (preset: QuickPreset) => {
    const range = preset.getValue();
    onChange(range);
    setSelectingStart(true);
  };

  // Navigate to previous month
  const goToPreviousMonth = () => {
    setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() - 1));
  };

  // Navigate to next month
  const goToNextMonth = () => {
    setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1));
  };

  // Clear selection
  const clearSelection = () => {
    onChange({ startDate: null, endDate: null });
    setSelectingStart(true);
  };

  return (
    <div ref={containerRef} className={`relative ${className}`}>
      {/* Input Display */}
      <div
        onClick={() => !disabled && setIsOpen(!isOpen)}
        className={`
          flex items-center gap-2 px-3 py-2 border rounded-lg cursor-pointer transition-colors
          ${disabled
            ? 'bg-gray-100 text-gray-400 cursor-not-allowed border-gray-200 dark:bg-gray-800 dark:text-gray-500 dark:border-gray-700'
            : 'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-700 hover:border-gray-400 dark:hover:border-gray-600'
          }
          ${isOpen ? 'ring-2 ring-blue-500 border-blue-500' : ''}
        `}
      >
        <Calendar className="w-5 h-5 text-gray-400" />
        <span className={`flex-1 text-sm ${!value.startDate && !value.endDate ? 'text-gray-500' : 'text-gray-900 dark:text-white'}`}>
          {formatDateRange()}
        </span>
        {(value.startDate || value.endDate) && !disabled && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              clearSelection();
            }}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            <X className="w-4 h-4" />
          </button>
        )}
      </div>

      {/* Dropdown Calendar */}
      {isOpen && (
        <div className="absolute top-full left-0 mt-2 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg z-50 p-4 min-w-80">
          {/* Quick Presets */}
          <div className="mb-4">
            <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">빠른 선택</div>
            <div className="grid grid-cols-3 gap-1">
              {QUICK_PRESETS.map((preset, index) => (
                <button
                  key={index}
                  onClick={() => handlePresetSelect(preset)}
                  className="px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded transition-colors"
                >
                  {preset.label}
                </button>
              ))}
            </div>
          </div>

          {/* Calendar Header */}
          <div className="flex items-center justify-between mb-4">
            <button
              onClick={goToPreviousMonth}
              className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
            >
              <ChevronLeft className="w-5 h-5" />
            </button>
            <div className="text-lg font-semibold text-gray-900 dark:text-white">
              {currentMonth.getFullYear()}년 {KOREAN_MONTHS[currentMonth.getMonth()]}
            </div>
            <button
              onClick={goToNextMonth}
              className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
            >
              <ChevronRight className="w-5 h-5" />
            </button>
          </div>

          {/* Day Headers */}
          <div className="grid grid-cols-7 mb-2">
            {KOREAN_DAYS.map((day, index) => (
              <div key={index} className="text-center text-sm font-medium text-gray-500 py-2">
                {day}
              </div>
            ))}
          </div>

          {/* Calendar Days */}
          <div className="grid grid-cols-7 gap-1">
            {generateCalendarDays().map((date, index) => {
              const isCurrentMonthDay = isCurrentMonth(date);
              const isTodayDay = isToday(date);
              const isSelectedDay = isSelected(date);
              const isInRangeDay = isInRange(date);
              const isDisabledDay = isDisabled(date);

              return (
                <button
                  key={index}
                  onClick={() => handleDateSelect(date)}
                  disabled={isDisabledDay}
                  className={`
                    w-8 h-8 text-sm rounded flex items-center justify-center transition-colors
                    ${!isCurrentMonthDay
                      ? 'text-gray-300 dark:text-gray-600'
                      : 'text-gray-900 dark:text-white'
                    }
                    ${isDisabledDay
                      ? 'cursor-not-allowed opacity-50'
                      : 'cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700'
                    }
                    ${isTodayDay && !isSelectedDay
                      ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300'
                      : ''
                    }
                    ${isSelectedDay
                      ? 'bg-blue-500 text-white'
                      : ''
                    }
                    ${isInRangeDay && !isSelectedDay
                      ? 'bg-blue-100 dark:bg-blue-900'
                      : ''
                    }
                  `}
                >
                  {date.getDate()}
                </button>
              );
            })}
          </div>

          {/* Selection Info */}
          {(value.startDate || value.endDate) && (
            <div className="mt-4 pt-3 border-t border-gray-200 dark:border-gray-700">
              <div className="text-sm text-gray-600 dark:text-gray-400">
                <div>시작일: {value.startDate ? formatDate(value.startDate) : '선택 안됨'}</div>
                <div>종료일: {value.endDate ? formatDate(value.endDate) : '선택 안됨'}</div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```


#### 📄 src\components\demo\ToastDemo.tsx

```typescript
'use client';

import React from 'react';
import { Bell, CheckCircle, XCircle, AlertTriangle, Info, Trash2, Upload, Save, RotateCcw } from 'lucide-react';
import { useToast } from '@/contexts/ToastContext';
import { useToastNotification } from '@/hooks/useToast';

export default function ToastDemo() {
  const toast = useToast();
  const koreanToast = useToastNotification();

  const handleBasicToasts = () => {
    toast.success('성공!', '작업이 성공적으로 완료되었습니다.');

    setTimeout(() => {
      toast.info('정보', '이것은 정보 메시지입니다.');
    }, 500);

    setTimeout(() => {
      toast.warning('경고', '주의가 필요한 상황입니다.');
    }, 1000);

    setTimeout(() => {
      toast.error('오류', '문제가 발생했습니다.');
    }, 1500);
  };

  const handleKoreanToasts = () => {
    koreanToast.저장완료('품목이 저장되었습니다.');

    setTimeout(() => {
      koreanToast.업로드완료('Excel 파일이 업로드되었습니다.');
    }, 500);

    setTimeout(() => {
      koreanToast.경고('중복된 데이터가 있습니다.');
    }, 1000);

    setTimeout(() => {
      koreanToast.연결오류('서버 연결에 실패했습니다.');
    }, 1500);
  };

  const handleActionToasts = () => {
    // Undo delete example
    const deletedItem = '품목 A-001';

    const undoDelete = () => {
      toast.success('실행 취소', `${deletedItem}이(가) 복원되었습니다.`);
    };

    koreanToast.삭제완료_실행취소(
      `${deletedItem}이(가) 삭제되었습니다.`,
      undoDelete
    );

    // View details example
    setTimeout(() => {
      const viewDetails = () => {
        toast.info('상세 정보', '상세 페이지로 이동합니다.');
      };

      koreanToast.저장완료_상세보기(
        '새 품목이 등록되었습니다.',
        viewDetails
      );
    }, 2000);

    // Retry example
    setTimeout(() => {
      const retryUpload = () => {
        toast.info('재시도 중', '파일을 다시 업로드합니다...');
      };

      koreanToast.오류발생_재시도(
        '네트워크 연결이 불안정합니다.',
        retryUpload
      );
    }, 4000);
  };

  const handlePersistentToasts = () => {
    const handleCriticalAction = () => {
      toast.success('처리 완료', '중요한 작업이 완료되었습니다.');
    };

    const dismissAction = () => {
      toast.info('알림 해제', '알림을 확인했습니다.');
    };

    koreanToast.중요알림(
      '시스템 점검이 예정되어 있습니다. 작업을 저장해 주세요.',
      [
        { label: '확인', onClick: handleCriticalAction, style: 'primary' },
        { label: '나중에', onClick: dismissAction, style: 'secondary' }
      ]
    );
  };

  const handleCustomDuration = () => {
    toast.success('짧은 알림', '1초 후 사라집니다.', 1000);

    setTimeout(() => {
      toast.info('긴 알림', '10초 후 사라집니다.', 10000);
    }, 200);
  };

  const handleStressTest = () => {
    // Test maximum toast limit (5)
    for (let i = 1; i <= 8; i++) {
      setTimeout(() => {
        toast.info(`토스트 ${i}`, `${i}번째 토스트 메시지입니다.`);
      }, i * 200);
    }
  };

  return (
    <div className="p-6 bg-white dark:bg-gray-900 rounded-lg shadow-sm">
      <div className="flex items-center gap-3 mb-6">
        <Bell className="w-8 h-8 text-blue-500" />
        <div>
          <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
            Toast 알림 시스템 데모
          </h2>
          <p className="text-gray-600 dark:text-gray-400 mt-1">
            향상된 토스트 알림 기능을 테스트해보세요
          </p>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
        {/* Basic Toasts */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            기본 알림
          </h3>
          <button
            onClick={handleBasicToasts}
            className="w-full flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            <CheckCircle className="w-5 h-5" />
            기본 알림 테스트
          </button>
        </div>

        {/* Korean Methods */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            한국어 편의 메서드
          </h3>
          <button
            onClick={handleKoreanToasts}
            className="w-full flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
          >
            <Save className="w-5 h-5" />
            한국어 알림 테스트
          </button>
        </div>

        {/* Action Toasts */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            액션 버튼 알림
          </h3>
          <button
            onClick={handleActionToasts}
            className="w-full flex items-center gap-2 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors"
          >
            <RotateCcw className="w-5 h-5" />
            액션 알림 테스트
          </button>
        </div>

        {/* Persistent Toasts */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            지속 알림
          </h3>
          <button
            onClick={handlePersistentToasts}
            className="w-full flex items-center gap-2 px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors"
          >
            <AlertTriangle className="w-5 h-5" />
            중요 알림 테스트
          </button>
        </div>

        {/* Custom Duration */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            진행률 표시
          </h3>
          <button
            onClick={handleCustomDuration}
            className="w-full flex items-center gap-2 px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-colors"
          >
            <Upload className="w-5 h-5" />
            진행률 알림 테스트
          </button>
        </div>

        {/* Stacked Toasts */}
        <div className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            스택형 알림
          </h3>
          <button
            onClick={handleStressTest}
            className="w-full flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors"
          >
            <XCircle className="w-5 h-5" />
            다중 알림 테스트
          </button>
        </div>
      </div>

      {/* Individual Toast Tests */}
      <div className="space-y-3 mb-6">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
          개별 토스트 테스트
        </h3>
        <div className="flex gap-2 flex-wrap">
          <button
            onClick={() => toast.success('성공', '작업 완료!')}
            className="flex items-center gap-1.5 px-3 py-1.5 bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300 rounded text-sm hover:bg-green-200 dark:hover:bg-green-800 transition-colors"
          >
            <CheckCircle className="w-4 h-4" />
            성공
          </button>
          <button
            onClick={() => toast.error('오류', '문제 발생!')}
            className="flex items-center gap-1.5 px-3 py-1.5 bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300 rounded text-sm hover:bg-red-200 dark:hover:bg-red-800 transition-colors"
          >
            <XCircle className="w-4 h-4" />
            오류
          </button>
          <button
            onClick={() => toast.warning('경고', '주의 필요!')}
            className="flex items-center gap-1.5 px-3 py-1.5 bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300 rounded text-sm hover:bg-yellow-200 dark:hover:bg-yellow-800 transition-colors"
          >
            <AlertTriangle className="w-4 h-4" />
            경고
          </button>
          <button
            onClick={() => toast.info('정보', '알림 메시지!')}
            className="flex items-center gap-1.5 px-3 py-1.5 bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300 rounded text-sm hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors"
          >
            <Info className="w-4 h-4" />
            정보
          </button>
          <button
            onClick={() => toast.clearToasts()}
            className="flex items-center gap-1.5 px-3 py-1.5 bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300 rounded text-sm hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
          >
            <Trash2 className="w-4 h-4" />
            모두 지우기
          </button>
        </div>
      </div>

      {/* Feature Information */}
      <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
          새로운 기능들
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-600 dark:text-gray-400">
          <div className="space-y-2">
            <h4 className="font-medium text-gray-900 dark:text-white">✨ 향상된 기능</h4>
            <ul className="space-y-1 list-disc list-inside">
              <li>진행률 바 표시 (호버 시 일시정지)</li>
              <li>액션 버튼 지원 (실행취소, 상세보기, 재시도)</li>
              <li>지속 알림 (수동 닫기 필요)</li>
              <li>개선된 스택 애니메이션</li>
              <li>한국어 편의 메서드 확장</li>
            </ul>
          </div>
          <div className="space-y-2">
            <h4 className="font-medium text-gray-900 dark:text-white">🎨 디자인 개선</h4>
            <ul className="space-y-1 list-disc list-inside">
              <li>좌측 컬러 보더로 타입 구분</li>
              <li>호버 시 스택 확장 효과</li>
              <li>백드롭 블러 효과</li>
              <li>다크 모드 최적화</li>
              <li>접근성 향상 (ARIA 라벨)</li>
            </ul>
          </div>
        </div>
      </div>

      {/* Usage Examples */}
      <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
          사용 예제 코드
        </h3>
        <pre className="text-sm text-gray-700 dark:text-gray-300 overflow-x-auto whitespace-pre-wrap">
{`// 기본 사용법
toast.success('성공', '작업이 완료되었습니다.');
toast.error('오류', '문제가 발생했습니다.');

// 한국어 편의 메서드
toast.저장완료('데이터가 저장되었습니다.');
toast.삭제완료('항목이 삭제되었습니다.');

// 액션 버튼과 함께
toast.삭제완료_실행취소(
  '품목이 삭제되었습니다.',
  () => console.log('실행 취소!')
);

// 지속 알림
toast.중요알림('시스템 점검 예정', [
  { label: '확인', onClick: handleOk, style: 'primary' }
]);`}
        </pre>
      </div>
    </div>
  );
}
```


#### 📄 src\components\ExcelExportButton.tsx

```typescript
'use client';

import React, { useState } from 'react';
import { Download, FileSpreadsheet, Loader2 } from 'lucide-react';

interface ExcelExportButtonProps {
  onExport: () => Promise<void> | void;
  data?: any[];
  disabled?: boolean;
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  children?: React.ReactNode;
  tooltip?: string;
  showIcon?: boolean;
  className?: string;
}

export const ExcelExportButton: React.FC<ExcelExportButtonProps> = ({
  onExport,
  data = [],
  disabled = false,
  variant = 'outline',
  size = 'md',
  children,
  tooltip = 'Excel 파일로 내보내기',
  showIcon = true,
  className = ''
}) => {
  const [isExporting, setIsExporting] = useState(false);
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState('');
  const [toastType, setToastType] = useState<'success' | 'error'>('success');

  const showToastMessage = (message: string, type: 'success' | 'error') => {
    setToastMessage(message);
    setToastType(type);
    setShowToast(true);
    setTimeout(() => setShowToast(false), 3000);
  };

  const handleExport = async () => {
    if (disabled || isExporting) return;

    // Check if there's data to export
    if (data.length === 0) {
      showToastMessage('내보낼 데이터가 없습니다.', 'error');
      return;
    }

    setIsExporting(true);

    try {
      await onExport();
      showToastMessage(
        `${data.length}개 항목이 Excel 파일로 내보내기 완료되었습니다.`,
        'success'
      );
    } catch (error) {
      console.error('Excel export failed:', error);
      showToastMessage(
        'Excel 내보내기 중 오류가 발생했습니다.',
        'error'
      );
    } finally {
      setIsExporting(false);
    }
  };

  // Style variants
  const baseStyles = 'inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2';

  const variantStyles = {
    primary: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500 shadow-sm',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500 shadow-sm',
    outline: 'border border-green-600 text-green-600 hover:bg-green-50 focus:ring-green-500 hover:border-green-700'
  };

  const sizeStyles = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-sm',
    lg: 'px-6 py-3 text-base'
  };

  const disabledStyles = 'opacity-50 cursor-not-allowed';

  const buttonClasses = [
    baseStyles,
    variantStyles[variant],
    sizeStyles[size],
    (disabled || isExporting) && disabledStyles,
    className
  ].filter(Boolean).join(' ');

  return (
    <>
      <button
        onClick={handleExport}
        disabled={disabled || isExporting}
        className={buttonClasses}
        title={tooltip}
        aria-label={tooltip}
      >
        {isExporting ? (
          <>
            <Loader2 className="w-4 h-4 animate-spin" />
            내보내는 중...
          </>
        ) : (
          <>
            {showIcon && (
              <FileSpreadsheet className="w-4 h-4" />
            )}
            {children || 'Excel 내보내기'}
          </>
        )}
      </button>

      {/* Toast Notification */}
      {showToast && (
        <div
          className={`fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 ${
            toastType === 'success'
              ? 'bg-green-500 text-white'
              : 'bg-red-500 text-white'
          }`}
          role="alert"
        >
          <div className="flex items-center gap-2">
            {toastType === 'success' ? (
              <Download className="w-5 h-5" />
            ) : (
              <div className="w-5 h-5 rounded-full bg-white/20 flex items-center justify-center">
                <span className="text-sm font-bold">!</span>
              </div>
            )}
            <span className="font-medium">{toastMessage}</span>
          </div>
        </div>
      )}
    </>
  );
};

// Specialized export buttons for different data types
interface ItemsExportButtonProps {
  items: any[];
  filtered?: boolean;
  className?: string;
}

export const ItemsExportButton: React.FC<ItemsExportButtonProps> = ({
  items,
  filtered = false,
  className
}) => {
  const handleExport = async () => {
    try {
      // Use the server-side API endpoint for better Korean character support
      const response = await fetch('/api/export/items');
      if (!response.ok) {
        throw new Error('Export failed');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = response.headers.get('Content-Disposition')?.split('filename=')[1]?.replace(/"/g, '') || '품목목록.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Excel export failed:', error);
      throw error;
    }
  };

  return (
    <ExcelExportButton
      onExport={handleExport}
      data={items}
      tooltip={`품목 목록 Excel 내보내기 (${items.length}개)`}
      className={className}
    >
      품목 내보내기
    </ExcelExportButton>
  );
};

interface CompaniesExportButtonProps {
  companies: any[];
  filtered?: boolean;
  className?: string;
}

export const CompaniesExportButton: React.FC<CompaniesExportButtonProps> = ({
  companies,
  filtered = false,
  className
}) => {
  const handleExport = async () => {
    try {
      // Use the server-side API endpoint for better Korean character support
      const response = await fetch('/api/export/companies');
      if (!response.ok) {
        throw new Error('Export failed');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = response.headers.get('Content-Disposition')?.split('filename=')[1]?.replace(/"/g, '') || '회사목록.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Excel export failed:', error);
      throw error;
    }
  };

  return (
    <ExcelExportButton
      onExport={handleExport}
      data={companies}
      tooltip={`거래처 목록 Excel 내보내기 (${companies.length}개)`}
      className={className}
    >
      거래처 내보내기
    </ExcelExportButton>
  );
};

interface BOMExportButtonProps {
  bomData: any[];
  filtered?: boolean;
  className?: string;
}

export const BOMExportButton: React.FC<BOMExportButtonProps> = ({
  bomData,
  filtered = false,
  className
}) => {
  const handleExport = async () => {
    const { exportBOM } = await import('../utils/excelExport');
    exportBOM(bomData);
  };

  return (
    <ExcelExportButton
      onExport={handleExport}
      data={bomData}
      tooltip={`BOM 목록 Excel 내보내기 (${bomData.length}개)`}
      className={className}
    >
      BOM 내보내기
    </ExcelExportButton>
  );
};

interface TransactionsExportButtonProps {
  transactions: unknown[];
  type?: string;
  className?: string;
}

export const TransactionsExportButton: React.FC<TransactionsExportButtonProps> = ({
  transactions,
  type = '전체',
  className
}) => {
  const handleExport = async () => {
    try {
      // Use the server-side API endpoint for better Korean character support
      const response = await fetch('/api/export/inventory');
      if (!response.ok) {
        throw new Error('Export failed');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = response.headers.get('Content-Disposition')?.split('filename=')[1]?.replace(/"/g, '') || '재고거래.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Excel export failed:', error);
      throw error;
    }
  };

  return (
    <ExcelExportButton
      onExport={handleExport}
      data={transactions}
      tooltip={`${type} 거래내역 Excel 내보내기 (${transactions.length}개)`}
      className={className}
    >
      거래내역 내보내기
    </ExcelExportButton>
  );
};

interface StockExportButtonProps {
  stockData: any[];
  className?: string;
}

export const StockExportButton: React.FC<StockExportButtonProps> = ({
  stockData,
  className
}) => {
  const handleExport = async () => {
    try {
      // Use the server-side API endpoint for better Korean character support
      const response = await fetch('/api/export/stock');
      if (!response.ok) {
        throw new Error('Export failed');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = response.headers.get('Content-Disposition')?.split('filename=')[1]?.replace(/"/g, '') || '재고현황.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Excel export failed:', error);
      throw error;
    }
  };

  return (
    <ExcelExportButton
      onExport={handleExport}
      data={stockData}
      tooltip={`재고 현황 Excel 내보내기 (${stockData.length}개)`}
      className={className}
    >
      재고현황 내보내기
    </ExcelExportButton>
  );
};
```


#### 📄 src\components\ItemForm.tsx

```typescript
'use client';

import { useEffect, useMemo, useState } from 'react';
import { Loader2, Save } from 'lucide-react';
import { useToastNotification } from '@/hooks/useToast';
import type { ItemCategory, ItemTypeCode, MaterialTypeCode } from '@/types/supabase';

interface ItemFormProps {
  item?: Partial<ItemFormValues> | null;
  onSubmit: (payload: Record<string, unknown>) => Promise<void>;
  onCancel: () => void;
}

interface ItemFormValues {
  item_id?: number;
  item_code: string;
  item_name: string;
  category: ItemCategory | '';
  item_type: ItemTypeCode;
  material_type: MaterialTypeCode;
  vehicle_model: string;
  material: string;
  spec: string;
  unit: string;
  thickness: string;
  width: string;
  height: string;
  specific_gravity: string;
  mm_weight: string;
  daily_requirement: string;
  blank_size: string;
  current_stock: string;
  safety_stock: string;
  price: string;
  location: string;
  description: string;
}

const ITEM_CATEGORIES: { value: ItemCategory; label: string }[] = [
  { value: '원자재' as ItemCategory, label: '원자재' },
  { value: '부자재' as ItemCategory, label: '부자재' },
  { value: '반제품' as ItemCategory, label: '반제품' },
  { value: '완제품' as ItemCategory, label: '완제품' },
  { value: '폐제품' as ItemCategory, label: '폐제품' }
];

const ITEM_TYPES: { value: ItemTypeCode; label: string }[] = [
  { value: 'RAW', label: '원자재 (RAW)' },
  { value: 'SUB', label: '부자재 (SUB)' },
  { value: 'FINISHED', label: '완제품 (FINISHED)' }
];

const MATERIAL_TYPES: { value: MaterialTypeCode; label: string }[] = [
  { value: 'COIL', label: 'COIL' },
  { value: 'SHEET', label: 'SHEET' },
  { value: 'OTHER', label: '기타 (OTHER)' }
];

const UNIT_OPTIONS = ['EA', 'SET', 'KG', 'M', 'L', 'BOX', 'MM', 'CM'];

const DEFAULT_VALUES: ItemFormValues = {
  item_code: '',
  item_name: '',
  category: '' as ItemCategory | '',
  item_type: 'RAW',
  material_type: 'OTHER',
  vehicle_model: '',
  material: '',
  spec: '',
  unit: 'EA',
  thickness: '',
  width: '',
  height: '',
  specific_gravity: '7.85',
  mm_weight: '',
  daily_requirement: '',
  blank_size: '',
  current_stock: '',
  safety_stock: '',
  price: '',
  location: '',
  description: ''
};

export default function ItemForm({ item, onSubmit, onCancel }: ItemFormProps) {
  const [formData, setFormData] = useState<ItemFormValues>(DEFAULT_VALUES);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [mmWeightDirty, setMmWeightDirty] = useState(false);
  const toast = useToastNotification();

  useEffect(() => {
    if (!item) {
      setFormData(DEFAULT_VALUES);
      setMmWeightDirty(false);
      return;
    }

    const initialCategory = (item.category as ItemCategory | undefined) ?? (item as any)?.category ?? '';
    const initialValues: ItemFormValues = {
      item_id: item.item_id,
      item_code: item.item_code ?? '',
      item_name: item.item_name ?? (item as any)?.name ?? '',
      category: (initialCategory as ItemCategory) ?? ('' as ItemCategory | ''),
      item_type: (item.item_type as ItemTypeCode) ?? 'RAW',
      material_type: (item.material_type as MaterialTypeCode) ?? 'OTHER',
      vehicle_model: item.vehicle_model ?? '',
      material: item.material ?? '',
      spec: item.spec ?? '',
      unit: item.unit ?? 'EA',
      thickness: toFormValue(item.thickness),
      width: toFormValue(item.width),
      height: toFormValue(item.height),
      specific_gravity: toFormValue(item.specific_gravity, '7.85'),
      mm_weight: toFormValue(item.mm_weight),
      daily_requirement: toFormValue(item.daily_requirement),
      blank_size: toFormValue(item.blank_size),
      current_stock: toFormValue(item.current_stock),
      safety_stock: toFormValue(item.safety_stock ?? (item as any)?.min_stock_level),
      price: toFormValue(item.price ?? (item as any)?.unit_price),
      location: item.location ?? '',
      description: item.description ?? ''
    };

    setFormData(initialValues);
    setMmWeightDirty(Boolean(item?.mm_weight));
  }, [item]);

  useEffect(() => {
    if (mmWeightDirty) return;
    const computed = computeMmWeight(
      parseNumber(formData.thickness),
      parseNumber(formData.width),
      parseNumber(formData.specific_gravity),
      formData.material_type,
      parseNumber(formData.height),
      parseNumber(formData.blank_size)
    );

    if (computed === null) {
      if (formData.mm_weight !== '') {
        setFormData(prev => ({ ...prev, mm_weight: '' }));
      }
      return;
    }

    const formatted = computed.toFixed(4);
    if (formatted !== formData.mm_weight) {
      setFormData(prev => ({ ...prev, mm_weight: formatted }));
    }
  }, [
    formData.thickness,
    formData.width,
    formData.height,
    formData.blank_size,
    formData.specific_gravity,
    formData.material_type,
    mmWeightDirty
  ]);

  const itemTypeOptions = useMemo(() => ITEM_TYPES, []);
  const materialTypeOptions = useMemo(() => MATERIAL_TYPES, []);

  const handleInputChange = (
    event: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = event.target;

    setFormData(prev => ({
      ...prev,
      [name]: value
    }));

    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }

    if (name === 'mm_weight') {
      setMmWeightDirty(true);
    } else if (
      name === 'material_type' ||
      name === 'thickness' ||
      name === 'width' ||
      name === 'specific_gravity' ||
      name === 'height' ||
      name === 'blank_size'
    ) {
      setMmWeightDirty(false);
    }
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    const validation = validate(formData);
    setErrors(validation);

    if (Object.keys(validation).length > 0) {
      toast.입력오류('입력값을 확인해주세요.');
      return;
    }

    setLoading(true);
    try {
      const payload = buildSubmitPayload(formData);
      await onSubmit(payload);
      setMmWeightDirty(false);
      onCancel();
    } catch (error) {
      console.error('Failed to submit item form:', error);
      toast.error('품목 정보를 저장하는 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-8">
      <section>
        <h2 className="text-sm font-semibold text-gray-700 dark:text-gray-200 mb-4">기본 정보</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <FormField
            label="품목 코드"
            name="item_code"
            value={formData.item_code}
            onChange={handleInputChange}
            error={errors.item_code}
            placeholder="예: ITEM-001"
            required
          />
          <FormField
            label="품목명"
            name="item_name"
            value={formData.item_name}
            onChange={handleInputChange}
            error={errors.item_name}
            placeholder="예: 프레스 강판"
            required
          />
          <FormSelect
            label="품목 분류"
            name="category"
            value={formData.category}
            onChange={handleInputChange}
            options={ITEM_CATEGORIES}
            placeholder="분류 선택"
            error={errors.category}
            required
          />
          <FormSelect
            label="품목 타입"
            name="item_type"
            value={formData.item_type}
            onChange={handleInputChange}
            options={itemTypeOptions}
          />
          <FormSelect
            label="소재 형태"
            name="material_type"
            value={formData.material_type}
            onChange={handleInputChange}
            options={materialTypeOptions}
          />
          <FormField
            label="차종"
            name="vehicle_model"
            value={formData.vehicle_model}
            onChange={handleInputChange}
            error={errors.vehicle_model}
            placeholder="예: EV6"
          />
          <FormField
            label="소재/강종"
            name="material"
            value={formData.material}
            onChange={handleInputChange}
            error={errors.material}
            placeholder="예: SPHC"
          />
          <FormField
            label="규격/사양"
            name="spec"
            value={formData.spec}
            onChange={handleInputChange}
            error={errors.spec}
            placeholder="예: 0.8T x 1200"
          />
        </div>
      </section>

      <section>
        <h2 className="text-sm font-semibold text-gray-700 dark:text-gray-200 mb-4">치수 및 물성</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <FormNumber
            label="두께 (mm)"
            name="thickness"
            value={formData.thickness}
            onChange={handleInputChange}
            error={errors.thickness}
            min={0}
            step="0.01"
          />
          <FormNumber
            label="폭 (mm)"
            name="width"
            value={formData.width}
            onChange={handleInputChange}
            error={errors.width}
            min={0}
            step="0.01"
          />
          <FormNumber
            label="길이 (mm)"
            name="height"
            value={formData.height}
            onChange={handleInputChange}
            error={errors.height}
            min={0}
            step="0.01"
          />
          <FormNumber
            label="비중"
            name="specific_gravity"
            value={formData.specific_gravity}
            onChange={handleInputChange}
            error={errors.specific_gravity}
            min={0}
            step="0.01"
          />
          <FormNumber
            label="단위중량 (kg)"
            name="mm_weight"
            value={formData.mm_weight}
            onChange={handleInputChange}
            error={errors.mm_weight}
            min={0}
            step="0.0001"
            helperText="두께·폭·비중에 따라 자동 계산됩니다. 값을 직접 입력하면 수동 모드로 전환됩니다."
          />
          <FormNumber
            label="일일 소요량"
            name="daily_requirement"
            value={formData.daily_requirement}
            onChange={handleInputChange}
            error={errors.daily_requirement}
            min={0}
            step="1"
          />
          <FormNumber
            label="블랭크 사이즈"
            name="blank_size"
            value={formData.blank_size}
            onChange={handleInputChange}
            error={errors.blank_size}
            min={0}
            step="1"
          />
        </div>
      </section>

      <section>
        <h2 className="text-sm font-semibold text-gray-700 dark:text-gray-200 mb-4">재고 및 단가</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <FormSelect
            label="단위"
            name="unit"
            value={formData.unit}
            onChange={handleInputChange}
            options={UNIT_OPTIONS.map(value => ({ value, label: value }))}
            error={errors.unit}
            required
          />
          <FormNumber
            label="현재고"
            name="current_stock"
            value={formData.current_stock}
            onChange={handleInputChange}
            error={errors.current_stock}
            min={0}
            step="1"
          />
          <FormNumber
            label="안전재고"
            name="safety_stock"
            value={formData.safety_stock}
            onChange={handleInputChange}
            error={errors.safety_stock}
            min={0}
            step="1"
          />
          <FormNumber
            label="기준단가"
            name="price"
            value={formData.price}
            onChange={handleInputChange}
            error={errors.price}
            min={0}
            step="0.01"
            prefix="₩"
          />
          <FormField
            label="보관 위치"
            name="location"
            value={formData.location}
            onChange={handleInputChange}
            error={errors.location}
            placeholder="예: A-01-01"
          />
          <FormTextArea
            label="비고"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            error={errors.description}
            rows={3}
            placeholder="추가 메모를 입력하세요."
            className="md:col-span-3"
          />
        </div>
      </section>

      <div className="flex justify-end gap-4 border-t border-gray-200 dark:border-gray-700 pt-6">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading}
          className="flex items-center gap-2 px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              저장 중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              {item ? '수정' : '등록'}
            </>
          )}
        </button>
      </div>
    </form>
  );
}

function toFormValue(value: unknown, fallback = ''): string {
  if (value === null || value === undefined) {
    return fallback;
  }
  const numeric = Number(value);
  if (Number.isFinite(numeric)) {
    return String(numeric);
  }
  return String(value);
}

function parseNumber(value: string): number | null {
  if (value === '') return null;
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : null;
}

function computeMmWeight(
  thickness: number | null,
  width: number | null,
  density: number | null,
  materialType: MaterialTypeCode,
  height: number | null,
  blankSize: number | null
): number | null {
  if (thickness === null || width === null) {
    return null;
  }

  const safeDensity = density && density > 0 ? density : 7.85;
  if (safeDensity <= 0 || thickness <= 0 || width <= 0) {
    return null;
  }

  const thicknessCm = thickness / 10;
  const widthCm = width / 10;
  const rawLength = blankSize && blankSize > 0 ? blankSize : height && height > 0 ? height : null;
  const lengthCm = rawLength ? rawLength / 10 : 100; // 기본 1m 기준
  const volumeCm3 = thicknessCm * widthCm * lengthCm;
  const weightKg = (volumeCm3 * safeDensity) / 1000;
  return Number.isFinite(weightKg) ? weightKg : null;
}

function buildSubmitPayload(formData: ItemFormValues): Record<string, unknown> {
  return {
    item_id: formData.item_id,
    item_code: formData.item_code.trim(),
    item_name: formData.item_name.trim(),
    category: formData.category || null,
    unit: formData.unit.trim(),
    item_type: formData.item_type,
    material_type: formData.material_type,
    vehicle_model: formData.vehicle_model.trim() || null,
    material: formData.material.trim() || null,
    spec: formData.spec.trim() || null,
    thickness: parseNumber(formData.thickness),
    width: parseNumber(formData.width),
    height: parseNumber(formData.height),
    specific_gravity: parseNumber(formData.specific_gravity),
    mm_weight: parseNumber(formData.mm_weight),
    daily_requirement: parseNumber(formData.daily_requirement),
    blank_size: parseNumber(formData.blank_size),
    current_stock: parseNumber(formData.current_stock),
    safety_stock: parseNumber(formData.safety_stock),
    price: parseNumber(formData.price),
    location: formData.location.trim() || null,
    description: formData.description.trim() || null,
  };
}

function validate(formData: ItemFormValues): Record<string, string> {
  const errors: Record<string, string> = {};

  if (!formData.item_code.trim()) {
    errors.item_code = '품목 코드를 입력해주세요.';
  }

  if (!formData.item_name.trim()) {
    errors.item_name = '품목명을 입력해주세요.';
  }

  if (!formData.category) {
    errors.category = '품목 분류를 선택해주세요.';
  }

  if (!formData.unit.trim()) {
    errors.unit = '단위를 입력해주세요.';
  }

  const numericFields: Array<{ name: keyof ItemFormValues; label: string; allowZero?: boolean }> = [
    { name: 'thickness', label: '두께' },
    { name: 'width', label: '폭' },
    { name: 'height', label: '길이' },
    { name: 'specific_gravity', label: '비중' },
    { name: 'mm_weight', label: '단위중량', allowZero: true },
    { name: 'daily_requirement', label: '일일 소요량', allowZero: true },
    { name: 'blank_size', label: '블랭크 사이즈', allowZero: true },
    { name: 'current_stock', label: '현재고', allowZero: true },
    { name: 'safety_stock', label: '안전재고', allowZero: true },
    { name: 'price', label: '기준단가', allowZero: true }
  ];

  numericFields.forEach(({ name, label, allowZero }) => {
    const value = formData[name];
    if (value === '') return;
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || (!allowZero && numeric <= 0) || (allowZero && numeric < 0)) {
      errors[name as string] = ${label} 값이 올바르지 않습니다.;
    }
  });

  return errors;
}

type FormFieldProps = {
  label: string;
  name: string;
  value: string;
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  error?: string;
  placeholder?: string;
  required?: boolean;
};

function FormField({ label, name, value, onChange, error, placeholder, required }: FormFieldProps) {
  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        {label} {required && <span className="text-red-500">*</span>}
      </label>
      <input
        type="text"
        name={name}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        className={w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 }
      />
      {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
    </div>
  );
}

type FormNumberProps = FormFieldProps & {
  min?: number;
  step?: string;
  prefix?: string;
  helperText?: string;
};

function FormNumber({ label, name, value, onChange, error, placeholder, min, step, prefix, helperText }: FormNumberProps) {
  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        {label}
      </label>
      <div className="relative">
        {prefix && (
          <span className="absolute left-3 top-1/2 -translate-y-1/2 text-sm text-gray-500">{prefix}</span>
        )}
        <input
          type="number"
          name={name}
          value={value}
          onChange={onChange}
          placeholder={placeholder}
          min={min}
          step={step}
          className={w-full px-4 py-2  border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 }
        />
      </div>
      {helperText && <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">{helperText}</p>}
      {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
    </div>
  );
}

type FormSelectProps = {
  label: string;
  name: string;
  value: string | ItemCategory | ItemTypeCode | MaterialTypeCode;
  onChange: (event: React.ChangeEvent<HTMLSelectElement>) => void;
  options: { value: string; label: string }[];
  placeholder?: string;
  error?: string;
  required?: boolean;
};

function FormSelect({ label, name, value, onChange, options, placeholder, error, required }: FormSelectProps) {
  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        {label} {required && <span className="text-red-500">*</span>}
      </label>
      <select
        name={name}
        value={value}
        onChange={onChange}
        className={w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 }
      >
        {placeholder && <option value="">{placeholder}</option>}
        {options.map(option => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
      {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
    </div>
  );
}

type FormTextAreaProps = {
  label: string;
  name: string;
  value: string;
  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  error?: string;
  placeholder?: string;
  rows?: number;
  className?: string;
};

function FormTextArea({ label, name, value, onChange, error, placeholder, rows = 4, className }: FormTextAreaProps) {
  return (
    <div className={className}>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        {label}
      </label>
      <textarea
        name={name}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        rows={rows}
        className={w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 }
      />
      {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
    </div>
  );
}

```


#### 📄 src\components\ItemSelect.tsx

```typescript
'use client';

import { useState, useEffect, useRef } from 'react';
import { Search, Package, Loader2, AlertCircle } from 'lucide-react';
import { ItemForComponent as Item } from '@/types/inventory';
import type { ItemTypeCode } from '@/types/supabase';

export interface ItemSelectProps {
  value?: number;
  onChange: (item: Item | null) => void;
  placeholder?: string;
  label?: string;
  required?: boolean;
  error?: string;
  disabled?: boolean;
  className?: string;
  showPrice?: boolean;
  itemType?: 'ALL' | ItemTypeCode;
}

interface ApiSuccessResponse {
  success: true;
  data: {
    items: Item[];
    pagination?: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasMore: boolean;
    };
  };
}

interface ApiErrorResponse {
  success: false;
  error?: string;
}

type ApiResponse = ApiSuccessResponse | ApiErrorResponse;

export default function ItemSelect({
  value,
  onChange,
  placeholder = "품번 또는 품명으로 검색...",
  label = "품목",
  required = false,
  error,
  disabled = false,
  className = "",
  showPrice = true,
  itemType = 'ALL'
}: ItemSelectProps) {
  const [search, setSearch] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState<Item[]>([]);
  const [filteredItems, setFilteredItems] = useState<Item[]>([]);
  const [selectedItem, setSelectedItem] = useState<Item | null>(null);
  const [loading, setLoading] = useState(false);
  const [loadError, setLoadError] = useState('');

  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Fetch items from API
  useEffect(() => {
    fetchItems();
  }, [itemType]);

  // Handle search filtering
  useEffect(() => {
    if (search.trim()) {
      const filtered = items.filter(item =>
        item.item_code.toLowerCase().includes(search.toLowerCase()) ||
        item.item_name.toLowerCase().includes(search.toLowerCase())
      );
      setFilteredItems(filtered.slice(0, 10)); // Limit to 10 results for performance
      setIsOpen(true);
    } else {
      setFilteredItems([]);
      setIsOpen(false);
    }
  }, [search, items]);

  // Handle click outside to close dropdown
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Update search when value changes externally
  useEffect(() => {
    if (value && items.length > 0) {
      const item = items.find(item => item.item_id === value);
      if (item) {
        setSelectedItem(item);
        setSearch(`${item.item_code} - ${item.item_name}`);
      }
    } else if (!value) {
      setSelectedItem(null);
      setSearch('');
    }
  }, [value, items]);

  const fetchItems = async () => {
    setLoading(true);
    setLoadError('');

    try {
      let url = '/api/items';
      if (itemType !== 'ALL') {
        url += `?type=${itemType}`;
      }

      const response = await fetch(url);
      const data: ApiResponse = await response.json();

      if (data.success && data.data && data.data.data) {
        // Transform data to match ItemForComponent interface
        const transformedItems: Item[] = data.data.data.map(item => ({
          ...item,
          item_id: item.item_id || item.id,
          item_name: item.item_name || item.name,
          unit_price: item.unit_price || 0
        }));

        setItems(transformedItems);
      } else {
        throw new Error(data.error || '품목 목록을 불러오는데 실패했습니다.');
      }
    } catch (error) {
      console.error('Failed to fetch items:', error);
      setLoadError(error instanceof Error ? error.message : '품목 목록을 불러오는데 실패했습니다.');
      setItems([]);
    } finally {
      setLoading(false);
    }
  };

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newSearch = e.target.value;
    setSearch(newSearch);

    // Clear selection if search is cleared
    if (!newSearch) {
      setSelectedItem(null);
      onChange(null);
    }
  };

  const handleItemSelect = (item: Item) => {
    setSelectedItem(item);
    setSearch(`${item.item_code} - ${item.item_name}`);
    setIsOpen(false);
    onChange(item);
  };

  const handleInputFocus = () => {
    if (search && filteredItems.length > 0) {
      setIsOpen(true);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Escape') {
      setIsOpen(false);
    } else if (e.key === 'ArrowDown' && filteredItems.length > 0) {
      e.preventDefault();
      setIsOpen(true);
    } else if (e.key === 'Enter' && isOpen && filteredItems.length === 1) {
      e.preventDefault();
      handleItemSelect(filteredItems[0]);
    }
  };

  const handleRefresh = () => {
    fetchItems();
  };

  return (
    <div className={`relative ${className}`}>
      {/* Label */}
      {label && (
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          <Package className="w-4 h-4 inline mr-2" />
          {label} {required && <span className="text-red-500">*</span>}
        </label>
      )}

      {/* Search Input */}
      <div className="relative" ref={dropdownRef}>
        <input
          ref={inputRef}
          type="text"
          value={search}
          onChange={handleSearchChange}
          onFocus={handleInputFocus}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={disabled || loading}
          className={`w-full px-4 py-2 pl-10 pr-10 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed ${
            error ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
          }`}
        />

        {/* Search Icon */}
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />

        {/* Loading/Refresh Button */}
        <button
          type="button"
          onClick={handleRefresh}
          disabled={loading}
          className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 disabled:cursor-not-allowed"
          title="품목 목록 새로고침"
        >
          {loading ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <Package className="w-4 h-4" />
          )}
        </button>
      </div>

      {/* Error Message */}
      {(error || loadError) && (
        <div className="mt-1 flex items-center gap-1 text-sm text-red-500">
          <AlertCircle className="w-3 h-3" />
          <span>{error || loadError}</span>
        </div>
      )}

      {/* Loading State */}
      {loading && !items.length && (
        <div className="mt-2 text-sm text-gray-500 flex items-center gap-2">
          <Loader2 className="w-4 h-4 animate-spin" />
          품목 목록을 불러오는 중...
        </div>
      )}

      {/* Dropdown */}
      {isOpen && filteredItems.length > 0 && !disabled && (
        <div className="absolute z-[9999] w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-y-auto">
          {filteredItems.map(item => (
            <button
              key={item.item_id}
              type="button"
              onMouseDown={(e) => {
                e.preventDefault();
                e.stopPropagation();
                handleItemSelect(item);
              }}
              className="w-full px-4 py-3 text-left hover:bg-gray-50 dark:hover:bg-gray-700 border-b border-gray-200 dark:border-gray-600 last:border-b-0 focus:outline-none focus:bg-gray-50 dark:focus:bg-gray-700"
            >
              <div className="flex justify-between items-start">
                <div className="flex-1 min-w-0">
                  <div className="text-sm font-medium text-gray-900 dark:text-white truncate">
                    {item.item_code}
                  </div>
                  <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
                    {item.item_name}
                  </div>
                </div>
                <div className="text-right ml-2 flex-shrink-0">
                  <div className="text-sm text-gray-500 dark:text-gray-400">
                    {item.unit}
                  </div>
                  {showPrice && (
                    <div className="text-sm font-medium text-gray-900 dark:text-white">
                      ₩{item.unit_price?.toLocaleString() || 0}
                    </div>
                  )}
                </div>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* No Results */}
      {isOpen && search && filteredItems.length === 0 && !loading && (
        <div className="absolute z-[9999] w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg">
          <div className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400 text-center">
            검색 결과가 없습니다.
          </div>
        </div>
      )}

      {/* Selected Item Info */}
      {selectedItem && !isOpen && (
        <div className="mt-1 text-xs text-gray-500 dark:text-gray-400">
          선택된 품목: {selectedItem.item_code} - {selectedItem.item_name}
          {showPrice && ` (₩${selectedItem.unit_price?.toLocaleString() || 0})`}
        </div>
      )}
    </div>
  );
}
```


#### 📄 src\components\layout\Header.tsx

```typescript
'use client';

import { useState } from 'react';
import { Menu, Moon, Sun, User, Bell, Settings } from 'lucide-react';

interface HeaderProps {
  toggleSidebar: () => void;
  isDarkMode: boolean;
  toggleDarkMode: () => void;
}

export default function Header({ toggleSidebar, isDarkMode, toggleDarkMode }: HeaderProps) {
  const [showUserMenu, setShowUserMenu] = useState(false);

  return (
    <header className="sticky top-0 z-50 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700">
      <div className="flex items-center justify-between h-16 px-4 md:px-6">
        {/* Left side */}
        <div className="flex items-center gap-4">
          <button
            onClick={toggleSidebar}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            aria-label="Toggle sidebar"
          >
            <Menu className="w-5 h-5 text-gray-600 dark:text-gray-400" />
          </button>

          <div className="flex items-center gap-2">
            <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
              <span className="text-white font-bold text-sm">TC</span>
            </div>
            <h1 className="text-xl font-bold text-gray-900 dark:text-white">
              태창 ERP
            </h1>
          </div>
        </div>

        {/* Right side */}
        <div className="flex items-center gap-2">
          {/* Notifications */}
          <button
            className="relative p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            aria-label="Notifications"
          >
            <Bell className="w-5 h-5 text-gray-600 dark:text-gray-400" />
            <span className="absolute top-1 right-1 w-2 h-2 bg-red-500 rounded-full"></span>
          </button>

          {/* Settings */}
          <button
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            aria-label="Settings"
          >
            <Settings className="w-5 h-5 text-gray-600 dark:text-gray-400" />
          </button>

          {/* Dark Mode Toggle */}
          <button
            onClick={toggleDarkMode}
            className="relative p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-200 hover:scale-105 active:scale-95"
            aria-label={isDarkMode ? "Switch to light mode" : "Switch to dark mode"}
            title={isDarkMode ? "라이트 모드로 전환" : "다크 모드로 전환"}
          >
            <div className="relative">
              {isDarkMode ? (
                <Sun className="w-5 h-5 text-yellow-500 dark:text-yellow-400 transition-all duration-200 animate-pulse" />
              ) : (
                <Moon className="w-5 h-5 text-gray-600 dark:text-gray-400 transition-all duration-200" />
              )}
            </div>
          </button>

          {/* User Menu */}
          <div className="relative">
            <button
              onClick={() => setShowUserMenu(!showUserMenu)}
              className="flex items-center gap-2 p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            >
              <div className="w-8 h-8 bg-gray-300 dark:bg-gray-700 rounded-full flex items-center justify-center">
                <User className="w-5 h-5 text-gray-600 dark:text-gray-400" />
              </div>
              <span className="hidden md:block text-sm font-medium text-gray-700 dark:text-gray-300">
                관리자
              </span>
            </button>

            {showUserMenu && (
              <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 py-1">
                <a
                  href="#"
                  className="block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                >
                  프로필
                </a>
                <a
                  href="#"
                  className="block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                >
                  설정
                </a>
                <hr className="my-1 border-gray-200 dark:border-gray-700" />
                <a
                  href="#"
                  className="block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                >
                  로그아웃
                </a>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}
```


#### 📄 src\components\layout\MainLayout.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import Header from './Header';
import Sidebar from './Sidebar';

interface MainLayoutProps {
  children: React.ReactNode;
}

export default function MainLayout({ children }: MainLayoutProps) {
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const [isDarkMode, setIsDarkMode] = useState(false);

  // Load dark mode preference on mount
  useEffect(() => {
    // Add preload class to prevent transition flashing during initial load
    document.body.classList.add('preload');

    const savedDarkMode = localStorage.getItem('darkMode') === 'true';
    setIsDarkMode(savedDarkMode);
    if (savedDarkMode) {
      document.documentElement.classList.add('dark');
    }

    // Remove preload class after a short delay to enable transitions
    setTimeout(() => {
      document.body.classList.remove('preload');
    }, 100);
  }, []);

  // Handle responsive sidebar
  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth < 1024) {
        setIsSidebarOpen(false);
      } else {
        setIsSidebarOpen(true);
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const toggleSidebar = () => {
    setIsSidebarOpen(!isSidebarOpen);
  };

  const toggleDarkMode = () => {
    const newDarkMode = !isDarkMode;
    setIsDarkMode(newDarkMode);
    localStorage.setItem('darkMode', String(newDarkMode));

    if (newDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-950">
      <Header
        toggleSidebar={toggleSidebar}
        isDarkMode={isDarkMode}
        toggleDarkMode={toggleDarkMode}
      />

      <Sidebar
        isOpen={isSidebarOpen}
        toggleSidebar={toggleSidebar}
      />

      <main
        className={`pt-4 px-4 md:px-6 transition-all duration-300 ${
          isSidebarOpen ? 'lg:ml-64' : 'lg:ml-16'
        }`}
      >
        <div>
          {children}
        </div>
      </main>
    </div>
  );
}
```


#### 📄 src\components\layout\Sidebar.tsx

```typescript
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import {
  Home,
  Package,
  Database,
  BarChart3,
  ChevronDown,
  ChevronRight,
  Box,
  Users,
  FileText,
  Settings,
  Layers,
  Truck,
  ClipboardList,
  Monitor,
  Activity
} from 'lucide-react';

interface SidebarProps {
  isOpen: boolean;
  toggleSidebar: () => void;
}

interface MenuItem {
  id: string;
  title: string;
  icon: React.ReactNode;
  href?: string;
  children?: MenuItem[];
}

const menuItems: MenuItem[] = [
  {
    id: 'dashboard',
    title: '대시보드',
    icon: <Home className="w-5 h-5" />,
    href: '/'
  },
  {
    id: 'master',
    title: '기준정보',
    icon: <Database className="w-5 h-5" />,
    children: [
      {
        id: 'items',
        title: '품목관리',
        icon: <Package className="w-5 h-5" />,
        href: '/master/items'
      },
      {
        id: 'companies',
        title: '거래처관리',
        icon: <Users className="w-5 h-5" />,
        href: '/master/companies'
      },
      {
        id: 'bom',
        title: 'BOM관리',
        icon: <Layers className="w-5 h-5" />,
        href: '/master/bom'
      }
    ]
  },
  {
    id: 'inventory',
    title: '재고관리',
    icon: <Box className="w-5 h-5" />,
    children: [
      {
        id: 'in',
        title: '입고관리',
        icon: <Truck className="w-5 h-5" />,
        href: '/inventory?tab=receiving'
      },
      {
        id: 'production',
        title: '생산관리',
        icon: <Package className="w-5 h-5" />,
        href: '/inventory?tab=production'
      },
      {
        id: 'out',
        title: '출고관리',
        icon: <Truck className="w-5 h-5" />,
        href: '/inventory?tab=shipping'
      }
    ]
  },
  {
    id: 'stock',
    title: '재고현황',
    icon: <BarChart3 className="w-5 h-5" />,
    children: [
      {
        id: 'current',
        title: '현재고조회',
        icon: <FileText className="w-5 h-5" />,
        href: '/stock/current'
      },
      {
        id: 'history',
        title: '재고이력',
        icon: <FileText className="w-5 h-5" />,
        href: '/stock/history'
      },
      {
        id: 'reports',
        title: '재고보고서',
        icon: <FileText className="w-5 h-5" />,
        href: '/stock/reports'
      }
    ]
  },
  {
    id: 'monitoring',
    title: '시스템 모니터링',
    icon: <Monitor className="w-5 h-5" />,
    children: [
      {
        id: 'dashboard',
        title: '모니터링 대시보드',
        icon: <Activity className="w-5 h-5" />,
        href: '/monitoring'
      },
      {
        id: 'health',
        title: '헬스체크',
        icon: <Settings className="w-5 h-5" />,
        href: '/monitoring/health'
      }
    ]
  }
];

export default function Sidebar({ isOpen, toggleSidebar }: SidebarProps) {
  const pathname = usePathname();
  const [expandedItems, setExpandedItems] = useState<string[]>(['master', 'inventory', 'stock', 'monitoring']);

  const toggleExpand = (itemId: string) => {
    setExpandedItems(prev =>
      prev.includes(itemId)
        ? prev.filter(id => id !== itemId)
        : [...prev, itemId]
    );
  };

  const renderMenuItem = (item: MenuItem, depth = 0) => {
    // Check if the current path matches the menu item
    // Handle both exact matches and URL parameter matches for inventory
    const isActive = item.href && (
      pathname === item.href ||
      (pathname === '/inventory' && item.href.startsWith('/inventory?'))
    );
    const isExpanded = expandedItems.includes(item.id);
    const hasChildren = item.children && item.children.length > 0;

    return (
      <div key={item.id}>
        {item.href ? (
          <Link
            href={item.href}
            className={`flex items-center gap-3 px-4 py-2.5 text-sm font-medium transition-colors ${
              depth > 0 ? 'pl-12' : ''
            } ${
              isActive
                ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400 border-l-4 border-blue-600'
                : 'text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 border-l-4 border-transparent'
            }`}
          >
            {item.icon}
            <span className={`${!isOpen && 'hidden'}`}>{item.title}</span>
          </Link>
        ) : (
          <button
            onClick={() => hasChildren && toggleExpand(item.id)}
            className={`w-full flex items-center gap-3 px-4 py-2.5 text-sm font-medium transition-colors ${
              depth > 0 ? 'pl-12' : ''
            } text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800`}
          >
            {item.icon}
            <span className={`flex-1 text-left ${!isOpen && 'hidden'}`}>
              {item.title}
            </span>
            {hasChildren && isOpen && (
              <span className="ml-auto">
                {isExpanded ? (
                  <ChevronDown className="w-4 h-4" />
                ) : (
                  <ChevronRight className="w-4 h-4" />
                )}
              </span>
            )}
          </button>
        )}

        {hasChildren && isExpanded && isOpen && (
          <div className="bg-gray-50 dark:bg-gray-800/50">
            {item.children!.map(child => renderMenuItem(child, depth + 1))}
          </div>
        )}
      </div>
    );
  };

  return (
    <>
      {/* Mobile overlay */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden"
          onClick={toggleSidebar}
        />
      )}

      {/* Sidebar */}
      <aside
        className={`fixed left-0 top-16 h-[calc(100vh-4rem)] bg-white dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700 transition-all duration-300 z-40 ${
          isOpen ? 'w-64' : 'w-16'
        }`}
      >
        <div className="h-full flex flex-col">
          {/* Navigation */}
          <nav className="flex-1 overflow-y-auto py-4">
            {menuItems.map(item => renderMenuItem(item))}
          </nav>

          {/* Bottom section */}
          <div className="border-t border-gray-200 dark:border-gray-700 p-4">
            <button
              className="flex items-center gap-3 w-full px-4 py-2.5 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 rounded-lg transition-colors"
            >
              <Settings className="w-5 h-5" />
              <span className={`${!isOpen && 'hidden'}`}>설정</span>
            </button>
          </div>
        </div>
      </aside>
    </>
  );
}
```


#### 📄 src\components\Modal.tsx

```typescript
'use client';

import { useEffect } from 'react';
import { X } from 'lucide-react';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl';
}

export default function Modal({
  isOpen,
  onClose,
  title,
  children,
  size = 'md'
}: ModalProps) {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  if (!isOpen) return null;

  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-2xl',
    lg: 'max-w-4xl',
    xl: 'max-w-6xl'
  };

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex min-h-full items-center justify-center p-4">
        {/* Backdrop */}
        <div
          className="fixed inset-0 bg-black bg-opacity-50 transition-opacity"
          onClick={onClose}
        />

        {/* Modal */}
        <div
          className={`relative bg-white dark:bg-gray-900 rounded-lg shadow-xl w-full ${sizeClasses[size]} transform transition-all`}
        >
          {/* Header */}
          <div className="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
            {title && (
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
                {title}
              </h2>
            )}
            <button
              onClick={onClose}
              className="ml-auto text-gray-400 hover:text-gray-500 dark:hover:text-gray-300"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Content */}
          <div className="p-6">{children}</div>
        </div>
      </div>
    </div>
  );
}
```


#### 📄 src\components\PrintButton.tsx

```typescript
'use client';

import React, { useState } from 'react';
import { Printer, Download, Settings, Eye } from 'lucide-react';
import {
  printTable,
  printWithPreview,
  PrintOptions,
  TableColumn
} from '@/utils/printUtils';

interface PrintButtonProps {
  data: Record<string, any>[];
  columns: TableColumn[];
  title?: string;
  subtitle?: string;
  variant?: 'default' | 'icon' | 'text';
  size?: 'sm' | 'md' | 'lg';
  showPreview?: boolean;
  showOptions?: boolean;
  orientation?: 'portrait' | 'landscape';
  className?: string;
  disabled?: boolean;
  children?: React.ReactNode;
  onPrintStart?: () => void;
  onPrintComplete?: () => void;
  onError?: (error: Error) => void;
}

interface PrintOptionsModalProps {
  isOpen: boolean;
  onClose: () => void;
  onPrint: (options: PrintOptions) => void;
  currentOptions: PrintOptions;
}

/**
 * 인쇄 옵션 모달
 */
function PrintOptionsModal({ isOpen, onClose, onPrint, currentOptions }: PrintOptionsModalProps) {
  const [options, setOptions] = useState<PrintOptions>(currentOptions);

  if (!isOpen) return null;

  const handlePrint = () => {
    onPrint(options);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            인쇄 옵션
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            ✕
          </button>
        </div>

        <div className="space-y-4">
          {/* 용지 방향 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              용지 방향
            </label>
            <div className="flex gap-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="orientation"
                  value="portrait"
                  checked={options.orientation === 'portrait'}
                  onChange={(e) => setOptions({ ...options, orientation: e.target.value as 'portrait' })}
                  className="mr-2"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">세로</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  name="orientation"
                  value="landscape"
                  checked={options.orientation === 'landscape'}
                  onChange={(e) => setOptions({ ...options, orientation: e.target.value as 'landscape' })}
                  className="mr-2"
                />
                <span className="text-sm text-gray-700 dark:text-gray-300">가로</span>
              </label>
            </div>
          </div>

          {/* 용지 크기 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              용지 크기
            </label>
            <select
              value={options.pageSize || 'A4'}
              onChange={(e) => setOptions({ ...options, pageSize: e.target.value as 'A4' | 'A3' })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="A4">A4</option>
              <option value="A3">A3</option>
            </select>
          </div>

          {/* 헤더/푸터 옵션 */}
          <div className="space-y-2">
            <label className="flex items-center">
              <input
                type="checkbox"
                checked={options.includeHeader !== false}
                onChange={(e) => setOptions({ ...options, includeHeader: e.target.checked })}
                className="mr-2"
              />
              <span className="text-sm text-gray-700 dark:text-gray-300">
                회사 정보 헤더 포함
              </span>
            </label>
            <label className="flex items-center">
              <input
                type="checkbox"
                checked={options.includeFooter !== false}
                onChange={(e) => setOptions({ ...options, includeFooter: e.target.checked })}
                className="mr-2"
              />
              <span className="text-sm text-gray-700 dark:text-gray-300">
                페이지 번호 푸터 포함
              </span>
            </label>
            <label className="flex items-center">
              <input
                type="checkbox"
                checked={options.showPageNumbers !== false}
                onChange={(e) => setOptions({ ...options, showPageNumbers: e.target.checked })}
                className="mr-2"
              />
              <span className="text-sm text-gray-700 dark:text-gray-300">
                페이지 번호 표시
              </span>
            </label>
          </div>

          {/* 제목 및 부제목 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              보고서 제목
            </label>
            <input
              type="text"
              value={options.title || ''}
              onChange={(e) => setOptions({ ...options, title: e.target.value })}
              placeholder="보고서 제목을 입력하세요"
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              부제목 (선택)
            </label>
            <input
              type="text"
              value={options.subtitle || ''}
              onChange={(e) => setOptions({ ...options, subtitle: e.target.value })}
              placeholder="부제목을 입력하세요"
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
        </div>

        {/* 버튼 */}
        <div className="flex gap-3 mt-6">
          <button
            onClick={handlePrint}
            className="flex-1 flex items-center justify-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            <Printer className="w-4 h-4" />
            인쇄
          </button>
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
          >
            취소
          </button>
        </div>
      </div>
    </div>
  );
}

/**
 * 인쇄 버튼 컴포넌트
 */
export default function PrintButton({
  data,
  columns,
  title = '데이터 목록',
  subtitle,
  variant = 'default',
  size = 'md',
  showPreview = false,
  showOptions = true,
  orientation = 'landscape',
  className = '',
  disabled = false,
  children,
  onPrintStart,
  onPrintComplete,
  onError
}: PrintButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [showOptionsModal, setShowOptionsModal] = useState(false);

  const defaultOptions: PrintOptions = {
    orientation,
    pageSize: 'A4',
    includeHeader: true,
    includeFooter: true,
    showPageNumbers: true,
    title,
    subtitle
  };

  const getSizeClasses = () => {
    switch (size) {
      case 'sm':
        return 'px-3 py-1.5 text-sm';
      case 'lg':
        return 'px-6 py-3 text-lg';
      default:
        return 'px-4 py-2 text-base';
    }
  };

  const getIconSize = () => {
    switch (size) {
      case 'sm':
        return 'w-4 h-4';
      case 'lg':
        return 'w-6 h-6';
      default:
        return 'w-5 h-5';
    }
  };

  const handlePrint = async (options: PrintOptions = defaultOptions) => {
    if (disabled || data.length === 0) return;

    try {
      setIsLoading(true);
      onPrintStart?.();

      if (showPreview) {
        await printWithPreview(data, columns, options);
      } else {
        await printTable(data, columns, options);
      }

      onPrintComplete?.();
    } catch (error) {
      console.error('Print error:', error);
      onError?.(error as Error);

      // 사용자에게 오류 메시지 표시
      alert(`인쇄 중 오류가 발생했습니다: ${error instanceof Error ? error.message : '알 수 없는 오류'}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDirectPrint = () => {
    if (showOptions) {
      setShowOptionsModal(true);
    } else {
      handlePrint();
    }
  };

  const renderButton = () => {
    const baseClasses = `
      inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-colors
      disabled:opacity-50 disabled:cursor-not-allowed
      ${getSizeClasses()}
      ${className}
    `;

    const iconClass = getIconSize();

    if (variant === 'icon') {
      return (
        <button
          onClick={handleDirectPrint}
          disabled={disabled || isLoading || data.length === 0}
          className={`${baseClasses} bg-gray-500 text-white hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700`}
          title="인쇄"
        >
          {isLoading ? (
            <div className={`${iconClass} border-2 border-white border-t-transparent rounded-full animate-spin`} />
          ) : (
            children || <Printer className={iconClass} />
          )}
        </button>
      );
    }

    if (variant === 'text') {
      return (
        <button
          onClick={handleDirectPrint}
          disabled={disabled || isLoading || data.length === 0}
          className={`${baseClasses} text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300`}
        >
          {isLoading ? (
            <>
              <div className={`${iconClass} border-2 border-blue-600 border-t-transparent rounded-full animate-spin`} />
              인쇄 중...
            </>
          ) : (
            <>
              <Printer className={iconClass} />
              인쇄
            </>
          )}
        </button>
      );
    }

    return (
      <button
        onClick={handleDirectPrint}
        disabled={disabled || isLoading || data.length === 0}
        className={`${baseClasses} bg-gray-500 text-white hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700`}
      >
        {isLoading ? (
          <>
            <div className={`${iconClass} border-2 border-white border-t-transparent rounded-full animate-spin`} />
            인쇄 중...
          </>
        ) : (
          <>
            <Printer className={iconClass} />
            인쇄
          </>
        )}
      </button>
    );
  };

  const isEmpty = data.length === 0;

  return (
    <>
      <div className="relative">
        {renderButton()}

        {/* 데이터가 없을 때 툴팁 */}
        {isEmpty && (
          <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-gray-800 text-white text-xs rounded opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all">
            인쇄할 데이터가 없습니다
          </div>
        )}
      </div>

      {/* 인쇄 옵션 모달 */}
      <PrintOptionsModal
        isOpen={showOptionsModal}
        onClose={() => setShowOptionsModal(false)}
        onPrint={handlePrint}
        currentOptions={defaultOptions}
      />
    </>
  );
}

/**
 * 프리셋 인쇄 버튼들
 */

interface QuickPrintButtonsProps {
  data: Record<string, any>[];
  columns: TableColumn[];
  title?: string;
  className?: string;
}

export function QuickPrintButtons({ data, columns, title, className = '' }: QuickPrintButtonsProps) {
  return (
    <div className={`flex gap-2 ${className}`}>
      {/* 빠른 인쇄 */}
      <PrintButton
        data={data as Record<string, any>[]}
        columns={columns}
        title={title}
        variant="default"
        size="md"
        showPreview={false}
        showOptions={false}
      />

      {/* 미리보기 후 인쇄 */}
      <PrintButton
        data={data as Record<string, any>[]}
        columns={columns}
        title={title}
        variant="icon"
        size="md"
        showPreview={true}
        showOptions={false}
        className="bg-blue-500 hover:bg-blue-600"
      >
        <Eye className="w-5 h-5" />
      </PrintButton>

      {/* 옵션 설정 후 인쇄 */}
      <PrintButton
        data={data as Record<string, any>[]}
        columns={columns}
        title={title}
        variant="icon"
        size="md"
        showPreview={false}
        showOptions={true}
        className="bg-green-500 hover:bg-green-600"
      >
        <Settings className="w-5 h-5" />
      </PrintButton>
    </div>
  );
}

/**
 * 드롭다운 인쇄 메뉴
 */
interface PrintDropdownProps {
  data: Record<string, any>[];
  columns: TableColumn[];
  title?: string;
  onExportExcel?: () => void;
  onExportPDF?: () => void;
}

export function PrintDropdown({ data, columns, title, onExportExcel, onExportPDF }: PrintDropdownProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
      >
        <Download className="w-5 h-5" />
        내보내기
        <span className="ml-1">▼</span>
      </button>

      {isOpen && (
        <>
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />
          <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-20">
            <div className="py-1">
              <PrintButton
                data={data as Record<string, any>[]}
                columns={columns}
                title={title}
                variant="text"
                size="sm"
                showPreview={false}
                showOptions={false}
                className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
              />

              <PrintButton
                data={data as Record<string, any>[]}
                columns={columns}
                title={title}
                variant="text"
                size="sm"
                showPreview={true}
                showOptions={false}
                className="w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700"
              />

              {onExportExcel && (
                <button
                  onClick={() => {
                    onExportExcel();
                    setIsOpen(false);
                  }}
                  className="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                >
                  Excel로 내보내기
                </button>
              )}

              {onExportPDF && (
                <button
                  onClick={() => {
                    onExportPDF();
                    setIsOpen(false);
                  }}
                  className="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                >
                  PDF로 내보내기
                </button>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
}
```


#### 📄 src\components\ProductionForm.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Save, Loader2, Calendar, Package, AlertTriangle, CheckCircle, Factory, Wrench } from 'lucide-react';
import {
  Product,
  BOMItem,
  ProductionFormData,
  ProductionFormProps,
  ItemForComponent as Item
} from '@/types/inventory';
import ItemSelect from '@/components/ItemSelect';

export default function ProductionForm({ onSubmit, onCancel }: ProductionFormProps) {
  const [formData, setFormData] = useState<ProductionFormData>({
    transaction_date: new Date().toISOString().split('T')[0],
    product_item_id: 0,
    quantity: 0,
    reference_no: '',
    notes: '',
    use_bom: true,
    scrap_quantity: 0,
    created_by: 1 // Default user ID
  });

  const [loading, setLoading] = useState(false);
  const [loadingBOM, setLoadingBOM] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [bomItems, setBomItems] = useState<BOMItem[]>([]);
  const [stockCheck, setStockCheck] = useState<{ hasStock: boolean; insufficientItems: BOMItem[] }>({
    hasStock: true,
    insufficientItems: []
  });


  useEffect(() => {
    if (selectedProduct && formData.quantity > 0 && formData.use_bom) {
      checkBOMAndStock();
    } else {
      setBomItems([]);
      setStockCheck({ hasStock: true, insufficientItems: [] });
    }
  }, [selectedProduct, formData.quantity, formData.use_bom]);


  const checkBOMAndStock = async () => {
    if (!selectedProduct || formData.quantity <= 0) return;

    setLoadingBOM(true);
    try {
      const response = await fetch('/api/inventory/production/bom-check', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
          product_item_id: selectedProduct.id,
          quantity: formData.quantity
        }),
      });

      const data = await response.json();

      if (data.success) {
        setBomItems(data.data.bom_items || []);

        const insufficientItems = data.data.bom_items?.filter((item: BOMItem) => !item.sufficient_stock) || [];
        setStockCheck({
          hasStock: insufficientItems.length === 0,
          insufficientItems: insufficientItems
        });
      } else {
        setBomItems([]);
        setStockCheck({ hasStock: false, insufficientItems: [] });

        if (data.error) {
          setErrors(prev => ({ ...prev, bom: data.error }));
        }
      }
    } catch (error) {
      console.error('Failed to check BOM and stock:', error);
      setBomItems([]);
      setStockCheck({ hasStock: false, insufficientItems: [] });
    } finally {
      setLoadingBOM(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    const checked = (e.target as HTMLInputElement).checked;

    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : type === 'number' ? (value ? parseFloat(value) : 0) : value
    }));

    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleProductSelect = (item: Item | null) => {
    if (item) {
      const product = item as Product;
      setSelectedProduct(product);
      setFormData(prev => ({
        ...prev,
        product_item_id: product.id
      }));
      setBomItems([]);

      // Clear product selection error
      if (errors.product_item_id) {
        setErrors(prev => ({ ...prev, product_item_id: '' }));
      }
    } else {
      setSelectedProduct(null);
      setBomItems([]);
      setFormData(prev => ({ ...prev, product_item_id: 0 }));
    }
  };

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.transaction_date) {
      newErrors.transaction_date = '생산일자는 필수입니다';
    }

    if (!formData.product_item_id || formData.product_item_id === 0) {
      newErrors.product_item_id = '생산할 제품을 선택해주세요';
    }

    if (!formData.quantity || formData.quantity <= 0) {
      newErrors.quantity = '생산수량은 0보다 커야 합니다';
    }

    if (formData.use_bom && !stockCheck.hasStock) {
      newErrors.stock = '재고가 부족한 자재가 있습니다. 재고를 확인해주세요.';
    }

    if (formData.scrap_quantity && formData.scrap_quantity < 0) {
      newErrors.scrap_quantity = '스크랩 수량은 0 이상이어야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    setLoading(true);
    try {
      const submissionData = {
        ...formData,
        created_by: 1 // Default user ID, should be from auth context
      };

      // Remove empty optional fields
      Object.keys(submissionData).forEach(key => {
        if (submissionData[key as keyof typeof submissionData] === '' ||
            submissionData[key as keyof typeof submissionData] === undefined) {
          delete submissionData[key as keyof typeof submissionData];
        }
      });

      await onSubmit(submissionData);
    } finally {
      setLoading(false);
    }
  };

  const generateProductionOrder = () => {
    const now = new Date();
    const timestamp = now.toISOString().replace(/[-:T]/g, '').slice(0, 12);
    return `PRD-${timestamp}`;
  };

  const handleGenerateReference = () => {
    setFormData(prev => ({
      ...prev,
      reference_no: generateProductionOrder()
    }));
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* 생산일자 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Calendar className="w-4 h-4 inline mr-2" />
            생산일자 <span className="text-red-500">*</span>
          </label>
          <input
            type="date"
            name="transaction_date"
            value={formData.transaction_date}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.transaction_date ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          />
          {errors.transaction_date && (
            <p className="mt-1 text-sm text-red-500">{errors.transaction_date}</p>
          )}
        </div>

        {/* 생산오더 번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Factory className="w-4 h-4 inline mr-2" />
            생산오더 번호
          </label>
          <div className="flex gap-2">
            <input
              type="text"
              name="reference_no"
              value={formData.reference_no}
              onChange={handleChange}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="예: PRD-20240101001"
            />
            <button
              type="button"
              onClick={handleGenerateReference}
              className="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
              title="자동 생성"
            >
              <Wrench className="w-4 h-4" />
            </button>
          </div>
        </div>

        {/* 제품 검색 */}
        <div className="md:col-span-2">
          <ItemSelect
            value={formData.product_item_id || undefined}
            onChange={handleProductSelect}
            label="생산 제품"
            placeholder="제품 품번 또는 품명으로 검색..."
            required={true}
            error={errors.product_item_id}
            showPrice={true}
            itemType="PRODUCT"
          />
        </div>

        {/* 생산수량 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            생산수량 <span className="text-red-500">*</span>
          </label>
          <input
            type="number"
            name="quantity"
            value={formData.quantity}
            onChange={handleChange}
            min="0"
            step="0.01"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.quantity ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="0"
          />
          {selectedProduct && (
            <p className="mt-1 text-sm text-gray-500">단위: {selectedProduct.unit}</p>
          )}
          {errors.quantity && (
            <p className="mt-1 text-sm text-red-500">{errors.quantity}</p>
          )}
        </div>

        {/* 스크랩 수량 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            스크랩 수량
          </label>
          <input
            type="number"
            name="scrap_quantity"
            value={formData.scrap_quantity}
            onChange={handleChange}
            min="0"
            step="0.01"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.scrap_quantity ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="0"
          />
          {selectedProduct && (
            <p className="mt-1 text-sm text-gray-500">불량품 또는 스크랩 발생량</p>
          )}
          {errors.scrap_quantity && (
            <p className="mt-1 text-sm text-red-500">{errors.scrap_quantity}</p>
          )}
        </div>

        {/* BOM 사용 여부 */}
        <div className="md:col-span-2">
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              name="use_bom"
              checked={formData.use_bom}
              onChange={handleChange}
              className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
            />
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              BOM(Bill of Materials)을 사용하여 자재 자동 차감
            </span>
          </label>
          <p className="mt-1 text-sm text-gray-500">
            체크 시 등록된 BOM에 따라 필요한 자재가 자동으로 출고됩니다.
          </p>
        </div>

        {/* 메모 */}
        <div className="md:col-span-2">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            메모
          </label>
          <textarea
            name="notes"
            value={formData.notes}
            onChange={handleChange}
            rows={3}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="생산 관련 특이사항이나 메모를 입력하세요"
          />
        </div>
      </div>

      {/* BOM Materials Display */}
      {formData.use_bom && selectedProduct && formData.quantity > 0 && (
        <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
          <div className="flex items-center gap-2 mb-4">
            <Package className="w-5 h-5 text-blue-500" />
            <h4 className="text-lg font-medium text-gray-900 dark:text-white">
              필요 자재 (BOM 기준)
            </h4>
            {loadingBOM && (
              <Loader2 className="w-4 h-4 animate-spin text-gray-500" />
            )}
          </div>

          {errors.bom && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <p className="text-sm text-red-600 dark:text-red-400">{errors.bom}</p>
            </div>
          )}

          {!stockCheck.hasStock && stockCheck.insufficientItems.length > 0 && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <AlertTriangle className="w-4 h-4 text-red-500" />
                <span className="text-sm font-medium text-red-600 dark:text-red-400">
                  재고 부족 자재
                </span>
              </div>
              <ul className="text-sm text-red-600 dark:text-red-400 space-y-1">
                {stockCheck.insufficientItems.map(item => (
                  <li key={item.child_item_id}>
                    {item.child_item_code} - {item.child_item_name}:
                    필요 {item.required_quantity.toLocaleString()}{item.unit},
                    보유 {item.current_stock.toLocaleString()}{item.unit}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {errors.stock && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <p className="text-sm text-red-600 dark:text-red-400">{errors.stock}</p>
            </div>
          )}

          {bomItems.length > 0 && (
            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead>
                  <tr className="border-b border-gray-200 dark:border-gray-600">
                    <th className="text-left py-2 text-gray-700 dark:text-gray-300">품번</th>
                    <th className="text-left py-2 text-gray-700 dark:text-gray-300">품명</th>
                    <th className="text-right py-2 text-gray-700 dark:text-gray-300">단위소요량</th>
                    <th className="text-right py-2 text-gray-700 dark:text-gray-300">총 필요량</th>
                    <th className="text-right py-2 text-gray-700 dark:text-gray-300">현재고</th>
                    <th className="text-center py-2 text-gray-700 dark:text-gray-300">상태</th>
                  </tr>
                </thead>
                <tbody>
                  {bomItems.map(item => (
                    <tr key={item.child_item_id} className="border-b border-gray-100 dark:border-gray-700">
                      <td className="py-2 text-gray-900 dark:text-white">{item.child_item_code}</td>
                      <td className="py-2 text-gray-900 dark:text-white">{item.child_item_name}</td>
                      <td className="py-2 text-right text-gray-900 dark:text-white">
                        {item.bom_quantity.toLocaleString()} {item.unit}
                      </td>
                      <td className="py-2 text-right text-gray-900 dark:text-white">
                        {item.required_quantity.toLocaleString()} {item.unit}
                      </td>
                      <td className="py-2 text-right text-gray-900 dark:text-white">
                        {item.current_stock.toLocaleString()} {item.unit}
                      </td>
                      <td className="py-2 text-center">
                        {item.sufficient_stock ? (
                          <CheckCircle className="w-4 h-4 text-green-500 mx-auto" />
                        ) : (
                          <AlertTriangle className="w-4 h-4 text-red-500 mx-auto" />
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {bomItems.length === 0 && !loadingBOM && formData.use_bom && (
            <p className="text-sm text-gray-500 text-center py-4">
              선택한 제품에 대한 BOM이 등록되지 않았습니다.
            </p>
          )}
        </div>
      )}

      {/* Production Summary */}
      {selectedProduct && formData.quantity > 0 && (
        <div className="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-4">
          <h4 className="text-lg font-medium text-gray-900 dark:text-white mb-2">생산 요약</h4>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div>
              <span className="text-gray-500 dark:text-gray-400">제품:</span>
              <span className="ml-2 font-medium text-gray-900 dark:text-white">
                {selectedProduct.item_code}
              </span>
            </div>
            <div>
              <span className="text-gray-500 dark:text-gray-400">수량:</span>
              <span className="ml-2 font-medium text-gray-900 dark:text-white">
                {formData.quantity.toLocaleString()} {selectedProduct.unit}
              </span>
            </div>
            <div>
              <span className="text-gray-500 dark:text-gray-400">BOM 사용:</span>
              <span className="ml-2 font-medium text-gray-900 dark:text-white">
                {formData.use_bom ? '예' : '아니오'}
              </span>
            </div>
            <div>
              <span className="text-gray-500 dark:text-gray-400">재고 상태:</span>
              <span className={`ml-2 font-medium ${stockCheck.hasStock ? 'text-green-600' : 'text-red-600'}`}>
                {stockCheck.hasStock ? '충분' : '부족'}
              </span>
            </div>
          </div>
        </div>
      )}

      {/* Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200 dark:border-gray-700">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading || (!stockCheck.hasStock && formData.use_bom)}
          className="flex items-center gap-2 px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              생산 중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              생산 등록
            </>
          )}
        </button>
      </div>
    </form>
  );
}
```


#### 📄 src\components\ReceivingForm.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Save, Loader2, Calendar, Building2 } from 'lucide-react';
import {
  CompanyForComponent as Company,
  ItemForComponent as Item,
  ReceivingFormData,
  ReceivingFormProps,
  SearchOption
} from '@/types/inventory';
import ItemSelect from '@/components/ItemSelect';
import CompanySelect from '@/components/CompanySelect';

export default function ReceivingForm({ onSubmit, onCancel }: ReceivingFormProps) {
  const [formData, setFormData] = useState<ReceivingFormData>({
    transaction_date: new Date().toISOString().split('T')[0],
    item_id: 0,
    quantity: 0,
    unit_price: 0,
    company_id: undefined,
    reference_no: '',
    lot_no: '',
    expiry_date: '',
    to_location: '',
    notes: '',
    created_by: 1 // Default user ID
  });

  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [selectedItem, setSelectedItem] = useState<Item | null>(null);
  const [selectedCompany, setSelectedCompany] = useState<any>(null);


  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'number' ? (value ? parseFloat(value) : 0) : value
    }));

    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleItemChange = (item: Item | null) => {
    setSelectedItem(item);
    if (item) {
      setFormData(prev => ({
        ...prev,
        item_id: item.item_id,
        unit_price: item.unit_price || 0
      }));
    } else {
      setFormData(prev => ({ ...prev, item_id: 0, unit_price: 0 }));
    }

    // Clear item selection error
    if (errors.item_id) {
      setErrors(prev => ({ ...prev, item_id: '' }));
    }
  };

  const handleCompanyChange = (companyId: number | null, company?: any) => {
    setFormData(prev => ({ ...prev, company_id: companyId || undefined }));
    setSelectedCompany(company || null);

    // Clear company error
    if (errors.company_id) {
      setErrors(prev => ({ ...prev, company_id: '' }));
    }
  };

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.transaction_date) {
      newErrors.transaction_date = '거래일자는 필수입니다';
    }

    if (!formData.item_id || formData.item_id === 0) {
      newErrors.item_id = '품목을 선택해주세요';
    }

    if (!formData.quantity || formData.quantity <= 0) {
      newErrors.quantity = '수량은 0보다 커야 합니다';
    }

    if (formData.unit_price < 0) {
      newErrors.unit_price = '단가는 0 이상이어야 합니다';
    }

    if (formData.expiry_date && formData.expiry_date < formData.transaction_date) {
      newErrors.expiry_date = '만료일은 거래일자보다 뒤여야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    setLoading(true);
    try {
      // Prepare submission data
      const submissionData = {
        ...formData,
        created_by: 1 // Default user ID, should be from auth context
      };

      // Remove empty optional fields
      Object.keys(submissionData).forEach(key => {
        if (submissionData[key as keyof typeof submissionData] === '' ||
            submissionData[key as keyof typeof submissionData] === undefined) {
          delete submissionData[key as keyof typeof submissionData];
        }
      });

      await onSubmit(submissionData);
    } finally {
      setLoading(false);
    }
  };

  const calculateTotalAmount = () => {
    return formData.quantity * formData.unit_price;
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* 거래일자 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Calendar className="w-4 h-4 inline mr-2" />
            거래일자 <span className="text-red-500">*</span>
          </label>
          <input
            type="date"
            name="transaction_date"
            value={formData.transaction_date}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.transaction_date ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          />
          {errors.transaction_date && (
            <p className="mt-1 text-sm text-red-500">{errors.transaction_date}</p>
          )}
        </div>

        {/* 공급업체 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Building2 className="w-4 h-4 inline mr-2" />
            공급업체
          </label>
          <CompanySelect
            value={formData.company_id}
            onChange={handleCompanyChange}
            companyType="SUPPLIER"
            placeholder="공급업체를 선택하세요"
            error={errors.company_id}
          />
        </div>

        {/* 품목 검색 */}
        <div className="md:col-span-2">
          <ItemSelect
            value={formData.item_id || undefined}
            onChange={handleItemChange}
            label="품목"
            placeholder="품번 또는 품명으로 검색..."
            required={true}
            error={errors.item_id}
            showPrice={true}
            itemType="ALL"
            className=""
          />
        </div>

        {/* 수량 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            수량 <span className="text-red-500">*</span>
          </label>
          <input
            type="number"
            name="quantity"
            value={formData.quantity}
            onChange={handleChange}
            min="0"
            step="0.01"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.quantity ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="0"
          />
          {selectedItem && (
            <p className="mt-1 text-sm text-gray-500">단위: {selectedItem.unit}</p>
          )}
          {errors.quantity && (
            <p className="mt-1 text-sm text-red-500">{errors.quantity}</p>
          )}
        </div>

        {/* 단가 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            단가 (₩) <span className="text-red-500">*</span>
          </label>
          <input
            type="number"
            name="unit_price"
            value={formData.unit_price}
            onChange={handleChange}
            min="0"
            step="0.01"
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.unit_price ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
            placeholder="0"
          />
          {errors.unit_price && (
            <p className="mt-1 text-sm text-red-500">{errors.unit_price}</p>
          )}
        </div>

        {/* 참조번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            참조번호
          </label>
          <input
            type="text"
            name="reference_no"
            value={formData.reference_no}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: PO-2024-001"
          />
        </div>

        {/* LOT 번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            LOT 번호
          </label>
          <input
            type="text"
            name="lot_no"
            value={formData.lot_no}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: LOT-20240101"
          />
        </div>

        {/* 만료일 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            만료일
          </label>
          <input
            type="date"
            name="expiry_date"
            value={formData.expiry_date}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.expiry_date ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          />
          {errors.expiry_date && (
            <p className="mt-1 text-sm text-red-500">{errors.expiry_date}</p>
          )}
        </div>

        {/* 입고 위치 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            입고 위치
          </label>
          <input
            type="text"
            name="to_location"
            value={formData.to_location}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: A-01-01"
          />
        </div>

        {/* 메모 */}
        <div className="md:col-span-2">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            메모
          </label>
          <textarea
            name="notes"
            value={formData.notes}
            onChange={handleChange}
            rows={3}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="추가 메모나 특이사항을 입력하세요"
          />
        </div>
      </div>

      {/* Summary */}
      {formData.quantity > 0 && formData.unit_price > 0 && (
        <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
          <h4 className="text-lg font-medium text-gray-900 dark:text-white mb-2">입고 요약</h4>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div>
              <span className="text-gray-500 dark:text-gray-400">수량:</span>
              <span className="ml-2 font-medium text-gray-900 dark:text-white">
                {formData.quantity.toLocaleString()} {selectedItem?.unit || ''}
              </span>
            </div>
            <div>
              <span className="text-gray-500 dark:text-gray-400">단가:</span>
              <span className="ml-2 font-medium text-gray-900 dark:text-white">
                ₩{formData.unit_price.toLocaleString()}
              </span>
            </div>
            <div className="md:col-span-2">
              <span className="text-gray-500 dark:text-gray-400">총 금액:</span>
              <span className="ml-2 font-bold text-lg text-blue-600 dark:text-blue-400">
                ₩{calculateTotalAmount().toLocaleString()}
              </span>
            </div>
          </div>
        </div>
      )}

      {/* Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200 dark:border-gray-700">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading}
          className="flex items-center gap-2 px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              처리 중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              입고 등록
            </>
          )}
        </button>
      </div>
    </form>
  );
}
```


#### 📄 src\components\SearchFilters\CategoryFilter.tsx

```typescript
/**
 * 카테고리/타입 드롭다운 필터 컴포넌트
 * Category/Type Dropdown Filter Component
 */

import React, { useState } from 'react';
import { ChevronDown, X, Filter } from 'lucide-react';

export interface FilterOption {
  value: string;
  label: string;
  count?: number;
  disabled?: boolean;
}

interface CategoryFilterProps {
  options: FilterOption[];
  value?: string | string[];
  onChange: (value: string | string[]) => void;
  label?: string;
  placeholder?: string;
  multiple?: boolean;
  className?: string;
  disabled?: boolean;
  showCount?: boolean;
  allowClear?: boolean;
}

export const CategoryFilter: React.FC<CategoryFilterProps> = ({
  options,
  value,
  onChange,
  label,
  placeholder = '선택하세요',
  multiple = false,
  className = '',
  disabled = false,
  showCount = true,
  allowClear = true
}) => {
  const [isOpen, setIsOpen] = useState(false);

  const selectedValues = multiple
    ? (Array.isArray(value) ? value : value ? [value] : [])
    : value ? [value] : [];

  const getDisplayText = (): string => {
    if (selectedValues.length === 0) return placeholder;

    if (!multiple) {
      const option = options.find(opt => opt.value === selectedValues[0]);
      return option ? option.label : String(selectedValues[0]);
    }

    if (selectedValues.length === 1) {
      const option = options.find(opt => opt.value === selectedValues[0]);
      return option ? option.label : String(selectedValues[0]);
    }

    return `${selectedValues.length}개 선택됨`;
  };

  const handleOptionClick = (optionValue: string) => {
    if (disabled) return;

    if (!multiple) {
      onChange(optionValue);
      setIsOpen(false);
      return;
    }

    const newValues = selectedValues.includes(optionValue)
      ? selectedValues.filter(v => v !== optionValue)
      : [...selectedValues, optionValue];

    onChange(newValues as string[]);
  };

  const handleClear = (e: React.MouseEvent) => {
    e.stopPropagation();
    onChange(multiple ? [] : '');
  };

  const hasValue = selectedValues.length > 0;

  return (
    <div className={`relative ${className}`}>
      {label && (
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          {label}
        </label>
      )}

      <div className="relative">
        <button
          type="button"
          onClick={() => !disabled && setIsOpen(!isOpen)}
          disabled={disabled}
          className="w-full flex items-center justify-between px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span className={`truncate ${!hasValue ? 'text-gray-500 dark:text-gray-400' : ''}`}>
            {getDisplayText()}
          </span>

          <div className="flex items-center gap-1">
            {hasValue && allowClear && !disabled && (
              <button
                onClick={handleClear}
                className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <X className="w-4 h-4" />
              </button>
            )}
            <ChevronDown className={`w-4 h-4 text-gray-400 transition-transform ${
              isOpen ? 'transform rotate-180' : ''
            }`} />
          </div>
        </button>

        {/* 드롭다운 옵션 */}
        {isOpen && (
          <div className="absolute z-50 w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-auto">
            {/* 전체 선택/해제 (다중 선택 시) */}
            {multiple && options.length > 1 && (
              <>
                <button
                  onClick={() => {
                    const allValues = options.filter(opt => !opt.disabled).map(opt => opt.value);
                    onChange(selectedValues.length === allValues.length ? [] : allValues);
                  }}
                  className="w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 border-b border-gray-200 dark:border-gray-600"
                >
                  {selectedValues.length === options.filter(opt => !opt.disabled).length ? '전체 해제' : '전체 선택'}
                </button>
              </>
            )}

            {/* 옵션 목록 */}
            {options.map((option) => (
              <button
                key={option.value}
                onClick={() => handleOptionClick(option.value)}
                disabled={option.disabled}
                className={`w-full px-3 py-2 text-left text-sm transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${
                  selectedValues.includes(option.value)
                    ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300'
                    : 'text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                }`}
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    {multiple && (
                      <input
                        type="checkbox"
                        checked={selectedValues.includes(option.value)}
                        onChange={() => {}} // 부모 onClick에서 처리
                        className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                      />
                    )}
                    <span>{option.label}</span>
                  </div>
                  {showCount && option.count !== undefined && (
                    <span className="text-xs text-gray-500 dark:text-gray-400">
                      ({option.count})
                    </span>
                  )}
                </div>
              </button>
            ))}

            {/* 옵션이 없을 때 */}
            {options.length === 0 && (
              <div className="px-3 py-2 text-sm text-gray-500 dark:text-gray-400">
                선택할 수 있는 옵션이 없습니다.
              </div>
            )}
          </div>
        )}
      </div>

      {/* 클릭 외부 영역 감지 */}
      {isOpen && (
        <div
          className="fixed inset-0 z-40"
          onClick={() => setIsOpen(false)}
        />
      )}

      {/* 선택된 값들 표시 (다중 선택 시) */}
      {multiple && selectedValues.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {selectedValues.map((val) => {
            const option = options.find(opt => opt.value === val);
            const label = option ? option.label : String(val);

            return (
              <span
                key={String(val)}
                className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 dark:bg-blue-900/20 text-blue-800 dark:text-blue-300 text-xs rounded-full"
              >
                {label}
                {!disabled && (
                  <button
                    onClick={() => handleOptionClick(String(val))}
                    className="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200"
                  >
                    <X className="w-3 h-3" />
                  </button>
                )}
              </span>
            );
          })}
        </div>
      )}
    </div>
  );
};

export default CategoryFilter;
```


#### 📄 src\components\SearchFilters\DateRangeFilter.tsx

```typescript
/**
 * 날짜 범위 필터 컴포넌트
 * Date Range Filter Component with Korean Calendar Support
 */

import React, { useState } from 'react';
import { Calendar, X } from 'lucide-react';

interface DateRangeFilterProps {
  startDate?: string;
  endDate?: string;
  onChange: (range: { startDate?: string; endDate?: string }) => void;
  label?: string;
  placeholder?: {
    start?: string;
    end?: string;
  };
  className?: string;
  disabled?: boolean;
}

export const DateRangeFilter: React.FC<DateRangeFilterProps> = ({
  startDate,
  endDate,
  onChange,
  label = '기간 선택',
  placeholder = {
    start: '시작일',
    end: '종료일'
  },
  className = '',
  disabled = false
}) => {
  const [isOpen, setIsOpen] = useState(false);

  const formatDateForDisplay = (dateString?: string): string => {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      return date.toLocaleDateString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
    } catch {
      return dateString;
    }
  };

  const handleStartDateChange = (value: string) => {
    onChange({ startDate: value, endDate });
  };

  const handleEndDateChange = (value: string) => {
    onChange({ startDate, endDate: value });
  };

  const handleClear = () => {
    onChange({ startDate: undefined, endDate: undefined });
  };

  const hasValue = startDate || endDate;

  return (
    <div className={`relative ${className}`}>
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        {label}
      </label>

      <div className="space-y-2">
        {/* 시작일 입력 */}
        <div className="relative">
          <input
            type="date"
            value={startDate || ''}
            onChange={(e) => handleStartDateChange(e.target.value)}
            disabled={disabled}
            max={endDate}
            className="w-full pl-10 pr-10 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            placeholder={placeholder.start}
          />
          <Calendar className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
          {startDate && (
            <button
              onClick={() => handleStartDateChange('')}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              disabled={disabled}
            >
              <X className="w-4 h-4" />
            </button>
          )}
        </div>

        {/* 구분자 */}
        <div className="text-center text-gray-400 text-sm">~</div>

        {/* 종료일 입력 */}
        <div className="relative">
          <input
            type="date"
            value={endDate || ''}
            onChange={(e) => handleEndDateChange(e.target.value)}
            disabled={disabled}
            min={startDate}
            className="w-full pl-10 pr-10 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            placeholder={placeholder.end}
          />
          <Calendar className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400" />
          {endDate && (
            <button
              onClick={() => handleEndDateChange('')}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              disabled={disabled}
            >
              <X className="w-4 h-4" />
            </button>
          )}
        </div>

        {/* 전체 초기화 버튼 */}
        {hasValue && (
          <button
            onClick={handleClear}
            disabled={disabled}
            className="w-full py-1 text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            날짜 범위 초기화
          </button>
        )}
      </div>

      {/* 선택된 범위 표시 */}
      {hasValue && (
        <div className="mt-2 p-2 bg-blue-50 dark:bg-blue-900/20 rounded text-sm text-blue-700 dark:text-blue-300">
          {startDate && formatDateForDisplay(startDate)}
          {startDate && endDate && ' ~ '}
          {endDate && formatDateForDisplay(endDate)}
        </div>
      )}

      {/* 유효성 검사 메시지 */}
      {startDate && endDate && new Date(startDate) > new Date(endDate) && (
        <div className="mt-1 text-sm text-red-600 dark:text-red-400">
          시작일은 종료일보다 이전이어야 합니다.
        </div>
      )}
    </div>
  );
};

export default DateRangeFilter;
```


#### 📄 src\components\SearchFilters\index.ts

```typescript
/**
 * SearchFilters 컴포넌트 인덱스
 * SearchFilters components index file
 */

export { DateRangeFilter } from './DateRangeFilter';
export { CategoryFilter } from './CategoryFilter';
export type { FilterOption } from './CategoryFilter';

export { StatusFilter, stockStatusOptions, transactionStatusOptions, itemStatusOptions } from './StatusFilter';
export type { StatusOption } from './StatusFilter';

export { QuickFilters, itemQuickFilters, companyQuickFilters, inventoryQuickFilters } from './QuickFilters';

export { SavedFilters } from './SavedFilters';

// Re-export the main AdvancedSearch component
export { default as AdvancedSearch } from '../AdvancedSearch';
```


#### 📄 src\components\SearchFilters\QuickFilters.tsx

```typescript
/**
 * 빠른 필터 버튼 컴포넌트
 * Quick Filter Buttons Component with presets
 */

import React from 'react';
import { Calendar, Clock, Zap, Globe } from 'lucide-react';
import { getQuickFilters, QuickFilter } from '@/utils/searchUtils';

interface QuickFiltersProps {
  onFilterSelect: (filter: QuickFilter) => void;
  activeFilter?: string;
  className?: string;
  disabled?: boolean;
  customFilters?: QuickFilter[];
  showIcons?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

const QuickFilterIcon: React.FC<{ filterId: string; className?: string }> = ({
  filterId,
  className = 'w-4 h-4'
}) => {
  switch (filterId) {
    case 'today':
      return <Clock className={className} />;
    case 'thisWeek':
      return <Calendar className={className} />;
    case 'thisMonth':
      return <Calendar className={className} />;
    case 'thisYear':
      return <Calendar className={className} />;
    case 'all':
      return <Globe className={className} />;
    default:
      return <Zap className={className} />;
  }
};

export const QuickFilters: React.FC<QuickFiltersProps> = ({
  onFilterSelect,
  activeFilter,
  className = '',
  disabled = false,
  customFilters,
  showIcons = true,
  size = 'md'
}) => {
  const defaultFilters = getQuickFilters();
  const filters = customFilters || defaultFilters;

  const getSizeClasses = () => {
    switch (size) {
      case 'sm':
        return 'px-2 py-1 text-xs';
      case 'lg':
        return 'px-4 py-3 text-base';
      default:
        return 'px-3 py-2 text-sm';
    }
  };

  const getIconSize = () => {
    switch (size) {
      case 'sm':
        return 'w-3 h-3';
      case 'lg':
        return 'w-5 h-5';
      default:
        return 'w-4 h-4';
    }
  };

  const getButtonClasses = (filter: QuickFilter) => {
    const baseClasses = `
      inline-flex items-center gap-1.5 font-medium rounded-lg
      transition-all duration-200 border
      focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1
      disabled:opacity-50 disabled:cursor-not-allowed
      ${getSizeClasses()}
    `;

    if (activeFilter === filter.id) {
      return `${baseClasses}
        bg-blue-500 text-white border-blue-500
        shadow-md transform scale-105`;
    }

    return `${baseClasses}
      bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300
      border-gray-300 dark:border-gray-600
      hover:bg-gray-50 dark:hover:bg-gray-700
      hover:border-gray-400 dark:hover:border-gray-500
      hover:shadow-sm`;
  };

  const formatDateRange = (filter: QuickFilter): string => {
    if (!filter.dateRange) return '';

    const { startDate, endDate } = filter.dateRange;
    if (!startDate || !endDate) return '';

    try {
      const start = new Date(startDate);
      const end = new Date(endDate);

      if (start.toDateString() === end.toDateString()) {
        return start.toLocaleDateString('ko-KR', {
          month: 'short',
          day: 'numeric'
        });
      }

      return `${start.toLocaleDateString('ko-KR', {
        month: 'short',
        day: 'numeric'
      })} ~ ${end.toLocaleDateString('ko-KR', {
        month: 'short',
        day: 'numeric'
      })}`;
    } catch {
      return '';
    }
  };

  return (
    <div className={`space-y-3 ${className}`}>
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
          빠른 필터:
        </span>
      </div>

      <div className="flex flex-wrap gap-2">
        {filters.map((filter) => (
          <button
            key={filter.id}
            onClick={() => onFilterSelect(filter)}
            disabled={disabled}
            className={getButtonClasses(filter)}
            title={formatDateRange(filter)}
          >
            {showIcons && (
              <QuickFilterIcon
                filterId={filter.id}
                className={getIconSize()}
              />
            )}
            <span>{filter.label}</span>

            {/* 날짜 범위 표시 (작은 텍스트로) */}
            {filter.dateRange && size !== 'sm' && (
              <span className="text-xs opacity-75 ml-1">
                {formatDateRange(filter)}
              </span>
            )}
          </button>
        ))}
      </div>

      {/* 선택된 필터 정보 */}
      {activeFilter && (
        <div className="text-xs text-gray-500 dark:text-gray-400">
          {(() => {
            const active = filters.find(f => f.id === activeFilter);
            if (!active) return null;

            const parts = [];
            if (active.dateRange) {
              const range = formatDateRange(active);
              if (range) parts.push(`기간: ${range}`);
            }

            const filterCount = Object.keys(active.filters).length;
            if (filterCount > 0) {
              parts.push(`추가 필터: ${filterCount}개`);
            }

            return parts.length > 0 ? `적용됨 - ${parts.join(', ')}` : '적용됨';
          })()}
        </div>
      )}
    </div>
  );
};

// 도메인별 커스텀 빠른 필터들
export const itemQuickFilters: QuickFilter[] = [
  ...getQuickFilters(),
  {
    id: 'lowStock',
    label: '재고부족',
    filters: { stockStatus: 'low' }
  },
  {
    id: 'products',
    label: '완제품',
    filters: { item_type: 'PRODUCT' }
  },
  {
    id: 'materials',
    label: '원자재',
    filters: { item_type: 'MATERIAL' }
  }
];

export const companyQuickFilters: QuickFilter[] = [
  ...getQuickFilters(),
  {
    id: 'customers',
    label: '고객사',
    filters: { company_type: 'CUSTOMER' }
  },
  {
    id: 'suppliers',
    label: '공급사',
    filters: { company_type: 'SUPPLIER' }
  }
];

export const inventoryQuickFilters: QuickFilter[] = [
  ...getQuickFilters().slice(0, 4), // 올해 제외
  {
    id: 'receiving',
    label: '입고',
    filters: { transaction_type: '입고' }
  },
  {
    id: 'production',
    label: '생산',
    filters: { transaction_type: '생산입고' }
  },
  {
    id: 'shipping',
    label: '출고',
    filters: { transaction_type: '출고' }
  },
  {
    id: 'lastMonth',
    label: '지난달',
    filters: {},
    dateRange: (() => {
      const now = new Date();
      const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
      return {
        startDate: lastMonth.toISOString().split('T')[0],
        endDate: lastMonthEnd.toISOString().split('T')[0]
      };
    })()
  }
];

export default QuickFilters;
```


#### 📄 src\components\SearchFilters\SavedFilters.tsx

```typescript
/**
 * 저장된 필터 관리 컴포넌트
 * Saved Filters Management Component
 */

import React, { useState, useEffect } from 'react';
import { Save, Bookmark, Trash2, Edit2, Calendar, Filter } from 'lucide-react';
import { FilterState } from '@/hooks/useAdvancedFilter';

interface SavedFilter {
  name: string;
  filters: FilterState;
  createdAt: string;
}

interface SavedFiltersProps {
  currentFilters: FilterState;
  onLoadFilter: (name: string) => void;
  onSaveFilter: (name: string) => void;
  onDeleteFilter: (name: string) => void;
  getSavedFilters: () => SavedFilter[];
  className?: string;
  disabled?: boolean;
}

export const SavedFilters: React.FC<SavedFiltersProps> = ({
  currentFilters,
  onLoadFilter,
  onSaveFilter,
  onDeleteFilter,
  getSavedFilters,
  className = '',
  disabled = false
}) => {
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [showManageDialog, setShowManageDialog] = useState(false);
  const [newFilterName, setNewFilterName] = useState('');
  const [editingFilter, setEditingFilter] = useState<string | null>(null);
  const [editName, setEditName] = useState('');

  useEffect(() => {
    refreshSavedFilters();
  }, [getSavedFilters]);

  const refreshSavedFilters = () => {
    setSavedFilters(getSavedFilters());
  };

  const handleSaveFilter = () => {
    if (!newFilterName.trim()) return;

    // 중복 이름 확인
    const exists = savedFilters.some(f => f.name === newFilterName.trim());
    if (exists) {
      if (!confirm('같은 이름의 필터가 존재합니다. 덮어쓰시겠습니까?')) {
        return;
      }
    }

    onSaveFilter(newFilterName.trim());
    setNewFilterName('');
    setShowSaveDialog(false);
    refreshSavedFilters();
  };

  const handleDeleteFilter = (name: string) => {
    if (confirm(`"${name}" 필터를 삭제하시겠습니까?`)) {
      onDeleteFilter(name);
      refreshSavedFilters();
    }
  };

  const handleEditFilter = (oldName: string) => {
    if (!editName.trim() || editName === oldName) {
      setEditingFilter(null);
      setEditName('');
      return;
    }

    // 중복 이름 확인
    const exists = savedFilters.some(f => f.name === editName.trim());
    if (exists) {
      alert('같은 이름의 필터가 이미 존재합니다.');
      return;
    }

    // 필터 이름 변경 (삭제 후 재저장)
    const filter = savedFilters.find(f => f.name === oldName);
    if (filter) {
      onDeleteFilter(oldName);
      // 현재 필터를 임시 저장 후 해당 필터로 교체
      const currentTemp = currentFilters;
      onLoadFilter(oldName); // 필터 데이터 로드
      onSaveFilter(editName.trim()); // 새 이름으로 저장
      // 원래 필터로 복원
      Object.assign(currentFilters, currentTemp);
    }

    setEditingFilter(null);
    setEditName('');
    refreshSavedFilters();
  };

  const getFilterDescription = (filters: FilterState): string => {
    const parts = [];

    if (filters.searchTerm) {
      parts.push(`검색: "${filters.searchTerm}"`);
    }

    if (filters.dateRange.startDate || filters.dateRange.endDate) {
      const start = filters.dateRange.startDate;
      const end = filters.dateRange.endDate;
      if (start && end) {
        parts.push(`기간: ${new Date(start).toLocaleDateString('ko-KR')} ~ ${new Date(end).toLocaleDateString('ko-KR')}`);
      } else if (start) {
        parts.push(`시작일: ${new Date(start).toLocaleDateString('ko-KR')}`);
      } else if (end) {
        parts.push(`종료일: ${new Date(end).toLocaleDateString('ko-KR')}`);
      }
    }

    const filterCount = Object.values(filters.filters).filter(
      v => v !== '' && v !== null && v !== undefined
    ).length;

    if (filterCount > 0) {
      parts.push(`필터: ${filterCount}개`);
    }

    return parts.length > 0 ? parts.join(', ') : '필터 없음';
  };

  const hasCurrentFilters = () => {
    return (
      currentFilters.searchTerm !== '' ||
      currentFilters.dateRange.startDate ||
      currentFilters.dateRange.endDate ||
      Object.values(currentFilters.filters).some(
        v => v !== '' && v !== null && v !== undefined
      )
    );
  };

  return (
    <div className={`space-y-3 ${className}`}>
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">
          저장된 필터
        </h3>
        <div className="flex gap-1">
          {hasCurrentFilters() && (
            <button
              onClick={() => setShowSaveDialog(true)}
              disabled={disabled}
              className="p-1 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400 disabled:opacity-50 disabled:cursor-not-allowed"
              title="현재 필터 저장"
            >
              <Save className="w-4 h-4" />
            </button>
          )}
          {savedFilters.length > 0 && (
            <button
              onClick={() => setShowManageDialog(true)}
              disabled={disabled}
              className="p-1 text-gray-500 hover:text-gray-600 dark:text-gray-400 dark:hover:text-gray-300 disabled:opacity-50 disabled:cursor-not-allowed"
              title="필터 관리"
            >
              <Filter className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>

      {/* 저장된 필터 목록 */}
      {savedFilters.length > 0 ? (
        <div className="space-y-1 max-h-40 overflow-y-auto">
          {savedFilters.slice(0, 5).map((filter) => (
            <button
              key={filter.name}
              onClick={() => onLoadFilter(filter.name)}
              disabled={disabled}
              className="w-full p-2 text-left text-sm bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded border border-gray-200 dark:border-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <div className="flex items-center gap-2">
                <Bookmark className="w-3 h-3 text-blue-500 flex-shrink-0" />
                <div className="flex-1 min-w-0">
                  <div className="font-medium text-gray-900 dark:text-white truncate">
                    {filter.name}
                  </div>
                  <div className="text-xs text-gray-500 dark:text-gray-400 truncate">
                    {getFilterDescription(filter.filters)}
                  </div>
                </div>
                <div className="text-xs text-gray-400 flex-shrink-0">
                  <Calendar className="w-3 h-3 inline mr-1" />
                  {new Date(filter.createdAt).toLocaleDateString('ko-KR', {
                    month: 'short',
                    day: 'numeric'
                  })}
                </div>
              </div>
            </button>
          ))}

          {savedFilters.length > 5 && (
            <button
              onClick={() => setShowManageDialog(true)}
              className="w-full p-2 text-center text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
            >
              +{savedFilters.length - 5}개 더 보기...
            </button>
          )}
        </div>
      ) : (
        <div className="text-sm text-gray-500 dark:text-gray-400 text-center py-4">
          저장된 필터가 없습니다
        </div>
      )}

      {/* 필터 저장 다이얼로그 */}
      {showSaveDialog && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md mx-4">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              필터 저장
            </h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  필터 이름
                </label>
                <input
                  type="text"
                  value={newFilterName}
                  onChange={(e) => setNewFilterName(e.target.value)}
                  placeholder="필터 이름을 입력하세요"
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  autoFocus
                />
              </div>
              <div className="text-sm text-gray-500 dark:text-gray-400">
                현재 필터: {getFilterDescription(currentFilters)}
              </div>
              <div className="flex gap-2 justify-end">
                <button
                  onClick={() => {
                    setShowSaveDialog(false);
                    setNewFilterName('');
                  }}
                  className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"
                >
                  취소
                </button>
                <button
                  onClick={handleSaveFilter}
                  disabled={!newFilterName.trim()}
                  className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  저장
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* 필터 관리 다이얼로그 */}
      {showManageDialog && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl mx-4 max-h-[80vh] overflow-hidden flex flex-col">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              저장된 필터 관리
            </h3>
            <div className="flex-1 overflow-y-auto space-y-2">
              {savedFilters.map((filter) => (
                <div
                  key={filter.name}
                  className="flex items-center gap-3 p-3 border border-gray-200 dark:border-gray-700 rounded-lg"
                >
                  <div className="flex-1 min-w-0">
                    {editingFilter === filter.name ? (
                      <input
                        type="text"
                        value={editName}
                        onChange={(e) => setEditName(e.target.value)}
                        onBlur={() => handleEditFilter(filter.name)}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') handleEditFilter(filter.name);
                          if (e.key === 'Escape') {
                            setEditingFilter(null);
                            setEditName('');
                          }
                        }}
                        className="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                        autoFocus
                      />
                    ) : (
                      <div className="font-medium text-gray-900 dark:text-white">
                        {filter.name}
                      </div>
                    )}
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      {getFilterDescription(filter.filters)}
                    </div>
                    <div className="text-xs text-gray-400 mt-1">
                      저장일: {new Date(filter.createdAt).toLocaleString('ko-KR')}
                    </div>
                  </div>
                  <div className="flex gap-1">
                    <button
                      onClick={() => onLoadFilter(filter.name)}
                      className="p-1 text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                      title="필터 적용"
                    >
                      <Bookmark className="w-4 h-4" />
                    </button>
                    <button
                      onClick={() => {
                        setEditingFilter(filter.name);
                        setEditName(filter.name);
                      }}
                      className="p-1 text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-300"
                      title="이름 변경"
                    >
                      <Edit2 className="w-4 h-4" />
                    </button>
                    <button
                      onClick={() => handleDeleteFilter(filter.name)}
                      className="p-1 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                      title="삭제"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>
                </div>
              ))}
            </div>
            <div className="flex justify-end mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
              <button
                onClick={() => setShowManageDialog(false)}
                className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"
              >
                닫기
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SavedFilters;
```


#### 📄 src\components\SearchFilters\StatusFilter.tsx

```typescript
/**
 * 상태 기반 필터 컴포넌트
 * Status-based Filter Component with visual indicators
 */

import React from 'react';
import { CheckCircle, AlertCircle, Clock, XCircle, Package } from 'lucide-react';
import { CategoryFilter, FilterOption } from './CategoryFilter';

export interface StatusOption extends FilterOption {
  color?: 'green' | 'yellow' | 'red' | 'blue' | 'gray';
  icon?: 'check' | 'alert' | 'clock' | 'x' | 'package';
  description?: string;
}

interface StatusFilterProps {
  options: StatusOption[];
  value?: string | string[];
  onChange: (value: string | string[]) => void;
  label?: string;
  placeholder?: string;
  multiple?: boolean;
  className?: string;
  disabled?: boolean;
  showCount?: boolean;
  allowClear?: boolean;
  showVisualIndicators?: boolean;
}

const StatusIcon: React.FC<{ type?: string; className?: string }> = ({ type, className = 'w-4 h-4' }) => {
  switch (type) {
    case 'check':
      return <CheckCircle className={className} />;
    case 'alert':
      return <AlertCircle className={className} />;
    case 'clock':
      return <Clock className={className} />;
    case 'x':
      return <XCircle className={className} />;
    case 'package':
      return <Package className={className} />;
    default:
      return <CheckCircle className={className} />;
  }
};

const getColorClasses = (color?: string) => {
  switch (color) {
    case 'green':
      return {
        bg: 'bg-green-100 dark:bg-green-900/20',
        text: 'text-green-800 dark:text-green-300',
        icon: 'text-green-600 dark:text-green-400'
      };
    case 'yellow':
      return {
        bg: 'bg-yellow-100 dark:bg-yellow-900/20',
        text: 'text-yellow-800 dark:text-yellow-300',
        icon: 'text-yellow-600 dark:text-yellow-400'
      };
    case 'red':
      return {
        bg: 'bg-red-100 dark:bg-red-900/20',
        text: 'text-red-800 dark:text-red-300',
        icon: 'text-red-600 dark:text-red-400'
      };
    case 'blue':
      return {
        bg: 'bg-blue-100 dark:bg-blue-900/20',
        text: 'text-blue-800 dark:text-blue-300',
        icon: 'text-blue-600 dark:text-blue-400'
      };
    default:
      return {
        bg: 'bg-gray-100 dark:bg-gray-700',
        text: 'text-gray-800 dark:text-gray-300',
        icon: 'text-gray-600 dark:text-gray-400'
      };
  }
};

export const StatusFilter: React.FC<StatusFilterProps> = ({
  options,
  value,
  onChange,
  label = '상태',
  placeholder = '상태 선택',
  multiple = false,
  className = '',
  disabled = false,
  showCount = true,
  allowClear = true,
  showVisualIndicators = true
}) => {
  // 시각적 인디케이터와 함께 옵션 렌더링
  const renderCustomOption = (option: StatusOption, isSelected: boolean) => {
    const colorClasses = getColorClasses(option.color);

    return (
      <div className="flex items-center justify-between w-full">
        <div className="flex items-center gap-2">
          {multiple && (
            <input
              type="checkbox"
              checked={isSelected}
              onChange={() => {}} // 부모에서 처리
              className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
            />
          )}

          {showVisualIndicators && (
            <div className={`flex items-center gap-2 px-2 py-1 rounded-full ${colorClasses.bg}`}>
              <StatusIcon
                type={option.icon}
                className={`w-3 h-3 ${colorClasses.icon}`}
              />
              <span className={`text-xs font-medium ${colorClasses.text}`}>
                {option.label}
              </span>
            </div>
          )}

          {!showVisualIndicators && (
            <span>{option.label}</span>
          )}

          {option.description && (
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {option.description}
            </span>
          )}
        </div>

        {showCount && option.count !== undefined && (
          <span className="text-xs text-gray-500 dark:text-gray-400">
            ({option.count})
          </span>
        )}
      </div>
    );
  };

  return (
    <div className={className}>
      <CategoryFilter
        options={options}
        value={value}
        onChange={onChange}
        label={label}
        placeholder={placeholder}
        multiple={multiple}
        disabled={disabled}
        showCount={false} // 커스텀 렌더링에서 처리
        allowClear={allowClear}
      />

      {/* 선택된 상태들을 시각적으로 표시 (단일 선택일 때도) */}
      {showVisualIndicators && value && (
        <div className="mt-2">
          {(Array.isArray(value) ? value : [value]).map((val) => {
            const option = options.find(opt => opt.value === val);
            if (!option) return null;

            const colorClasses = getColorClasses(option.color);

            return (
              <div
                key={val}
                className={`inline-flex items-center gap-2 px-3 py-1 rounded-full ${colorClasses.bg} mr-2 mb-1`}
              >
                <StatusIcon
                  type={option.icon}
                  className={`w-3 h-3 ${colorClasses.icon}`}
                />
                <span className={`text-sm font-medium ${colorClasses.text}`}>
                  {option.label}
                </span>
                {showCount && option.count !== undefined && (
                  <span className={`text-xs ${colorClasses.text} opacity-75`}>
                    ({option.count})
                  </span>
                )}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
};

// 미리 정의된 상태 옵션들
export const stockStatusOptions: StatusOption[] = [
  {
    value: 'normal',
    label: '정상',
    color: 'green',
    icon: 'check',
    description: '충분한 재고'
  },
  {
    value: 'low',
    label: '부족',
    color: 'yellow',
    icon: 'alert',
    description: '최소 재고 이하'
  },
  {
    value: 'empty',
    label: '재고없음',
    color: 'red',
    icon: 'x',
    description: '재고 0개'
  },
  {
    value: 'excess',
    label: '과다',
    color: 'blue',
    icon: 'package',
    description: '과다 재고'
  }
];

export const transactionStatusOptions: StatusOption[] = [
  {
    value: 'pending',
    label: '대기중',
    color: 'yellow',
    icon: 'clock',
    description: '처리 대기'
  },
  {
    value: 'completed',
    label: '완료',
    color: 'green',
    icon: 'check',
    description: '처리 완료'
  },
  {
    value: 'cancelled',
    label: '취소',
    color: 'red',
    icon: 'x',
    description: '처리 취소'
  }
];

export const itemStatusOptions: StatusOption[] = [
  {
    value: 'active',
    label: '활성',
    color: 'green',
    icon: 'check',
    description: '사용 중인 품목'
  },
  {
    value: 'inactive',
    label: '비활성',
    color: 'gray',
    icon: 'x',
    description: '사용 중지된 품목'
  }
];

export default StatusFilter;
```


#### 📄 src\components\SearchPresets.tsx

```typescript
'use client';

import { useState } from 'react';
import { Star, Plus, Edit, Trash2, Download, Upload, Clock } from 'lucide-react';
import { SearchPreset } from '@/hooks/useAdvancedSearch';
import Modal from './Modal';

interface SearchPresetsProps {
  presets: SearchPreset[];
  onLoadPreset: (preset: SearchPreset) => void;
  onSavePreset: (name: string, description?: string) => SearchPreset;
  onDeletePreset: (presetId: string) => void;
  className?: string;
  currentFilters?: any;
  hasActiveFilters?: boolean;
}

interface PresetFormData {
  name: string;
  description: string;
}

export default function SearchPresets({
  presets,
  onLoadPreset,
  onSavePreset,
  onDeletePreset,
  className = '',
  currentFilters,
  hasActiveFilters = false
}: SearchPresetsProps) {
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [editingPreset, setEditingPreset] = useState<SearchPreset | null>(null);
  const [showExportModal, setShowExportModal] = useState(false);
  const [formData, setFormData] = useState<PresetFormData>({ name: '', description: '' });

  // Default presets (cannot be deleted)
  const defaultPresets = presets.filter(p => p.isDefault);
  const userPresets = presets.filter(p => !p.isDefault);

  // Handle save preset
  const handleSavePreset = () => {
    if (!formData.name.trim()) return;

    try {
      const newPreset = onSavePreset(formData.name.trim(), formData.description.trim() || undefined);
      setShowSaveModal(false);
      setFormData({ name: '', description: '' });
      console.log('프리셋이 저장되었습니다:', newPreset.name);
    } catch (error) {
      console.error('프리셋 저장 실패:', error);
    }
  };

  // Handle preset click
  const handlePresetClick = (preset: SearchPreset) => {
    onLoadPreset(preset);
  };

  // Handle delete preset
  const handleDeletePreset = (preset: SearchPreset) => {
    if (preset.isDefault) return;

    if (confirm(`'${preset.name}' 프리셋을 삭제하시겠습니까?`)) {
      onDeletePreset(preset.id);
    }
  };

  // Export presets
  const handleExportPresets = () => {
    const exportData = {
      presets: userPresets,
      exportedAt: new Date().toISOString(),
      version: '1.0'
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `search_presets_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setShowExportModal(false);
  };

  // Import presets
  const handleImportPresets = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importData = JSON.parse(e.target?.result as string);
        if (importData.presets && Array.isArray(importData.presets)) {
          // Here you would implement the import logic
          // For now, just log the imported data
          console.log('프리셋 가져오기:', importData.presets);
          alert(`${importData.presets.length}개의 프리셋을 가져왔습니다.`);
        }
      } catch (error) {
        alert('프리셋 파일 형식이 올바르지 않습니다.');
      }
    };
    reader.readAsText(file);
  };

  // Format preset description for display
  const formatPresetDescription = (preset: SearchPreset): string => {
    if (preset.description) return preset.description;

    // Generate description from filters
    const filters = preset.filters;
    const descriptions: string[] = [];

    if (filters.search) descriptions.push(`검색: "${filters.search}"`);
    if (filters.itemType) descriptions.push(`타입: ${filters.itemType}`);
    if (filters.companyType) descriptions.push(`거래처타입: ${filters.companyType}`);
    if (filters.isLowStock) descriptions.push('재고부족품목');
    if (filters.priceRange?.min || filters.priceRange?.max) {
      const min = filters.priceRange.min ? `₩${filters.priceRange.min.toLocaleString()}` : '';
      const max = filters.priceRange.max ? `₩${filters.priceRange.max.toLocaleString()}` : '';
      if (min && max) descriptions.push(`가격: ${min} ~ ${max}`);
      else if (min) descriptions.push(`가격: ${min} 이상`);
      else if (max) descriptions.push(`가격: ${max} 이하`);
    }

    return descriptions.join(', ') || '사용자 정의 필터';
  };

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 ${className}`}>
      {/* Header */}
      <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Star className="w-5 h-5 text-yellow-500" />
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">검색 프리셋</h3>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={() => setShowExportModal(true)}
              className="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              title="프리셋 내보내기/가져오기"
            >
              <Download className="w-4 h-4" />
            </button>
            <button
              onClick={() => setShowSaveModal(true)}
              disabled={!hasActiveFilters}
              className="flex items-center gap-1 px-3 py-1.5 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              title="현재 필터를 프리셋으로 저장"
            >
              <Plus className="w-4 h-4" />
              저장
            </button>
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="p-4 space-y-4">
        {/* Default Presets */}
        {defaultPresets.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">기본 프리셋</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
              {defaultPresets.map((preset) => (
                <button
                  key={preset.id}
                  onClick={() => handlePresetClick(preset)}
                  className="p-3 text-left bg-gray-50 dark:bg-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors"
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-medium text-gray-900 dark:text-white truncate">
                        {preset.name}
                      </div>
                      <div className="text-xs text-gray-500 dark:text-gray-400 mt-1 line-clamp-2">
                        {formatPresetDescription(preset)}
                      </div>
                    </div>
                    <Star className="w-4 h-4 text-yellow-500 ml-2 flex-shrink-0" />
                  </div>
                </button>
              ))}
            </div>
          </div>
        )}

        {/* User Presets */}
        {userPresets.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              사용자 프리셋 ({userPresets.length})
            </h4>
            <div className="space-y-2">
              {userPresets.map((preset) => (
                <div
                  key={preset.id}
                  className="p-3 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg"
                >
                  <div className="flex items-start justify-between">
                    <button
                      onClick={() => handlePresetClick(preset)}
                      className="flex-1 text-left hover:bg-gray-50 dark:hover:bg-gray-600 -m-1 p-1 rounded"
                    >
                      <div className="text-sm font-medium text-gray-900 dark:text-white">
                        {preset.name}
                      </div>
                      <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        {formatPresetDescription(preset)}
                      </div>
                      <div className="flex items-center gap-1 text-xs text-gray-400 dark:text-gray-500 mt-2">
                        <Clock className="w-3 h-3" />
                        {new Date(preset.createdAt).toLocaleDateString('ko-KR')}
                      </div>
                    </button>
                    <div className="flex items-center gap-1 ml-2">
                      <button
                        onClick={() => handleDeletePreset(preset)}
                        className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                        title="프리셋 삭제"
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Empty State */}
        {userPresets.length === 0 && (
          <div className="text-center py-8">
            <Star className="w-12 h-12 text-gray-300 dark:text-gray-600 mx-auto mb-3" />
            <div className="text-sm text-gray-500 dark:text-gray-400 mb-3">
              저장된 사용자 프리셋이 없습니다
            </div>
            <button
              onClick={() => setShowSaveModal(true)}
              disabled={!hasActiveFilters}
              className="inline-flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <Plus className="w-4 h-4" />
              첫 번째 프리셋 저장하기
            </button>
          </div>
        )}
      </div>

      {/* Save Preset Modal */}
      <Modal
        isOpen={showSaveModal}
        onClose={() => {
          setShowSaveModal(false);
          setFormData({ name: '', description: '' });
        }}
        title="검색 프리셋 저장"
        size="md"
      >
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              프리셋 이름 *
            </label>
            <input
              type="text"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              placeholder="예: 재고부족품목, 고가자재 등"
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              maxLength={50}
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              설명 (선택사항)
            </label>
            <textarea
              value={formData.description}
              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
              placeholder="프리셋에 대한 간단한 설명을 입력하세요"
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              maxLength={200}
            />
          </div>

          {/* Current Filters Preview */}
          {currentFilters && (
            <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
              <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                저장될 필터 설정:
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400">
                {Object.entries(currentFilters)
                  .filter(([, value]) => value !== null && value !== undefined && value !== '')
                  .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
                  .join(', ') || '필터 없음'}
              </div>
            </div>
          )}

          <div className="flex justify-end gap-3 pt-4">
            <button
              onClick={() => {
                setShowSaveModal(false);
                setFormData({ name: '', description: '' });
              }}
              className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg transition-colors"
            >
              취소
            </button>
            <button
              onClick={handleSavePreset}
              disabled={!formData.name.trim()}
              className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              저장
            </button>
          </div>
        </div>
      </Modal>

      {/* Export/Import Modal */}
      <Modal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        title="프리셋 내보내기/가져오기"
        size="md"
      >
        <div className="space-y-6">
          {/* Export */}
          <div>
            <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">프리셋 내보내기</h4>
            <div className="p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                현재 저장된 사용자 프리셋을 JSON 파일로 내보냅니다.
              </p>
              <button
                onClick={handleExportPresets}
                disabled={userPresets.length === 0}
                className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <Download className="w-4 h-4" />
                프리셋 내보내기 ({userPresets.length}개)
              </button>
            </div>
          </div>

          {/* Import */}
          <div>
            <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">프리셋 가져오기</h4>
            <div className="p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                이전에 내보낸 프리셋 JSON 파일을 선택하여 가져옵니다.
              </p>
              <label className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 cursor-pointer">
                <Upload className="w-4 h-4" />
                프리셋 파일 선택
                <input
                  type="file"
                  accept=".json"
                  onChange={handleImportPresets}
                  className="hidden"
                />
              </label>
            </div>
          </div>
        </div>
      </Modal>
    </div>
  );
}
```


#### 📄 src\components\ShippingForm.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Save, Loader2, Calendar, Building2, Package, Plus, X, AlertTriangle, CheckCircle, Truck } from 'lucide-react';
import {
  CompanyForComponent,
  Product,
  ShippingItem,
  ShippingFormData,
  ShippingFormProps,
  ItemForComponent as Item
} from '@/types/inventory';
import { Database } from '@/types/supabase';
import ItemSelect from '@/components/ItemSelect';
import CompanySelect from '@/components/CompanySelect';

// Company type from unified Supabase layer
type Company = Database['public']['Tables']['companies']['Row'];

// Define a type alias for customer to maintain compatibility
type Customer = CompanyForComponent;

export default function ShippingForm({ onSubmit, onCancel }: ShippingFormProps) {
  const [formData, setFormData] = useState<ShippingFormData>({
    transaction_date: new Date().toISOString().split('T')[0],
    customer_id: undefined,
    items: [],
    reference_no: '',
    delivery_address: '',
    delivery_date: '',
    notes: '',
    created_by: 1 // Default user ID
  });

  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [stockCheckComplete, setStockCheckComplete] = useState(false);

  useEffect(() => {
    fetchInitialData();
  }, []);


  useEffect(() => {
    if (formData.items.length > 0) {
      checkStockAvailability();
    } else {
      setStockCheckComplete(false);
    }
  }, [formData.items]);

  const fetchInitialData = async () => {
    try {
      // Fetch customers (companies with type CUSTOMER or BOTH)
      const customersResponse = await fetch('/api/companies?type=CUSTOMER');
      const customersData = await customersResponse.json();
      if (customersData.success) {
        setCustomers(customersData.data);
      }

      // Fetch products only
      const productsResponse = await fetch('/api/items?type=PRODUCT');
      const productsData = await productsResponse.json();
      if (productsData.success) {
        // Get current stock for each product
        const stockResponse = await fetch('/api/stock');
        const stockData = await stockResponse.json();
        if (stockData.success) {
          const stockMap = new Map(stockData.data.map((item: Record<string, any>) => [item.item_id, item.current_stock]));

          const productsWithStock = productsData.data
            .filter((item: Product) => item.item_type === 'PRODUCT')
            .map((item: Product) => ({
              ...item,
              current_stock: stockMap.get(item.id) || 0
            }));

          setProducts(productsWithStock);
        }
      }
    } catch (error) {
      console.error('Failed to fetch initial data:', error);
    }
  };

  const checkStockAvailability = async () => {
    try {
      const response = await fetch('/api/inventory/shipping/stock-check', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
          items: formData.items.map(item => ({
            item_id: item.item_id,
            quantity: item.quantity
          }))
        }),
      });

      const data = await response.json();
      if (data.success) {
        const updatedItems = formData.items.map(item => {
          const stockInfo = data.data.find((s: any) => s.item_id === item.item_id);
          return {
            ...item,
            current_stock: stockInfo?.current_stock || 0,
            sufficient_stock: stockInfo ? stockInfo.sufficient_stock : false
          };
        });

        setFormData(prev => ({ ...prev, items: updatedItems }));
        setStockCheckComplete(true);
      }
    } catch (error) {
      console.error('Failed to check stock availability:', error);
      setStockCheckComplete(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'number' ? (value ? parseFloat(value) : 0) : value
    }));

    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleAddProduct = (item: Item | null) => {
    if (!item) return;

    // Check if product is already added
    const existingItem = formData.items.find(shipItem => shipItem.item_id === item.item_id);
    if (existingItem) {
      alert('이미 추가된 제품입니다.');
      return;
    }

    const newItem: ShippingItem = {
      item_id: item.item_id,
      item_code: item.item_code,
      item_name: item.item_name,
      unit: item.unit,
      unit_price: item.unit_price || 0,
      current_stock: item.current_stock || 0,
      quantity: 1,
      total_amount: item.unit_price || 0,
      sufficient_stock: (item.current_stock || 0) >= 1
    };

    setFormData(prev => ({
      ...prev,
      items: [...prev.items, newItem]
    }));

    setStockCheckComplete(false);
  };

  const handleCustomerChange = (customerId: number | null, customer?: Company) => {
    setFormData(prev => ({ ...prev, customer_id: customerId || undefined }));

    // Clear customer error
    if (errors.customer_id) {
      setErrors(prev => ({ ...prev, customer_id: '' }));
    }
  };

  const handleItemQuantityChange = (itemId: number, quantity: number) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map(item =>
        item.item_id === itemId
          ? {
              ...item,
              quantity: quantity,
              total_amount: quantity * item.unit_price,
              sufficient_stock: item.current_stock >= quantity
            }
          : item
      )
    }));
    setStockCheckComplete(false);
  };

  const handleItemUnitPriceChange = (itemId: number, unitPrice: number) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map(item =>
        item.item_id === itemId
          ? {
              ...item,
              unit_price: unitPrice,
              total_amount: item.quantity * unitPrice
            }
          : item
      )
    }));
  };

  const removeItem = (itemId: number) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.filter(item => item.item_id !== itemId)
    }));
  };

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.transaction_date) {
      newErrors.transaction_date = '출고일자는 필수입니다';
    }

    if (formData.items.length === 0) {
      newErrors.items = '출고할 제품을 하나 이상 추가해주세요';
    }

    // Check if any item has insufficient stock
    const insufficientItems = formData.items.filter(item => !item.sufficient_stock || item.current_stock < item.quantity);
    if (insufficientItems.length > 0) {
      newErrors.stock = '재고가 부족한 제품이 있습니다. 수량을 확인해주세요.';
    }

    // Check if any item has zero or negative quantity
    const invalidQuantityItems = formData.items.filter(item => item.quantity <= 0);
    if (invalidQuantityItems.length > 0) {
      newErrors.quantity = '모든 제품의 수량이 0보다 커야 합니다';
    }

    if (formData.delivery_date && formData.delivery_date < formData.transaction_date) {
      newErrors.delivery_date = '배송일은 출고일자보다 뒤여야 합니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;

    setLoading(true);
    try {
      const submissionData = {
        ...formData,
        created_by: 1 // Default user ID, should be from auth context
      };

      // Remove empty optional fields
      Object.keys(submissionData).forEach(key => {
        if (key !== 'items' && (submissionData[key as keyof typeof submissionData] === '' ||
            submissionData[key as keyof typeof submissionData] === undefined)) {
          delete submissionData[key as keyof typeof submissionData];
        }
      });

      await onSubmit(submissionData);
    } finally {
      setLoading(false);
    }
  };

  const generateShippingOrder = () => {
    const now = new Date();
    const timestamp = now.toISOString().replace(/[-:T]/g, '').slice(0, 12);
    return `SHP-${timestamp}`;
  };

  const handleGenerateReference = () => {
    setFormData(prev => ({
      ...prev,
      reference_no: generateShippingOrder()
    }));
  };

  const calculateTotalAmount = () => {
    return formData.items.reduce((total, item) => total + item.total_amount, 0);
  };

  const hasInsufficientStock = () => {
    return formData.items.some(item => !item.sufficient_stock || item.current_stock < item.quantity);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* 출고일자 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Calendar className="w-4 h-4 inline mr-2" />
            출고일자 <span className="text-red-500">*</span>
          </label>
          <input
            type="date"
            name="transaction_date"
            value={formData.transaction_date}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.transaction_date ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          />
          {errors.transaction_date && (
            <p className="mt-1 text-sm text-red-500">{errors.transaction_date}</p>
          )}
        </div>

        {/* 고객사 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Building2 className="w-4 h-4 inline mr-2" />
            고객사
          </label>
          <CompanySelect
            value={formData.customer_id}
            onChange={handleCustomerChange}
            companyType="CUSTOMER"
            placeholder="고객사를 선택하세요"
            required={false}
            error={errors.customer_id}
          />
        </div>

        {/* 출고번호 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            <Truck className="w-4 h-4 inline mr-2" />
            출고번호
          </label>
          <div className="flex gap-2">
            <input
              type="text"
              name="reference_no"
              value={formData.reference_no}
              onChange={handleChange}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="예: SHP-20240101001"
            />
            <button
              type="button"
              onClick={handleGenerateReference}
              className="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
              title="자동 생성"
            >
              <Plus className="w-4 h-4" />
            </button>
          </div>
        </div>

        {/* 배송일 */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            배송 예정일
          </label>
          <input
            type="date"
            name="delivery_date"
            value={formData.delivery_date}
            onChange={handleChange}
            className={`w-full px-4 py-2 border rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.delivery_date ? 'border-red-500' : 'border-gray-300 dark:border-gray-700'
            }`}
          />
          {errors.delivery_date && (
            <p className="mt-1 text-sm text-red-500">{errors.delivery_date}</p>
          )}
        </div>

        {/* 배송주소 */}
        <div className="md:col-span-2">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            배송주소
          </label>
          <input
            type="text"
            name="delivery_address"
            value={formData.delivery_address}
            onChange={handleChange}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="예: 서울시 강남구 테헤란로 123"
          />
        </div>
      </div>

      {/* Product Search and Selection */}
      <div>
        <ItemSelect
          onChange={handleAddProduct}
          label="출고 제품 추가"
          placeholder="제품 품번 또는 품명으로 검색하여 추가..."
          required={true}
          showPrice={true}
          itemType="PRODUCT"
          className=""
          error={errors.items}
        />
      </div>

      {/* Selected Items */}
      {formData.items.length > 0 && (
        <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
          <div className="flex items-center justify-between mb-4">
            <h4 className="text-lg font-medium text-gray-900 dark:text-white">
              출고 제품 목록
            </h4>
            {!stockCheckComplete && (
              <button
                type="button"
                onClick={checkStockAvailability}
                className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
              >
                재고 확인
              </button>
            )}
          </div>

          {hasInsufficientStock() && stockCheckComplete && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <div className="flex items-center gap-2">
                <AlertTriangle className="w-4 h-4 text-red-500" />
                <span className="text-sm font-medium text-red-600 dark:text-red-400">
                  일부 제품의 재고가 부족합니다
                </span>
              </div>
            </div>
          )}

          {errors.stock && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <p className="text-sm text-red-600 dark:text-red-400">{errors.stock}</p>
            </div>
          )}

          {errors.quantity && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
              <p className="text-sm text-red-600 dark:text-red-400">{errors.quantity}</p>
            </div>
          )}

          <div className="space-y-3">
            {formData.items.map((item, index) => (
              <div
                key={item.item_id}
                className={`p-4 border rounded-lg ${
                  stockCheckComplete && !item.sufficient_stock
                    ? 'border-red-300 bg-red-50 dark:bg-red-900/10'
                    : 'border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      <span className="text-sm font-medium text-gray-900 dark:text-white">
                        {item.item_code} - {item.item_name}
                      </span>
                      {stockCheckComplete && (
                        item.sufficient_stock ? (
                          <CheckCircle className="w-4 h-4 text-green-500" />
                        ) : (
                          <AlertTriangle className="w-4 h-4 text-red-500" />
                        )
                      )}
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                      <div>
                        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">
                          수량 ({item.unit})
                        </label>
                        <input
                          type="number"
                          value={item.quantity}
                          onChange={(e) => handleItemQuantityChange(item.item_id, parseFloat(e.target.value) || 0)}
                          min="0"
                          step="0.01"
                          className="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                        />
                      </div>

                      <div>
                        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">
                          단가 (₩)
                        </label>
                        <input
                          type="number"
                          value={item.unit_price}
                          onChange={(e) => handleItemUnitPriceChange(item.item_id, parseFloat(e.target.value) || 0)}
                          min="0"
                          step="0.01"
                          className="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                        />
                      </div>

                      <div>
                        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">
                          현재고
                        </label>
                        <span className="text-sm text-gray-900 dark:text-white">
                          {item.current_stock.toLocaleString()} {item.unit}
                        </span>
                      </div>

                      <div>
                        <label className="block text-xs text-gray-500 dark:text-gray-400 mb-1">
                          합계금액
                        </label>
                        <span className="text-sm font-medium text-gray-900 dark:text-white">
                          ₩{item.total_amount.toLocaleString()}
                        </span>
                      </div>
                    </div>

                    {stockCheckComplete && !item.sufficient_stock && (
                      <p className="mt-2 text-xs text-red-600 dark:text-red-400">
                        재고 부족: 필요 {item.quantity.toLocaleString()}{item.unit},
                        보유 {item.current_stock.toLocaleString()}{item.unit}
                      </p>
                    )}
                  </div>

                  <button
                    type="button"
                    onClick={() => removeItem(item.item_id)}
                    className="ml-4 p-1 text-red-500 hover:text-red-700 transition-colors"
                  >
                    <X className="w-4 h-4" />
                  </button>
                </div>
              </div>
            ))}
          </div>

          {/* Total Summary */}
          <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
                총 출고 금액:
              </span>
              <span className="text-lg font-bold text-blue-600 dark:text-blue-400">
                ₩{calculateTotalAmount().toLocaleString()}
              </span>
            </div>
          </div>
        </div>
      )}

      {/* 메모 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          메모
        </label>
        <textarea
          name="notes"
          value={formData.notes}
          onChange={handleChange}
          rows={3}
          className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="출고 관련 특이사항이나 메모를 입력하세요"
        />
      </div>

      {/* Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t border-gray-200 dark:border-gray-700">
        <button
          type="button"
          onClick={onCancel}
          className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
        >
          취소
        </button>
        <button
          type="submit"
          disabled={loading || hasInsufficientStock() || formData.items.length === 0}
          className="flex items-center gap-2 px-6 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              출고 중...
            </>
          ) : (
            <>
              <Save className="w-5 h-5" />
              출고 등록
            </>
          )}
        </button>
      </div>
    </form>
  );
}
```


#### 📄 src\components\StockAdjustmentForm.tsx

```typescript
'use client';

import { useState } from 'react';
import { Plus, X } from 'lucide-react';
import ItemSelect from './ItemSelect';
import { ItemForComponent } from '@/types/inventory';

interface StockAdjustmentFormProps {
  onSubmit: (formData: any) => void;
  onCancel: () => void;
}

interface FormData {
  item_id: number | null;
  adjustment_type: 'INCREASE' | 'DECREASE' | 'SET';
  quantity: number;
  reason: string;
  reference_no: string;
  notes: string;
}

const ADJUSTMENT_TYPES = [
  { value: 'INCREASE', label: '재고 증가' },
  { value: 'DECREASE', label: '재고 감소' },
  { value: 'SET', label: '재고 설정' }
];

const ADJUSTMENT_REASONS = [
  '실사 조정',
  '손상품 처리',
  '유통기한 만료',
  '도난/분실',
  '시스템 오류 수정',
  '공정 손실',
  '기타'
];

export default function StockAdjustmentForm({ onSubmit, onCancel }: StockAdjustmentFormProps) {
  const [formData, setFormData] = useState<FormData>({
    item_id: null,
    adjustment_type: 'INCREASE',
    quantity: 0,
    reason: '',
    reference_no: '',
    notes: ''
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!formData.item_id) {
      newErrors.item_id = '품목을 선택해주세요.';
    }

    if (!formData.quantity || formData.quantity === 0) {
      newErrors.quantity = '조정 수량을 입력해주세요.';
    } else if (formData.quantity < 0) {
      newErrors.quantity = '수량은 0보다 커야 합니다.';
    }

    if (!formData.reason) {
      newErrors.reason = '조정 사유를 선택해주세요.';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    // Add created_by (임시로 1로 설정 - 실제로는 로그인한 사용자 ID 사용)
    const submitData = {
      ...formData,
      created_by: 1
    };

    onSubmit(submitData);
  };

  const handleItemSelect = (item: ItemForComponent | null) => {
    if (!item) return;
    setFormData(prev => ({
      ...prev,
      item_id: item.item_id
    }));
    if (errors.item_id) {
      setErrors(prev => ({ ...prev, item_id: '' }));
    }
  };

  const handleQuantityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseFloat(e.target.value) || 0;
    setFormData(prev => ({
      ...prev,
      quantity: value
    }));
    if (errors.quantity) {
      setErrors(prev => ({ ...prev, quantity: '' }));
    }
  };

  const handleReasonChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setFormData(prev => ({
      ...prev,
      reason: e.target.value
    }));
    if (errors.reason) {
      setErrors(prev => ({ ...prev, reason: '' }));
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* 품목 선택 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          품목 <span className="text-red-500">*</span>
        </label>
        <ItemSelect
          onChange={handleItemSelect}
          placeholder="품목을 선택하세요"
        />
        {errors.item_id && (
          <p className="mt-1 text-sm text-red-600 dark:text-red-400">{errors.item_id}</p>
        )}
      </div>

      {/* 조정 유형 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          조정 유형 <span className="text-red-500">*</span>
        </label>
        <select
          value={formData.adjustment_type}
          onChange={(e) => setFormData(prev => ({ ...prev, adjustment_type: e.target.value as any }))}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
        >
          {ADJUSTMENT_TYPES.map(type => (
            <option key={type.value} value={type.value}>
              {type.label}
            </option>
          ))}
        </select>
      </div>

      {/* 수량 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          수량 <span className="text-red-500">*</span>
        </label>
        <div className="flex items-center space-x-2">
          <input
            type="number"
            step="0.01"
            min="0"
            value={formData.quantity || ''}
            onChange={handleQuantityChange}
            placeholder="조정할 수량을 입력하세요"
            className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
          />
          {formData.adjustment_type === 'SET' && (
            <span className="text-sm text-gray-500 dark:text-gray-400">
              (현재 재고를 이 값으로 설정)
            </span>
          )}
        </div>
        {errors.quantity && (
          <p className="mt-1 text-sm text-red-600 dark:text-red-400">{errors.quantity}</p>
        )}
      </div>

      {/* 조정 사유 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          조정 사유 <span className="text-red-500">*</span>
        </label>
        <select
          value={formData.reason}
          onChange={handleReasonChange}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
        >
          <option value="">사유를 선택하세요</option>
          {ADJUSTMENT_REASONS.map(reason => (
            <option key={reason} value={reason}>
              {reason}
            </option>
          ))}
        </select>
        {errors.reason && (
          <p className="mt-1 text-sm text-red-600 dark:text-red-400">{errors.reason}</p>
        )}
      </div>

      {/* 참조번호 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          참조번호
        </label>
        <input
          type="text"
          value={formData.reference_no}
          onChange={(e) => setFormData(prev => ({ ...prev, reference_no: e.target.value }))}
          placeholder="참조번호 (선택사항)"
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white"
        />
      </div>

      {/* 비고 */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          비고
        </label>
        <textarea
          value={formData.notes}
          onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}
          placeholder="추가 설명이나 비고사항을 입력하세요"
          rows={3}
          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white resize-none"
        />
      </div>

      {/* 버튼 */}
      <div className="flex justify-end space-x-3">
        <button
          type="button"
          onClick={onCancel}
          className="flex items-center gap-2 px-4 py-2 text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
        >
          <X className="w-4 h-4" />
          취소
        </button>
        <button
          type="submit"
          className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
        >
          <Plus className="w-4 h-4" />
          조정 등록
        </button>
      </div>
    </form>
  );
}
```


#### 📄 src\components\Toast.tsx

```typescript
'use client';

import React, { useEffect, useState, useCallback } from 'react';
import { X, CheckCircle, XCircle, AlertTriangle, Info, Undo2, ExternalLink } from 'lucide-react';

export type ToastType = 'success' | 'error' | 'warning' | 'info';

export interface ToastAction {
  label: string;
  onClick: () => void;
  style?: 'primary' | 'secondary';
  icon?: React.ComponentType<{ className?: string }>;
}

export interface ToastProps {
  id: string;
  type: ToastType;
  title: string;
  message?: string;
  duration?: number;
  showProgress?: boolean;
  persistent?: boolean;
  actions?: ToastAction[];
  onClose: (id: string) => void;
}

const Toast: React.FC<ToastProps> = ({
  id,
  type,
  title,
  message,
  duration = 3000,
  showProgress = true,
  persistent = false,
  actions = [],
  onClose,
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isExiting, setIsExiting] = useState(false);
  const [progress, setProgress] = useState(100);
  const [isPaused, setIsPaused] = useState(false);

  const handleClose = useCallback(() => {
    setIsExiting(true);
    setTimeout(() => onClose(id), 300);
  }, [id, onClose]);

  useEffect(() => {
    // Trigger entrance animation immediately after mount
    const enterTimer = setTimeout(() => setIsVisible(true), 10);

    // Auto-dismiss logic (only if not persistent)
    let dismissTimer: NodeJS.Timeout;
    let progressTimer: NodeJS.Timeout;

    if (!persistent && duration > 0) {
      // Progress bar animation
      const startTime = Date.now();
      const updateProgress = () => {
        if (isPaused) {
          progressTimer = setTimeout(updateProgress, 50);
          return;
        }

        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, duration - elapsed);
        const progressPercent = (remaining / duration) * 100;

        setProgress(progressPercent);

        if (remaining <= 0) {
          handleClose();
        } else {
          progressTimer = setTimeout(updateProgress, 50);
        }
      };

      // Start progress animation after entrance
      setTimeout(() => {
        updateProgress();
      }, 300);

      // Fallback dismiss timer
      dismissTimer = setTimeout(() => {
        handleClose();
      }, duration + 300);
    }

    return () => {
      clearTimeout(enterTimer);
      clearTimeout(dismissTimer);
      clearTimeout(progressTimer);
    };
  }, [duration, persistent, isPaused, handleClose]);

  const handleMouseEnter = () => {
    if (!persistent) {
      setIsPaused(true);
    }
  };

  const handleMouseLeave = () => {
    if (!persistent) {
      setIsPaused(false);
    }
  };

  const getIcon = () => {
    const iconClass = "w-5 h-5 flex-shrink-0";

    switch (type) {
      case 'success':
        return <CheckCircle className={`${iconClass} text-green-500`} />;
      case 'error':
        return <XCircle className={`${iconClass} text-red-500`} />;
      case 'warning':
        return <AlertTriangle className={`${iconClass} text-yellow-500`} />;
      case 'info':
        return <Info className={`${iconClass} text-blue-500`} />;
    }
  };

  const getColorClasses = () => {
    switch (type) {
      case 'success':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-green-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-green-500'
        };
      case 'error':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-red-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-red-500'
        };
      case 'warning':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-yellow-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-yellow-500'
        };
      case 'info':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-blue-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-blue-500'
        };
    }
  };

  const colorClasses = getColorClasses();

  return (
    <div
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className={`
        relative max-w-sm w-full shadow-lg rounded-lg pointer-events-auto
        ring-1 ring-black ring-opacity-5 dark:ring-white dark:ring-opacity-10 overflow-hidden
        transform transition-all duration-300 ease-out backdrop-blur-sm
        ${isVisible && !isExiting
          ? 'translate-x-0 opacity-100 scale-100'
          : 'translate-x-full opacity-0 scale-95'
        }
        ${colorClasses.container}
      `}
    >
      {/* Progress bar */}
      {showProgress && !persistent && duration > 0 && (
        <div className="absolute top-0 left-0 right-0 h-1 bg-gray-200 dark:bg-gray-700">
          <div
            className={`h-full transition-all duration-75 ease-linear ${colorClasses.progress}`}
            style={{ width: `${progress}%` }}
          />
        </div>
      )}

      <div className="p-4">
        <div className="flex items-start">
          <div className="flex-shrink-0 mt-0.5">
            {getIcon()}
          </div>
          <div className="ml-3 w-0 flex-1">
            <p className={`text-sm font-semibold leading-tight ${colorClasses.text}`}>
              {title}
            </p>
            {message && (
              <p className={`mt-1 text-sm opacity-80 leading-relaxed ${colorClasses.text}`}>
                {message}
              </p>
            )}

            {/* Action buttons */}
            {actions.length > 0 && (
              <div className="mt-3 flex gap-2 flex-wrap">
                {actions.map((action, index) => (
                  <button
                    key={index}
                    type="button"
                    onClick={action.onClick}
                    className={`
                      inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-md
                      transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2
                      focus:ring-blue-500 dark:focus:ring-offset-gray-800
                      ${action.style === 'primary'
                        ? `bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600`
                        : `bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600`
                      }
                    `}
                  >
                    {action.icon && <action.icon className="w-3 h-3" />}
                    {action.label}
                  </button>
                ))}
              </div>
            )}
          </div>
          <div className="ml-4 flex-shrink-0 flex">
            <button
              type="button"
              className="inline-flex rounded-md p-1.5 text-gray-400 dark:text-gray-500
                hover:text-gray-600 dark:hover:text-gray-300
                hover:bg-gray-100 dark:hover:bg-gray-700
                focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500
                dark:focus:ring-offset-gray-800 transition-colors"
              onClick={handleClose}
              aria-label="토스트 알림 닫기"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Toast;
```


#### 📄 src\components\ui\alert.tsx

```typescript
/**
 * Alert Component
 * Simple alert UI component for notifications and messages
 */

import React from 'react';

type AlertVariant = 'default' | 'info' | 'warning' | 'error' | 'success';

interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  variant?: AlertVariant;
}

const variantStyles: Record<AlertVariant, string> = {
  default: 'border-gray-200 bg-gray-50 text-gray-900 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100',
  info: 'border-blue-200 bg-blue-50 text-blue-900 dark:border-blue-800 dark:bg-blue-900/20 dark:text-blue-300',
  warning: 'border-yellow-200 bg-yellow-50 text-yellow-900 dark:border-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-300',
  error: 'border-red-200 bg-red-50 text-red-900 dark:border-red-800 dark:bg-red-900/20 dark:text-red-300',
  success: 'border-green-200 bg-green-50 text-green-900 dark:border-green-800 dark:bg-green-900/20 dark:text-green-300'
};

export const Alert: React.FC<AlertProps> = ({
  children,
  variant = 'default',
  className = '',
  ...props
}) => {
  return (
    <div
      className={`border rounded-lg p-4 ${variantStyles[variant]} ${className}`}
      role="alert"
      {...props}
    >
      {children}
    </div>
  );
};

interface AlertDescriptionProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const AlertDescription: React.FC<AlertDescriptionProps> = ({
  children,
  className = '',
  ...props
}) => {
  return (
    <div className={`text-sm ${className}`} {...props}>
      {children}
    </div>
  );
};

```


#### 📄 src\components\ui\badge.tsx

```typescript
/**
 * Badge Component
 * Simple badge UI component for labels and status indicators
 */

import React from 'react';

type BadgeVariant = 'default' | 'outline' | 'secondary';

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement> {
  children: React.ReactNode;
  variant?: BadgeVariant;
}

const variantStyles: Record<BadgeVariant, string> = {
  default: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300',
  outline: 'border border-gray-300 text-gray-700 dark:border-gray-600 dark:text-gray-300',
  secondary: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
};

export const Badge: React.FC<BadgeProps> = ({
  children,
  variant = 'default',
  className = '',
  ...props
}) => {
  return (
    <span
      className={`inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full ${variantStyles[variant]} ${className}`}
      {...props}
    >
      {children}
    </span>
  );
};

```


#### 📄 src\components\ui\button.tsx

```typescript
/**
 * Button Component
 * Simple button UI component with variants
 */

import React from 'react';

type ButtonVariant = 'default' | 'outline' | 'ghost' | 'destructive';
type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  variant?: ButtonVariant;
  size?: ButtonSize;
}

const variantStyles: Record<ButtonVariant, string> = {
  default: 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600',
  outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:text-gray-300 dark:hover:bg-gray-800',
  ghost: 'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-800',
  destructive: 'bg-red-600 text-white hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600'
};

const sizeStyles: Record<ButtonSize, string> = {
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg'
};

export const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'default',
  size = 'md',
  className = '',
  disabled = false,
  ...props
}) => {
  return (
    <button
      className={`inline-flex items-center justify-center font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
};

```


#### 📄 src\components\ui\card.tsx

```typescript
/**
 * Card Component
 * Simple card UI component for layouts
 */

import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const Card: React.FC<CardProps> = ({ children, className = '', ...props }) => {
  return (
    <div
      className={`bg-white dark:bg-gray-900 rounded-lg shadow-sm ${className}`}
      {...props}
    >
      {children}
    </div>
  );
};

interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const CardHeader: React.FC<CardHeaderProps> = ({ children, className = '', ...props }) => {
  return (
    <div
      className={`p-6 border-b border-gray-200 dark:border-gray-700 ${className}`}
      {...props}
    >
      {children}
    </div>
  );
};

interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> {
  children: React.ReactNode;
}

export const CardTitle: React.FC<CardTitleProps> = ({ children, className = '', ...props }) => {
  return (
    <h3
      className={`text-lg font-semibold text-gray-900 dark:text-white ${className}`}
      {...props}
    >
      {children}
    </h3>
  );
};

interface CardContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const CardContent: React.FC<CardContentProps> = ({ children, className = '', ...props }) => {
  return (
    <div className={`p-6 ${className}`} {...props}>
      {children}
    </div>
  );
};

```


#### 📄 src\components\ui\LoadingSpinner.tsx

```typescript
import React from 'react';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  color?: 'primary' | 'secondary' | 'white' | 'gray';
  text?: string;
  className?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  color = 'primary',
  text,
  className = ''
}) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8',
    xl: 'h-12 w-12'
  };

  const colorClasses = {
    primary: 'text-blue-600 dark:text-blue-400',
    secondary: 'text-gray-600 dark:text-gray-400',
    white: 'text-white',
    gray: 'text-gray-500'
  };

  return (
    <div className={`flex items-center justify-center ${className}`}>
      <div className="flex flex-col items-center space-y-2">
        <svg
          className={`animate-spin ${sizeClasses[size]} ${colorClasses[color]}`}
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          aria-label="로딩 중"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
        {text && (
          <span className={`text-sm ${colorClasses[color]}`}>
            {text}
          </span>
        )}
      </div>
    </div>
  );
};

// Full screen loading overlay
interface LoadingOverlayProps {
  text?: string;
  isVisible?: boolean;
}

export const LoadingOverlay: React.FC<LoadingOverlayProps> = ({
  text = "로딩 중...",
  isVisible = true
}) => {
  if (!isVisible) return null;

  return (
    <div className="fixed inset-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm z-50 flex items-center justify-center">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg border border-gray-200 dark:border-gray-700">
        <LoadingSpinner size="lg" text={text} />
      </div>
    </div>
  );
};

// Inline loading for buttons
interface ButtonLoadingProps {
  isLoading?: boolean;
  text?: string;
  loadingText?: string;
  disabled?: boolean;
  onClick?: () => void;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export const ButtonLoading: React.FC<ButtonLoadingProps> = ({
  isLoading = false,
  text = "확인",
  loadingText = "처리 중...",
  disabled = false,
  onClick,
  variant = 'primary',
  size = 'md',
  className = ''
}) => {
  const variantClasses = {
    primary: 'bg-blue-600 hover:bg-blue-700 text-white',
    secondary: 'bg-gray-600 hover:bg-gray-700 text-white',
    danger: 'bg-red-600 hover:bg-red-700 text-white'
  };

  const sizeClasses = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2',
    lg: 'px-6 py-3 text-lg'
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled || isLoading}
      className={`
        inline-flex items-center justify-center space-x-2 rounded-md font-medium
        transition-colors duration-200
        disabled:opacity-50 disabled:cursor-not-allowed
        ${variantClasses[variant]}
        ${sizeClasses[size]}
        ${className}
      `}
    >
      {isLoading && (
        <LoadingSpinner
          size={size === 'lg' ? 'md' : 'sm'}
          color="white"
        />
      )}
      <span>{isLoading ? loadingText : text}</span>
    </button>
  );
};

// Content loading placeholder
interface ContentLoadingProps {
  title?: string;
  subtitle?: string;
}

export const ContentLoading: React.FC<ContentLoadingProps> = ({
  title = "데이터를 불러오는 중...",
  subtitle = "잠시만 기다려 주세요."
}) => {
  return (
    <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
      <LoadingSpinner size="lg" />
      <h3 className="mt-4 text-lg font-medium text-gray-900 dark:text-gray-100">
        {title}
      </h3>
      <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
        {subtitle}
      </p>
    </div>
  );
};

export default LoadingSpinner;
```


#### 📄 src\components\ui\Skeleton.tsx

```typescript
import React from 'react';

interface SkeletonProps {
  className?: string;
}

// Base skeleton component
export const Skeleton: React.FC<SkeletonProps> = ({ className = '' }) => {
  return (
    <div
      className={`animate-pulse bg-gray-200 dark:bg-gray-700 rounded ${className}`}
      aria-label="로딩 중..."
    />
  );
};

// Table skeleton for data tables
interface TableSkeletonProps {
  rows?: number;
  columns?: number;
  showHeader?: boolean;
}

export const TableSkeleton: React.FC<TableSkeletonProps> = ({
  rows = 5,
  columns = 4,
  showHeader = true
}) => {
  return (
    <div className="w-full">
      {/* Table header */}
      {showHeader && (
        <div className="border-b border-gray-200 dark:border-gray-700 pb-3 mb-4">
          <div className="grid gap-4" style={{ gridTemplateColumns: `repeat(${columns}, 1fr)` }}>
            {Array.from({ length: columns }).map((_, index) => (
              <Skeleton key={`header-${index}`} className="h-5 w-20" />
            ))}
          </div>
        </div>
      )}

      {/* Table rows */}
      <div className="space-y-3">
        {Array.from({ length: rows }).map((_, rowIndex) => (
          <div
            key={`row-${rowIndex}`}
            className="grid gap-4 py-3 border-b border-gray-100 dark:border-gray-800"
            style={{ gridTemplateColumns: `repeat(${columns}, 1fr)` }}
          >
            {Array.from({ length: columns }).map((_, colIndex) => (
              <Skeleton
                key={`cell-${rowIndex}-${colIndex}`}
                className={`h-4 ${
                  colIndex === 0 ? 'w-24' :
                  colIndex === 1 ? 'w-32' :
                  colIndex === 2 ? 'w-20' : 'w-16'
                }`}
              />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

// Card skeleton for dashboard widgets
interface CardSkeletonProps {
  showTitle?: boolean;
  showContent?: boolean;
  contentLines?: number;
}

export const CardSkeleton: React.FC<CardSkeletonProps> = ({
  showTitle = true,
  showContent = true,
  contentLines = 3
}) => {
  return (
    <div className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
      {/* Card title */}
      {showTitle && (
        <div className="mb-4">
          <Skeleton className="h-6 w-32" />
        </div>
      )}

      {/* Card content */}
      {showContent && (
        <div className="space-y-3">
          {Array.from({ length: contentLines }).map((_, index) => (
            <Skeleton
              key={`content-${index}`}
              className={`h-4 ${
                index === 0 ? 'w-full' :
                index === 1 ? 'w-3/4' : 'w-1/2'
              }`}
            />
          ))}
        </div>
      )}
    </div>
  );
};

// Form skeleton for loading forms
interface FormSkeletonProps {
  fields?: number;
  showButtons?: boolean;
}

export const FormSkeleton: React.FC<FormSkeletonProps> = ({
  fields = 4,
  showButtons = true
}) => {
  return (
    <div className="space-y-6">
      {/* Form fields */}
      {Array.from({ length: fields }).map((_, index) => (
        <div key={`field-${index}`} className="space-y-2">
          <Skeleton className="h-4 w-20" /> {/* Label */}
          <Skeleton className="h-10 w-full" /> {/* Input */}
        </div>
      ))}

      {/* Form buttons */}
      {showButtons && (
        <div className="flex justify-end space-x-3 pt-4">
          <Skeleton className="h-10 w-20" />
          <Skeleton className="h-10 w-20" />
        </div>
      )}
    </div>
  );
};

// List skeleton for simple lists
interface ListSkeletonProps {
  items?: number;
  showAvatar?: boolean;
}

export const ListSkeleton: React.FC<ListSkeletonProps> = ({
  items = 6,
  showAvatar = false
}) => {
  return (
    <div className="space-y-4">
      {Array.from({ length: items }).map((_, index) => (
        <div key={`item-${index}`} className="flex items-center space-x-4">
          {showAvatar && <Skeleton className="h-10 w-10 rounded-full" />}
          <div className="flex-1 space-y-2">
            <Skeleton className="h-4 w-3/4" />
            <Skeleton className="h-3 w-1/2" />
          </div>
        </div>
      ))}
    </div>
  );
};

// Stats skeleton for dashboard metrics
export const StatsSkeleton: React.FC = () => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
      {Array.from({ length: 4 }).map((_, index) => (
        <div
          key={`stat-${index}`}
          className="p-6 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
        >
          <div className="flex items-center justify-between">
            <div className="space-y-2">
              <Skeleton className="h-4 w-16" /> {/* Label */}
              <Skeleton className="h-8 w-20" /> {/* Value */}
            </div>
            <Skeleton className="h-12 w-12 rounded-lg" /> {/* Icon */}
          </div>
        </div>
      ))}
    </div>
  );
};

export default Skeleton;
```


#### 📄 src\components\ui\Toast.tsx

```typescript
'use client';

import React, { useEffect, useState, useCallback } from 'react';
import { X, CheckCircle, XCircle, AlertTriangle, Info, Undo2, ExternalLink } from 'lucide-react';

export type ToastType = 'success' | 'error' | 'warning' | 'info';

export interface ToastAction {
  label: string;
  onClick: () => void;
  style?: 'primary' | 'secondary';
  icon?: React.ComponentType<{ className?: string }>;
}

export interface ToastProps {
  id: string;
  type: ToastType;
  title: string;
  message?: string;
  duration?: number;
  showProgress?: boolean;
  persistent?: boolean;
  actions?: ToastAction[];
  onClose: (id: string) => void;
}

const Toast: React.FC<ToastProps> = ({
  id,
  type,
  title,
  message,
  duration = 3000,
  showProgress = true,
  persistent = false,
  actions = [],
  onClose,
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isExiting, setIsExiting] = useState(false);
  const [progress, setProgress] = useState(100);
  const [isPaused, setIsPaused] = useState(false);

  const handleClose = useCallback(() => {
    setIsExiting(true);
    setTimeout(() => onClose(id), 300);
  }, [id, onClose]);

  useEffect(() => {
    // Trigger entrance animation immediately after mount
    const enterTimer = setTimeout(() => setIsVisible(true), 10);

    // Auto-dismiss logic (only if not persistent)
    let dismissTimer: NodeJS.Timeout;
    let progressTimer: NodeJS.Timeout;

    if (!persistent && duration > 0) {
      // Progress bar animation
      const startTime = Date.now();
      const updateProgress = () => {
        if (isPaused) {
          progressTimer = setTimeout(updateProgress, 50);
          return;
        }

        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, duration - elapsed);
        const progressPercent = (remaining / duration) * 100;

        setProgress(progressPercent);

        if (remaining <= 0) {
          handleClose();
        } else {
          progressTimer = setTimeout(updateProgress, 50);
        }
      };

      // Start progress animation after entrance
      setTimeout(() => {
        updateProgress();
      }, 300);

      // Fallback dismiss timer
      dismissTimer = setTimeout(() => {
        handleClose();
      }, duration + 300);
    }

    return () => {
      clearTimeout(enterTimer);
      clearTimeout(dismissTimer);
      clearTimeout(progressTimer);
    };
  }, [duration, persistent, isPaused, handleClose]);

  const handleMouseEnter = () => {
    if (!persistent) {
      setIsPaused(true);
    }
  };

  const handleMouseLeave = () => {
    if (!persistent) {
      setIsPaused(false);
    }
  };

  const getIcon = () => {
    const iconClass = "w-5 h-5 flex-shrink-0";

    switch (type) {
      case 'success':
        return <CheckCircle className={`${iconClass} text-green-500`} />;
      case 'error':
        return <XCircle className={`${iconClass} text-red-500`} />;
      case 'warning':
        return <AlertTriangle className={`${iconClass} text-yellow-500`} />;
      case 'info':
        return <Info className={`${iconClass} text-blue-500`} />;
    }
  };

  const getColorClasses = () => {
    switch (type) {
      case 'success':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-green-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-green-500'
        };
      case 'error':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-red-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-red-500'
        };
      case 'warning':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-yellow-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-yellow-500'
        };
      case 'info':
        return {
          container: 'bg-white dark:bg-gray-800 border-l-4 border-l-blue-500',
          text: 'text-gray-900 dark:text-white',
          progress: 'bg-blue-500'
        };
    }
  };

  const colorClasses = getColorClasses();

  return (
    <div
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className={`
        relative max-w-sm w-full shadow-lg rounded-lg pointer-events-auto
        ring-1 ring-black ring-opacity-5 dark:ring-white dark:ring-opacity-10 overflow-hidden
        transform transition-all duration-300 ease-out backdrop-blur-sm
        ${isVisible && !isExiting
          ? 'translate-x-0 opacity-100 scale-100'
          : 'translate-x-full opacity-0 scale-95'
        }
        ${colorClasses.container}
      `}
    >
      {/* Progress bar */}
      {showProgress && !persistent && duration > 0 && (
        <div className="absolute top-0 left-0 right-0 h-1 bg-gray-200 dark:bg-gray-700">
          <div
            className={`h-full transition-all duration-75 ease-linear ${colorClasses.progress}`}
            style={{ width: `${progress}%` }}
          />
        </div>
      )}

      <div className="p-4">
        <div className="flex items-start">
          <div className="flex-shrink-0 mt-0.5">
            {getIcon()}
          </div>
          <div className="ml-3 w-0 flex-1">
            <p className={`text-sm font-semibold leading-tight ${colorClasses.text}`}>
              {title}
            </p>
            {message && (
              <p className={`mt-1 text-sm opacity-80 leading-relaxed ${colorClasses.text}`}>
                {message}
              </p>
            )}

            {/* Action buttons */}
            {actions.length > 0 && (
              <div className="mt-3 flex gap-2 flex-wrap">
                {actions.map((action, index) => (
                  <button
                    key={index}
                    type="button"
                    onClick={action.onClick}
                    className={`
                      inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-md
                      transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2
                      focus:ring-blue-500 dark:focus:ring-offset-gray-800
                      ${action.style === 'primary'
                        ? `bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600`
                        : `bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600`
                      }
                    `}
                  >
                    {action.icon && <action.icon className="w-3 h-3" />}
                    {action.label}
                  </button>
                ))}
              </div>
            )}
          </div>
          <div className="ml-4 flex-shrink-0 flex">
            <button
              type="button"
              className="inline-flex rounded-md p-1.5 text-gray-400 dark:text-gray-500
                hover:text-gray-600 dark:hover:text-gray-300
                hover:bg-gray-100 dark:hover:bg-gray-700
                focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500
                dark:focus:ring-offset-gray-800 transition-colors"
              onClick={handleClose}
              aria-label="토스트 알림 닫기"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Toast;
```


#### 📄 src\components\ui\VirtualGrid.tsx

```typescript
'use client';

import React, { useMemo, useState, useCallback } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import { Search, Filter, Grid, List } from 'lucide-react';
import { LoadingSpinner } from './LoadingSpinner';

// Grid item render function type
export type GridItemRenderer<T = any> = (
  item: T,
  index: number,
  isSelected?: boolean
) => React.ReactNode;

// Grid configuration
interface GridConfig {
  columns: number;
  gap: number;
  itemHeight: number;
  itemWidth?: number;
}

// Filter configuration
interface FilterConfig {
  [key: string]: string;
}

// Virtual grid props
interface VirtualGridProps<T = any> {
  data: T[];
  renderItem: GridItemRenderer<T>;
  height?: number;
  loading?: boolean;
  emptyMessage?: string;
  searchable?: boolean;
  searchKeys?: string[];
  searchPlaceholder?: string;
  filterable?: boolean;
  filters?: { key: string; label: string; options?: string[] }[];
  className?: string;
  itemClassName?: string | ((item: T, index: number) => string);
  onItemClick?: (item: T, index: number) => void;
  selectable?: boolean;
  selectedItems?: T[];
  onSelectionChange?: (selectedItems: T[]) => void;
  getItemKey?: (item: T, index: number) => string | number;
  overscan?: number;
  // Responsive grid configuration
  gridConfig?: {
    sm?: GridConfig;
    md?: GridConfig;
    lg?: GridConfig;
    xl?: GridConfig;
    '2xl'?: GridConfig;
  };
  // Default grid config
  defaultGridConfig?: GridConfig;
}

// Default responsive grid configurations
const defaultResponsiveConfig = {
  sm: { columns: 1, gap: 16, itemHeight: 200 },
  md: { columns: 2, gap: 16, itemHeight: 200 },
  lg: { columns: 3, gap: 20, itemHeight: 220 },
  xl: { columns: 4, gap: 20, itemHeight: 220 },
  '2xl': { columns: 5, gap: 24, itemHeight: 240 }
};

export function VirtualGrid<T extends Record<string, any>>({
  data,
  renderItem,
  height = 600,
  loading = false,
  emptyMessage = '데이터가 없습니다',
  searchable = true,
  searchKeys = [],
  searchPlaceholder = '검색...',
  filterable = true,
  filters = [],
  className = '',
  itemClassName = '',
  onItemClick,
  selectable = false,
  selectedItems = [],
  onSelectionChange,
  getItemKey,
  overscan = 5,
  gridConfig,
  defaultGridConfig = defaultResponsiveConfig.lg
}: VirtualGridProps<T>) {
  // Local state
  const [searchTerm, setSearchTerm] = useState('');
  const [activeFilters, setActiveFilters] = useState<FilterConfig>({});
  const [showFilters, setShowFilters] = useState(false);
  const [currentGridConfig, setCurrentGridConfig] = useState<GridConfig>(defaultGridConfig);

  // Container ref for virtualizer
  const parentRef = React.useRef<HTMLDivElement>(null);

  // Responsive grid handling
  React.useEffect(() => {
    if (!gridConfig) return;

    const handleResize = () => {
      const width = window.innerWidth;
      let config: GridConfig;

      if (width >= 1536 && gridConfig['2xl']) {
        config = gridConfig['2xl'];
      } else if (width >= 1280 && gridConfig.xl) {
        config = gridConfig.xl;
      } else if (width >= 1024 && gridConfig.lg) {
        config = gridConfig.lg;
      } else if (width >= 768 && gridConfig.md) {
        config = gridConfig.md;
      } else if (gridConfig.sm) {
        config = gridConfig.sm;
      } else {
        config = defaultGridConfig;
      }

      setCurrentGridConfig(config);
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [gridConfig, defaultGridConfig]);

  // Process data (filter and search)
  const processedData = useMemo(() => {
    let result = [...data];

    // Apply search
    if (searchTerm && searchKeys.length > 0) {
      result = result.filter(item =>
        searchKeys.some(key => {
          const value = item[key];
          return value?.toString().toLowerCase().includes(searchTerm.toLowerCase());
        })
      );
    } else if (searchTerm) {
      // Search all string properties if no specific keys provided
      result = result.filter(item =>
        Object.values(item).some(value =>
          value?.toString().toLowerCase().includes(searchTerm.toLowerCase())
        )
      );
    }

    // Apply filters
    Object.entries(activeFilters).forEach(([key, filterValue]) => {
      if (filterValue) {
        result = result.filter(item => {
          const value = item[key];
          return value?.toString().toLowerCase().includes(filterValue.toLowerCase());
        });
      }
    });

    return result;
  }, [data, searchTerm, searchKeys, activeFilters]);

  // Calculate grid layout
  const gridLayout = useMemo(() => {
    const { columns, gap, itemHeight, itemWidth } = currentGridConfig;
    const totalRows = Math.ceil(processedData.length / columns);
    const rowHeight = itemHeight + gap;

    return {
      columns,
      totalRows,
      rowHeight,
      itemHeight,
      itemWidth,
      gap
    };
  }, [currentGridConfig, processedData.length]);

  // Create virtualizer for rows
  const virtualizer = useVirtualizer({
    count: gridLayout.totalRows,
    getScrollElement: () => parentRef.current,
    estimateSize: () => gridLayout.rowHeight,
    overscan
  });

  // Handle filter change
  const handleFilterChange = useCallback((key: string, value: string) => {
    setActiveFilters(current => ({
      ...current,
      [key]: value
    }));
  }, []);

  // Clear all filters
  const clearFilters = useCallback(() => {
    setActiveFilters({});
    setSearchTerm('');
  }, []);

  // Handle item selection
  const handleItemSelect = useCallback((item: T, index: number) => {
    if (!selectable || !onSelectionChange) return;

    const itemKey = getItemKey ? getItemKey(item, index) : index;
    const isSelected = selectedItems.some((selected, idx) => {
      const selectedKey = getItemKey ? getItemKey(selected, idx) : idx;
      return selectedKey === itemKey;
    });

    if (isSelected) {
      onSelectionChange(selectedItems.filter((selected, idx) => {
        const selectedKey = getItemKey ? getItemKey(selected, idx) : idx;
        return selectedKey !== itemKey;
      }));
    } else {
      onSelectionChange([...selectedItems, item]);
    }
  }, [selectable, selectedItems, onSelectionChange, getItemKey]);

  // Get item class name
  const getItemClassName = useCallback((item: T, index: number) => {
    if (typeof itemClassName === 'function') {
      return itemClassName(item, index);
    }
    return itemClassName;
  }, [itemClassName]);

  // Check if item is selected
  const isItemSelected = useCallback((item: T, index: number) => {
    if (!selectable) return false;
    const itemKey = getItemKey ? getItemKey(item, index) : index;
    return selectedItems.some((selected, idx) => {
      const selectedKey = getItemKey ? getItemKey(selected, idx) : idx;
      return selectedKey === itemKey;
    });
  }, [selectable, selectedItems, getItemKey]);

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden ${className}`}>
      {/* Search and Filter Controls */}
      {(searchable || filterable) && (
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex flex-col sm:flex-row gap-4">
            {/* Search Input */}
            {searchable && (
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
                  <input
                    type="text"
                    placeholder={searchPlaceholder}
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              </div>
            )}

            {/* Controls */}
            <div className="flex gap-2">
              {/* Grid Config Display */}
              <div className="flex items-center px-3 py-2 text-sm text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <Grid className="w-4 h-4 mr-2" />
                {gridLayout.columns}열
              </div>

              {/* Filter Toggle */}
              {filterable && filters.length > 0 && (
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className={`flex items-center gap-2 px-4 py-2 border rounded-lg transition-colors ${
                    showFilters
                      ? 'bg-blue-50 border-blue-300 text-blue-700 dark:bg-blue-900 dark:border-blue-700 dark:text-blue-300'
                      : 'border-gray-300 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800'
                  }`}
                >
                  <Filter className="w-5 h-5" />
                  필터
                </button>
              )}

              {/* Clear Filters */}
              {(Object.values(activeFilters).some(v => v) || searchTerm) && (
                <button
                  onClick={clearFilters}
                  className="px-4 py-2 text-sm text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
                >
                  초기화
                </button>
              )}
            </div>
          </div>

          {/* Filter Inputs */}
          {filterable && showFilters && filters.length > 0 && (
            <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {filters.map(filter => (
                <div key={filter.key}>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    {filter.label}
                  </label>
                  {filter.options ? (
                    <select
                      value={activeFilters[filter.key] || ''}
                      onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                    >
                      <option value="">전체</option>
                      {filter.options.map(option => (
                        <option key={option} value={option}>{option}</option>
                      ))}
                    </select>
                  ) : (
                    <input
                      type="text"
                      placeholder={`${filter.label} 필터...`}
                      value={activeFilters[filter.key] || ''}
                      onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                      className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                    />
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Data Info */}
      <div className="px-4 py-2 text-sm text-gray-600 dark:text-gray-400 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
        <span>전체 {data.length}개 항목 중 {processedData.length}개 표시</span>
        {selectable && selectedItems.length > 0 && (
          <span className="text-blue-600 dark:text-blue-400">
            {selectedItems.length}개 선택됨
          </span>
        )}
      </div>

      {/* Virtual Grid */}
      <div
        ref={parentRef}
        className="overflow-auto"
        style={{ height: `${height}px` }}
      >
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <LoadingSpinner size="lg" text="데이터 로딩 중..." />
          </div>
        ) : processedData.length === 0 ? (
          <div className="flex items-center justify-center h-full text-gray-500 dark:text-gray-400">
            {emptyMessage}
          </div>
        ) : (
          <div
            style={{
              height: `${virtualizer.getTotalSize()}px`,
              width: '100%',
              position: 'relative',
              padding: `${gridLayout.gap}px`
            }}
          >
            {virtualizer.getVirtualItems().map((virtualRow) => {
              const startIndex = virtualRow.index * gridLayout.columns;
              const endIndex = Math.min(startIndex + gridLayout.columns, processedData.length);
              const rowItems = processedData.slice(startIndex, endIndex);

              return (
                <div
                  key={virtualRow.index}
                  className="absolute top-0 left-0 w-full"
                  style={{
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start}px)`
                  }}
                >
                  <div
                    className="grid h-full"
                    style={{
                      gridTemplateColumns: `repeat(${gridLayout.columns}, 1fr)`,
                      gap: `${gridLayout.gap}px`,
                      padding: `0 ${gridLayout.gap}px`
                    }}
                  >
                    {rowItems.map((item, columnIndex) => {
                      const itemIndex = startIndex + columnIndex;
                      const isSelected = isItemSelected(item, itemIndex);

                      return (
                        <div
                          key={getItemKey ? getItemKey(item, itemIndex) : itemIndex}
                          className={`relative transition-all duration-200 ${
                            onItemClick || selectable ? 'cursor-pointer' : ''
                          } ${isSelected ? 'ring-2 ring-blue-500 ring-opacity-50' : ''} ${
                            getItemClassName(item, itemIndex)
                          }`}
                          style={{
                            height: `${gridLayout.itemHeight}px`,
                            width: gridLayout.itemWidth || '100%'
                          }}
                          onClick={() => {
                            if (selectable) {
                              handleItemSelect(item, itemIndex);
                            }
                            onItemClick?.(item, itemIndex);
                          }}
                        >
                          {renderItem(item, itemIndex, isSelected)}

                          {/* Selection indicator */}
                          {selectable && isSelected && (
                            <div className="absolute top-2 right-2 w-6 h-6 bg-blue-500 text-white rounded-full flex items-center justify-center text-xs font-bold">
                              ✓
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}

export default VirtualGrid;
```


#### 📄 src\components\ui\VirtualTable.tsx

```typescript
'use client';

import React, { useMemo, useState, useCallback } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import { ChevronUp, ChevronDown, Filter, Search } from 'lucide-react';
import { LoadingSpinner } from './LoadingSpinner';

// Column definition interface
export interface VirtualTableColumn<T = any> {
  key: string;
  title: string;
  render?: (value: unknown, row: T, index: number) => React.ReactNode;
  sortable?: boolean;
  filterable?: boolean;
  width?: number | string;
  align?: 'left' | 'center' | 'right';
  className?: string;
}

// Sort configuration
interface SortConfig {
  key: string;
  direction: 'asc' | 'desc';
}

// Filter configuration
interface FilterConfig {
  [key: string]: string;
}

// Virtual table props
interface VirtualTableProps<T = any> {
  data: T[];
  columns: VirtualTableColumn<T>[];
  height?: number;
  rowHeight?: number;
  loading?: boolean;
  emptyMessage?: string;
  onRowClick?: (row: T, index: number) => void;
  sortable?: boolean;
  filterable?: boolean;
  searchable?: boolean;
  searchPlaceholder?: string;
  className?: string;
  headerClassName?: string;
  rowClassName?: string | ((row: T, index: number) => string);
  overscan?: number;
  stickyHeader?: boolean;
}

export function VirtualTable<T extends Record<string, any>>({
  data,
  columns,
  height = 600,
  rowHeight = 48,
  loading = false,
  emptyMessage = '데이터가 없습니다',
  onRowClick,
  sortable = true,
  filterable = true,
  searchable = true,
  searchPlaceholder = '검색...',
  className = '',
  headerClassName = '',
  rowClassName = '',
  overscan = 5,
  stickyHeader = true
}: VirtualTableProps<T>) {
  // Local state
  const [sortConfig, setSortConfig] = useState<SortConfig | null>(null);
  const [filters, setFilters] = useState<FilterConfig>({});
  const [searchTerm, setSearchTerm] = useState('');
  const [showFilters, setShowFilters] = useState(false);

  // Create container ref for virtualizer
  const parentRef = React.useRef<HTMLDivElement>(null);

  // Filter and sort data
  const processedData = useMemo(() => {
    let result = [...data];

    // Apply search
    if (searchTerm) {
      result = result.filter(row =>
        columns.some(column => {
          const value = row[column.key];
          return value?.toString().toLowerCase().includes(searchTerm.toLowerCase());
        })
      );
    }

    // Apply column filters
    Object.entries(filters).forEach(([key, filterValue]) => {
      if (filterValue) {
        result = result.filter(row => {
          const value = row[key];
          return value?.toString().toLowerCase().includes(filterValue.toLowerCase());
        });
      }
    });

    // Apply sorting
    if (sortConfig) {
      result.sort((a, b) => {
        const aVal = a[sortConfig.key];
        const bVal = b[sortConfig.key];

        if (aVal < bVal) return sortConfig.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return sortConfig.direction === 'asc' ? 1 : -1;
        return 0;
      });
    }

    return result;
  }, [data, searchTerm, filters, sortConfig, columns]);

  // Create virtualizer
  const virtualizer = useVirtualizer({
    count: processedData.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => rowHeight,
    overscan
  });

  // Handle sorting
  const handleSort = useCallback((key: string) => {
    if (!sortable) return;

    setSortConfig(current => {
      if (!current || current.key !== key) {
        return { key, direction: 'asc' };
      }
      if (current.direction === 'asc') {
        return { key, direction: 'desc' };
      }
      return null;
    });
  }, [sortable]);

  // Handle filter change
  const handleFilterChange = useCallback((key: string, value: string) => {
    setFilters(current => ({
      ...current,
      [key]: value
    }));
  }, []);

  // Clear all filters
  const clearFilters = useCallback(() => {
    setFilters({});
    setSearchTerm('');
  }, []);

  // Render cell content
  const renderCell = useCallback((column: VirtualTableColumn<T>, row: T, index: number) => {
    const value = row[column.key];

    if (column.render) {
      return column.render(value, row, index);
    }

    return value?.toString() || '-';
  }, []);

  // Get row class name
  const getRowClassName = useCallback((row: T, index: number) => {
    if (typeof rowClassName === 'function') {
      return rowClassName(row, index);
    }
    return rowClassName;
  }, [rowClassName]);

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden ${className}`}>
      {/* Search and Filter Controls */}
      {(searchable || filterable) && (
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex flex-col sm:flex-row gap-4">
            {/* Search Input */}
            {searchable && (
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
                  <input
                    type="text"
                    placeholder={searchPlaceholder}
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              </div>
            )}

            {/* Filter Toggle */}
            {filterable && (
              <div className="flex gap-2">
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className={`flex items-center gap-2 px-4 py-2 border rounded-lg transition-colors ${
                    showFilters
                      ? 'bg-blue-50 border-blue-300 text-blue-700 dark:bg-blue-900 dark:border-blue-700 dark:text-blue-300'
                      : 'border-gray-300 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800'
                  }`}
                >
                  <Filter className="w-5 h-5" />
                  필터
                </button>
                {(Object.values(filters).some(v => v) || searchTerm) && (
                  <button
                    onClick={clearFilters}
                    className="px-4 py-2 text-sm text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    초기화
                  </button>
                )}
              </div>
            )}
          </div>

          {/* Column Filters */}
          {filterable && showFilters && (
            <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {columns.filter(col => col.filterable !== false).map(column => (
                <div key={column.key}>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    {column.title}
                  </label>
                  <input
                    type="text"
                    placeholder={`${column.title} 필터...`}
                    value={filters[column.key] || ''}
                    onChange={(e) => handleFilterChange(column.key, e.target.value)}
                    className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                  />
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Data Info */}
      <div className="px-4 py-2 text-sm text-gray-600 dark:text-gray-400 border-b border-gray-200 dark:border-gray-700">
        전체 {data.length}개 항목 중 {processedData.length}개 표시
      </div>

      {/* Virtual Table */}
      <div
        ref={parentRef}
        className="overflow-auto"
        style={{ height: `${height}px` }}
      >
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <LoadingSpinner size="lg" text="데이터 로딩 중..." />
          </div>
        ) : processedData.length === 0 ? (
          <div className="flex items-center justify-center h-full text-gray-500 dark:text-gray-400">
            {emptyMessage}
          </div>
        ) : (
          <div
            style={{
              height: `${virtualizer.getTotalSize()}px`,
              width: '100%',
              position: 'relative'
            }}
          >
            {/* Sticky Header */}
            {stickyHeader && (
              <div
                className={`sticky top-0 z-10 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 ${headerClassName}`}
                style={{ height: `${rowHeight}px` }}
              >
                <div className="flex items-center h-full">
                  {columns.map((column, columnIndex) => (
                    <div
                      key={column.key}
                      className={`flex items-center justify-between px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider ${
                        column.className || ''
                      }`}
                      style={{
                        width: column.width || `${100 / columns.length}%`,
                        textAlign: column.align || 'left'
                      }}
                    >
                      <span className="truncate">{column.title}</span>
                      {sortable && column.sortable !== false && (
                        <button
                          onClick={() => handleSort(column.key)}
                          className="ml-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                        >
                          {sortConfig?.key === column.key ? (
                            sortConfig.direction === 'asc' ? (
                              <ChevronUp className="w-4 h-4" />
                            ) : (
                              <ChevronDown className="w-4 h-4" />
                            )
                          ) : (
                            <div className="w-4 h-4 flex flex-col justify-center">
                              <ChevronUp className="w-4 h-2" />
                              <ChevronDown className="w-4 h-2" />
                            </div>
                          )}
                        </button>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Virtual Rows */}
            {virtualizer.getVirtualItems().map((virtualRow) => {
              const row = processedData[virtualRow.index];
              return (
                <div
                  key={virtualRow.index}
                  className={`absolute top-0 left-0 w-full flex items-center border-b border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 ${
                    onRowClick ? 'cursor-pointer' : ''
                  } ${getRowClassName(row, virtualRow.index)}`}
                  style={{
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${virtualRow.start + (stickyHeader ? rowHeight : 0)}px)`
                  }}
                  onClick={() => onRowClick?.(row, virtualRow.index)}
                >
                  {columns.map((column) => (
                    <div
                      key={column.key}
                      className={`px-6 py-3 text-sm text-gray-900 dark:text-white ${
                        column.className || ''
                      }`}
                      style={{
                        width: column.width || `${100 / columns.length}%`,
                        textAlign: column.align || 'left'
                      }}
                    >
                      <div className="truncate">
                        {renderCell(column, row, virtualRow.index)}
                      </div>
                    </div>
                  ))}
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}

export default VirtualTable;
```


#### 📄 src\components\upload\ExcelUploadModal.tsx

```typescript
'use client';

import { useState, useRef, useCallback } from 'react';
import dynamic from 'next/dynamic';
import { Upload, Download, FileSpreadsheet, X, Loader2, AlertCircle } from 'lucide-react';
import { useToast } from '@/contexts/ToastContext';

// Dynamic import for Modal component to reduce initial bundle size
const Modal = dynamic(() => import('../Modal'), {
  loading: () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="animate-pulse">
          <div className="h-6 bg-gray-300 dark:bg-gray-600 rounded mb-4"></div>
          <div className="h-32 bg-gray-300 dark:bg-gray-600 rounded"></div>
        </div>
      </div>
    </div>
  ),
  ssr: false
});

interface ExcelUploadModalProps {
  isOpen: boolean;
  onClose: () => void;
  uploadUrl: string;
  title: string;
  onUploadSuccess: () => void;
}

export default function ExcelUploadModal({
  isOpen,
  onClose,
  uploadUrl,
  title,
  onUploadSuccess
}: ExcelUploadModalProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragOver, setIsDragOver] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState<string>('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { success, error: toastError } = useToast();

  // Allowed file types
  const allowedTypes = [
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
    'application/vnd.ms-excel' // .xls
  ];

  const allowedExtensions = ['.xlsx', '.xls'];

  const validateFile = (file: File): boolean => {
    // Check file type
    if (!allowedTypes.includes(file.type)) {
      const extension = '.' + file.name.split('.').pop()?.toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        setError('Excel 파일만 업로드 가능합니다. (.xlsx, .xls)');
        return false;
      }
    }

    // Check file size (10MB limit)
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      setError('파일 크기는 10MB를 초과할 수 없습니다.');
      return false;
    }

    setError('');
    return true;
  };

  const handleFileSelect = (file: File) => {
    if (validateFile(file)) {
      setSelectedFile(file);
    }
  };

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      handleFileSelect(files[0]);
    }
  }, []);

  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      handleFileSelect(files[0]);
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) return;

    setIsUploading(true);
    setUploadProgress(0);
    setError('');

    try {
      // Simulate upload progress
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          if (prev >= 90) return prev;
          return prev + 10;
        });
      }, 100);

      // Upload file using FormData
      const formData = new FormData();
      formData.append('file', selectedFile);

      const response = await fetch(uploadUrl, {
        method: 'POST',
        body: formData,
      });

      clearInterval(progressInterval);
      setUploadProgress(100);

      if (response.ok) {
        const result = await response.json();
        if (result.success) {
          setTimeout(() => {
            resetModal();
            onUploadSuccess();
          }, 500);
        } else {
          throw new Error(result.error || '업로드에 실패했습니다.');
        }
      } else {
        const errorData = await response.json();
        throw new Error(errorData.error || '업로드에 실패했습니다.');
      }
    } catch (err: any) {
      setError(err.message || '업로드 중 오류가 발생했습니다.');
      toastError('업로드 실패', err.message || '업로드 중 오류가 발생했습니다.');
      setUploadProgress(0);
    } finally {
      setIsUploading(false);
    }
  };

  const resetModal = () => {
    setSelectedFile(null);
    setIsDragOver(false);
    setIsUploading(false);
    setUploadProgress(0);
    setError('');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleClose = () => {
    if (!isUploading) {
      resetModal();
      onClose();
    }
  };

  const removeFile = () => {
    setSelectedFile(null);
    setError('');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleTemplateDownload = async () => {
    try {
      const templateUrl = uploadUrl.replace('/upload/', '/download/template/');
      const response = await fetch(templateUrl);

      if (!response.ok) {
        throw new Error('템플릿을 찾을 수 없습니다.');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;

      // Determine filename based on upload URL
      const fileName = uploadUrl.includes('items') ? '품목_템플릿.xlsx' : '거래처_템플릿.xlsx';
      a.download = fileName;

      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

      success('템플릿 다운로드 완료', `${fileName}이 다운로드되었습니다.`);
    } catch (err: any) {
      toastError('다운로드 실패', err.message || '템플릿 다운로드에 실패했습니다.');
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={handleClose} title={title} size="md">
      <div className="space-y-6">
        {/* Template Download Button */}
        <div className="flex justify-end">
          <button
            onClick={handleTemplateDownload}
            disabled={isUploading}
            className="flex items-center gap-2 px-4 py-2 text-blue-600 dark:text-blue-400 border border-blue-300 dark:border-blue-500 rounded-lg hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Download className="w-4 h-4" />
            템플릿 다운로드
          </button>
        </div>

        {/* Upload Area */}
        <div
          className={`relative border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
            isDragOver
              ? 'border-blue-400 bg-blue-50 dark:bg-blue-900/20'
              : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500'
          }`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
        >
          <input
            ref={fileInputRef}
            type="file"
            accept=".xlsx,.xls"
            onChange={handleFileInputChange}
            className="hidden"
            disabled={isUploading}
          />

          {!selectedFile ? (
            <div className="space-y-4">
              <div className="flex justify-center">
                <FileSpreadsheet className="w-12 h-12 text-gray-400" />
              </div>
              <div>
                <p className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                  Excel 파일을 여기에 드래그하거나
                </p>
                <button
                  onClick={() => fileInputRef.current?.click()}
                  disabled={isUploading}
                  className="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  파일 선택
                </button>
              </div>
              <p className="text-sm text-gray-500 dark:text-gray-400">
                지원 형식: .xlsx, .xls (최대 10MB)
              </p>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="flex items-center justify-center gap-3">
                <FileSpreadsheet className="w-8 h-8 text-green-500" />
                <div className="text-left">
                  <p className="font-medium text-gray-900 dark:text-white">
                    {selectedFile.name}
                  </p>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    {(selectedFile.size / 1024 / 1024).toFixed(2)} MB
                  </p>
                </div>
                <button
                  onClick={removeFile}
                  disabled={isUploading}
                  className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>

              {/* Upload Progress */}
              {isUploading && (
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600 dark:text-gray-400">업로드 중...</span>
                    <span className="text-gray-600 dark:text-gray-400">{uploadProgress}%</span>
                  </div>
                  <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                    <div
                      className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${uploadProgress}%` }}
                    />
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Error Message */}
        {error && (
          <div className="flex items-center gap-2 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
            <AlertCircle className="w-5 h-5 text-red-500" />
            <p className="text-sm text-red-700 dark:text-red-400">{error}</p>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex justify-end gap-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <button
            onClick={handleClose}
            disabled={isUploading}
            className="px-6 py-2 border border-gray-300 dark:border-gray-700 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            취소
          </button>
          <button
            onClick={handleUpload}
            disabled={!selectedFile || isUploading}
            className="flex items-center gap-2 px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUploading ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin" />
                업로드 중...
              </>
            ) : (
              <>
                <Upload className="w-5 h-5" />
                업로드
              </>
            )}
          </button>
        </div>
      </div>
    </Modal>
  );
}
```


---

### LIB 코드


#### 📄 src\lib\api-error-handler.ts

```typescript
import { NextResponse } from 'next/server';

type ErrorDetails = Record<string, unknown> | string[] | string | undefined;

/**
 * Standard error response format
 */
export interface ErrorResponse {
  success: false;
  error: string;
  details?: ErrorDetails;
  timestamp?: string;
}

/**
 * Standard success response format
 */
export interface SuccessResponse<T = unknown> {
  success: true;
  data: T;
  message?: string;
}

/**
 * API Error class for consistent error handling
 */
export class APIError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public details?: ErrorDetails
  ) {
    super(message);
    this.name = 'APIError';
  }
}

/**
 * Database connection error handler
 */
export function handleDatabaseError(error: unknown): NextResponse {
  console.error('Database error:', error);

  // Type guard for database error
  if (!error || typeof error !== 'object') {
    return NextResponse.json(
      {
        success: false,
        error: 'Database operation failed',
        details: String(error)
      },
      { status: 500 }
    );
  }

  const dbError = error as { code?: string; message?: string };

  // Check for common MySQL errors
  if (dbError.code === 'ER_NO_SUCH_TABLE') {
    return NextResponse.json(
      {
        success: false,
        error: 'Database table not found',
        details: dbError.message
      },
      { status: 500 }
    );
  }

  if (dbError.code === 'ER_BAD_FIELD_ERROR') {
    return NextResponse.json(
      {
        success: false,
        error: 'Invalid database field',
        details: dbError.message
      },
      { status: 500 }
    );
  }

  if (dbError.code === 'ER_DUP_ENTRY') {
    return NextResponse.json(
      {
        success: false,
        error: 'Duplicate entry',
        details: 'This record already exists'
      },
      { status: 409 }
    );
  }

  // Generic database error
  return NextResponse.json(
    {
      success: false,
      error: 'Database operation failed',
      details: process.env.NODE_ENV === 'development' ? dbError.message : undefined
    },
    { status: 500 }
  );
}

/**
 * Validation error handler
 */
export function handleValidationError(errors: string[]): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error: 'Validation failed',
      details: errors
    },
    { status: 400 }
  );
}

/**
 * Not found error handler
 */
export function handleNotFoundError(resource: string): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error: `${resource} not found`
    },
    { status: 404 }
  );
}

/**
 * Generic error handler wrapper for API routes
 */
export async function withErrorHandler<T>(
  handler: () => Promise<T>
): Promise<NextResponse> {
  try {
    const result = await handler();
    return NextResponse.json({
      success: true,
      data: result
    });
  } catch (error) {
    if (error instanceof APIError) {
      return NextResponse.json(
        {
          success: false,
          error: error.message,
          details: error.details
        },
        { status: error.statusCode }
      );
    }

    if (error && typeof error === 'object' && 'code' in error) {
      return handleDatabaseError(error);
    }

    console.error('Unexpected error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'An unexpected error occurred',
        details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.message : undefined
      },
      { status: 500 }
    );
  }
}

/**
 * Validate required fields
 */
export function validateRequiredFields(
  data: Record<string, unknown>,
  requiredFields: string[]
): string[] {
  const errors: string[] = [];

  for (const field of requiredFields) {
    if (!data[field] && data[field] !== 0) {
      errors.push(`${field} is required`);
    }
  }

  return errors;
}

/**
 * Safe parse integer with default value
 */
export function parseIntSafe(value: unknown, defaultValue: number): number {
  const parsed = parseInt(String(value));
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Safe parse date
 */
export function parseDateSafe(value: unknown): Date | null {
  if (!value) return null;
  const date = new Date(String(value));
  return isNaN(date.getTime()) ? null : date;
}
```


#### 📄 src\lib\auth.ts

```typescript
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import type { User, UserRole, JWTPayload, AuthError } from '@/types/auth';
import { AUTH_ERRORS } from '@/types/auth';

// JWT 토큰 생성
export function generateToken(payload: JWTPayload): string {
  const secret = process.env.JWT_SECRET!;
  const expiresIn = process.env.JWT_EXPIRES_IN || '15m';

  // Cast payload to object type for jwt.sign
  return jwt.sign(payload as object, secret, { expiresIn } as jwt.SignOptions);
}

// JWT 토큰 검증
export function verifyToken(token: string): JWTPayload | null {
  try {
    const secret = process.env.JWT_SECRET!;
    const decoded = jwt.verify(token, secret) as JWTPayload;
    return decoded;
  } catch (error) {
    console.error('Token verification failed:', error);
    return null;
  }
}

// 비밀번호 해싱
export async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

// 비밀번호 검증
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return await bcrypt.compare(password, hash);
}

// 사용자 인증
export async function authenticateUser(username: string, password: string): Promise<{ user: User; token: string } | AuthError> {
  try {
    // 사용자 조회 (실제 DB 필드명 사용)
    const { getSupabaseClient } = await import('@/lib/db-unified');
    const supabase = getSupabaseClient();

    const { data: users, error } = await supabase
      .from('users')
      .select('user_id, username, password, name, email, role, is_active, created_at, updated_at')
      .eq('username', username)
      .eq('is_active', true);

    if (error || !users || users.length === 0) {
      return AUTH_ERRORS.INVALID_CREDENTIALS;
    }

    // Map database fields to User type
    const user = {
      id: users[0].user_id,
      username: users[0].username,
      name: users[0].name,
      email: users[0].email,
      role: users[0].role,
      is_active: users[0].is_active,
      created_at: users[0].created_at,
      updated_at: users[0].updated_at,
      password: users[0].password
    } as User & { password: string };

    // 비밀번호 검증
    const isPasswordValid = await verifyPassword(password, (user as any).password);

    if (!isPasswordValid) {
      return AUTH_ERRORS.INVALID_CREDENTIALS;
    }

    // 사용자 활성화 상태 확인
    if (!user.is_active) {
      return AUTH_ERRORS.USER_INACTIVE;
    }

    // JWT 토큰 생성
    const tokenPayload: JWTPayload = {
      userId: user.id,
      username: user.username,
      role: user.role,
    };

    const token = generateToken(tokenPayload);

    // password 제거 후 반환
    const { password: userPassword, ...userWithoutPassword } = user as any;

    return {
      user: userWithoutPassword,
      token
    };

  } catch (error) {
    console.error('Authentication error:', error);
    return AUTH_ERRORS.INVALID_CREDENTIALS;
  }
}

// 토큰에서 사용자 정보 조회
export async function getUserFromToken(token: string): Promise<User | AuthError> {
  try {
    const payload = verifyToken(token);

    if (!payload) {
      return AUTH_ERRORS.TOKEN_INVALID;
    }

    // 사용자 조회
    const { getSupabaseClient } = await import('@/lib/db-unified');
    const supabase = getSupabaseClient();

    const { data: users, error } = await supabase
      .from('users')
      .select('user_id, username, name, email, role, is_active, created_at, updated_at')
      .eq('user_id', payload.userId)
      .eq('is_active', true);

    if (error || !users || users.length === 0) {
      return AUTH_ERRORS.USER_NOT_FOUND;
    }

    // Map database fields to User type
    return {
      id: users[0].user_id,
      username: users[0].username,
      name: users[0].name,
      email: users[0].email,
      role: users[0].role,
      is_active: users[0].is_active,
      created_at: users[0].created_at,
      updated_at: users[0].updated_at
    } as User;

  } catch (error) {
    console.error('Get user from token error:', error);
    return AUTH_ERRORS.TOKEN_INVALID;
  }
}

// 권한 체크 유틸리티
export function checkPermission(userRole: UserRole, resource: string, action: string): boolean {
  const rolePermissions = {
    admin: ['*'], // 모든 권한
    manager: [
      'items:*', 'companies:*', 'inventory:*', 'production:*',
      'reports:read', 'reports:create', 'reports:update'
    ],
    operator: [
      'items:read', 'items:create', 'items:update',
      'companies:read', 'companies:create', 'companies:update',
      'inventory:read', 'inventory:create', 'inventory:update',
      'production:read', 'production:create', 'production:update',
      'reports:read'
    ],
    viewer: [
      'items:read', 'companies:read', 'inventory:read',
      'production:read', 'reports:read'
    ]
  };

  const permissions = rolePermissions[userRole] || [];

  // admin은 모든 권한
  if (permissions.includes('*')) {
    return true;
  }

  // 정확한 권한 매치
  if (permissions.includes(`${resource}:${action}`)) {
    return true;
  }

  // 와일드카드 권한 매치
  if (permissions.includes(`${resource}:*`)) {
    return true;
  }

  return false;
}

// 세션 쿠키 설정
export const SESSION_OPTIONS = {
  cookieName: 'taechang_session',
  password: process.env.SESSION_SECRET || 'session_secret_fallback',
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24시간
    sameSite: 'strict' as const,
  },
};
```


#### 📄 src\lib\bom.ts

```typescript
/**
 * BOM Utility Functions
 * 순환 참조 검사, BOM 전개, 트리 구조 변환 등
 */

import { supabaseAdmin } from './db-unified';
import { mcp__supabase__execute_sql } from './supabase-mcp';

/**
 * BOM 구조 관련 타입 정의
 */
export interface BOMNode {
  bom_id: number;
  parent_item_id: number;
  child_item_id: number;
  item_code: string;
  item_name: string;
  spec?: string;
  quantity: number;
  unit?: string;
  unit_price?: number;
  total_price?: number;
  level: number;
  path?: string;
  accumulated_quantity?: number;
  notes?: string;
  children?: BOMNode[];
}

/**
 * BOM 순환 참조 검사 (CTE 사용)
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @param childId - 하위 품목 ID
 * @param excludeBomId - 제외할 BOM ID (수정 시 사용)
 * @returns 순환 참조 여부
 */
export async function checkBomCircular(
  conn: any,
  parentId: number,
  childId: number,
  excludeBomId?: number
): Promise<boolean> {
  try {
    // WITH RECURSIVE CTE를 사용하여 순환 참조 검사
    const sql = excludeBomId ? `
      WITH RECURSIVE bom_hierarchy AS (
        -- 초기값: 추가하려는 하위 품목에서 시작
        SELECT
          $1::int as check_item_id,
          child_item_id,
          parent_item_id,
          1 as depth,
          $2::text as path
        FROM bom
        WHERE parent_item_id = $3
          AND is_active = 1
          AND bom_id != $4

        UNION ALL

        -- 재귀: BOM 계층 따라가기
        SELECT
          bh.check_item_id,
          b.child_item_id,
          b.parent_item_id,
          bh.depth + 1,
          bh.path || ',' || b.child_item_id
        FROM bom b
        INNER JOIN bom_hierarchy bh ON b.parent_item_id = bh.child_item_id
        WHERE b.is_active = 1
          AND bh.depth < 20
          AND b.child_item_id != ALL(string_to_array(bh.path, ',')::int[])
          AND b.bom_id != $5
      )
      SELECT COUNT(*) as has_circular
      FROM bom_hierarchy
      WHERE child_item_id = $6
    ` : `
      WITH RECURSIVE bom_hierarchy AS (
        -- 초기값: 추가하려는 하위 품목에서 시작
        SELECT
          $1::int as check_item_id,
          child_item_id,
          parent_item_id,
          1 as depth,
          $2::text as path
        FROM bom
        WHERE parent_item_id = $3
          AND is_active = 1

        UNION ALL

        -- 재귀: BOM 계층 따라가기
        SELECT
          bh.check_item_id,
          b.child_item_id,
          b.parent_item_id,
          bh.depth + 1,
          bh.path || ',' || b.child_item_id
        FROM bom b
        INNER JOIN bom_hierarchy bh ON b.parent_item_id = bh.child_item_id
        WHERE b.is_active = 1
          AND bh.depth < 20
          AND b.child_item_id != ALL(string_to_array(bh.path, ',')::int[])
      )
      SELECT COUNT(*) as has_circular
      FROM bom_hierarchy
      WHERE child_item_id = $4
    `;

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Note: MCP doesn't support parameterized queries, so we use string interpolation
    // Params: [parentId, childId.toString(), childId, excludeBomId, excludeBomId, parentId]
    // or: [parentId, childId.toString(), childId, parentId]
    const sqlWithParams = excludeBomId
      ? sql.replace(/\$1/g, parentId.toString())
             .replace(/\$2/g, `'${childId.toString()}'`)
             .replace(/\$3/g, childId.toString())
             .replace(/\$4/g, excludeBomId.toString())
             .replace(/\$5/g, excludeBomId.toString())
             .replace(/\$6/g, parentId.toString())
      : sql.replace(/\$1/g, parentId.toString())
             .replace(/\$2/g, `'${childId.toString()}'`)
             .replace(/\$3/g, childId.toString())
             .replace(/\$4/g, parentId.toString());

    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sqlWithParams
    });

    const rows = result.rows as Array<{has_circular: number}> | undefined;
    return (rows?.[0]?.has_circular || 0) > 0;

  } catch (error) {
    console.error('Error checking BOM circular reference:', error);
    // 오류 시 안전을 위해 순환 참조가 있다고 가정
    return true;
  }
}

/**
 * BOM 전개 (재귀적 조회)
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @param level - 현재 레벨 (재귀 깊이)
 * @param maxLevel - 최대 레벨 제한
 * @param parentQuantity - 부모의 수량 (누적 계산용)
 * @returns 전개된 BOM 노드 배열
 */
export async function explodeBom(
  conn: any,
  parentId: number,
  level: number = 0,
  maxLevel: number = 10,
  parentQuantity: number = 1
): Promise<BOMNode[]> {
  try {
    if (level >= maxLevel) {
      console.warn(`Max BOM level (${maxLevel}) reached for item ${parentId}`);
      return [];
    }

    // 현재 레벨의 BOM 항목 조회
    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const sql = `
      SELECT
        b.bom_id,
        b.parent_item_id,
        b.child_item_id,
        b.quantity,
        b.unit,
        b.notes,
        i.item_code,
        i.item_name,
        i.spec,
        i.unit_price
      FROM bom b
      INNER JOIN items i ON b.child_item_id = i.item_id
      WHERE b.parent_item_id = ${parentId}
        AND b.is_active = true
        AND i.is_active = true
      ORDER BY i.item_code
    `;

    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sql
    });

    const rows = result.rows as Array<{
      bom_id: number;
      parent_item_id: number;
      child_item_id: number;
      quantity: number;
      unit: string | null;
      notes: string | null;
      item_code: string;
      item_name: string;
      spec: string | null;
      unit_price: number | null;
    }> | undefined;

    const nodes: BOMNode[] = [];

    for (const row of rows || []) {
      const accumulatedQuantity = row.quantity * parentQuantity;

      const node: BOMNode = {
        bom_id: row.bom_id,
        parent_item_id: row.parent_item_id,
        child_item_id: row.child_item_id,
        item_code: row.item_code,
        item_name: row.item_name,
        spec: row.spec || undefined,
        quantity: row.quantity,
        unit: row.unit || 'EA',
        unit_price: row.unit_price || 0,
        total_price: (row.unit_price || 0) * accumulatedQuantity,
        level: level + 1,
        accumulated_quantity: accumulatedQuantity,
        notes: row.notes || undefined
      };

      // 재귀적으로 하위 BOM 조회
      const children = await explodeBom(
        conn,
        row.child_item_id,
        level + 1,
        maxLevel,
        accumulatedQuantity
      );

      if (children.length > 0) {
        node.children = children;
      }

      nodes.push(node);
    }

    return nodes;

  } catch (error) {
    console.error('Error exploding BOM:', error);
    return [];
  }
}

/**
 * BOM 트리 구조로 변환
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @param includeInactive - 비활성 항목 포함 여부
 * @returns BOM 트리 구조
 */
export async function getBomTree(
  conn: any,
  parentId: number,
  includeInactive: boolean = false
): Promise<BOMNode | null> {
  try {
    // 상위 품목 정보 조회
    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const parentSql = `
      SELECT
        item_id,
        item_code,
        item_name,
        spec,
        unit_price
      FROM items
      WHERE item_id = ${parentId} ${includeInactive ? '' : 'AND is_active = true'}
    `;

    const parentResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: parentSql
    });

    const parentRows = parentResult.rows as Array<{
      item_id: number;
      item_code: string;
      item_name: string;
      spec: string | null;
      unit_price: number | null;
    }> | undefined;

    if (!parentRows || parentRows.length === 0) {
      return null;
    }

    const parent = parentRows[0];

    // BOM 전개하여 하위 구조 가져오기
    const children = await explodeBom(conn, parentId, 0, 10, 1);

    const rootNode: BOMNode = {
      bom_id: 0,
      parent_item_id: 0,
      child_item_id: parent.item_id,
      item_code: parent.item_code,
      item_name: parent.item_name,
      spec: parent.spec || undefined,
      quantity: 1,
      unit: 'EA',
      unit_price: parent.unit_price || 0,
      total_price: parent.unit_price || 0,
      level: 0,
      accumulated_quantity: 1,
      children: children.length > 0 ? children : undefined
    };

    return rootNode;

  } catch (error) {
    console.error('Error getting BOM tree:', error);
    return null;
  }
}

/**
 * 최하위 품목들의 총 원가 계산
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @returns 총 원가
 */
export async function calculateTotalCost(
  conn: any,
  parentId: number
): Promise<number> {
  try {
    // WITH RECURSIVE를 사용하여 모든 최하위 품목과 수량 계산
    const sql = `
      WITH RECURSIVE bom_costs AS (
        -- 초기값: 직접 하위 품목
        SELECT
          b.child_item_id,
          b.quantity,
          b.quantity as accumulated_qty,
          i.unit_price,
          CASE
            WHEN NOT EXISTS (
              SELECT 1 FROM bom b2
              WHERE b2.parent_item_id = b.child_item_id
                AND b2.is_active = 1
            ) THEN 1
            ELSE 0
          END as is_leaf
        FROM bom b
        INNER JOIN items i ON b.child_item_id = i.item_id
        WHERE b.parent_item_id = $1
          AND b.is_active = 1
          AND i.is_active = 1

        UNION ALL

        -- 재귀: 하위 품목들
        SELECT
          b.child_item_id,
          b.quantity,
          bc.accumulated_qty * b.quantity as accumulated_qty,
          i.unit_price,
          CASE
            WHEN NOT EXISTS (
              SELECT 1 FROM bom b2
              WHERE b2.parent_item_id = b.child_item_id
                AND b2.is_active = 1
            ) THEN 1
            ELSE 0
          END as is_leaf
        FROM bom b
        INNER JOIN bom_costs bc ON b.parent_item_id = bc.child_item_id
        INNER JOIN items i ON b.child_item_id = i.item_id
        WHERE b.is_active = 1
          AND i.is_active = 1
          AND bc.is_leaf = 0
      )
      SELECT
        SUM(accumulated_qty * COALESCE(unit_price, 0)) as total_cost
      FROM bom_costs
      WHERE is_leaf = 1
    `;

    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const sqlWithParams = sql.replace(/\$1/g, parentId.toString());

    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sqlWithParams
    });

    const rows = result.rows as Array<{total_cost: number | null}> | undefined;
    return rows?.[0]?.total_cost || 0;

  } catch (error) {
    console.error('Error calculating total cost:', error);
    return 0;
  }
}

/**
 * BOM 역전개 (Where-Used)
 * 특정 품목이 어느 상위 품목에 사용되는지 조회
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param childId - 하위 품목 ID
 * @returns 상위 품목 목록
 */
export async function getWhereUsed(
  conn: any,
  childId: number
): Promise<any[]> {
  try {
    const sql = `
      WITH RECURSIVE where_used AS (
        -- 초기값: 직접 상위 품목
        SELECT
          b.bom_id,
          b.parent_item_id,
          b.child_item_id,
          b.quantity,
          i.item_code,
          i.item_name,
          i.spec,
          1 as level,
          b.parent_item_id::text as path
        FROM bom b
        INNER JOIN items i ON b.parent_item_id = i.item_id
        WHERE b.child_item_id = $1
          AND b.is_active = 1
          AND i.is_active = 1

        UNION ALL

        -- 재귀: 상위의 상위 품목들
        SELECT
          b.bom_id,
          b.parent_item_id,
          b.child_item_id,
          b.quantity * wu.quantity as quantity,
          i.item_code,
          i.item_name,
          i.spec,
          wu.level + 1,
          wu.path || ',' || b.parent_item_id
        FROM bom b
        INNER JOIN where_used wu ON b.child_item_id = wu.parent_item_id
        INNER JOIN items i ON b.parent_item_id = i.item_id
        WHERE b.is_active = 1
          AND i.is_active = 1
          AND wu.level < 10
          AND b.parent_item_id != ALL(string_to_array(wu.path, ',')::int[])
      )
      SELECT * FROM where_used
      ORDER BY level, item_code
    `;

    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const sqlWithParams = sql.replace(/\$1/g, childId.toString());

    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sqlWithParams
    });

    return result.rows || [];

  } catch (error) {
    console.error('Error getting where-used:', error);
    return [];
  }
}

/**
 * BOM 레벨별 요약 정보
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @returns 레벨별 품목 수와 원가 정보
 */
export async function getBomLevelSummary(
  conn: any,
  parentId: number
): Promise<any[]> {
  try {
    const sql = `
      WITH RECURSIVE bom_levels AS (
        -- 초기값
        SELECT
          b.child_item_id,
          b.quantity,
          b.quantity as accumulated_qty,
          1 as level,
          i.unit_price
        FROM bom b
        INNER JOIN items i ON b.child_item_id = i.item_id
        WHERE b.parent_item_id = $1
          AND b.is_active = 1
          AND i.is_active = 1

        UNION ALL

        -- 재귀
        SELECT
          b.child_item_id,
          b.quantity,
          bl.accumulated_qty * b.quantity,
          bl.level + 1,
          i.unit_price
        FROM bom b
        INNER JOIN bom_levels bl ON b.parent_item_id = bl.child_item_id
        INNER JOIN items i ON b.child_item_id = i.item_id
        WHERE b.is_active = 1
          AND i.is_active = 1
          AND bl.level < 10
      )
      SELECT
        level,
        COUNT(DISTINCT child_item_id) as item_count,
        SUM(accumulated_qty) as total_quantity,
        SUM(accumulated_qty * COALESCE(unit_price, 0)) as level_cost
      FROM bom_levels
      GROUP BY level
      ORDER BY level
    `;

    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const sqlWithParams = sql.replace(/\$1/g, parentId.toString());

    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sqlWithParams
    });

    return result.rows || [];

  } catch (error) {
    console.error('Error getting BOM level summary:', error);
    return [];
  }
}

/**
 * BOM 유효성 검사
 * @param conn - DB 연결 (supabaseAdmin 사용)
 * @param parentId - 상위 품목 ID
 * @returns 유효성 검사 결과
 */
export async function validateBom(
  conn: any,
  parentId: number
): Promise<{
  valid: boolean;
  errors: string[];
  warnings: string[];
}> {
  const errors: string[] = [];
  const warnings: string[] = [];

  try {
    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // 1. 상위 품목 존재 확인
    const parentCheckSql = `
      SELECT item_id, item_code, item_name, is_active
      FROM items WHERE item_id = ${parentId}
    `;
    const parentCheckResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: parentCheckSql
    });

    const parentRows = parentCheckResult.rows as Array<{
      item_id: number;
      item_code: string;
      item_name: string;
      is_active: boolean;
    }> | undefined;

    if (!parentRows || parentRows.length === 0) {
      errors.push(`상위 품목 ID ${parentId}가 존재하지 않습니다.`);
      return { valid: false, errors, warnings };
    }

    if (!parentRows[0].is_active) {
      warnings.push(`상위 품목 '${parentRows[0].item_code}'가 비활성 상태입니다.`);
    }

    // 2. 순환 참조 검사
    const circularCheckSql = `
      WITH RECURSIVE bom_check AS (
        SELECT child_item_id, parent_item_id, 1 as depth
        FROM bom
        WHERE parent_item_id = ${parentId} AND is_active = true

        UNION ALL

        SELECT b.child_item_id, b.parent_item_id, bc.depth + 1
        FROM bom b
        INNER JOIN bom_check bc ON b.parent_item_id = bc.child_item_id
        WHERE b.is_active = true AND bc.depth < 20
      )
      SELECT COUNT(*) as circular_count
      FROM bom_check
      WHERE child_item_id = ${parentId}
    `;

    const circularCheckResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: circularCheckSql
    });

    const circularRows = circularCheckResult.rows as Array<{circular_count: number}> | undefined;

    if (circularRows && circularRows.length > 0 && circularRows[0]?.circular_count > 0) {
      errors.push('BOM 구조에 순환 참조가 존재합니다.');
    }

    // 3. 비활성 하위 품목 확인
    const inactiveCheckSql = `
      SELECT i.item_code, i.item_name
      FROM bom b
      INNER JOIN items i ON b.child_item_id = i.item_id
      WHERE b.parent_item_id = ${parentId}
        AND b.is_active = true
        AND i.is_active = false
    `;

    const inactiveCheckResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: inactiveCheckSql
    });

    const inactiveRows = inactiveCheckResult.rows as Array<{
      item_code: string;
      item_name: string;
    }> | undefined;

    if (inactiveRows && inactiveRows.length > 0) {
      inactiveRows.forEach((item: Record<string, any>) => {
        warnings.push(`하위 품목 '${item.item_code} - ${item.item_name}'가 비활성 상태입니다.`);
      });
    }

    // 4. 중복 BOM 항목 확인
    const duplicateCheckSql = `
      SELECT child_item_id, COUNT(*) as cnt
      FROM bom
      WHERE parent_item_id = $1 AND is_active = 1
      GROUP BY child_item_id
      HAVING COUNT(*) > 1
    `;

    const duplicateResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: duplicateCheckSql
    });

    const duplicateRows = duplicateResult.rows as Array<{child_item_id: number}> | undefined;

    if (duplicateRows && duplicateRows.length > 0) {
      duplicateRows.forEach((item) => {
        errors.push(`하위 품목 ID ${item.child_item_id}에 대한 중복 BOM 항목이 존재합니다.`);
      });
    }

    // 5. 0 수량 확인
    const zeroQtyCheckSql = `
      SELECT i.item_code, i.item_name
      FROM bom b
      INNER JOIN items i ON b.child_item_id = i.item_id
      WHERE b.parent_item_id = $1
        AND b.is_active = 1
        AND (b.quantity IS NULL OR b.quantity <= 0)
    `;

    const zeroQtyResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: zeroQtyCheckSql.replace('$1', parentId.toString())
    });

    const zeroQtyRows = zeroQtyResult.rows as Array<{item_code: string, item_name: string}> | undefined;

    if (zeroQtyRows && zeroQtyRows.length > 0) {
      zeroQtyRows.forEach((item) => {
        errors.push(`품목 '${item.item_code} - ${item.item_name}'의 수량이 0 또는 NULL입니다.`);
      });
    }

    const valid = errors.length === 0;

    return {
      valid,
      errors,
      warnings
    };

  } catch (error) {
    console.error('Error validating BOM:', error);
    errors.push(`BOM 유효성 검사 중 오류 발생: ${error}`);
    return {
      valid: false,
      errors,
      warnings
    };
  }
}
```


#### 📄 src\lib\db-health-check.ts

```typescript
import { mcp__supabase__execute_sql } from './supabase-mcp';

/**
 * Supabase Database health check utilities
 */

export interface TableHealthStatus {
  tableName: string;
  exists: boolean;
  requiredColumns: string[];
  missingColumns: string[];
  status: 'healthy' | 'warning' | 'error';
}

export interface DatabaseHealth {
  connected: boolean;
  tables: TableHealthStatus[];
  overallStatus: 'healthy' | 'warning' | 'error';
}

/**
 * Required table schemas for the application (Supabase/PostgreSQL)
 * Based on actual database structure from TAECHANG_ERP project
 */
const REQUIRED_TABLES = {
  users: [
    'user_id', 'username', 'password', 'name', 'email', 'phone', 'role', 'is_active', 'created_at', 'updated_at'
  ],
  items: [
    'item_id', 'item_code', 'item_name', 'category', 'spec', 'unit', 'price', 'safety_stock', 
    'current_stock', 'location', 'description', 'is_active', 'created_at', 'updated_at', 'created_by', 'updated_by'
  ],
  companies: [
    'company_id', 'company_code', 'company_name', 'company_type', 'business_number', 'representative',
    'phone', 'fax', 'email', 'address', 'description', 'is_active', 'created_at', 'updated_at', 'created_by', 'updated_by'
  ],
  inventory_transactions: [
    'transaction_id', 'transaction_date', 'transaction_type', 'item_id', 'company_id', 'quantity',
    'unit_price', 'total_amount', 'tax_amount', 'grand_total', 'document_number', 'reference_number',
    'warehouse_id', 'location', 'lot_number', 'expiry_date', 'status', 'notes', 'transaction_number',
    'description', 'created_at', 'updated_at', 'created_by', 'updated_by'
  ],
  bom: [
    'bom_id', 'parent_item_id', 'child_item_id', 'quantity', 'unit', 'is_active',
    'created_at', 'updated_at', 'created_by', 'updated_by'
  ],
  warehouses: [
    'warehouse_id', 'warehouse_code', 'warehouse_name', 'warehouse_type', 'address', 'manager_name',
    'manager_phone', 'temperature_controlled', 'max_capacity', 'current_usage', 'is_active',
    'created_by', 'created_at', 'updated_at'
  ],
  warehouse_stock: [
    'warehouse_stock_id', 'warehouse_id', 'item_id', 'current_quantity', 'reserved_quantity',
    'available_quantity', 'location_code', 'min_stock', 'max_stock', 'last_in_date', 'last_out_date',
    'created_at', 'updated_at'
  ],
  serials: [
    'serial_id', 'prefix', 'year_month', 'current_number', 'created_at', 'updated_at'
  ],
  stock_adjustments: [
    'adjustment_id', 'adjustment_number', 'adjustment_date', 'warehouse_id', 'item_id', 'adjustment_type',
    'quantity_before', 'quantity_after', 'adjustment_quantity', 'reason', 'approved_by', 'approval_date',
    'unit_cost', 'total_cost_impact', 'status', 'created_by', 'created_at', 'updated_at'
  ],
  current_stock_view: [
    'item_id', 'item_code', 'item_name', 'category', 'spec', 'unit', 
    'current_stock', 'safety_stock', 'stock_status', 'location', 'is_active'
  ]
};

/**
 * Check if a table exists and has required columns (PostgreSQL)
 */
async function checkTableHealth(tableName: string, requiredColumns: string[]): Promise<TableHealthStatus> {
  try {
    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Check if table exists using PostgreSQL information_schema
    const tableExistsQuery = `SELECT COUNT(*) as count FROM information_schema.tables
       WHERE table_schema = 'public' AND table_name = '${tableName}'`;

    const tableExistsResponse = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: tableExistsQuery
    });

    const tableExistsResult = tableExistsResponse.rows as Array<{count: string}> | null;

    if (!tableExistsResult || tableExistsResult.length === 0 || parseInt(tableExistsResult[0].count) === 0) {
      return {
        tableName,
        exists: false,
        requiredColumns,
        missingColumns: requiredColumns,
        status: 'error'
      };
    }

    // Check columns using PostgreSQL information_schema
    const columnsQuery = `SELECT column_name FROM information_schema.columns
       WHERE table_schema = 'public' AND table_name = '${tableName}'`;

    const columnsResponse = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: columnsQuery
    });

    const columnsResult = columnsResponse.rows as Array<{column_name: string}> | null;

    if (!columnsResult || columnsResult.length === 0) {
      return {
        tableName,
        exists: true,
        requiredColumns,
        missingColumns: requiredColumns,
        status: 'error'
      };
    }

    const existingColumns = columnsResult.map((col: {column_name: string}) => col.column_name.toLowerCase());
    const missingColumns = requiredColumns.filter(
      col => !existingColumns.includes(col.toLowerCase())
    );

    // Log column check details for debugging
    if (missingColumns.length > 0) {
      console.log(`Table ${tableName}: Missing columns: ${missingColumns.join(', ')}`);
      console.log(`Table ${tableName}: Existing columns: ${existingColumns.join(', ')}`);
    }

    return {
      tableName,
      exists: true,
      requiredColumns,
      missingColumns,
      status: missingColumns.length === 0 ? 'healthy' : 'warning'
    };
  } catch (error) {
    console.error(`Error checking table health for ${tableName}:`, error);
    return {
      tableName,
      exists: false,
      requiredColumns,
      missingColumns: requiredColumns,
      status: 'error'
    };
  }
}

/**
 * Check overall database health (Supabase)
 */
export async function checkDatabaseHealth(): Promise<DatabaseHealth> {
  const health: DatabaseHealth = {
    connected: false,
    tables: [],
    overallStatus: 'healthy'
  };

  try {
    // Test connection using Supabase
    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Test connection using Supabase
    const connectionTestResponse = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: 'SELECT 1 as test'
    });

    const connectionTest = connectionTestResponse.rows as Array<{test: number}> | null;
    health.connected = !!connectionTest && connectionTest.length > 0;

    // Check each table
    for (const [tableName, columns] of Object.entries(REQUIRED_TABLES)) {
      const tableHealth = await checkTableHealth(tableName, columns);
      health.tables.push(tableHealth);

      // Update overall status
      if (tableHealth.status === 'error') {
        health.overallStatus = 'error';
      } else if (tableHealth.status === 'warning' && health.overallStatus !== 'error') {
        health.overallStatus = 'warning';
      }
    }
  } catch (error) {
    console.error('Database health check failed:', error);
    health.connected = false;
    health.overallStatus = 'error';
  }

  return health;
}

/**
 * Auto-fix common database issues (Supabase/PostgreSQL)
 */
export async function autoFixDatabaseIssues(): Promise<string[]> {
  const fixes: string[] = [];

  try {
    const health = await checkDatabaseHealth();

    for (const table of health.tables) {
      if (!table.exists) {
        // Log missing table but don't auto-create (too risky)
        fixes.push(`Table '${table.tableName}' is missing - manual creation required`);
      } else if (table.missingColumns.length > 0) {
        // Log missing columns but don't auto-add (need proper types)
        fixes.push(`Table '${table.tableName}' is missing columns: ${table.missingColumns.join(', ')}`);
      }
    }

    // Check and fix common issues for PostgreSQL
    try {
      const projectId = process.env.SUPABASE_PROJECT_ID || '';

      // Ensure transaction_type can handle Korean values (PostgreSQL uses UTF-8 by default)
      const columnCheckResponse = await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `SELECT column_name, data_type
          FROM information_schema.columns
          WHERE table_name = 'inventory_transactions'
          AND column_name = 'transaction_type'`
      });

      const result = columnCheckResponse.rows as Array<{column_name: string, data_type: string}> | null;

      if (result && result.length > 0) {
        fixes.push('transaction_type column exists and supports UTF-8 (PostgreSQL default)');
      }

      // Check if all required tables exist
      const tableNames = Object.keys(REQUIRED_TABLES);
      const tableNamesStr = tableNames.map(t => `'${t}'`).join(',');

      const tableCheckResponse = await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `SELECT table_name
          FROM information_schema.tables
          WHERE table_schema = 'public'
          AND table_name IN (${tableNamesStr})`
      });

      const tableCheckResult = tableCheckResponse.rows as Array<{table_name: string}> | null;

      if (tableCheckResult && tableCheckResult.length > 0) {
        const existingTables = tableCheckResult.map(row => row.table_name);
        const missingTables = tableNames.filter(
          table => !existingTables.includes(table)
        );

        if (missingTables.length === 0) {
          fixes.push(`All ${tableNames.length} required tables exist in the database`);
        } else {
          fixes.push(`Missing tables: ${missingTables.join(', ')}`);
        }
      }
    } catch (e) {
      fixes.push(`Database schema check failed: ${e instanceof Error ? e.message : 'Unknown error'}`);
    }

    return fixes;
  } catch (error) {
    console.error('Auto-fix failed:', error);
    return [`Auto-fix failed: ${error instanceof Error ? error.message : 'Unknown error'}`];
  }
}

/**
 * Get database statistics (Supabase)
 */
export async function getDatabaseStats() {
  try {
    const projectId = process.env.SUPABASE_PROJECT_ID || '';
    const stats: any = {};

    // Get table row counts - using parameterized query for safety
    const tables = Object.keys(REQUIRED_TABLES);
    
    // Validate table names to prevent SQL injection
    const validTableNames = tables.filter(tableName => 
      /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(tableName)
    );

    for (const table of validTableNames) {
      try {
        // Use parameterized query with table name validation
        const response = await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `SELECT COUNT(*) as count FROM "${table}"`
      });

      const result = response.rows as Array<{count: string}> | null;
        if (result && result.length > 0) {
          stats[table] = parseInt(result[0].count);
        } else {
          stats[table] = 'error';
        }
      } catch (e) {
        console.error(`Error counting rows in table ${table}:`, e);
        stats[table] = 'error';
      }
    }

    return stats;
  } catch (error) {
    console.error('Failed to get database stats:', error);
    return null;
  }
}
```


#### 📄 src\lib\db-unified.ts

```typescript
/**
 * Unified Supabase Database Layer
 *
 * This module consolidates all database operations into a single, consistent interface.
 * It replaces the legacy MySQL layer (db.ts) and merges db-supabase.ts + supabase.ts.
 *
 * Features:
 * - Single source of truth for database operations
 * - Reusable error handling
 * - Type-safe operations
 * - Browser and server client support
 */

import { createBrowserClient } from '@supabase/ssr';
import { createClient, SupabaseClient, PostgrestError } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

// ============================================================================
// CONFIGURATION & CLIENTS
// ============================================================================

const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabaseServiceRole = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase configuration. Check SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY');
}

/**
 * Browser client for client-side operations
 * Uses anon key with RLS policies
 */
export const createSupabaseBrowserClient = () =>
  createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!);

/**
 * Standard client for client-side operations with session persistence
 */
export const supabase: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl!,
  supabaseAnonKey!,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
    db: { schema: 'public' },
    global: {
      headers: { 'x-my-custom-header': 'taechang-erp' }
    }
  }
);

/**
 * Admin client for server-side operations
 * Bypasses RLS - use with caution!
 */
export const supabaseAdmin: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl!,
  supabaseServiceRole || supabaseAnonKey!,
  {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
    },
    db: { schema: 'public' }
  }
);

/**
 * Get appropriate Supabase client (singleton pattern)
 * Defaults to admin client for server-side operations
 */
let clientInstance: SupabaseClient<Database> | null = null;

export function getSupabaseClient(): SupabaseClient<Database> {
  if (!clientInstance) {
    clientInstance = supabaseAdmin;
  }
  return clientInstance;
}

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export interface SupabaseResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  count?: number;
}

export interface QueryOptions {
  columns?: string;
  filters?: Record<string, any>;
  search?: { columns: string[]; term: string };
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
  page?: number;
  limit?: number;
  count?: boolean;
}

// ============================================================================
// REUSABLE ERROR HANDLING (Eliminates 60% code duplication)
// ============================================================================

/**
 * Centralized error handler for Supabase operations
 * Eliminates duplicate error handling code across 20+ locations
 */
export function handleSupabaseError(
  operation: string,
  table: string,
  error: PostgrestError | Error | any
): SupabaseResponse<never> {
  const errorMessage = error?.message || String(error);
  console.error(`[Supabase] ${table}.${operation} failed:`, {
    message: errorMessage,
    code: error?.code,
    details: error?.details,
    hint: error?.hint,
  });

  return {
    success: false,
    error: errorMessage,
  };
}

/**
 * Success response wrapper for consistency
 */
export function createSuccessResponse<T>(
  data: T,
  count?: number
): SupabaseResponse<T> {
  return {
    success: true,
    data,
    ...(count !== undefined && { count }),
  };
}

/**
 * Exception handler wrapper for consistency
 * Converts unknown errors to standard response format
 */
export function handleException<T = never>(
  operation: string,
  error: unknown
): SupabaseResponse<T> {
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';

  console.error(`[Exception ${operation}]`, {
    message: errorMessage,
    stack: error instanceof Error ? error.stack : undefined,
    timestamp: new Date().toISOString()
  });

  return {
    success: false,
    error: errorMessage
  };
}

/**
 * Try-catch wrapper for async operations
 * Automatically handles errors and returns standard response
 */
export async function tryCatchWrapper<T>(
  operation: string,
  asyncFn: () => Promise<SupabaseResponse<T>>
): Promise<SupabaseResponse<T>> {
  try {
    return await asyncFn();
  } catch (error) {
    return handleException(operation, error);
  }
}

/**
 * Convert Supabase query result to standard response
 */
export function toDbResponse<T>(
  operation: string,
  queryResult: {
    data: T | null;
    error: PostgrestError | null;
    count?: number | null;
  }
): SupabaseResponse<T> {
  const { data, error, count } = queryResult;

  if (error) {
    return handleSupabaseError(operation, 'unknown', error);
  }

  return {
    success: true,
    data: data === null ? undefined : data,
    count: count ?? undefined
  };
}

/**
 * Convert single query result to array response
 */
export function toDbResponseSingle<T>(
  operation: string,
  queryResult: {
    data: T | null;
    error: PostgrestError | null;
  }
): SupabaseResponse<T[]> {
  const { data, error } = queryResult;

  if (error) {
    return handleSupabaseError(operation, 'unknown', error);
  }

  return {
    success: true,
    data: data ? [data] : [],
    error: undefined
  };
}

/**
 * Convert mutation result to standard response
 */
export function toDbResponseMutation<T>(
  operation: string,
  mutationResult: {
    data: T | null;
    error: PostgrestError | null;
  }
): SupabaseResponse<T> {
  const { data, error } = mutationResult;

  if (error) {
    return handleSupabaseError(operation, 'unknown', error);
  }

  return {
    success: true,
    data: data ?? undefined
  };
}

// ============================================================================
// QUERY BUILDER (Generic database operations)
// ============================================================================

export class SupabaseQueryBuilder {
  private client: SupabaseClient<Database>;

  constructor(client?: SupabaseClient<Database>) {
    this.client = client || getSupabaseClient();
  }

  /**
   * Generic SELECT with pagination, filters, and search
   * Eliminates duplicate query logic
   */
  async select<T>(
    table: string,
    options: QueryOptions = {}
  ): Promise<SupabaseResponse<T[]>> {
    try {
      let query = this.client
        .from(table as any)
        .select(
          options.columns || '*',
          options.count ? { count: 'exact' } : undefined
        );

      // Apply filters
      if (options.filters) {
        Object.entries(options.filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            if (typeof value === 'string' && value.includes('%')) {
              query = query.like(key, value);
            } else {
              query = query.eq(key, value);
            }
          }
        });
      }

      // Apply search across multiple columns
      if (options.search && options.search.term) {
        const searchConditions = options.search.columns
          .map(col => `${col}.ilike.%${options.search!.term}%`)
          .join(',');
        query = query.or(searchConditions);
      }

      // Apply ordering
      if (options.orderBy) {
        query = query.order(options.orderBy, {
          ascending: options.orderDirection !== 'desc',
        });
      }

      // Apply pagination
      if (options.page && options.limit) {
        const start = (options.page - 1) * options.limit;
        const end = start + options.limit - 1;
        query = query.range(start, end);
      }

      const { data, error, count } = await query;

      if (error) {
        return handleSupabaseError('select', table, error);
      }

      return createSuccessResponse(data as T[], count || undefined);
    } catch (error) {
      return handleSupabaseError('select', table, error);
    }
  }

  /**
   * Generic INSERT operation
   */
  async insert<T>(
    table: string,
    values: any | any[]
  ): Promise<SupabaseResponse<T>> {
    try {
      const { data, error } = await this.client
        .from(table as any)
        .insert(values)
        .select()
        .single();

      if (error) {
        return handleSupabaseError('insert', table, error);
      }

      return createSuccessResponse(data as T);
    } catch (error) {
      return handleSupabaseError('insert', table, error);
    }
  }

  /**
   * Generic UPDATE operation
   */
  async update<T>(
    table: string,
    id: number,
    values: any,
    idColumn: string = 'id'
  ): Promise<SupabaseResponse<T>> {
    try {
      const { data, error } = await this.client
        .from(table as any)
        .update(values)
        .eq(idColumn, id)
        .select()
        .single();

      if (error) {
        return handleSupabaseError('update', table, error);
      }

      return createSuccessResponse(data as T);
    } catch (error) {
      return handleSupabaseError('update', table, error);
    }
  }

  /**
   * Generic DELETE operation (soft delete preferred)
   */
  async delete(
    table: string,
    id: number,
    idColumn: string = 'id',
    softDelete: boolean = true
  ): Promise<SupabaseResponse<any>> {
    try {
      if (softDelete) {
        // Soft delete: set is_active = false
        return await this.update(table, id, { is_active: false }, idColumn);
      } else {
        // Hard delete
        const { error } = await this.client
          .from(table as any)
          .delete()
          .eq(idColumn, id);

        if (error) {
          return handleSupabaseError('delete', table, error);
        }

        return createSuccessResponse(null);
      }
    } catch (error) {
      return handleSupabaseError('delete', table, error);
    }
  }
}

// ============================================================================
// DATABASE HELPERS (Domain-specific operations)
// ============================================================================

export const db = {
  /**
   * Authentication helpers
   */
  auth: {
    signUp: async (email: string, password: string) => {
      return await supabase.auth.signUp({ email, password });
    },
    signIn: async (email: string, password: string) => {
      return await supabase.auth.signInWithPassword({ email, password });
    },
    signOut: async () => {
      return await supabase.auth.signOut();
    },
    getUser: async () => {
      return await supabase.auth.getUser();
    },
    getSession: async () => {
      return await supabase.auth.getSession();
    },
  },

  /**
   * Items operations
   */
  items: {
    getAll: async (options: QueryOptions = {}) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.select('items', {
        ...options,
        filters: { is_active: true, ...options.filters },
        orderBy: options.orderBy || 'item_code',
      });
    },

    getById: async (id: number) => {
      try {
        const { data, error } = await supabase
          .from('items')
          .select('*')
          .eq('item_id', id)
          .single();

        if (error) return handleSupabaseError('getById', 'items', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('getById', 'items', error);
      }
    },

    checkDuplicateCode: async (itemCode: string, excludeId?: number) => {
      try {
        let query = supabase
          .from('items')
          .select('item_id, item_code')
          .eq('item_code', itemCode);

        if (excludeId) {
          query = query.neq('item_id', excludeId);
        }

        const { data, error } = await query;

        if (error) return handleSupabaseError('checkDuplicateCode', 'items', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('checkDuplicateCode', 'items', error);
      }
    },

    create: async (item: Database['public']['Tables']['items']['Insert']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.insert('items', item);
    },

    update: async (id: number, item: Database['public']['Tables']['items']['Update']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.update('items', id, item, 'item_id');
    },

    delete: async (id: number) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.delete('items', id, 'item_id', true); // Soft delete
    },
  },

  /**
   * Companies operations
   */
  companies: {
    getAll: async (options: QueryOptions = {}) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.select('companies', {
        ...options,
        filters: { is_active: true, ...options.filters },
        orderBy: options.orderBy || 'company_name',
      });
    },

    getById: async (id: number) => {
      try {
        const { data, error } = await supabase
          .from('companies')
          .select('*')
          .eq('company_id', id)
          .single();

        if (error) return handleSupabaseError('getById', 'companies', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('getById', 'companies', error);
      }
    },

    checkDuplicateName: async (companyName: string, excludeId?: number) => {
      try {
        let query = supabase
          .from('companies')
          .select('company_id, company_name')
          .eq('company_name', companyName);

        if (excludeId) {
          query = query.neq('company_id', excludeId);
        }

        const { data, error } = await query;

        if (error) return handleSupabaseError('checkDuplicateName', 'companies', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('checkDuplicateName', 'companies', error);
      }
    },

    create: async (company: Database['public']['Tables']['companies']['Insert']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.insert('companies', company);
    },

    update: async (id: number, company: Database['public']['Tables']['companies']['Update']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.update('companies', id, company, 'company_id');
    },

    delete: async (id: number) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.delete('companies', id, 'company_id', true);
    },

    query: async (sql: string, params?: any[]) => {
      console.warn('companies.query() is deprecated. Use Supabase MCP for complex SQL.');
      throw new Error('Raw queries not supported. Use Supabase MCP for complex SQL.');
    },
  },

  /**
   * Inventory transactions operations
   */
  transactions: {
    getAll: async (options: QueryOptions = {}) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.select('inventory_transactions', {
        ...options,
        orderBy: options.orderBy || 'transaction_date',
        orderDirection: 'desc',
      });
    },

    getById: async (id: number) => {
      try {
        const { data, error } = await supabase
          .from('inventory_transactions')
          .select('*')
          .eq('transaction_id', id)
          .single();

        if (error) return handleSupabaseError('getById', 'inventory_transactions', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('getById', 'inventory_transactions', error);
      }
    },

    create: async (transaction: Database['public']['Tables']['inventory_transactions']['Insert']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.insert('inventory_transactions', transaction);
    },

    update: async (id: number, data: Database['public']['Tables']['inventory_transactions']['Update']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.update('inventory_transactions', id, data, 'transaction_id');
    },

    delete: async (id: number) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.delete('inventory_transactions', id, 'transaction_id', false);
    },

    getCountByFilters: async (filters: {
      type?: string;
      item_id?: number;
      start_date?: string;
      end_date?: string;
    }) => {
      const builder = new SupabaseQueryBuilder();
      const result = await builder.select('inventory_transactions', {
        filters: {
          ...(filters.type && { transaction_type: filters.type }),
          ...(filters.item_id && { item_id: filters.item_id }),
        },
        count: true,
        limit: 1
      });

      return {
        success: result.success,
        data: result.count || 0,
        error: result.error
      };
    }
  },

  // Alias for backward compatibility
  get inventoryTransactions() {
    return this.transactions;
  },

  /**
   * BOM operations
   */
  bom: {
    getAll: async (options: QueryOptions = {}) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.select('bom', {
        ...options,
        filters: { is_active: true, ...options.filters },
      });
    },

    getById: async (id: number) => {
      try {
        const { data, error } = await supabase
          .from('bom')
          .select('*')
          .eq('bom_id', id)
          .single();

        if (error) return handleSupabaseError('getById', 'bom', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('getById', 'bom', error);
      }
    },

    getByParentId: async (parentId: number) => {
      try {
        const { data, error } = await supabase
          .from('bom')
          .select(`
            *,
            parent_item:items!bom_parent_item_id_fkey(item_id, item_code, item_name, spec, unit),
            child_item:items!bom_child_item_id_fkey(item_id, item_code, item_name, spec, unit)
          `)
          .eq('parent_item_id', parentId)
          .eq('is_active', true);

        if (error) return handleSupabaseError('getByParentId', 'bom', error);
        return createSuccessResponse(data);
      } catch (error) {
        return handleSupabaseError('getByParentId', 'bom', error);
      }
    },

    create: async (bom: Database['public']['Tables']['bom']['Insert']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.insert('bom', bom);
    },

    update: async (id: number, bom: Database['public']['Tables']['bom']['Update']) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.update('bom', id, bom, 'bom_id');
    },

    delete: async (id: number) => {
      const builder = new SupabaseQueryBuilder();
      return await builder.delete('bom', id, 'bom_id', true);
    },
  },

  /**
   * Raw SQL query execution (DEPRECATED - use Supabase MCP for complex queries)
   * Maintained for backward compatibility only
   * Returns SupabaseResponse format for consistency
   */
  query: async <T>(sql: string, params?: any[]): Promise<SupabaseResponse<T[]>> => {
    console.warn('Warning: db.query() is deprecated. Use typed methods or Supabase MCP.');

    try {
      // Use standalone query function
      const result = await query<T>(sql, params);

      return {
        success: true,
        data: result
      };
    } catch (error: any) {
      console.error('[db.query] Failed:', error);
      return {
        success: false,
        error: error.message || 'Query failed. Consider using Supabase MCP for complex queries.'
      };
    }
  },
};

// ============================================================================
// LEGACY COMPATIBILITY (For gradual migration)
// ============================================================================

/**
 * Connection test (for health checks)
 */
export async function testConnection(): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase.from('items').select('item_id').limit(1);
    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

/**
 * Raw query execution (use sparingly - prefer typed methods)
 * For complex queries with JOINs and aggregations, use Supabase MCP instead
 */
export async function query<T>(sql: string, params?: any[]): Promise<T[]> {
  console.warn('Warning: Using raw query. Consider using typed methods or Supabase MCP.');

  try {
    // Use Supabase RPC for SQL execution
    // Note: This requires a database function to execute arbitrary SQL
    // For production, implement proper stored procedures or use Supabase MCP
    const { data, error } = await (supabaseAdmin.rpc as any)('exec_sql', {
      query_text: sql,
      params: params || []
    });

    if (error) {
      // Fallback: If RPC not available, throw error to use MCP
      console.error('[query] RPC failed:', error);
      throw new Error('Use Supabase MCP for complex SQL: ' + error.message);
    }

    return data as T[];
  } catch (error: any) {
    console.error('[query] Failed:', error);
    // Return empty array for compatibility, log warning
    console.warn('Query failed. Consider using Supabase MCP for complex queries.');
    return [] as T[];
  }
}

// Export everything for backward compatibility
export * from '@supabase/supabase-js';
export type { Database } from '@/types/supabase';

```


#### 📄 src\lib\error-format.ts

```typescript
/**
 * Standardized error format for ERP system
 * 태창 ERP 시스템의 표준화된 오류 형식
 */

/**
 * Error codes with Korean descriptions
 */
export enum ErrorCode {
  // Validation errors (4xx)
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  MISSING_REQUIRED_FIELD = 'MISSING_REQUIRED_FIELD',
  INVALID_FORMAT = 'INVALID_FORMAT',
  INVALID_TYPE = 'INVALID_TYPE',
  INVALID_VALUE = 'INVALID_VALUE',
  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',

  // Authentication & Authorization errors (401, 403)
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  TOKEN_INVALID = 'TOKEN_INVALID',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',

  // Resource errors (404, 409)
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',
  RESOURCE_CONFLICT = 'RESOURCE_CONFLICT',
  RESOURCE_LOCKED = 'RESOURCE_LOCKED',

  // Business logic errors (422)
  BUSINESS_RULE_VIOLATION = 'BUSINESS_RULE_VIOLATION',
  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK',
  INVALID_OPERATION = 'INVALID_OPERATION',
  CONSTRAINT_VIOLATION = 'CONSTRAINT_VIOLATION',

  // Rate limiting (429)
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',

  // Server errors (5xx)
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR = 'EXTERNAL_SERVICE_ERROR',
  CONFIGURATION_ERROR = 'CONFIGURATION_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
}

/**
 * Korean error messages mapping
 */
export const ERROR_MESSAGES: Record<ErrorCode, string> = {
  // Validation errors
  [ErrorCode.VALIDATION_ERROR]: '입력값 검증에 실패했습니다',
  [ErrorCode.MISSING_REQUIRED_FIELD]: '필수 입력 항목이 누락되었습니다',
  [ErrorCode.INVALID_FORMAT]: '입력 형식이 올바르지 않습니다',
  [ErrorCode.INVALID_TYPE]: '입력 타입이 올바르지 않습니다',
  [ErrorCode.INVALID_VALUE]: '입력값이 유효하지 않습니다',
  [ErrorCode.DUPLICATE_ENTRY]: '중복된 데이터입니다',

  // Authentication & Authorization
  [ErrorCode.UNAUTHORIZED]: '인증이 필요합니다',
  [ErrorCode.FORBIDDEN]: '접근 권한이 없습니다',
  [ErrorCode.INVALID_CREDENTIALS]: '로그인 정보가 올바르지 않습니다',
  [ErrorCode.TOKEN_EXPIRED]: '세션이 만료되었습니다. 다시 로그인해주세요',
  [ErrorCode.TOKEN_INVALID]: '유효하지 않은 토큰입니다',
  [ErrorCode.INSUFFICIENT_PERMISSIONS]: '해당 작업을 수행할 권한이 없습니다',

  // Resource errors
  [ErrorCode.RESOURCE_NOT_FOUND]: '요청한 리소스를 찾을 수 없습니다',
  [ErrorCode.RESOURCE_CONFLICT]: '리소스 충돌이 발생했습니다',
  [ErrorCode.RESOURCE_LOCKED]: '리소스가 잠겨있습니다',

  // Business logic errors
  [ErrorCode.BUSINESS_RULE_VIOLATION]: '비즈니스 규칙 위반입니다',
  [ErrorCode.INSUFFICIENT_STOCK]: '재고가 부족합니다',
  [ErrorCode.INVALID_OPERATION]: '유효하지 않은 작업입니다',
  [ErrorCode.CONSTRAINT_VIOLATION]: '제약 조건 위반입니다',

  // Rate limiting
  [ErrorCode.RATE_LIMIT_EXCEEDED]: '요청 한도를 초과했습니다',
  [ErrorCode.TOO_MANY_REQUESTS]: '너무 많은 요청이 발생했습니다',

  // Server errors
  [ErrorCode.INTERNAL_SERVER_ERROR]: '서버 내부 오류가 발생했습니다',
  [ErrorCode.DATABASE_ERROR]: '데이터베이스 오류가 발생했습니다',
  [ErrorCode.EXTERNAL_SERVICE_ERROR]: '외부 서비스 오류가 발생했습니다',
  [ErrorCode.CONFIGURATION_ERROR]: '서버 설정 오류입니다',
  [ErrorCode.SERVICE_UNAVAILABLE]: '서비스를 사용할 수 없습니다',
  [ErrorCode.TIMEOUT_ERROR]: '요청 시간이 초과되었습니다',
};

/**
 * HTTP status code mapping for error codes
 */
export const ERROR_STATUS_CODES: Record<ErrorCode, number> = {
  // 400 Bad Request
  [ErrorCode.VALIDATION_ERROR]: 400,
  [ErrorCode.MISSING_REQUIRED_FIELD]: 400,
  [ErrorCode.INVALID_FORMAT]: 400,
  [ErrorCode.INVALID_TYPE]: 400,
  [ErrorCode.INVALID_VALUE]: 400,

  // 401 Unauthorized
  [ErrorCode.UNAUTHORIZED]: 401,
  [ErrorCode.INVALID_CREDENTIALS]: 401,
  [ErrorCode.TOKEN_EXPIRED]: 401,
  [ErrorCode.TOKEN_INVALID]: 401,

  // 403 Forbidden
  [ErrorCode.FORBIDDEN]: 403,
  [ErrorCode.INSUFFICIENT_PERMISSIONS]: 403,

  // 404 Not Found
  [ErrorCode.RESOURCE_NOT_FOUND]: 404,

  // 409 Conflict
  [ErrorCode.DUPLICATE_ENTRY]: 409,
  [ErrorCode.RESOURCE_CONFLICT]: 409,
  [ErrorCode.RESOURCE_LOCKED]: 409,

  // 422 Unprocessable Entity
  [ErrorCode.BUSINESS_RULE_VIOLATION]: 422,
  [ErrorCode.INSUFFICIENT_STOCK]: 422,
  [ErrorCode.INVALID_OPERATION]: 422,
  [ErrorCode.CONSTRAINT_VIOLATION]: 422,

  // 429 Too Many Requests
  [ErrorCode.RATE_LIMIT_EXCEEDED]: 429,
  [ErrorCode.TOO_MANY_REQUESTS]: 429,

  // 500 Internal Server Error
  [ErrorCode.INTERNAL_SERVER_ERROR]: 500,
  [ErrorCode.DATABASE_ERROR]: 500,
  [ErrorCode.CONFIGURATION_ERROR]: 500,

  // 502 Bad Gateway
  [ErrorCode.EXTERNAL_SERVICE_ERROR]: 502,

  // 503 Service Unavailable
  [ErrorCode.SERVICE_UNAVAILABLE]: 503,

  // 504 Gateway Timeout
  [ErrorCode.TIMEOUT_ERROR]: 504,
};

/**
 * Standardized error response interface
 */
export interface ErrorResponse {
  success: false;
  error: {
    code: ErrorCode;
    message: string;
    details?: any;
    field?: string;
    resource?: string;
    action?: string;
  };
  timestamp: string;
  requestId?: string;
  path?: string;
}

/**
 * Standardized success response interface
 */
export interface SuccessResponse<T = any> {
  success: true;
  data: T;
  message?: string;
  timestamp?: string;
  requestId?: string;
}

/**
 * API Response type union
 */
export type APIResponse<T = any> = SuccessResponse<T> | ErrorResponse;

/**
 * Error details for specific error types
 */
export interface ValidationErrorDetails {
  field: string;
  value?: any;
  expectedType?: string;
  allowedValues?: any[];
  constraints?: Record<string, any>;
}

export interface BusinessRuleErrorDetails {
  rule: string;
  entity?: string;
  entityId?: string | number;
  conflictingData?: any;
}

export interface ResourceErrorDetails {
  resource: string;
  id?: string | number;
  action?: string;
  availability?: Date;
}

export interface RateLimitErrorDetails {
  limit: number;
  windowMs: number;
  retryAfter: number;
  endpoint?: string;
}

/**
 * Create standardized error response
 */
export function createErrorResponse(
  code: ErrorCode,
  customMessage?: string,
  details?: any,
  options: {
    field?: string;
    resource?: string;
    action?: string;
    requestId?: string;
    path?: string;
  } = {}
): ErrorResponse {
  return {
    success: false,
    error: {
      code,
      message: customMessage || ERROR_MESSAGES[code],
      details,
      field: options.field,
      resource: options.resource,
      action: options.action,
    },
    timestamp: new Date().toISOString(),
    requestId: options.requestId,
    path: options.path,
  };
}

/**
 * Create standardized success response
 */
export function createSuccessResponse<T>(
  data: T,
  message?: string,
  options: {
    requestId?: string;
  } = {}
): SuccessResponse<T> {
  return {
    success: true,
    data,
    message,
    timestamp: new Date().toISOString(),
    requestId: options.requestId,
  };
}

/**
 * Get HTTP status code for error code
 */
export function getStatusCode(errorCode: ErrorCode): number {
  return ERROR_STATUS_CODES[errorCode] || 500;
}

/**
 * Check if error is client error (4xx)
 */
export function isClientError(errorCode: ErrorCode): boolean {
  const statusCode = getStatusCode(errorCode);
  return statusCode >= 400 && statusCode < 500;
}

/**
 * Check if error is server error (5xx)
 */
export function isServerError(errorCode: ErrorCode): boolean {
  const statusCode = getStatusCode(errorCode);
  return statusCode >= 500;
}

/**
 * ERP-specific error class
 */
export class ERPError extends Error {
  public readonly code: ErrorCode;
  public readonly details?: any;
  public readonly field?: string;
  public readonly resource?: string;
  public readonly action?: string;

  constructor(
    code: ErrorCode,
    message?: string,
    details?: any,
    options: {
      field?: string;
      resource?: string;
      action?: string;
    } = {}
  ) {
    super(message || ERROR_MESSAGES[code]);
    this.name = 'ERPError';
    this.code = code;
    this.details = details;
    this.field = options.field;
    this.resource = options.resource;
    this.action = options.action;

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ERPError);
    }
  }

  /**
   * Get HTTP status code for this error
   */
  get statusCode(): number {
    return getStatusCode(this.code);
  }

  /**
   * Convert to error response format
   */
  toErrorResponse(options: {
    requestId?: string;
    path?: string;
  } = {}): ErrorResponse {
    return createErrorResponse(
      this.code,
      this.message,
      this.details,
      {
        field: this.field,
        resource: this.resource,
        action: this.action,
        requestId: options.requestId,
        path: options.path,
      }
    );
  }

  /**
   * Create validation error
   */
  static validation(
    message: string,
    field?: string,
    details?: ValidationErrorDetails
  ): ERPError {
    return new ERPError(
      ErrorCode.VALIDATION_ERROR,
      message,
      details,
      { field }
    );
  }

  /**
   * Create business rule error
   */
  static businessRule(
    message: string,
    details?: BusinessRuleErrorDetails
  ): ERPError {
    return new ERPError(
      ErrorCode.BUSINESS_RULE_VIOLATION,
      message,
      details
    );
  }

  /**
   * Create resource not found error
   */
  static notFound(
    resource: string,
    id?: string | number,
    action?: string
  ): ERPError {
    return new ERPError(
      ErrorCode.RESOURCE_NOT_FOUND,
      `${resource}을(를) 찾을 수 없습니다`,
      { id },
      { resource, action }
    );
  }

  /**
   * Create duplicate entry error
   */
  static duplicate(
    resource: string,
    field?: string,
    value?: any
  ): ERPError {
    return new ERPError(
      ErrorCode.DUPLICATE_ENTRY,
      `중복된 ${resource}입니다`,
      { field, value },
      { resource, field }
    );
  }

  /**
   * Create insufficient permissions error
   */
  static forbidden(
    action?: string,
    resource?: string
  ): ERPError {
    return new ERPError(
      ErrorCode.FORBIDDEN,
      '접근 권한이 없습니다',
      { action, resource },
      { action, resource }
    );
  }

  /**
   * Create database error
   */
  static database(
    message: string,
    details?: any
  ): ERPError {
    return new ERPError(
      ErrorCode.DATABASE_ERROR,
      message,
      details
    );
  }
}

/**
 * MySQL error code mapping to ERP error codes
 */
export const MYSQL_ERROR_MAPPING: Record<string, ErrorCode> = {
  'ER_NO_SUCH_TABLE': ErrorCode.CONFIGURATION_ERROR,
  'ER_BAD_FIELD_ERROR': ErrorCode.CONFIGURATION_ERROR,
  'ER_DUP_ENTRY': ErrorCode.DUPLICATE_ENTRY,
  'ER_NO_REFERENCED_ROW': ErrorCode.CONSTRAINT_VIOLATION,
  'ER_ROW_IS_REFERENCED': ErrorCode.CONSTRAINT_VIOLATION,
  'ER_LOCK_WAIT_TIMEOUT': ErrorCode.RESOURCE_LOCKED,
  'ER_LOCK_DEADLOCK': ErrorCode.RESOURCE_CONFLICT,
  'ECONNREFUSED': ErrorCode.SERVICE_UNAVAILABLE,
  'ETIMEDOUT': ErrorCode.TIMEOUT_ERROR,
  'ENOTFOUND': ErrorCode.CONFIGURATION_ERROR,
};

/**
 * Convert MySQL error to ERP error
 */
export function convertMySQLError(mysqlError: any): ERPError {
  const errorCode = MYSQL_ERROR_MAPPING[mysqlError.code] || ErrorCode.DATABASE_ERROR;

  let message = ERROR_MESSAGES[errorCode];
  let details = mysqlError;

  // Customize messages for specific MySQL errors
  switch (mysqlError.code) {
    case 'ER_DUP_ENTRY':
      message = '중복된 데이터입니다';
      break;
    case 'ER_NO_REFERENCED_ROW':
      message = '참조하는 데이터가 존재하지 않습니다';
      break;
    case 'ER_ROW_IS_REFERENCED':
      message = '삭제할 수 없습니다. 다른 데이터에서 참조중입니다';
      break;
    case 'ER_LOCK_WAIT_TIMEOUT':
      message = '다른 사용자가 사용중입니다. 잠시 후 다시 시도해주세요';
      break;
  }

  // Hide sensitive details in production
  if (process.env.NODE_ENV === 'production') {
    details = { code: mysqlError.code };
  }

  return new ERPError(errorCode, message, details);
}
```


#### 📄 src\lib\errorAdapter.ts

```typescript
import { NextResponse } from 'next/server';
import {
  errorHandler,
  ErrorType,
  ERPError,
  createSuccessResponse as newCreateSuccessResponse,
  handleError as newHandleError
} from './errorHandler';

/**
 * 기존 validationMiddleware와의 호환성을 위한 어댑터
 */

/**
 * 기존 createErrorResponse와 호환되는 함수
 * @deprecated 새로운 handleError 사용 권장
 */
export function createErrorResponse(
  message: string,
  statusCode: number = 500,
  details?: any
): NextResponse {
  // 상태 코드에 따른 에러 유형 매핑
  let errorType: ErrorType;

  switch (statusCode) {
    case 400:
      errorType = ErrorType.VALIDATION;
      break;
    case 401:
      errorType = ErrorType.AUTHENTICATION;
      break;
    case 403:
      errorType = ErrorType.AUTHORIZATION;
      break;
    case 404:
      errorType = ErrorType.NOT_FOUND;
      break;
    case 409:
      errorType = ErrorType.CONFLICT;
      break;
    case 422:
      errorType = ErrorType.BUSINESS_RULE;
      break;
    case 503:
      errorType = ErrorType.DATABASE_CONNECTION;
      break;
    default:
      errorType = ErrorType.SYSTEM;
  }

  const erpError = new ERPError(errorType, message, details);
  return errorHandler.handleError(erpError);
}

/**
 * 기존 createSuccessResponse와 호환되는 함수
 * 새로운 시스템으로 자동 전달
 */
export function createSuccessResponse<T>(
  data: T,
  message?: string,
  statusCode?: number,
  metadata?: any
): NextResponse {
  return newCreateSuccessResponse(data, message, metadata);
}

/**
 * 기존 withErrorHandler와 호환되는 함수
 * @deprecated 새로운 handleError 직접 사용 권장
 */
export async function withErrorHandler<T>(
  handler: () => Promise<T>,
  context?: {
    resource?: string;
    action?: string;
    userId?: string;
    requestId?: string;
  }
): Promise<NextResponse> {
  try {
    const result = await handler();
    return newCreateSuccessResponse(result);
  } catch (error) {
    return newHandleError(error, context);
  }
}

/**
 * 기존 API 라우트를 새로운 에러 핸들러로 감싸는 래퍼
 */
export function wrapApiRoute(
  handler: (request: any, context?: any) => Promise<NextResponse>,
  options?: {
    resource?: string;
    action?: string;
  }
) {
  return async (request: any, routeContext?: any) => {
    const context = {
      resource: options?.resource,
      action: options?.action,
      userId: request.headers?.get?.('x-user-id') || undefined,
      requestId: request.headers?.get?.('x-request-id') || undefined
    };

    try {
      return await handler(request, routeContext);
    } catch (error) {
      return newHandleError(error, context);
    }
  };
}

/**
 * 기존 MySQL 에러 처리와 호환
 */
export function handleDatabaseError(error: unknown): NextResponse {
  const erpError = errorHandler.convertMySQLError(error);
  return errorHandler.handleError(erpError);
}

/**
 * 기존 검증 에러 처리와 호환
 */
export function handleValidationError(errors: string[]): NextResponse {
  return errorHandler.handleValidationError(errors);
}

/**
 * 기존 Not Found 에러 처리와 호환
 */
export function handleNotFoundError(resource: string): NextResponse {
  return errorHandler.handleNotFoundError(resource);
}

/**
 * 마이그레이션 도우미: 기존 try-catch 블록을 새로운 시스템으로 변환
 */
export function migrateErrorHandling(
  originalTryCatchBlock: () => Promise<NextResponse>,
  context?: {
    resource?: string;
    action?: string;
    userId?: string;
    requestId?: string;
  }
): Promise<NextResponse> {
  return withErrorHandler(async () => {
    return await originalTryCatchBlock();
  }, context);
}

/**
 * 개발자를 위한 마이그레이션 가이드 출력
 */
export function printMigrationGuide(): void {
  if (process.env.NODE_ENV === 'development') {
    console.log(`
🔄 에러 핸들링 마이그레이션 가이드

기존 코드:
  try {
    // API 로직
    return createSuccessResponse(data);
  } catch (error) {
    return createErrorResponse('Failed', 500);
  }

새로운 코드:
  try {
    // API 로직
    return createSuccessResponse(data);
  } catch (error) {
    return handleError(error, { resource: 'items', action: 'create' });
  }

더 나은 방법:
  const context = { resource: 'items', action: 'create', userId: 'user123' };
  try {
    // API 로직
    return createSuccessResponse(data);
  } catch (error) {
    return handleError(error, context);
  }

특화된 에러:
  if (!item) {
    return handleNotFoundError('아이템', itemId, context);
  }

  if (stockInsufficient) {
    return handleInsufficientStockError(itemCode, requested, available, context);
  }
    `);
  }
}

// 개발 환경에서 가이드 출력
if (process.env.NODE_ENV === 'development') {
  // printMigrationGuide(); // 필요시 주석 해제
}
```


#### 📄 src\lib\errorHandler.ts

```typescript
import { NextResponse } from 'next/server';
import { errorLoggingManager } from './errorLogger';

/**
 * 에러 유형 정의
 */
export enum ErrorType {
  // 검증 관련 에러
  VALIDATION = 'VALIDATION',
  AUTHENTICATION = 'AUTHENTICATION',
  AUTHORIZATION = 'AUTHORIZATION',

  // 데이터베이스 관련 에러
  DATABASE_CONNECTION = 'DATABASE_CONNECTION',
  DATABASE_QUERY = 'DATABASE_QUERY',
  DATABASE_CONSTRAINT = 'DATABASE_CONSTRAINT',
  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',

  // 비즈니스 로직 에러
  BUSINESS_RULE = 'BUSINESS_RULE',
  INSUFFICIENT_STOCK = 'INSUFFICIENT_STOCK',
  INVALID_OPERATION = 'INVALID_OPERATION',

  // 시스템 에러
  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',
  FILE_OPERATION = 'FILE_OPERATION',
  SYSTEM = 'SYSTEM',

  // 리소스 에러
  NOT_FOUND = 'NOT_FOUND',
  CONFLICT = 'CONFLICT'
}

/**
 * 에러 심각도 레벨
 */
export enum ErrorSeverity {
  LOW = 'LOW',        // 일반적인 사용자 실수
  MEDIUM = 'MEDIUM',  // 비즈니스 로직 위반
  HIGH = 'HIGH',      // 시스템 오류
  CRITICAL = 'CRITICAL' // 시스템 다운 가능성
}

/**
 * 한국어 에러 메시지 정의
 */
export const ErrorMessages = {
  // 검증 에러
  [ErrorType.VALIDATION]: {
    ko: '입력값이 올바르지 않습니다',
    en: 'Invalid input data'
  },
  [ErrorType.AUTHENTICATION]: {
    ko: '인증이 필요합니다',
    en: 'Authentication required'
  },
  [ErrorType.AUTHORIZATION]: {
    ko: '접근 권한이 없습니다',
    en: 'Access denied'
  },

  // 데이터베이스 에러
  [ErrorType.DATABASE_CONNECTION]: {
    ko: '데이터베이스 연결에 실패했습니다',
    en: 'Database connection failed'
  },
  [ErrorType.DATABASE_QUERY]: {
    ko: '데이터베이스 작업에 실패했습니다',
    en: 'Database operation failed'
  },
  [ErrorType.DATABASE_CONSTRAINT]: {
    ko: '데이터 무결성 제약 조건을 위반했습니다',
    en: 'Database constraint violation'
  },
  [ErrorType.DUPLICATE_ENTRY]: {
    ko: '이미 존재하는 데이터입니다',
    en: 'Duplicate entry'
  },

  // 비즈니스 로직 에러
  [ErrorType.BUSINESS_RULE]: {
    ko: '비즈니스 규칙을 위반했습니다',
    en: 'Business rule violation'
  },
  [ErrorType.INSUFFICIENT_STOCK]: {
    ko: '재고가 부족합니다',
    en: 'Insufficient stock'
  },
  [ErrorType.INVALID_OPERATION]: {
    ko: '유효하지 않은 작업입니다',
    en: 'Invalid operation'
  },

  // 시스템 에러
  [ErrorType.EXTERNAL_SERVICE]: {
    ko: '외부 서비스 연결에 실패했습니다',
    en: 'External service connection failed'
  },
  [ErrorType.FILE_OPERATION]: {
    ko: '파일 작업에 실패했습니다',
    en: 'File operation failed'
  },
  [ErrorType.SYSTEM]: {
    ko: '시스템 오류가 발생했습니다',
    en: 'System error occurred'
  },

  // 리소스 에러
  [ErrorType.NOT_FOUND]: {
    ko: '요청한 리소스를 찾을 수 없습니다',
    en: 'Resource not found'
  },
  [ErrorType.CONFLICT]: {
    ko: '리소스 충돌이 발생했습니다',
    en: 'Resource conflict'
  }
};

/**
 * 에러 유형별 HTTP 상태 코드 매핑
 */
export const ErrorStatusCodes = {
  [ErrorType.VALIDATION]: 400,
  [ErrorType.AUTHENTICATION]: 401,
  [ErrorType.AUTHORIZATION]: 403,
  [ErrorType.DATABASE_CONNECTION]: 503,
  [ErrorType.DATABASE_QUERY]: 500,
  [ErrorType.DATABASE_CONSTRAINT]: 422,
  [ErrorType.DUPLICATE_ENTRY]: 409,
  [ErrorType.BUSINESS_RULE]: 422,
  [ErrorType.INSUFFICIENT_STOCK]: 422,
  [ErrorType.INVALID_OPERATION]: 400,
  [ErrorType.EXTERNAL_SERVICE]: 503,
  [ErrorType.FILE_OPERATION]: 500,
  [ErrorType.SYSTEM]: 500,
  [ErrorType.NOT_FOUND]: 404,
  [ErrorType.CONFLICT]: 409
};

/**
 * 에러 유형별 심각도 매핑
 */
export const ErrorSeverityMap = {
  [ErrorType.VALIDATION]: ErrorSeverity.LOW,
  [ErrorType.AUTHENTICATION]: ErrorSeverity.MEDIUM,
  [ErrorType.AUTHORIZATION]: ErrorSeverity.MEDIUM,
  [ErrorType.DATABASE_CONNECTION]: ErrorSeverity.CRITICAL,
  [ErrorType.DATABASE_QUERY]: ErrorSeverity.HIGH,
  [ErrorType.DATABASE_CONSTRAINT]: ErrorSeverity.MEDIUM,
  [ErrorType.DUPLICATE_ENTRY]: ErrorSeverity.LOW,
  [ErrorType.BUSINESS_RULE]: ErrorSeverity.MEDIUM,
  [ErrorType.INSUFFICIENT_STOCK]: ErrorSeverity.MEDIUM,
  [ErrorType.INVALID_OPERATION]: ErrorSeverity.LOW,
  [ErrorType.EXTERNAL_SERVICE]: ErrorSeverity.HIGH,
  [ErrorType.FILE_OPERATION]: ErrorSeverity.MEDIUM,
  [ErrorType.SYSTEM]: ErrorSeverity.CRITICAL,
  [ErrorType.NOT_FOUND]: ErrorSeverity.LOW,
  [ErrorType.CONFLICT]: ErrorSeverity.MEDIUM
};

/**
 * 구조화된 에러 정보
 */
export type ErrorDetails = Record<string, unknown> | string[] | string | null;

export interface ErrorInfo {
  type: ErrorType;
  message: string;
  details?: ErrorDetails;
  severity: ErrorSeverity;
  statusCode: number;
  timestamp: string;
  requestId?: string;
  userId?: string;
  resource?: string;
  action?: string;
  stackTrace?: string;
}

/**
 * 표준 API 응답 인터페이스
 */
export interface StandardResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: {
    type: string;
    message: string;
    details?: ErrorDetails;
    timestamp: string;
    requestId?: string;
  };
  metadata?: {
    total?: number;
    page?: number;
    limit?: number;
    hasMore?: boolean;
  };
}

/**
 * 커스텀 에러 클래스
 */
export class ERPError extends Error {
  public readonly type: ErrorType;
  public readonly severity: ErrorSeverity;
  public readonly statusCode: number;
  public readonly details?: ErrorDetails;
  public readonly timestamp: string;
  public readonly requestId?: string;
  public readonly userId?: string;
  public readonly resource?: string;
  public readonly action?: string;

  constructor(
    type: ErrorType,
    message?: string,
    details?: ErrorDetails,
    options?: {
      requestId?: string;
      userId?: string;
      resource?: string;
      action?: string;
    }
  ) {
    const errorMessage = message || ErrorMessages[type].ko;
    super(errorMessage);

    this.name = 'ERPError';
    this.type = type;
    this.severity = ErrorSeverityMap[type];
    this.statusCode = ErrorStatusCodes[type];
    this.details = details;
    this.timestamp = new Date().toISOString();
    this.requestId = options?.requestId;
    this.userId = options?.userId;
    this.resource = options?.resource;
    this.action = options?.action;

    // Error.captureStackTrace가 존재하는 경우에만 사용
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ERPError);
    }
  }

  toJSON(): ErrorInfo {
    return {
      type: this.type,
      message: this.message,
      details: this.details,
      severity: this.severity,
      statusCode: this.statusCode,
      timestamp: this.timestamp,
      requestId: this.requestId,
      userId: this.userId,
      resource: this.resource,
      action: this.action,
      stackTrace: process.env.NODE_ENV === 'development' ? this.stack : undefined
    };
  }
}

/**
 * 통합 에러 핸들러 클래스
 */
export class ErrorHandler {
  private static instance: ErrorHandler;
  private loggers: ((error: ErrorInfo) => void)[] = [];

  private constructor() {}

  public static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }

  /**
   * 로거 추가
   */
  public addLogger(logger: (error: ErrorInfo) => void): void {
    this.loggers.push(logger);
  }

  /**
   * 에러 로깅
   */
  private logError(error: ErrorInfo): void {
    // 콘솔 로깅 (개발 환경)
    if (process.env.NODE_ENV === 'development') {
      console.error('🚨 ERP Error:', {
        type: error.type,
        message: error.message,
        severity: error.severity,
        details: error.details,
        timestamp: error.timestamp,
        resource: error.resource,
        action: error.action
      });
    }

    // 등록된 추가 로거들 실행
    this.loggers.forEach(logger => {
      try {
        logger(error);
      } catch (loggerError) {
        console.error('Logger error:', loggerError);
      }
    });
  }

  /**
   * MySQL 에러 코드를 ERPError로 변환
   */
  public convertMySQLError(error: unknown, context?: { resource?: string; action?: string; userId?: string }): ERPError {
    const { resource, action, userId } = context || {};

    // Type guard for error object
    if (!error || typeof error !== 'object' || !('code' in error)) {
      return new ERPError(
        ErrorType.DATABASE_QUERY,
        '알 수 없는 데이터베이스 오류가 발생했습니다',
        { originalError: String(error) },
        { resource, action, userId }
      );
    }

    const dbError = error as { code?: string; sqlState?: string; errno?: number; message?: string };

    switch (dbError.code) {
      case 'ER_NO_SUCH_TABLE':
        return new ERPError(
          ErrorType.DATABASE_QUERY,
          '데이터베이스 테이블을 찾을 수 없습니다',
          { sqlState: dbError.sqlState, errno: dbError.errno },
          { resource, action, userId }
        );

      case 'ER_BAD_FIELD_ERROR':
        return new ERPError(
          ErrorType.DATABASE_QUERY,
          '유효하지 않은 데이터베이스 필드입니다',
          { sqlState: dbError.sqlState, errno: dbError.errno },
          { resource, action, userId }
        );

      case 'ER_DUP_ENTRY':
        return new ERPError(
          ErrorType.DUPLICATE_ENTRY,
          '이미 존재하는 데이터입니다',
          { sqlState: dbError.sqlState, errno: dbError.errno },
          { resource, action, userId }
        );

      case 'ER_ROW_IS_REFERENCED_2':
        return new ERPError(
          ErrorType.DATABASE_CONSTRAINT,
          '다른 데이터에서 참조 중인 항목은 삭제할 수 없습니다',
          { sqlState: dbError.sqlState, errno: dbError.errno },
          { resource, action, userId }
        );

      case 'ER_NO_REFERENCED_ROW_2':
        return new ERPError(
          ErrorType.DATABASE_CONSTRAINT,
          '참조하는 데이터가 존재하지 않습니다',
          { sqlState: dbError.sqlState, errno: dbError.errno },
          { resource, action, userId }
        );

      case 'ECONNREFUSED':
      case 'ENOTFOUND':
        return new ERPError(
          ErrorType.DATABASE_CONNECTION,
          '데이터베이스 연결에 실패했습니다',
          { code: dbError.code, errno: dbError.errno },
          { resource, action, userId }
        );

      default:
        return new ERPError(
          ErrorType.DATABASE_QUERY,
          '데이터베이스 작업 중 오류가 발생했습니다',
          {
            code: dbError.code,
            sqlState: dbError.sqlState,
            errno: dbError.errno,
            originalMessage: dbError.message
          },
          { resource, action, userId }
        );
    }
  }

  /**
   * 에러를 NextResponse로 변환
   */
  public handleError(
    error: unknown,
    context?: {
      resource?: string;
      action?: string;
      userId?: string;
      requestId?: string;
    }
  ): NextResponse {
    let erpError: ERPError;

    if (error instanceof ERPError) {
      erpError = error;
    } else if (error && typeof error === 'object' && 'code' in error) {
      // MySQL 에러
      erpError = this.convertMySQLError(error, context);
    } else if (error instanceof Error) {
      // 일반 JavaScript 에러
      erpError = new ERPError(
        ErrorType.SYSTEM,
        error.message || '시스템 오류가 발생했습니다',
        { originalError: error.name },
        context
      );
    } else {
      // 알 수 없는 에러
      erpError = new ERPError(
        ErrorType.SYSTEM,
        '알 수 없는 오류가 발생했습니다',
        { originalError: String(error) },
        context
      );
    }

    // 에러 로깅 (로깅 매니저에 위임)
    errorLoggingManager.logError(erpError.toJSON()).catch(logError => {
      console.error('Failed to log error:', logError);
    });

    // NextResponse 생성
    const response: StandardResponse = {
      success: false,
      error: {
        type: erpError.type,
        message: erpError.message,
        details: process.env.NODE_ENV === 'development' ? erpError.details : undefined,
        timestamp: erpError.timestamp,
        requestId: erpError.requestId
      }
    };

    return NextResponse.json(response, { status: erpError.statusCode });
  }

  /**
   * 성공 응답 생성
   */
  public createSuccessResponse<T>(
    data: T,
    message?: string,
    metadata?: {
      total?: number;
      page?: number;
      limit?: number;
      hasMore?: boolean;
    }
  ): NextResponse {
    const response: StandardResponse<T> = {
      success: true,
      data,
      metadata
    };

    return NextResponse.json(response);
  }

  /**
   * 검증 에러 처리
   */
  public handleValidationError(
    errors: string[] | Record<string, string>,
    context?: { resource?: string; action?: string; userId?: string }
  ): NextResponse {
    const errorDetails = Array.isArray(errors)
      ? { fields: errors }
      : { validation: errors };

    const erpError = new ERPError(
      ErrorType.VALIDATION,
      '입력 데이터가 유효하지 않습니다',
      errorDetails,
      context
    );

    return this.handleError(erpError, context);
  }

  /**
   * 비즈니스 로직 에러 처리
   */
  public handleBusinessError(
    message: string,
    details?: ErrorDetails,
    context?: { resource?: string; action?: string; userId?: string }
  ): NextResponse {
    const erpError = new ERPError(
      ErrorType.BUSINESS_RULE,
      message,
      details,
      context
    );

    return this.handleError(erpError, context);
  }

  /**
   * 리소스 미발견 에러 처리
   */
  public handleNotFoundError(
    resource: string,
    identifier?: string | number | null,
    context?: { userId?: string }
  ): NextResponse {
    const erpError = new ERPError(
      ErrorType.NOT_FOUND,
      `${resource}을(를) 찾을 수 없습니다`,
      { resource, identifier },
      { ...context, resource, action: 'read' }
    );

    return this.handleError(erpError, context);
  }

  /**
   * 재고 부족 에러 처리
   */
  public handleInsufficientStockError(
    itemCode: string,
    requested: number,
    available: number,
    context?: { userId?: string }
  ): NextResponse {
    const erpError = new ERPError(
      ErrorType.INSUFFICIENT_STOCK,
      `재고가 부족합니다. 요청: ${requested}, 가용: ${available}`,
      { itemCode, requested, available },
      { ...context, resource: 'stock', action: 'check' }
    );

    return this.handleError(erpError, context);
  }
}

// 싱글톤 인스턴스 내보내기
export const errorHandler = ErrorHandler.getInstance();

// Context type for error handlers
export interface ErrorContext {
  resource?: string;
  action?: string;
  userId?: string;
  requestId?: string;
}

// Metadata type for success responses
export interface ResponseMetadata {
  total?: number;
  page?: number;
  limit?: number;
  hasMore?: boolean;
}

// 편의 함수들
export const handleError = (error: unknown, context?: ErrorContext) =>
  errorHandler.handleError(error, context);

export const createSuccessResponse = <T>(data: T, message?: string, metadata?: ResponseMetadata) =>
  errorHandler.createSuccessResponse(data, message, metadata);

export const handleValidationError = (errors: string[] | Record<string, string>, context?: ErrorContext) =>
  errorHandler.handleValidationError(errors, context);

export const handleBusinessError = (message: string, details?: ErrorDetails, context?: ErrorContext) =>
  errorHandler.handleBusinessError(message, details, context);

export const handleNotFoundError = (resource: string, identifier?: string | number | null, context?: ErrorContext) =>
  errorHandler.handleNotFoundError(resource, identifier, context);

export const handleInsufficientStockError = (itemCode: string, requested: number, available: number, context?: ErrorContext) =>
  errorHandler.handleInsufficientStockError(itemCode, requested, available, context);
```


#### 📄 src\lib\errorLogger.ts

```typescript
import { ErrorInfo, ErrorSeverity } from './errorHandler';
import { query } from './db-unified';

/**
 * 에러 로그 데이터베이스 스키마 인터페이스
 */
export interface ErrorLog {
  log_id?: number;
  error_type: string;
  message: string;
  details?: string;
  severity: string;
  status_code: number;
  timestamp: string;
  request_id?: string;
  user_id?: string;
  resource?: string;
  action?: string;
  stack_trace?: string;
  resolved: boolean;
  resolved_at?: string;
  resolved_by?: string;
  created_at?: string;
}

/**
 * 에러 통계 인터페이스
 */
export interface ErrorStats {
  total_errors: number;
  critical_errors: number;
  high_errors: number;
  medium_errors: number;
  low_errors: number;
  unresolved_errors: number;
  today_errors: number;
  last_24h_errors: number;
  top_error_types: Array<{
    error_type: string;
    count: number;
    percentage: number;
  }>;
  error_trend: Array<{
    date: string;
    count: number;
    critical_count: number;
  }>;
}

/**
 * 데이터베이스 에러 로거
 */
export class DatabaseLogger {
  /**
   * 에러 로그를 데이터베이스에 저장
   */
  async logError(errorInfo: ErrorInfo): Promise<void> {
    try {
      const sql = `
        INSERT INTO error_logs (
          error_type, message, details, severity, status_code,
          timestamp, request_id, user_id, resource, action, stack_trace
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      `;

      await query(sql, [
        errorInfo.type,
        errorInfo.message,
        errorInfo.details ? JSON.stringify(errorInfo.details) : null,
        errorInfo.severity,
        errorInfo.statusCode,
        errorInfo.timestamp,
        errorInfo.requestId || null,
        errorInfo.userId || null,
        errorInfo.resource || null,
        errorInfo.action || null,
        errorInfo.stackTrace || null
      ]);
    } catch (error) {
      // 로깅 자체에서 에러가 발생한 경우 콘솔에만 기록
      console.error('Failed to log error to database:', error);
      console.error('Original error info:', errorInfo);
    }
  }

  /**
   * 에러 통계 조회
   */
  async getErrorStats(days: number = 7): Promise<ErrorStats> {
    try {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // 전체 통계
      const totalStatsQuery = `
        SELECT
          COUNT(*) as total_errors,
          SUM(CASE WHEN severity = 'CRITICAL' THEN 1 ELSE 0 END) as critical_errors,
          SUM(CASE WHEN severity = 'HIGH' THEN 1 ELSE 0 END) as high_errors,
          SUM(CASE WHEN severity = 'MEDIUM' THEN 1 ELSE 0 END) as medium_errors,
          SUM(CASE WHEN severity = 'LOW' THEN 1 ELSE 0 END) as low_errors,
          SUM(CASE WHEN resolved = false THEN 1 ELSE 0 END) as unresolved_errors,
          SUM(CASE WHEN DATE(created_at) = CURRENT_DATE THEN 1 ELSE 0 END) as today_errors,
          SUM(CASE WHEN created_at >= NOW() - INTERVAL '24 hours' THEN 1 ELSE 0 END) as last_24h_errors
        FROM error_logs
        WHERE created_at >= $1
      `;

      const totalStatsResult = await query<{total_errors: string, critical_errors: string, high_errors: string, medium_errors: string, low_errors: string, unresolved_errors: string, today_errors: string, last_24h_errors: string}>(totalStatsQuery, [startDate.toISOString()]);
      const totalStats = totalStatsResult[0];

      // 에러 유형별 통계
      const typeStatsQuery = `
        SELECT
          error_type,
          COUNT(*) as count,
          ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM error_logs WHERE created_at >= $1)), 2) as percentage
        FROM error_logs
        WHERE created_at >= $2
        GROUP BY error_type
        ORDER BY count DESC
        LIMIT 10
      `;

      const typeStats = await query<{error_type: string, count: string, percentage: string}>(typeStatsQuery, [startDate.toISOString(), startDate.toISOString()]);

      // 일별 에러 트렌드
      const trendQuery = `
        SELECT
          DATE(created_at) as date,
          COUNT(*) as count,
          SUM(CASE WHEN severity = 'CRITICAL' THEN 1 ELSE 0 END) as critical_count
        FROM error_logs
        WHERE created_at >= $1
        GROUP BY DATE(created_at)
        ORDER BY date ASC
      `;

      const trendData = await query<{date: string, count: string, critical_count: string}>(trendQuery, [startDate.toISOString()]);

      return {
        total_errors: totalStats ? parseInt(totalStats.total_errors) || 0 : 0,
        critical_errors: totalStats ? parseInt(totalStats.critical_errors) || 0 : 0,
        high_errors: totalStats ? parseInt(totalStats.high_errors) || 0 : 0,
        medium_errors: totalStats ? parseInt(totalStats.medium_errors) || 0 : 0,
        low_errors: totalStats ? parseInt(totalStats.low_errors) || 0 : 0,
        unresolved_errors: totalStats ? parseInt(totalStats.unresolved_errors) || 0 : 0,
        today_errors: totalStats ? parseInt(totalStats.today_errors) || 0 : 0,
        last_24h_errors: totalStats ? parseInt(totalStats.last_24h_errors) || 0 : 0,
        top_error_types: typeStats.map((stat: {error_type: string, count: string, percentage: string}) => ({
          error_type: stat.error_type,
          count: parseInt(stat.count),
          percentage: parseFloat(stat.percentage)
        })),
        error_trend: trendData.map((trend: {date: string, count: string, critical_count: string}) => ({
          date: trend.date,
          count: parseInt(trend.count),
          critical_count: parseInt(trend.critical_count)
        }))
      };
    } catch (error) {
      console.error('Failed to get error stats:', error);
      // 기본값 반환
      return {
        total_errors: 0,
        critical_errors: 0,
        high_errors: 0,
        medium_errors: 0,
        low_errors: 0,
        unresolved_errors: 0,
        today_errors: 0,
        last_24h_errors: 0,
        top_error_types: [],
        error_trend: []
      };
    }
  }

  /**
   * 에러 로그 조회 (페이징)
   */
  async getErrorLogs(options: {
    page?: number;
    limit?: number;
    severity?: ErrorSeverity;
    errorType?: string;
    resolved?: boolean;
    startDate?: Date;
    endDate?: Date;
  } = {}): Promise<{ logs: ErrorLog[]; total: number }> {
    const {
      page = 1,
      limit = 50,
      severity,
      errorType,
      resolved,
      startDate,
      endDate
    } = options;

    try {
      const whereConditions: string[] = [];
      const params: unknown[] = [];

      let paramIndex = 1;
      if (severity) {
        whereConditions.push(`severity = $${paramIndex++}`);
        params.push(severity);
      }

      if (errorType) {
        whereConditions.push(`error_type = $${paramIndex++}`);
        params.push(errorType);
      }

      if (resolved !== undefined) {
        whereConditions.push(`resolved = $${paramIndex++}`);
        params.push(resolved);
      }

      if (startDate) {
        whereConditions.push(`created_at >= $${paramIndex++}`);
        params.push(startDate.toISOString());
      }

      if (endDate) {
        whereConditions.push(`created_at <= $${paramIndex++}`);
        params.push(endDate.toISOString());
      }

      const whereClause = whereConditions.length > 0
        ? `WHERE ${whereConditions.join(' AND ')}`
        : '';

      // 총 개수 조회
      const countQuery = `SELECT COUNT(*) as total FROM error_logs ${whereClause}`;
      const countResult = await query<{total: string}>(countQuery, params);
      const total = parseInt(countResult[0]?.total || '0');

      // 로그 조회
      const offset = (page - 1) * limit;
      const logsQuery = `
        SELECT
          log_id, error_type, message, details, severity, status_code,
          timestamp, request_id, user_id, resource, action, stack_trace,
          resolved, resolved_at, resolved_by, created_at
        FROM error_logs
        ${whereClause}
        ORDER BY created_at DESC
        LIMIT $${paramIndex++} OFFSET $${paramIndex++}
      `;

      const logs = await query<ErrorLog>(logsQuery, [...params, limit, offset]);

      return { logs: Array.isArray(logs) ? logs : [], total };
    } catch (error) {
      console.error('Failed to get error logs:', error);
      return { logs: [], total: 0 };
    }
  }

  /**
   * 에러 해결 표시
   */
  async resolveError(logId: number, resolvedBy: string): Promise<boolean> {
    try {
      const sql = `
        UPDATE error_logs
        SET resolved = true, resolved_at = NOW(), resolved_by = $1
        WHERE log_id = $2
      `;

      const result = await query(sql, [resolvedBy, logId]);
      return Array.isArray(result) ? result.length > 0 : false;
    } catch (error) {
      console.error('Failed to resolve error:', error);
      return false;
    }
  }

  /**
   * 에러 로그 정리 (오래된 로그 삭제)
   */
  async cleanupOldLogs(daysToKeep: number = 90): Promise<number> {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

      const sql = `
        DELETE FROM error_logs
        WHERE created_at < $1 AND resolved = true
      `;

      const result = await query(sql, [cutoffDate.toISOString()]);
      return Array.isArray(result) ? result.length : 0;
    } catch (error) {
      console.error('Failed to cleanup old logs:', error);
      return 0;
    }
  }
}

/**
 * 파일 로거 (개발 환경용)
 */
export class FileLogger {
  private logFilePath: string;

  constructor(logFilePath: string = './logs/error.log') {
    this.logFilePath = logFilePath;
  }

  async logError(errorInfo: ErrorInfo): Promise<void> {
    if (process.env.NODE_ENV !== 'development') {
      return;
    }

    try {
      const fs = await import('fs/promises');
      const path = await import('path');

      // 로그 디렉토리 생성
      const logDir = path.dirname(this.logFilePath);
      await fs.mkdir(logDir, { recursive: true }).catch(() => {});

      // 로그 엔트리 생성
      const logEntry = {
        timestamp: errorInfo.timestamp,
        level: errorInfo.severity,
        type: errorInfo.type,
        message: errorInfo.message,
        details: errorInfo.details,
        resource: errorInfo.resource,
        action: errorInfo.action,
        userId: errorInfo.userId,
        requestId: errorInfo.requestId
      };

      const logLine = JSON.stringify(logEntry) + '\n';

      // 파일에 추가
      await fs.appendFile(this.logFilePath, logLine);
    } catch (error) {
      console.error('Failed to write to log file:', error);
    }
  }
}

/**
 * 콘솔 로거 (구조화된 출력)
 */
export class ConsoleLogger {
  private static readonly COLORS = {
    CRITICAL: '\x1b[41m\x1b[37m', // 빨간 배경, 흰 글자
    HIGH: '\x1b[31m',             // 빨간 글자
    MEDIUM: '\x1b[33m',           // 노란 글자
    LOW: '\x1b[36m',              // 시안 글자
    RESET: '\x1b[0m'              // 리셋
  };

  async logError(errorInfo: ErrorInfo): Promise<void> {
    const color = ConsoleLogger.COLORS[errorInfo.severity] || ConsoleLogger.COLORS.LOW;
    const reset = ConsoleLogger.COLORS.RESET;

    console.log(`\n${color}🚨 ERP 에러 발생${reset}`);
    console.log(`${color}┌─ 시간: ${errorInfo.timestamp}${reset}`);
    console.log(`${color}├─ 유형: ${errorInfo.type}${reset}`);
    console.log(`${color}├─ 심각도: ${errorInfo.severity}${reset}`);
    console.log(`${color}├─ 메시지: ${errorInfo.message}${reset}`);

    if (errorInfo.resource) {
      console.log(`${color}├─ 리소스: ${errorInfo.resource}${reset}`);
    }

    if (errorInfo.action) {
      console.log(`${color}├─ 액션: ${errorInfo.action}${reset}`);
    }

    if (errorInfo.userId) {
      console.log(`${color}├─ 사용자: ${errorInfo.userId}${reset}`);
    }

    if (errorInfo.requestId) {
      console.log(`${color}├─ 요청ID: ${errorInfo.requestId}${reset}`);
    }

    if (errorInfo.details) {
      console.log(`${color}├─ 상세정보:${reset}`);
      console.log(`${color}│  ${JSON.stringify(errorInfo.details, null, 2).replace(/\n/g, '\n│  ')}${reset}`);
    }

    if (errorInfo.stackTrace && process.env.NODE_ENV === 'development') {
      console.log(`${color}└─ 스택트레이스:${reset}`);
      console.log(`${color}   ${errorInfo.stackTrace.replace(/\n/g, '\n   ')}${reset}`);
    } else {
      console.log(`${color}└─ 상태코드: ${errorInfo.statusCode}${reset}`);
    }

    console.log(''); // 빈 줄
  }
}

/**
 * 에러 로깅 매니저
 */
export class ErrorLoggingManager {
  private loggers: Array<{ logError: (errorInfo: ErrorInfo) => Promise<void> }> = [];
  private static instance: ErrorLoggingManager;

  private constructor() {
    // 기본 로거들 등록
    this.addLogger(new ConsoleLogger());
    this.addLogger(new DatabaseLogger());

    if (process.env.NODE_ENV === 'development') {
      this.addLogger(new FileLogger('./logs/error.log'));
    }
  }

  public static getInstance(): ErrorLoggingManager {
    if (!ErrorLoggingManager.instance) {
      ErrorLoggingManager.instance = new ErrorLoggingManager();
    }
    return ErrorLoggingManager.instance;
  }

  public addLogger(logger: { logError: (errorInfo: ErrorInfo) => Promise<void> }): void {
    this.loggers.push(logger);
  }

  public async logError(errorInfo: ErrorInfo): Promise<void> {
    // 모든 로거에 병렬로 로깅
    const logPromises = this.loggers.map(logger =>
      logger.logError(errorInfo).catch(error =>
        console.error('Logger failed:', error)
      )
    );

    await Promise.all(logPromises);
  }

  public getDatabaseLogger(): DatabaseLogger {
    const dbLogger = this.loggers.find(logger => logger instanceof DatabaseLogger);
    return dbLogger as DatabaseLogger || new DatabaseLogger();
  }
}

// 싱글톤 인스턴스 내보내기
export const errorLoggingManager = ErrorLoggingManager.getInstance();
```


#### 📄 src\lib\excel-utils.ts

```typescript
import * as XLSX from 'xlsx';

// Excel 파일 파싱 유틸리티
export function parseExcelFile(filePath: string): any[] {
  const workbook = XLSX.readFile(filePath);
  const sheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[sheetName];
  const data = XLSX.utils.sheet_to_json(worksheet);
  return data;
}

// 이메일 유효성 검증
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// 사업자번호 유효성 검증 (기본적인 형식 확인)
export function isValidBusinessNumber(businessNumber: string): boolean {
  // 사업자번호는 숫자 10자리 또는 하이픈 포함 형식
  const businessRegex = /^\d{3}-?\d{2}-?\d{5}$/;
  return businessRegex.test(businessNumber.replace(/[^0-9-]/g, ''));
}

// 전화번호 유효성 검증
export function isValidPhoneNumber(phone: string): boolean {
  // 한국 전화번호 형식: 02-1234-5678, 010-1234-5678, 031-123-4567 등
  const phoneRegex = /^(02|0[3-9][0-9]?)-?[0-9]{3,4}-?[0-9]{4}$|^01[0-9]-?[0-9]{3,4}-?[0-9]{4}$/;
  return phoneRegex.test(phone.replace(/\s/g, ''));
}

// 숫자 유효성 검증
export function isValidNumber(value: unknown): boolean {
  return !isNaN(Number(value)) && isFinite(Number(value));
}

// 필수 필드 검증
export function validateRequiredField(value: unknown, fieldName: string): string | null {
  if (value === null || value === undefined || String(value).trim() === '') {
    return `${fieldName}은(는) 필수입니다`;
  }
  return null;
}

// 문자열 정리 (trim 및 null 처리)
export function cleanString(value: unknown): string | undefined {
  if (value === null || value === undefined || String(value).trim() === '') {
    return undefined;
  }
  return String(value).trim();
}

// 숫자 변환 및 정리
export function cleanNumber(value: unknown): number | undefined {
  if (value === null || value === undefined || value === '') {
    return undefined;
  }
  const num = Number(value);
  if (isNaN(num)) {
    return undefined;
  }
  return num;
}
```


#### 📄 src\lib\import-map.ts

```typescript
// Excel Import/Export 헤더 매핑 및 데이터 변환 유틸리티

export interface ColumnMapping {
  korean: string;
  english: string;
  type: 'string' | 'number' | 'date' | 'boolean';
  required?: boolean;
  default?: any;
}

// 아이템 매핑
export const itemsMapping: ColumnMapping[] = [
  { korean: '품목코드', english: 'item_code', type: 'string', required: true },
  { korean: '품목명', english: 'item_name', type: 'string', required: true },
  { korean: '규격', english: 'spec', type: 'string' },
  { korean: '단위', english: 'unit', type: 'string', required: true },
  { korean: '품목분류', english: 'category', type: 'string' },
  { korean: '안전재고', english: 'safety_stock', type: 'number', default: 0 },
  { korean: '현재고', english: 'current_stock', type: 'number', default: 0 },
  { korean: '활성여부', english: 'is_active', type: 'boolean', default: true }
];

// 회사 매핑
export const companiesMapping: ColumnMapping[] = [
  { korean: '회사코드', english: 'company_code', type: 'string', required: true },
  { korean: '회사명', english: 'company_name', type: 'string', required: true },
  { korean: '회사구분', english: 'company_type', type: 'string', required: true },
  { korean: '담당자', english: 'contact_person', type: 'string' },
  { korean: '전화번호', english: 'phone', type: 'string' },
  { korean: '이메일', english: 'email', type: 'string' },
  { korean: '주소', english: 'address', type: 'string' },
  { korean: '활성여부', english: 'is_active', type: 'boolean', default: true }
];

// BOM 매핑
export const bomMapping: ColumnMapping[] = [
  { korean: '상위품목코드', english: 'parent_item_code', type: 'string', required: true },
  { korean: '하위품목코드', english: 'child_item_code', type: 'string', required: true },
  { korean: '소요량', english: 'quantity', type: 'number', required: true },
  { korean: '단위', english: 'unit', type: 'string', required: true },
  { korean: '비고', english: 'remarks', type: 'string' }
];

// 재고 트랜잭션 매핑
export const inventoryMapping: ColumnMapping[] = [
  { korean: '거래일자', english: 'transaction_date', type: 'date', required: true },
  { korean: '거래유형', english: 'transaction_type', type: 'string', required: true },
  { korean: '품목코드', english: 'item_code', type: 'string', required: true },
  { korean: '수량', english: 'quantity', type: 'number', required: true },
  { korean: '단위', english: 'unit', type: 'string', required: true },
  { korean: '회사코드', english: 'company_code', type: 'string' },
  { korean: '참조번호', english: 'reference_number', type: 'string' },
  { korean: '비고', english: 'remarks', type: 'string' }
];

// 매핑 맵
export const mappings = {
  items: itemsMapping,
  companies: companiesMapping,
  bom: bomMapping,
  inventory: inventoryMapping
};

// 데이터 변환 함수
export function convertExcelData(data: Record<string, any>[], mapping: ColumnMapping[]): Record<string, any>[] {
  return data.map(row => {
    const converted: Record<string, any> = {};

    mapping.forEach(col => {
      const koreanValue = row[col.korean];
      let value = koreanValue;

      // 빈 값 처리
      if (value === undefined || value === null || value === '') {
        if (col.required) {
          throw new Error(`필수 항목이 비어있습니다: ${col.korean}`);
        }
        value = col.default;
      }

      // 타입 변환
      switch (col.type) {
        case 'number':
          if (typeof value === 'string') {
            value = parseFloat(value.replace(/,/g, ''));
            if (isNaN(value)) {
              throw new Error(`숫자 형식이 올바르지 않습니다: ${col.korean} = ${koreanValue}`);
            }
          }
          break;

        case 'date':
          if (typeof value === 'string') {
            // Excel 날짜 형식 처리 (YYYY-MM-DD, YYYY.MM.DD, YYYY/MM/DD)
            const dateStr = value.replace(/[.\/]/g, '-');
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
              throw new Error(`날짜 형식이 올바르지 않습니다: ${col.korean} = ${koreanValue}`);
            }
            value = date.toISOString().split('T')[0];
          }
          break;

        case 'boolean':
          if (typeof value === 'string') {
            const lowerValue = value.toLowerCase();
            if (['true', '참', 'y', 'yes', '1', 'o', 'x'].includes(lowerValue)) {
              value = lowerValue === 'true' || lowerValue === '참' || lowerValue === 'y' ||
                     lowerValue === 'yes' || lowerValue === '1' || lowerValue === 'o';
            } else {
              value = Boolean(value);
            }
          }
          break;

        case 'string':
          if (value !== null && value !== undefined) {
            value = String(value).trim();
          }
          break;
      }

      converted[col.english] = value;
    });

    return converted;
  });
}

// 한글 헤더를 영문 필드로 매핑
export function mapKoreanToEnglish(data: Record<string, any>[], mapping: ColumnMapping[]): any[] {
  return data.map(row => {
    const mapped: any = {};
    mapping.forEach(col => {
      if (row.hasOwnProperty(col.korean)) {
        mapped[col.english] = row[col.korean];
      }
    });
    return mapped;
  });
}

// 영문 필드를 한글 헤더로 매핑 (Export용)
export function mapEnglishToKorean(data: Record<string, any>[], mapping: ColumnMapping[]): any[] {
  return data.map(row => {
    const mapped: any = {};
    mapping.forEach(col => {
      if (row.hasOwnProperty(col.english)) {
        mapped[col.korean] = row[col.english];
      }
    });
    return mapped;
  });
}

// 회사 구분 매핑
export function mapCompanyType(type: string): string {
  const mapping: { [key: string]: string } = {
    'CUSTOMER': '고객사',
    'SUPPLIER': '공급사',
    '고객사': 'CUSTOMER',
    '공급사': 'SUPPLIER'
  };
  return mapping[type] || type;
}

// 거래 유형 매핑
export function mapTransactionType(type: string): string {
  const mapping: { [key: string]: string } = {
    'RECEIVING': '입고',
    'PRODUCTION': '생산',
    'SHIPPING': '출고',
    '입고': 'RECEIVING',
    '생산': 'PRODUCTION',
    '출고': 'SHIPPING'
  };
  return mapping[type] || type;
}

// Excel 템플릿 생성용 빈 데이터
export function createTemplate(mapping: ColumnMapping[]): Record<string, string> {
  const template: Record<string, string> = {};
  mapping.forEach(col => {
    template[col.korean] = '';
  });
  return template;
}

// 유효성 검사
export function validateData(data: Record<string, any>[], mapping: ColumnMapping[]): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];

  data.forEach((row, index) => {
    mapping.forEach(col => {
      const value = row[col.english];

      // 필수 필드 검사
      if (col.required && (value === undefined || value === null || value === '')) {
        errors.push(`행 ${index + 1}: ${col.korean}은(는) 필수 항목입니다.`);
      }

      // 타입 검사
      if (value !== null && value !== undefined && value !== '') {
        switch (col.type) {
          case 'number':
            if (typeof value !== 'number' || isNaN(value)) {
              errors.push(`행 ${index + 1}: ${col.korean}은(는) 숫자여야 합니다.`);
            }
            break;
          case 'date':
            if (typeof value === 'string') {
              const date = new Date(value);
              if (isNaN(date.getTime())) {
                errors.push(`행 ${index + 1}: ${col.korean}은(는) 올바른 날짜 형식이어야 합니다.`);
              }
            }
            break;
          case 'boolean':
            if (typeof value !== 'boolean') {
              errors.push(`행 ${index + 1}: ${col.korean}은(는) true/false 값이어야 합니다.`);
            }
            break;
        }
      }
    });
  });

  return {
    isValid: errors.length === 0,
    errors
  };
}
```


#### 📄 src\lib\logger.ts

```typescript
import { writeFileSync, appendFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

// Log levels
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

// Log entry interface
export interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  correlationId?: string;
  userId?: number;
  operation?: string;
  duration?: number;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// Logger configuration
export interface LoggerConfig {
  level: LogLevel;
  enableConsole: boolean;
  enableFile: boolean;
  logDirectory: string;
  maxFileSize: number; // MB
  correlationHeader: string;
}

class Logger {
  private config: LoggerConfig;
  private correlationId: string | null = null;

  constructor(config: Partial<LoggerConfig> = {}) {
    this.config = {
      level: LogLevel.INFO,
      enableConsole: true,
      enableFile: true,
      logDirectory: join(process.cwd(), 'logs'),
      maxFileSize: 10, // 10MB
      correlationHeader: 'x-correlation-id',
      ...config
    };

    // Ensure log directory exists
    if (this.config.enableFile && !existsSync(this.config.logDirectory)) {
      mkdirSync(this.config.logDirectory, { recursive: true });
    }
  }

  // Set correlation ID for request tracking
  setCorrelationId(id: string): void {
    this.correlationId = id;
  }

  // Clear correlation ID
  clearCorrelationId(): void {
    this.correlationId = null;
  }

  // Create log entry
  private createLogEntry(
    level: LogLevel,
    message: string,
    metadata?: Record<string, any>,
    error?: Error
  ): LogEntry {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel[level],
      message,
      correlationId: this.correlationId || undefined,
      metadata
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    }

    return entry;
  }

  // Format log entry for console
  private formatConsoleLog(entry: LogEntry): string {
    const timestamp = new Date(entry.timestamp).toLocaleString('ko-KR');
    const correlation = entry.correlationId ? ` [${entry.correlationId}]` : '';
    const duration = entry.duration ? ` (${entry.duration}ms)` : '';

    let logString = `${timestamp} [${entry.level}]${correlation} ${entry.message}${duration}`;

    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      logString += ` | ${JSON.stringify(entry.metadata)}`;
    }

    if (entry.error) {
      logString += `\nError: ${entry.error.message}`;
      if (entry.error.stack) {
        logString += `\nStack: ${entry.error.stack}`;
      }
    }

    return logString;
  }

  // Format log entry for file (JSON)
  private formatFileLog(entry: LogEntry): string {
    return JSON.stringify(entry) + '\n';
  }

  // Get log file path
  private getLogFilePath(level: string): string {
    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    return join(this.config.logDirectory, `${level.toLowerCase()}-${date}.log`);
  }

  // Write to file
  private writeToFile(entry: LogEntry): void {
    if (!this.config.enableFile) return;

    try {
      const filePath = this.getLogFilePath(entry.level);
      const logLine = this.formatFileLog(entry);

      // Check if file exists and create if not
      if (!existsSync(filePath)) {
        writeFileSync(filePath, logLine);
      } else {
        appendFileSync(filePath, logLine);
      }
    } catch (error) {
      console.error('Failed to write to log file:', error);
    }
  }

  // Main logging method
  private log(level: LogLevel, message: string, metadata?: Record<string, any>, error?: Error): void {
    if (level < this.config.level) return;

    const entry = this.createLogEntry(level, message, metadata, error);

    // Console output
    if (this.config.enableConsole) {
      const formattedLog = this.formatConsoleLog(entry);

      switch (level) {
        case LogLevel.DEBUG:
          console.debug(formattedLog);
          break;
        case LogLevel.INFO:
          console.info(formattedLog);
          break;
        case LogLevel.WARN:
          console.warn(formattedLog);
          break;
        case LogLevel.ERROR:
          console.error(formattedLog);
          break;
      }
    }

    // File output
    this.writeToFile(entry);
  }

  // Public logging methods
  debug(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.DEBUG, message, metadata);
  }

  info(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, metadata);
  }

  warn(message: string, metadata?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, metadata);
  }

  error(message: string, error?: Error, metadata?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, metadata, error);
  }

  // Request logging
  logRequest(method: string, url: string, statusCode: number, duration: number, userId?: number): void {
    const message = `${method} ${url} ${statusCode}`;
    const metadata = {
      method,
      url,
      statusCode,
      duration,
      userId,
      type: 'request'
    };

    if (statusCode >= 400) {
      this.warn(message, metadata);
    } else {
      this.info(message, metadata);
    }
  }

  // Database operation logging
  logDbOperation(operation: string, table: string, duration: number, rowsAffected?: number): void {
    const message = `DB ${operation} on ${table}`;
    const metadata = {
      operation,
      table,
      duration,
      rowsAffected,
      type: 'database'
    };

    if (duration > 1000) {
      this.warn(`Slow ${message} (${duration}ms)`, metadata);
    } else {
      this.debug(message, metadata);
    }
  }

  // Business operation logging (Korean support)
  logBusinessOperation(operation: string, entity: string, entityId: number, userId?: number, details?: Record<string, any>): void {
    const message = `비즈니스 작업: ${operation} - ${entity} (ID: ${entityId})`;
    const metadata = {
      operation,
      entity,
      entityId,
      userId,
      details,
      type: 'business'
    };

    this.info(message, metadata);
  }

  // Security event logging
  logSecurityEvent(event: string, userId?: number, ipAddress?: string, details?: Record<string, any>): void {
    const message = `보안 이벤트: ${event}`;
    const metadata = {
      event,
      userId,
      ipAddress,
      details,
      type: 'security'
    };

    this.warn(message, metadata);
  }

  // Performance logging
  logPerformance(operation: string, duration: number, threshold: number = 1000): void {
    const message = `성능 측정: ${operation} (${duration}ms)`;
    const metadata = {
      operation,
      duration,
      threshold,
      type: 'performance'
    };

    if (duration > threshold) {
      this.warn(`성능 임계값 초과: ${message}`, metadata);
    } else {
      this.debug(message, metadata);
    }
  }

  // Error with context
  logErrorWithContext(message: string, error: Error, context: Record<string, any>): void {
    this.error(message, error, { ...context, type: 'error' });
  }

  // Critical system events
  logCritical(message: string, metadata?: Record<string, any>): void {
    const criticalMetadata = {
      ...metadata,
      type: 'critical',
      severity: 'critical'
    };

    this.error(`[CRITICAL] ${message}`, undefined, criticalMetadata);

    // Also log to console regardless of settings
    console.error(`🚨 CRITICAL: ${message}`, criticalMetadata);
  }
}

// Create default logger instance
const defaultLogger = new Logger();

// Export logger instance and utilities
export { Logger, defaultLogger as logger };

// Request correlation middleware
export function createCorrelationMiddleware() {
  return (req: any, res: any, next: any) => {
    // Generate or extract correlation ID
    const correlationId = req.headers['x-correlation-id'] ||
                         req.headers['x-request-id'] ||
                         `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Set correlation ID in logger
    defaultLogger.setCorrelationId(correlationId);

    // Add to response headers
    res.setHeader('x-correlation-id', correlationId);

    // Store in request for access in routes
    req.correlationId = correlationId;

    // Clear correlation ID after request
    res.on('finish', () => {
      defaultLogger.clearCorrelationId();
    });

    next();
  };
}

// Performance monitoring wrapper with logging
export function withLogging<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  operationName: string
): T {
  return (async (...args: any[]) => {
    const startTime = Date.now();

    try {
      defaultLogger.debug(`Starting operation: ${operationName}`);
      const result = await fn(...args);
      const duration = Date.now() - startTime;

      defaultLogger.logPerformance(operationName, duration);
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      defaultLogger.logErrorWithContext(
        `Operation failed: ${operationName}`,
        error instanceof Error ? error : new Error(String(error)),
        { operationName, duration, args: args.map((arg, i) => `arg${i}`) }
      );
      throw error;
    }
  }) as T;
}

// API logging helper
export function logApiCall(
  method: string,
  path: string,
  statusCode: number,
  duration: number,
  userId?: number,
  error?: Error
): void {
  if (error) {
    defaultLogger.error(
      `API Error: ${method} ${path} ${statusCode}`,
      error,
      { method, path, statusCode, duration, userId, type: 'api' }
    );
  } else {
    defaultLogger.logRequest(method, path, statusCode, duration, userId);
  }
}

// Database logging helper
export function logDbQuery(
  query: string,
  duration: number,
  rowsAffected?: number,
  error?: Error
): void {
  const truncatedQuery = query.length > 100 ? query.substring(0, 100) + '...' : query;

  if (error) {
    defaultLogger.error(
      `DB Query Failed: ${truncatedQuery}`,
      error,
      { query: truncatedQuery, duration, rowsAffected, type: 'database' }
    );
  } else {
    defaultLogger.logDbOperation('QUERY', truncatedQuery, duration, rowsAffected);
  }
}

// Business event logging
export function logBusinessEvent(
  event: string,
  entityType: string,
  entityId: number,
  userId?: number,
  changes?: Record<string, any>
): void {
  defaultLogger.logBusinessOperation(event, entityType, entityId, userId, changes);
}

// System health logging
export function logSystemHealth(metrics: Record<string, any>): void {
  defaultLogger.info('시스템 헬스체크', { ...metrics, type: 'health' });
}

// LogLevel already exported above

// Create logger with custom config
export function createLogger(config: Partial<LoggerConfig>): Logger {
  return new Logger(config);
}
```


#### 📄 src\lib\middleware.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken, getUserFromToken, checkPermission } from '@/lib/auth';
import type { User, UserRole, JWTPayload } from '@/types/auth';
import { AUTH_ERRORS } from '@/types/auth';

// 요청에 사용자 정보를 추가하기 위한 인터페이스
export interface AuthenticatedRequest extends NextRequest {
  user?: User;
}

// 인증 미들웨어
export async function withAuth(request: NextRequest): Promise<NextResponse | { user: User }> {
  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = request.headers.get('authorization');
    let token: string | null = null;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      token = authHeader.substring(7);
    }

    // 쿠키에서 토큰 추출 (fallback)
    if (!token) {
      token = request.cookies.get('auth_token')?.value || null;
    }

    if (!token) {
      return NextResponse.json(
        { success: false, error: '인증 토큰이 없습니다.' },
        { status: 401 }
      );
    }

    // 토큰 검증
    const userResult = await getUserFromToken(token);

    if ('code' in userResult) {
      // AuthError인 경우
      let status = 401;
      if (userResult.code === 'TOKEN_EXPIRED') {
        status = 401;
      } else if (userResult.code === 'ACCESS_DENIED') {
        status = 403;
      }

      return NextResponse.json(
        { success: false, error: userResult.message },
        { status }
      );
    }

    // 정상적인 사용자 객체 반환
    return { user: userResult };

  } catch (error) {
    console.error('Authentication middleware error:', error);
    return NextResponse.json(
      { success: false, error: '인증 처리 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

// 권한 확인 미들웨어
export function withRole(requiredRole: UserRole | UserRole[]) {
  return async (request: NextRequest, user: User): Promise<NextResponse | null> => {
    try {
      const allowedRoles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];

      if (!allowedRoles.includes(user.role)) {
        return NextResponse.json(
          { success: false, error: '접근 권한이 없습니다.' },
          { status: 403 }
        );
      }

      return null; // 권한이 있으면 null 반환 (통과)

    } catch (error) {
      console.error('Role middleware error:', error);
      return NextResponse.json(
        { success: false, error: '권한 확인 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }
  };
}

// 리소스별 권한 확인 미들웨어
export function withPermission(resource: string, action: string) {
  return async (request: NextRequest, user: User): Promise<NextResponse | null> => {
    try {
      const hasAccess = checkPermission(user.role, resource, action);

      if (!hasAccess) {
        return NextResponse.json(
          { success: false, error: `${resource} ${action} 권한이 없습니다.` },
          { status: 403 }
        );
      }

      return null; // 권한이 있으면 null 반환 (통과)

    } catch (error) {
      console.error('Permission middleware error:', error);
      return NextResponse.json(
        { success: false, error: '권한 확인 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }
  };
}

// 미들웨어 체인 실행 헬퍼
export async function executeMiddleware(
  request: NextRequest,
  middlewares: Array<(req: NextRequest, user?: User) => Promise<NextResponse | { user: User } | null>>
): Promise<{ user?: User; response?: NextResponse }> {
  let user: User | undefined;

  for (const middleware of middlewares) {
    const result = await middleware(request, user);

    if (result === null) {
      // 미들웨어 통과
      continue;
    }

    if ('user' in result) {
      // 사용자 정보 설정
      user = result.user;
      continue;
    }

    // NextResponse가 반환된 경우 (에러 또는 리디렉트)
    return { response: result };
  }

  return { user };
}

// API 라우트 보호 래퍼
export function protectRoute(
  handler: (request: NextRequest, user: User) => Promise<NextResponse>,
  options: {
    roles?: UserRole | UserRole[];
    resource?: string;
    action?: string;
  } = {}
) {
  return async (request: NextRequest): Promise<NextResponse> => {
    try {
      const middlewares: Array<(req: NextRequest, user?: User) => Promise<NextResponse | { user: User } | null>> = [withAuth];

      // 역할 기반 권한 체크
      if (options.roles) {
        middlewares.push(async (req: NextRequest, user?: User) => {
          if (!user) return null;
          return await withRole(options.roles!)(req, user);
        });
      }

      // 리소스별 권한 체크
      if (options.resource && options.action) {
        middlewares.push(async (req: NextRequest, user?: User) => {
          if (!user) return null;
          return await withPermission(options.resource!, options.action!)(req, user);
        });
      }

      const { user, response } = await executeMiddleware(request, middlewares);

      if (response) {
        return response;
      }

      if (!user) {
        return NextResponse.json(
          { success: false, error: '인증된 사용자가 아닙니다.' },
          { status: 401 }
        );
      }

      // 실제 핸들러 실행
      return await handler(request, user);

    } catch (error) {
      console.error('Protected route error:', error);
      return NextResponse.json(
        { success: false, error: '요청 처리 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }
  };
}
```


#### 📄 src\lib\monitoring.ts

```typescript
import { testConnection } from './db-unified';

// Performance metrics collection
export interface PerformanceMetrics {
  timestamp: number;
  requestCount: number;
  responseTime: {
    avg: number;
    min: number;
    max: number;
    p95: number;
  };
  errorRate: number;
  dbConnections: {
    active: number;
    idle: number;
    total: number;
  };
  memory: {
    usage: number;
    heap: number;
    external: number;
  };
  businessMetrics: {
    totalItems: number;
    totalCompanies: number;
    totalTransactions: number;
    lowStockItems: number;
  };
}

// In-memory storage for metrics (in production, use Redis or similar)
class MetricsCollector {
  private requestTimes: number[] = [];
  private requestCount = 0;
  private errorCount = 0;
  private startTime = Date.now();

  // Track request performance
  trackRequest(responseTime: number, isError: boolean = false): void {
    this.requestCount++;
    this.requestTimes.push(responseTime);

    if (isError) {
      this.errorCount++;
    }

    // Keep only last 1000 requests to avoid memory issues
    if (this.requestTimes.length > 1000) {
      this.requestTimes.shift();
    }
  }

  // Get current metrics
  getMetrics(): Omit<PerformanceMetrics, 'dbConnections' | 'businessMetrics'> {
    const times = this.requestTimes.slice();
    times.sort((a, b) => a - b);

    return {
      timestamp: Date.now(),
      requestCount: this.requestCount,
      responseTime: {
        avg: times.length > 0 ? times.reduce((a, b) => a + b, 0) / times.length : 0,
        min: times.length > 0 ? times[0] : 0,
        max: times.length > 0 ? times[times.length - 1] : 0,
        p95: times.length > 0 ? times[Math.floor(times.length * 0.95)] : 0,
      },
      errorRate: this.requestCount > 0 ? (this.errorCount / this.requestCount) * 100 : 0,
      memory: {
        usage: process.memoryUsage().rss / 1024 / 1024, // MB
        heap: process.memoryUsage().heapUsed / 1024 / 1024, // MB
        external: process.memoryUsage().external / 1024 / 1024, // MB
      },
    };
  }

  // Reset metrics (useful for testing)
  reset(): void {
    this.requestTimes = [];
    this.requestCount = 0;
    this.errorCount = 0;
    this.startTime = Date.now();
  }

  // Get uptime
  getUptime(): number {
    return Date.now() - this.startTime;
  }
}

// Global metrics collector instance
const metricsCollector = new MetricsCollector();

// Database health check
export async function checkDatabaseHealth(): Promise<{
  isHealthy: boolean;
  connectionCount: number;
  responseTime: number;
  error?: string;
}> {
  const startTime = Date.now();

  try {
    // Test Supabase connection
    const connectionResult = await testConnection();
    const isHealthy = connectionResult.success;
    const responseTime = Date.now() - startTime;

    return {
      isHealthy,
      connectionCount: 1, // Supabase uses managed connections
      responseTime,
    };
  } catch (error) {
    return {
      isHealthy: false,
      connectionCount: 0,
      responseTime: Date.now() - startTime,
      error: error instanceof Error ? error.message : 'Unknown database error',
    };
  }
}

// Get database connection pool status
// Note: Supabase uses managed connections, so this returns mock data
export async function getConnectionPoolStatus(): Promise<{
  active: number;
  idle: number;
  total: number;
  limit: number;
}> {
  // Supabase manages connections internally
  return {
    active: 1,
    idle: 0,
    total: 1,
    limit: 100, // Supabase connection limit
  };
}

// Get business metrics from database (Supabase)
export async function getBusinessMetrics(): Promise<{
  totalItems: number;
  totalCompanies: number;
  totalTransactions: number;
  lowStockItems: number;
}> {
  try {
    const { mcp__supabase__execute_sql } = await import('./supabase-mcp');
    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Get total items
    const itemsResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: 'SELECT COUNT(*) as count FROM items WHERE is_active = true'
    });

    // Get total companies
    const companiesResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: 'SELECT COUNT(*) as count FROM companies WHERE is_active = true'
    });

    // Get total transactions (last 30 days)
    const transactionsResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: "SELECT COUNT(*) as count FROM inventory_transactions WHERE transaction_date >= CURRENT_DATE - INTERVAL '30 days'"
    });

    // Get low stock items (items where current stock is below safety stock)
    const lowStockResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: 'SELECT COUNT(*) as count FROM items WHERE is_active = true AND current_stock < safety_stock'
    });

    // Parse results with proper type assertions
    const items = itemsResult.rows as Array<{count: string}> | undefined;
    const companies = companiesResult.rows as Array<{count: string}> | undefined;
    const transactions = transactionsResult.rows as Array<{count: string}> | undefined;
    const lowStock = lowStockResult.rows as Array<{count: string}> | undefined;

    return {
      totalItems: items?.[0] ? parseInt(items[0].count) : 0,
      totalCompanies: companies?.[0] ? parseInt(companies[0].count) : 0,
      totalTransactions: transactions?.[0] ? parseInt(transactions[0].count) : 0,
      lowStockItems: lowStock?.[0] ? parseInt(lowStock[0].count) : 0,
    };
  } catch (error) {
    console.error('Error getting business metrics:', error);
    return {
      totalItems: 0,
      totalCompanies: 0,
      totalTransactions: 0,
      lowStockItems: 0,
    };
  }
}

// Get comprehensive metrics
export async function getComprehensiveMetrics(): Promise<PerformanceMetrics> {
  const basicMetrics = metricsCollector.getMetrics();
  const dbConnections = await getConnectionPoolStatus();
  const businessMetrics = await getBusinessMetrics();

  return {
    ...basicMetrics,
    dbConnections,
    businessMetrics,
  };
}

// Request tracking middleware function
export function createRequestTracker() {
  return (req: any, res: any, next: any) => {
    const startTime = Date.now();

    // Track response
    const originalSend = res.send;
    res.send = function(data: any) {
      const responseTime = Date.now() - startTime;
      const isError = res.statusCode >= 400;

      metricsCollector.trackRequest(responseTime, isError);

      return originalSend.call(this, data);
    };

    next();
  };
}

// Manual request tracking for API routes
export function trackApiRequest(responseTime: number, isError: boolean = false): void {
  metricsCollector.trackRequest(responseTime, isError);
}

// Performance monitoring wrapper
export function withPerformanceMonitoring<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  operationName: string
): T {
  return (async (...args: any[]) => {
    const startTime = Date.now();
    let isError = false;

    try {
      const result = await fn(...args);
      return result;
    } catch (error) {
      isError = true;
      throw error;
    } finally {
      const responseTime = Date.now() - startTime;
      metricsCollector.trackRequest(responseTime, isError);

      // Log slow operations
      if (responseTime > 1000) {
        console.warn(`Slow operation detected: ${operationName} took ${responseTime}ms`);
      }
    }
  }) as T;
}

// Database query performance tracking
export async function trackDbQuery<T>(
  queryName: string,
  queryFn: () => Promise<T>
): Promise<T> {
  const startTime = Date.now();
  let isError = false;

  try {
    const result = await queryFn();
    return result;
  } catch (error) {
    isError = true;
    throw error;
  } finally {
    const queryTime = Date.now() - startTime;

    // Log slow queries
    if (queryTime > 500) {
      console.warn(`Slow database query: ${queryName} took ${queryTime}ms`);
    }

    // Track as request for metrics
    metricsCollector.trackRequest(queryTime, isError);
  }
}

// Health check status
export interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  uptime: number;
  version: string;
  database: {
    status: 'healthy' | 'unhealthy';
    responseTime: number;
    connections: number;
    error?: string;
  };
  memory: {
    usage: number;
    heap: number;
    external: number;
  };
  lastCheck: number;
}

// Comprehensive health check
export async function getHealthStatus(): Promise<HealthStatus> {
  const dbHealth = await checkDatabaseHealth();
  const metrics = metricsCollector.getMetrics();

  // Determine overall status
  let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';

  if (!dbHealth.isHealthy) {
    status = 'unhealthy';
  } else if (dbHealth.responseTime > 1000 || metrics.errorRate > 5) {
    status = 'degraded';
  }

  return {
    status,
    uptime: metricsCollector.getUptime(),
    version: process.env.npm_package_version || '0.1.0',
    database: {
      status: dbHealth.isHealthy ? 'healthy' : 'unhealthy',
      responseTime: dbHealth.responseTime,
      connections: dbHealth.connectionCount,
      error: dbHealth.error,
    },
    memory: metrics.memory,
    lastCheck: Date.now(),
  };
}

// Export the metrics collector for external use
export { metricsCollector };

// Prometheus-style metrics formatter
export function formatPrometheusMetrics(metrics: PerformanceMetrics): string {
  const lines: string[] = [];

  // Request metrics
  lines.push(`# HELP http_requests_total Total number of HTTP requests`);
  lines.push(`# TYPE http_requests_total counter`);
  lines.push(`http_requests_total ${metrics.requestCount}`);

  lines.push(`# HELP http_request_duration_seconds HTTP request duration in seconds`);
  lines.push(`# TYPE http_request_duration_seconds summary`);
  lines.push(`http_request_duration_seconds{quantile="0.95"} ${metrics.responseTime.p95 / 1000}`);
  lines.push(`http_request_duration_seconds_sum ${(metrics.responseTime.avg * metrics.requestCount) / 1000}`);
  lines.push(`http_request_duration_seconds_count ${metrics.requestCount}`);

  // Error rate
  lines.push(`# HELP http_error_rate HTTP error rate percentage`);
  lines.push(`# TYPE http_error_rate gauge`);
  lines.push(`http_error_rate ${metrics.errorRate}`);

  // Memory metrics
  lines.push(`# HELP nodejs_memory_usage_bytes Node.js memory usage in bytes`);
  lines.push(`# TYPE nodejs_memory_usage_bytes gauge`);
  lines.push(`nodejs_memory_usage_bytes{type="rss"} ${metrics.memory.usage * 1024 * 1024}`);
  lines.push(`nodejs_memory_usage_bytes{type="heap"} ${metrics.memory.heap * 1024 * 1024}`);
  lines.push(`nodejs_memory_usage_bytes{type="external"} ${metrics.memory.external * 1024 * 1024}`);

  // Database metrics
  lines.push(`# HELP mysql_connections MySQL connection pool status`);
  lines.push(`# TYPE mysql_connections gauge`);
  lines.push(`mysql_connections{state="active"} ${metrics.dbConnections.active}`);
  lines.push(`mysql_connections{state="idle"} ${metrics.dbConnections.idle}`);
  lines.push(`mysql_connections{state="total"} ${metrics.dbConnections.total}`);

  // Business metrics
  lines.push(`# HELP erp_business_metrics ERP business metrics`);
  lines.push(`# TYPE erp_business_metrics gauge`);
  lines.push(`erp_business_metrics{type="items"} ${metrics.businessMetrics.totalItems}`);
  lines.push(`erp_business_metrics{type="companies"} ${metrics.businessMetrics.totalCompanies}`);
  lines.push(`erp_business_metrics{type="transactions"} ${metrics.businessMetrics.totalTransactions}`);
  lines.push(`erp_business_metrics{type="low_stock_items"} ${metrics.businessMetrics.lowStockItems}`);

  return lines.join('\n') + '\n';
}
```


#### 📄 src\lib\pagination.ts

```typescript
export type PaginationInput = {
  page?: number;
  limit?: number;
  orderBy?: string; // "created_at:desc,name:asc"
};

export type PaginationParams = {
  offset: number;
  limit: number;
  orderBy: string;
};

export type PaginationMeta = {
  page: number;
  limit: number;
  totalCount: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
};

export type PaginatedResponse<T> = {
  data: T[];
  meta: PaginationMeta;
  pagination?: PaginationMeta; // Alias for backward compatibility
};

export function parsePagination(
  input: PaginationInput,
  defaults = { page: 1, limit: 20, maxLimit: 100 }
): PaginationParams {
  // Parse page (minimum 1)
  const page = Math.max(1, Number(input.page) || defaults.page);

  // Parse limit (minimum 1, maximum maxLimit)
  let limit = Number(input.limit) || defaults.limit;
  limit = Math.max(1, Math.min(limit, defaults.maxLimit));

  // Calculate offset
  const offset = (page - 1) * limit;

  // Parse orderBy string
  let orderBy = '';
  if (input.orderBy) {
    const orderParts = input.orderBy.split(',').map(part => {
      const [column, direction = 'asc'] = part.trim().split(':');
      const cleanColumn = column.replace(/[^a-zA-Z0-9_]/g, ''); // SQL injection prevention
      const cleanDirection = direction.toLowerCase() === 'desc' ? 'DESC' : 'ASC';
      return `${cleanColumn} ${cleanDirection}`;
    });
    orderBy = orderParts.join(', ');
  }

  return {
    offset,
    limit,
    orderBy
  };
}

export function buildPaginatedResponse<T>(
  data: T[],
  totalCount: number,
  params: { page: number; limit: number }
): PaginatedResponse<T> {
  const { page, limit } = params;
  const totalPages = Math.ceil(totalCount / limit);

  const meta = {
    page,
    limit,
    totalCount,
    totalPages,
    hasNext: page < totalPages,
    hasPrev: page > 1
  };

  return {
    data,
    meta,
    pagination: meta // Include alias for backward compatibility
  };
}

// Helper function to build SQL with pagination
export function buildPaginatedSQL(
  baseSql: string,
  countSql: string,
  params: PaginationParams
): { dataSql: string; countSql: string } {
  let dataSql = baseSql;

  // Add ORDER BY clause if provided
  if (params.orderBy) {
    dataSql += ` ORDER BY ${params.orderBy}`;
  }

  // Add LIMIT and OFFSET
  dataSql += ` LIMIT ${params.limit} OFFSET ${params.offset}`;

  return {
    dataSql,
    countSql
  };
}

// Helper function to extract pagination params from URL search params
export function getPaginationFromSearchParams(searchParams: URLSearchParams): PaginationInput {
  return {
    page: searchParams.get('page') ? Number(searchParams.get('page')) : undefined,
    limit: searchParams.get('limit') ? Number(searchParams.get('limit')) : undefined,
    orderBy: searchParams.get('orderBy') || undefined
  };
}
```


#### 📄 src\lib\query-optimizer.ts

```typescript
// ERP 시스템 쿼리 최적화 유틸리티
// 페이징 최적화, 배치 처리, 캐싱 지원

import { query } from './db-unified';

// =============================================================================
// 1. 쿼리 최적화 유틸리티
// =============================================================================

export interface QueryOptimizationOptions {
  useCache?: boolean;
  cacheKey?: string;
  cacheTTL?: number; // seconds
  enableExplain?: boolean;
  timeout?: number; // milliseconds
  readPreference?: 'primary' | 'secondary';
}

export interface PaginationConfig {
  page: number;
  limit: number;
  orderBy?: string;
  direction?: 'ASC' | 'DESC';
  offset?: number;
}

export interface QueryResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
  executionTime: number;
  fromCache: boolean;
}

export interface ExplainResult {
  id: number;
  select_type: string;
  table: string;
  partitions?: string;
  type: string;
  possible_keys?: string;
  key?: string;
  key_len?: string;
  ref?: string;
  rows: number;
  filtered: number;
  Extra?: string;
}

// 메모리 캐시 (프로덕션에서는 Redis 사용 권장)
class QueryCache {
  private cache = new Map<string, { data: any; expiry: number }>();
  private maxSize = 1000;

  set(key: string, data: any, ttl: number = 300): void {
    // LRU 방식으로 캐시 크기 관리
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value as string | undefined;
      if (firstKey) {
        this.cache.delete(firstKey);
      }
    }

    const expiry = Date.now() + (ttl * 1000);
    this.cache.set(key, { data, expiry });
  }

  get(key: string): any | null {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }

  // 만료된 캐시 정리
  cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now > item.expiry) {
        this.cache.delete(key);
      }
    }
  }
}

const queryCache = new QueryCache();

// 캐시 정리 작업 (5분마다)
setInterval(() => {
  queryCache.cleanup();
}, 5 * 60 * 1000);

// =============================================================================
// 2. 최적화된 페이징 쿼리
// =============================================================================

export class OptimizedPagination {
  /**
   * 커서 기반 페이징 (대용량 데이터에 적합)
   */
  static async cursorPaginate<T>(
    baseQuery: string,
    countQuery: string,
    params: unknown[],
    config: {
      cursorColumn: string;
      cursorValue?: any;
      limit: number;
      direction?: 'next' | 'prev';
    },
    options: QueryOptimizationOptions = {}
  ): Promise<QueryResult<T>> {
    const startTime = Date.now();
    const cacheKey = options.cacheKey ||
      `cursor_${Buffer.from(baseQuery + JSON.stringify(params) + JSON.stringify(config)).toString('base64')}`;

    // 캐시 확인
    if (options.useCache) {
      const cached = queryCache.get(cacheKey);
      if (cached) {
        return {
          ...cached,
          executionTime: Date.now() - startTime,
          fromCache: true
        };
      }
    }

    const { cursorColumn, cursorValue, limit, direction = 'next' } = config;
    let modifiedQuery = baseQuery;
    const modifiedParams = [...params];

    // 커서 조건 추가
    if (cursorValue !== undefined) {
      const operator = direction === 'next' ? '>' : '<';
      const orderDirection = direction === 'next' ? 'ASC' : 'DESC';

      modifiedQuery += ` AND ${cursorColumn} ${operator} ?`;
      modifiedParams.push(cursorValue);

      modifiedQuery += ` ORDER BY ${cursorColumn} ${orderDirection}`;
    } else {
      modifiedQuery += ` ORDER BY ${cursorColumn} ASC`;
    }

    modifiedQuery += ` LIMIT ${limit + 1}`; // +1로 다음 페이지 존재 여부 확인

    const [data, totalResult] = await Promise.all([
      query<T>(modifiedQuery, modifiedParams),
      query<{ total: number }>(countQuery, params)
    ]);

    const total = totalResult[0]?.total || 0;
    const hasMore = data.length > limit;
    const actualData = hasMore ? data.slice(0, limit) : data;

    const result: QueryResult<T> = {
      data: actualData,
      total,
      page: 0, // 커서 기반에서는 page 개념이 다름
      limit,
      totalPages: Math.ceil(total / limit),
      hasNextPage: hasMore && direction === 'next',
      hasPrevPage: cursorValue !== undefined && direction === 'prev',
      executionTime: Date.now() - startTime,
      fromCache: false
    };

    // 캐시 저장
    if (options.useCache) {
      queryCache.set(cacheKey, result, options.cacheTTL || 300);
    }

    return result;
  }

  /**
   * 오프셋 기반 페이징 최적화 (작은 오프셋에 적합)
   */
  static async offsetPaginate<T>(
    baseQuery: string,
    countQuery: string,
    params: unknown[],
    config: PaginationConfig,
    options: QueryOptimizationOptions = {}
  ): Promise<QueryResult<T>> {
    const startTime = Date.now();
    const { page, limit, orderBy, direction = 'ASC' } = config;
    const offset = (page - 1) * limit;

    const cacheKey = options.cacheKey ||
      `offset_${Buffer.from(baseQuery + JSON.stringify(params) + JSON.stringify(config)).toString('base64')}`;

    // 캐시 확인
    if (options.useCache) {
      const cached = queryCache.get(cacheKey);
      if (cached) {
        return {
          ...cached,
          executionTime: Date.now() - startTime,
          fromCache: true
        };
      }
    }

    // 큰 오프셋 최적화
    let optimizedQuery = baseQuery;
    const optimizedParams = [...params];

    if (offset > 10000 && orderBy) {
      // 서브쿼리를 사용한 오프셋 최적화
      optimizedQuery = `
        SELECT * FROM (${baseQuery}) AS t1
        WHERE t1.${orderBy} >= (
          SELECT ${orderBy} FROM (${baseQuery}) AS t2
          ORDER BY ${orderBy} ${direction}
          LIMIT 1 OFFSET ${offset}
        )
        ORDER BY t1.${orderBy} ${direction}
        LIMIT ${limit}
      `;
    } else {
      if (orderBy) {
        optimizedQuery += ` ORDER BY ${orderBy} ${direction}`;
      }
      optimizedQuery += ` LIMIT ${limit} OFFSET ${offset}`;
    }

    const [data, totalResult] = await Promise.all([
      query<T>(optimizedQuery, optimizedParams),
      query<{ total: number }>(countQuery, params)
    ]);

    const total = totalResult[0]?.total || 0;
    const totalPages = Math.ceil(total / limit);

    const result: QueryResult<T> = {
      data,
      total,
      page,
      limit,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
      executionTime: Date.now() - startTime,
      fromCache: false
    };

    // 캐시 저장
    if (options.useCache) {
      queryCache.set(cacheKey, result, options.cacheTTL || 300);
    }

    return result;
  }
}

// =============================================================================
// 3. 배치 처리 유틸리티
// =============================================================================

export class BatchProcessor {
  /**
   * 배치 INSERT 최적화
   */
  static async batchInsert<T>(
    tableName: string,
    columns: string[],
    data: T[][],
    options: {
      batchSize?: number;
      onProgress?: (processed: number, total: number) => void;
      ignoreDuplicates?: boolean;
    } = {}
  ): Promise<{ inserted: number; errors: any[] }> {
    const { batchSize = 1000, onProgress, ignoreDuplicates = false } = options;
    const insertType = ignoreDuplicates ? 'INSERT IGNORE' : 'INSERT';

    let totalInserted = 0;
    const errors: any[] = [];
    const placeholders = `(${columns.map(() => '?').join(', ')})`;

    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      const batchPlaceholders = batch.map(() => placeholders).join(', ');
      const flatValues = batch.flat();

      const sql = `${insertType} INTO ${tableName} (${columns.join(', ')}) VALUES ${batchPlaceholders}`;

      try {
        const result = await query(sql, flatValues) as any;
        totalInserted += result.affectedRows || batch.length;

        if (onProgress) {
          onProgress(Math.min(i + batchSize, data.length), data.length);
        }
      } catch (error) {
        errors.push({
          batch: i / batchSize + 1,
          error: error instanceof Error ? error.message : error,
          data: batch
        });
      }
    }

    return { inserted: totalInserted, errors };
  }

  /**
   * 배치 UPDATE 최적화
   */
  static async batchUpdate<T extends Record<string, any>>(
    tableName: string,
    updates: T[],
    keyColumn: string,
    options: {
      batchSize?: number;
      onProgress?: (processed: number, total: number) => void;
    } = {}
  ): Promise<{ updated: number; errors: any[] }> {
    const { batchSize = 500, onProgress } = options;

    let totalUpdated = 0;
    const errors: any[] = [];

    for (let i = 0; i < updates.length; i += batchSize) {
      const batch = updates.slice(i, i + batchSize);

      try {
        // CASE WHEN 구문을 사용한 배치 업데이트
        const updateColumns = Object.keys(batch[0]).filter(col => col !== keyColumn);
        const keyValues = batch.map(item => item[keyColumn]);

        // Simple SQL escaping for values (basic implementation)
        const escapeValue = (val: any): string => {
          if (val === null || val === undefined) return 'NULL';
          if (typeof val === 'number') return String(val);
          return `'${String(val).replace(/'/g, "''")}'`;
        };

        const setClauses = updateColumns.map(column => {
          const cases = batch.map(item =>
            `WHEN ${keyColumn} = ${escapeValue(item[keyColumn])} THEN ${escapeValue(item[column])}`
          ).join(' ');
          return `${column} = CASE ${cases} ELSE ${column} END`;
        });

        const sql = `
          UPDATE ${tableName}
          SET ${setClauses.join(', ')}
          WHERE ${keyColumn} IN (${keyValues.map(v => escapeValue(v)).join(', ')})
        `;

        const result = await query(sql) as any;
        totalUpdated += result.affectedRows || 0;

        if (onProgress) {
          onProgress(Math.min(i + batchSize, updates.length), updates.length);
        }
      } catch (error) {
        errors.push({
          batch: i / batchSize + 1,
          error: error instanceof Error ? error.message : error,
          data: batch
        });
      }
    }

    return { updated: totalUpdated, errors };
  }
}

// =============================================================================
// 4. 쿼리 분석 및 최적화 도구
// =============================================================================

export class QueryAnalyzer {
  /**
   * 쿼리 실행 계획 분석
   */
  static async explainQuery(sql: string, params: unknown[] = []): Promise<ExplainResult[]> {
    const explainSql = `EXPLAIN ${sql}`;
    return await query<ExplainResult>(explainSql, params);
  }

  /**
   * 쿼리 성능 분석
   */
  static async analyzeQueryPerformance(
    sql: string,
    params: unknown[] = [],
    iterations: number = 5
  ): Promise<{
    avgExecutionTime: number;
    minExecutionTime: number;
    maxExecutionTime: number;
    explainPlan: ExplainResult[];
    recommendations: string[];
  }> {
    const executionTimes: number[] = [];

    // 여러 번 실행하여 평균 성능 측정
    for (let i = 0; i < iterations; i++) {
      const startTime = Date.now();
      await query(sql, params);
      executionTimes.push(Date.now() - startTime);
    }

    const explainPlan = await this.explainQuery(sql, params);
    const recommendations = this.generateRecommendations(explainPlan);

    return {
      avgExecutionTime: executionTimes.reduce((a, b) => a + b, 0) / iterations,
      minExecutionTime: Math.min(...executionTimes),
      maxExecutionTime: Math.max(...executionTimes),
      explainPlan,
      recommendations
    };
  }

  /**
   * 쿼리 최적화 제안 생성
   */
  private static generateRecommendations(explainPlan: ExplainResult[]): string[] {
    const recommendations: string[] = [];

    for (const step of explainPlan) {
      // 풀 테이블 스캔 감지
      if (step.type === 'ALL') {
        recommendations.push(`테이블 '${step.table}'에서 풀 스캔이 발생합니다. 인덱스 추가를 고려하세요.`);
      }

      // 높은 행 수 감지
      if (step.rows > 10000) {
        recommendations.push(`테이블 '${step.table}'에서 ${step.rows}행을 검사합니다. WHERE 조건을 추가하거나 인덱스를 최적화하세요.`);
      }

      // 임시 테이블 사용 감지
      if (step.Extra?.includes('Using temporary')) {
        recommendations.push(`임시 테이블이 사용됩니다. GROUP BY나 ORDER BY 절을 최적화하세요.`);
      }

      // 파일 정렬 감지
      if (step.Extra?.includes('Using filesort')) {
        recommendations.push(`파일 정렬이 발생합니다. ORDER BY에 적절한 인덱스를 추가하세요.`);
      }

      // 인덱스 조건 미사용 감지
      if (step.key === null && step.possible_keys) {
        recommendations.push(`가능한 인덱스가 있지만 사용되지 않습니다. 쿼리 조건을 검토하세요.`);
      }
    }

    return recommendations;
  }

  /**
   * 슬로우 쿼리 탐지
   */
  static async detectSlowQueries(thresholdMs: number = 1000): Promise<any[]> {
    const sql = `
      SELECT
        sql_text,
        exec_count,
        avg_timer_wait / 1000000000 as avg_time_ms,
        max_timer_wait / 1000000000 as max_time_ms,
        sum_timer_wait / 1000000000 as total_time_ms,
        sum_rows_examined,
        sum_rows_sent,
        digest
      FROM performance_schema.events_statements_summary_by_digest
      WHERE avg_timer_wait / 1000000000 > ?
      ORDER BY avg_timer_wait DESC
      LIMIT 20
    `;

    try {
      return await query(sql, [thresholdMs]);
    } catch (error) {
      console.warn('Performance schema를 사용할 수 없습니다:', error);
      return [];
    }
  }
}

// =============================================================================
// 5. ERP 특화 쿼리 최적화
// =============================================================================

export class ERPQueryOptimizer {
  /**
   * 재고 계산 최적화 (뷰 사용 권장)
   */
  static async getOptimizedStockLevels(
    itemIds?: number[],
    categories?: string[],
    options: QueryOptimizationOptions = {}
  ): Promise<any[]> {
    const whereConditions: string[] = [];
    const params: unknown[] = [];

    if (itemIds && itemIds.length > 0) {
      whereConditions.push(`item_id IN (${itemIds.map(() => '?').join(', ')})`);
      params.push(...itemIds);
    }

    if (categories && categories.length > 0) {
      whereConditions.push(`category IN (${categories.map(() => '?').join(', ')})`);
      params.push(...categories);
    }

    const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

    // 최적화된 뷰 사용
    const sql = `
      SELECT *
      FROM current_stock
      ${whereClause}
      ORDER BY stock_status DESC, item_code
    `;

    const result = await query(sql, params);
    return result as any[];
  }

  /**
   * 대시보드 KPI 최적화
   */
  static async getDashboardKPIs(options: QueryOptimizationOptions = {}): Promise<any> {
    const cacheKey = 'dashboard_kpis';

    if (options.useCache) {
      const cached = queryCache.get(cacheKey);
      if (cached) return cached;
    }

    // 최적화된 뷰 사용
    const result = await query('SELECT * FROM dashboard_kpi');
    const kpis = result[0] as any;

    if (options.useCache) {
      queryCache.set(cacheKey, kpis, options.cacheTTL || 60); // 1분 캐시
    }

    return kpis;
  }

  /**
   * 거래 이력 페이징 최적화
   */
  static async getOptimizedTransactionHistory(
    filters: {
      itemId?: number;
      companyId?: number;
      transactionType?: string;
      startDate?: string;
      endDate?: string;
    },
    pagination: PaginationConfig,
    options: QueryOptimizationOptions = {}
  ): Promise<QueryResult<any>> {
    let baseQuery = `
      SELECT
        it.*,
        i.item_code,
        i.item_name,
        c.company_name
      FROM inventory_transactions it
      USE INDEX (idx_inventory_date_item_type)
      JOIN items i ON it.item_id = i.item_id
      LEFT JOIN companies c ON it.company_id = c.company_id
      WHERE 1=1
    `;

    let countQuery = `
      SELECT COUNT(*) as total
      FROM inventory_transactions it
      USE INDEX (idx_inventory_date_item_type)
      WHERE 1=1
    `;

    const params: unknown[] = [];

    // 필터 조건 추가
    if (filters.itemId) {
      const condition = ' AND it.item_id = ?';
      baseQuery += condition;
      countQuery += condition;
      params.push(filters.itemId);
    }

    if (filters.companyId) {
      const condition = ' AND it.company_id = ?';
      baseQuery += condition;
      countQuery += condition;
      params.push(filters.companyId);
    }

    if (filters.transactionType) {
      const condition = ' AND it.transaction_type = ?';
      baseQuery += condition;
      countQuery += condition;
      params.push(filters.transactionType);
    }

    if (filters.startDate) {
      const condition = ' AND it.transaction_date >= ?';
      baseQuery += condition;
      countQuery += condition;
      params.push(filters.startDate);
    }

    if (filters.endDate) {
      const condition = ' AND it.transaction_date <= ?';
      baseQuery += condition;
      countQuery += condition;
      params.push(filters.endDate);
    }

    // 최적화된 페이징 사용
    return await OptimizedPagination.offsetPaginate(
      baseQuery,
      countQuery,
      params,
      { ...pagination, orderBy: 'it.transaction_date' },
      { ...options, cacheKey: `transactions_${JSON.stringify(filters)}_${JSON.stringify(pagination)}` }
    );
  }
}

// =============================================================================
// 6. 모니터링 및 통계
// =============================================================================

export class QueryMonitor {
  private static queryStats = new Map<string, {
    count: number;
    totalTime: number;
    avgTime: number;
    lastExecuted: Date;
  }>();

  /**
   * 쿼리 실행 통계 수집
   */
  static recordQuery(queryHash: string, executionTime: number): void {
    const existing = this.queryStats.get(queryHash) || {
      count: 0,
      totalTime: 0,
      avgTime: 0,
      lastExecuted: new Date()
    };

    existing.count += 1;
    existing.totalTime += executionTime;
    existing.avgTime = existing.totalTime / existing.count;
    existing.lastExecuted = new Date();

    this.queryStats.set(queryHash, existing);
  }

  /**
   * 쿼리 통계 조회
   */
  static getQueryStats(): Array<{
    queryHash: string;
    count: number;
    totalTime: number;
    avgTime: number;
    lastExecuted: Date;
  }> {
    return Array.from(this.queryStats.entries()).map(([queryHash, stats]) => ({
      queryHash,
      ...stats
    }));
  }

  /**
   * 캐시 통계 조회
   */
  static getCacheStats(): {
    size: number;
    hitRate?: number;
  } {
    return {
      size: queryCache.size()
    };
  }

  /**
   * 성능 리포트 생성
   */
  static generatePerformanceReport(): {
    slowQueries: any[];
    cacheStats: any;
    queryStats: any[];
    recommendations: string[];
  } {
    const queryStats = this.getQueryStats();
    const slowQueries = queryStats
      .filter(q => q.avgTime > 1000)
      .sort((a, b) => b.avgTime - a.avgTime);

    const recommendations: string[] = [];

    if (slowQueries.length > 0) {
      recommendations.push(`${slowQueries.length}개의 느린 쿼리가 감지되었습니다.`);
    }

    const highFrequencyQueries = queryStats
      .filter(q => q.count > 100)
      .sort((a, b) => b.count - a.count);

    if (highFrequencyQueries.length > 0) {
      recommendations.push('자주 실행되는 쿼리에 대해 캐싱을 고려하세요.');
    }

    return {
      slowQueries,
      cacheStats: this.getCacheStats(),
      queryStats: queryStats.slice(0, 20), // 상위 20개만
      recommendations
    };
  }
}

// 모듈 내보내기
export {
  queryCache
};

// Types are already exported as interfaces above, no need to re-export
```


#### 📄 src\lib\response.ts

```typescript
import { NextResponse } from 'next/server';

/**
 * UTF-8 인코딩을 명시적으로 설정한 JSON 응답 생성
 */
export function createUTF8Response(data: any, status: number = 200): NextResponse {
  const response = NextResponse.json(data, { status });
  
  // UTF-8 인코딩 명시적 설정
  response.headers.set('Content-Type', 'application/json; charset=utf-8');
  response.headers.set('Content-Encoding', 'utf-8');
  
  return response;
}

/**
 * 성공 응답 생성
 */
export function createSuccessResponse(data: any, message?: string): NextResponse {
  return createUTF8Response({
    success: true,
    data,
    message: message || '성공적으로 처리되었습니다.'
  });
}

/**
 * 에러 응답 생성
 */
export function createErrorResponse(error: string, status: number = 500): NextResponse {
  return createUTF8Response({
    success: false,
    error,
    timestamp: new Date().toISOString()
  }, status);
}

/**
 * 페이지네이션 응답 생성
 */
export function createPaginatedResponse(
  data: any[],
  total: number,
  page: number,
  limit: number
): NextResponse {
  const totalPages = Math.ceil(total / limit);
  
  return createUTF8Response({
    success: true,
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    }
  });
}

/**
 * 파일 다운로드 응답 생성
 */
export function createFileResponse(
  buffer: Buffer,
  filename: string,
  contentType: string = 'application/octet-stream'
): NextResponse {
  const response = new NextResponse(buffer);
  
  // UTF-8 인코딩 명시적 설정
  response.headers.set('Content-Type', `${contentType}; charset=utf-8`);
  response.headers.set('Content-Disposition', `attachment; filename="${encodeURIComponent(filename)}"`);
  response.headers.set('Content-Encoding', 'utf-8');
  
  return response;
}

/**
 * Excel 파일 다운로드 응답 생성
 */
export function createExcelResponse(buffer: Buffer, filename: string): NextResponse {
  return createFileResponse(
    buffer,
    filename,
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  );
}

```


#### 📄 src\lib\serial.ts

```typescript
// 문서 번호 자동 채번 시스템
import { getSupabaseClient } from './db-unified';

export interface SerialData {
  prefix: string;
  year_month: string;
  current_number: number;
}

/**
 * 다음 문서 번호를 생성합니다 (YYMM-#### 형식)
 * @param prefix 접두사 (REC, PRD, SHP 등)
 * @returns 생성된 문서 번호 (예: 2401-0001)
 */
export async function nextSerial(prefix: string): Promise<string> {
  const now = new Date();
  const year = now.getFullYear().toString().slice(-2); // 연도 마지막 2자리
  const month = (now.getMonth() + 1).toString().padStart(2, '0'); // 월 2자리
  const yearMonth = year + month;

  const supabase = getSupabaseClient();

  // Use Supabase RPC function for atomic serial number generation
  const { data, error } = await (supabase.rpc as any)('get_next_serial', {
    p_prefix: prefix,
    p_year_month: yearMonth
  });

  if (error) {
    throw new Error(`Failed to generate serial number: ${error.message}`);
  }

  // 문서 번호 형식: YYMM-#### (예: 2401-0001)
  const documentNumber = `${yearMonth}-${data.toString().padStart(4, '0')}`;

  return documentNumber;
}

/**
 * 특정 prefix의 현재 시리얼 정보를 조회합니다
 */
export async function getCurrentSerial(prefix: string, yearMonth?: string): Promise<SerialData | null> {
  const now = new Date();
  const currentYearMonth = yearMonth ||
    (now.getFullYear().toString().slice(-2) + (now.getMonth() + 1).toString().padStart(2, '0'));

  const supabase = getSupabaseClient();

  const { data, error } = await supabase
    .from('serials')
    .select('prefix, year_month, current_number')
    .eq('prefix', prefix)
    .eq('year_month', currentYearMonth)
    .single();

  if (error || !data) {
    return null;
  }

  return data as SerialData;
}

/**
 * 모든 시리얼 정보를 조회합니다
 */
export async function getAllSerials(): Promise<SerialData[]> {
  const supabase = getSupabaseClient();

  const { data, error } = await supabase
    .from('serials')
    .select('prefix, year_month, current_number, created_at, updated_at')
    .order('year_month', { ascending: false })
    .order('prefix', { ascending: true });

  if (error || !data) {
    return [];
  }

  return data as SerialData[];
}

/**
 * 트랜잭션 유형에 따른 접두사를 반환합니다
 */
export function getTransactionPrefix(transactionType: string): string {
  const prefixMap: Record<string, string> = {
    '입고': 'REC', // Receiving
    '생산': 'PRD', // Production
    '출고': 'SHP', // Shipping
    '조정': 'ADJ', // Adjustment
    '이동': 'TRF', // Transfer
  };

  return prefixMap[transactionType] || 'DOC'; // 기본값
}

/**
 * 문서 번호 형식을 검증합니다
 */
export function validateDocumentNumber(documentNumber: string): boolean {
  const pattern = /^\d{4}-\d{4}$/; // YYMM-#### 형식
  return pattern.test(documentNumber);
}

/**
 * 문서 번호에서 연월 정보를 추출합니다
 */
export function extractYearMonth(documentNumber: string): string | null {
  if (!validateDocumentNumber(documentNumber)) {
    return null;
  }

  return documentNumber.substring(0, 4); // YYMM 부분
}

/**
 * 문서 번호에서 시퀀스 번호를 추출합니다
 */
export function extractSequenceNumber(documentNumber: string): number | null {
  if (!validateDocumentNumber(documentNumber)) {
    return null;
  }

  const sequencePart = documentNumber.substring(5); // #### 부분
  return parseInt(sequencePart, 10);
}
```


#### 📄 src\lib\supabase-admin.ts

```typescript
import { createClient } from '@supabase/supabase-js'
import { Database } from '@/types/supabase'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!

// Admin client with service role key for server-side operations
export const supabaseAdmin = createClient<Database>(
  supabaseUrl,
  supabaseServiceRoleKey,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
)

// Admin helper functions for server-side operations
export const supabaseAdminHelpers = {
  // User management (admin only)
  users: {
    createUser: async (userData: {
      email: string
      password: string
      name: string
      username: string
      department?: string
      role?: 'admin' | 'manager' | 'operator' | 'viewer'
    }) => {
      // Create auth user
      const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
        email: userData.email,
        password: userData.password,
        email_confirm: true
      })

      if (authError || !authUser.user) {
        throw new Error(`Failed to create auth user: ${authError?.message}`)
      }

      // Create user record in database
      const { data: dbUser, error: dbError } = await supabaseAdmin
        .from('users')
        .insert({
          username: userData.username,
          password_hash: 'managed_by_auth', // Placeholder since we use Supabase Auth
          name: userData.name,
          email: userData.email ?? null,
          department: userData.department ?? null,
          role: userData.role ?? 'operator',
          is_active: true
        } as any)
        .select()
        .single()

      if (dbError) {
        // Cleanup auth user if database insert fails
        await supabaseAdmin.auth.admin.deleteUser(authUser.user.id)
        throw new Error(`Failed to create database user: ${dbError.message}`)
      }

      return { authUser, dbUser }
    },

    updateUser: async (id: number, updates: {
      name?: string
      email?: string
      department?: string
      role?: 'admin' | 'manager' | 'operator' | 'viewer'
      is_active?: boolean
    }) => {
      const { data, error } = await supabaseAdmin
        .from('users')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) {
        throw new Error(`Failed to update user: ${error.message}`)
      }

      return data
    },

    deleteUser: async (id: number) => {
      // Get user email for auth deletion
      const { data: user, error: getUserError } = await supabaseAdmin
        .from('users')
        .select('email')
        .eq('id', id)
        .single()

      if (getUserError || !user?.email) {
        throw new Error('User not found')
      }

      // Soft delete in database
      const { error: dbError } = await supabaseAdmin
        .from('users')
        .update({ is_active: false })
        .eq('id', id)

      if (dbError) {
        throw new Error(`Failed to deactivate user: ${dbError.message}`)
      }

      // Optionally delete from auth (uncomment if needed)
      // const { data: authUsers } = await supabaseAdmin.auth.admin.listUsers()
      // const authUser = authUsers.users.find(u => u.email === user.email)
      // if (authUser) {
      //   await supabaseAdmin.auth.admin.deleteUser(authUser.id)
      // }

      return true
    },

    getAllUsers: async () => {
      const { data, error } = await supabaseAdmin
        .from('users')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) {
        throw new Error(`Failed to fetch users: ${error.message}`)
      }

      return data
    }
  },

  // Database schema and migration helpers
  schema: {
    // Check if tables exist
    checkTables: async () => {
      try {
        const tables = [
          'users', 'items', 'companies', 'boms',
          'inventory_transactions', 'documents',
          'document_details', 'scraps'
        ]

        const results = []
        for (const table of tables) {
          const { data, error } = await supabaseAdmin
            .from(table as any)
            .select('*', { count: 'exact', head: true })

          results.push({
            table,
            exists: !error,
            error: error?.message
          })
        }

        return results
      } catch (error) {
        throw new Error(`Failed to check tables: ${error}`)
      }
    },

    // Check if views exist
    checkViews: async () => {
      try {
        const { data, error } = await supabaseAdmin
          .from('current_stock_view')
          .select('*', { count: 'exact', head: true } as any)

        return {
          current_stock: {
            exists: !error,
            error: error?.message
          }
        }
      } catch (error) {
        throw new Error(`Failed to check views: ${error}`)
      }
    },

    // Get table statistics
    getTableStats: async () => {
      const tables = [
        'users', 'items', 'companies', 'boms',
        'inventory_transactions', 'documents',
        'document_details', 'scraps'
      ]

      const stats = []
      for (const table of tables) {
        try {
          const { count, error } = await supabaseAdmin
            .from(table as any)
            .select('*', { count: 'exact', head: true })

          stats.push({
            table,
            count: count || 0,
            error: error?.message
          })
        } catch (error) {
          stats.push({
            table,
            count: 0,
            error: `Failed to count: ${error}`
          })
        }
      }

      return stats
    }
  },

  // Data migration helpers
  migration: {
    // Import sample data
    importSampleData: async () => {
      try {
        // Sample users
        const users = [
          {
            username: 'admin',
            password_hash: 'managed_by_auth',
            name: '관리자',
            email: 'admin@taechang.com',
            department: '전산팀',
            role: 'admin' as const
          },
          {
            username: 'manager',
            password_hash: 'managed_by_auth',
            name: '김부장',
            email: 'manager@taechang.com',
            department: '생산관리팀',
            role: 'manager' as const
          },
          {
            username: 'operator1',
            password_hash: 'managed_by_auth',
            name: '이대리',
            email: 'operator1@taechang.com',
            department: '생산팀',
            role: 'operator' as const
          }
        ]

        const { data: insertedUsers, error: usersError } = await supabaseAdmin
          .from('users')
          .insert(users as any)
          .select()

        if (usersError) {
          throw new Error(`Failed to insert users: ${usersError.message}`)
        }

        // Sample items
        const items = [
          {
            item_code: 'MAT-001',
            name: '스틸 플레이트',
            specification: '100x100x10mm',
            category: '원자재' as const,
            unit: 'EA',
            safety_stock: 50,
            lead_time_days: 7,
            unit_price: 15000
          },
          {
            item_code: 'MAT-002',
            name: '알루미늄 프로파일',
            specification: '30x30x1000mm',
            category: '원자재' as const,
            unit: 'EA',
            safety_stock: 20,
            lead_time_days: 5,
            unit_price: 8000
          },
          {
            item_code: 'PRD-001',
            name: 'A형 브라켓',
            specification: '자동차용 브라켓 A타입',
            category: '제품' as const,
            unit: 'EA',
            safety_stock: 10,
            lead_time_days: 0,
            unit_price: 45000
          }
        ]

        const { data: insertedItems, error: itemsError } = await supabaseAdmin
          .from('items')
          .insert(items as any)
          .select()

        if (itemsError) {
          throw new Error(`Failed to insert items: ${itemsError.message}`)
        }

        // Sample companies
        const companies = [
          {
            company_code: 'CUST-001',
            name: '현대자동차',
            company_type: '고객사' as const,
            business_number: '101-81-12345',
            ceo_name: '정의선',
            phone: '02-3464-1114',
            address: '서울특별시 서초구 헌릉로 12',
            contact_person: '김과장'
          },
          {
            company_code: 'SUPP-001',
            name: '동일철강',
            company_type: '공급사' as const,
            business_number: '124-81-45678',
            ceo_name: '박철수',
            phone: '031-123-4567',
            address: '경기도 안산시 단원구 별망로 100',
            contact_person: '최대리'
          }
        ]

        const { data: insertedCompanies, error: companiesError } = await supabaseAdmin
          .from('companies')
          .insert(companies as any)
          .select()

        if (companiesError) {
          throw new Error(`Failed to insert companies: ${companiesError.message}`)
        }

        return {
          users: insertedUsers,
          items: insertedItems,
          companies: insertedCompanies
        }
      } catch (error) {
        throw new Error(`Failed to import sample data: ${error}`)
      }
    },

    // Clear all data (use with caution)
    clearAllData: async () => {
      try {
        const tables = [
          'scraps', 'document_details', 'documents',
          'inventory_transactions', 'boms',
          'companies', 'items', 'users'
        ]

        const results = []
        for (const table of tables) {
          const { error } = await supabaseAdmin
            .from(table as any)
            .delete()
            .neq('id', 0) // Delete all records

          results.push({
            table,
            success: !error,
            error: error?.message
          })
        }

        return results
      } catch (error) {
        throw new Error(`Failed to clear data: ${error}`)
      }
    }
  },

  // Backup and restore helpers
  backup: {
    // Export table data
    exportTable: async (tableName: string) => {
      try {
        const { data, error } = await supabaseAdmin
          .from(tableName as any)
          .select('*')

        if (error) {
          throw new Error(`Failed to export ${tableName}: ${error.message}`)
        }

        return data
      } catch (error) {
        throw new Error(`Failed to export table ${tableName}: ${error}`)
      }
    },

    // Import table data
    importTable: async (tableName: string, data: unknown[]) => {
      try {
        const { error } = await supabaseAdmin
          .from(tableName as any)
          .insert(data)

        if (error) {
          throw new Error(`Failed to import ${tableName}: ${error.message}`)
        }

        return true
      } catch (error) {
        throw new Error(`Failed to import table ${tableName}: ${error}`)
      }
    }
  }
}

export default supabaseAdmin
```


#### 📄 src\lib\supabase-mcp.ts

```typescript
/**
 * Supabase MCP Integration Library
 *
 * This module provides a wrapper around the Supabase MCP server's execute_sql function.
 * It's used to execute raw SQL queries against the Supabase PostgreSQL database.
 *
 * Usage:
 * ```typescript
 * import { mcp__supabase__execute_sql } from '@/lib/supabase-mcp';
 *
 * const result = await mcp__supabase__execute_sql({
 *   project_id: process.env.SUPABASE_PROJECT_ID!,
 *   query: 'SELECT * FROM items WHERE is_active = true'
 * });
 *
 * const rows = result?.rows || [];
 * ```
 *
 * Migration from MySQL to PostgreSQL:
 * - `= 1` → `= true`, `= 0` → `= false`
 * - `?` parameters → string interpolation (MCP doesn't support parameterized queries yet)
 * - `NOW()` → `CURRENT_TIMESTAMP`
 * - `IFNULL()` → `COALESCE()`
 *
 * Important Notes:
 * - This is a temporary wrapper during Phase 5-2 migration
 * - SQL injection prevention: Sanitize inputs before string interpolation
 * - Error handling: Always wrap in try-catch blocks
 * - Environment variable SUPABASE_PROJECT_ID must be configured
 */

import { getSupabaseClient } from './db-unified';

interface ExecuteSqlParams {
  project_id: string;
  query: string;
}

interface ExecuteSqlResult {
  rows?: Record<string, unknown>[];
  error?: string;
}

/**
 * Execute SQL query using Supabase MCP server
 *
 * @param params - Object containing project_id and SQL query
 * @returns Promise resolving to query results or error
 * @throws Error if SUPABASE_PROJECT_ID is not configured or query execution fails
 */
export async function mcp__supabase__execute_sql(
  params: ExecuteSqlParams
): Promise<ExecuteSqlResult> {
  try {
    const { project_id, query } = params;

    if (!project_id) {
      throw new Error('SUPABASE_PROJECT_ID is required');
    }

    if (!query) {
      throw new Error('SQL query is required');
    }

    const supabase = getSupabaseClient();

    const { data, error } = await supabase.rpc('execute_sql', {
      query_text: query,
      params: null
    });

    if (error) {
      console.error('[Supabase MCP] execute_sql error:', error);
      return {
        rows: undefined,
        error: error.message || 'Supabase execute_sql failed'
      };
    }

    const rows = Array.isArray(data)
      ? (data as Record<string, unknown>[])
      : data
        ? [data as Record<string, unknown>]
        : [];

    return {
      rows,
      error: undefined
    };
  } catch (error) {
    console.error('[Supabase MCP] Query execution error:', error);
    return {
      rows: undefined,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Helper function to sanitize string values for SQL interpolation
 * Prevents SQL injection by escaping single quotes
 *
 * @param value - String value to sanitize
 * @returns Sanitized string safe for SQL interpolation
 */
export function sanitizeSqlString(value: string): string {
  return value.replace(/'/g, "''");
}

/**
 * Helper function to build WHERE clause from filters
 *
 * @param filters - Object containing filter key-value pairs
 * @returns SQL WHERE clause string
 */
export function buildWhereClause(filters: Record<string, unknown>): string {
  const conditions: string[] = [];

  for (const [key, value] of Object.entries(filters)) {
    if (value === null || value === undefined) {
      continue;
    }

    if (typeof value === 'string') {
      conditions.push(`${key} = '${sanitizeSqlString(value)}'`);
    } else if (typeof value === 'boolean') {
      conditions.push(`${key} = ${value}`);
    } else if (typeof value === 'number') {
      conditions.push(`${key} = ${value}`);
    } else if (Array.isArray(value)) {
      const values = value
        .map(v => (typeof v === 'string' ? `'${sanitizeSqlString(v)}'` : `${v}`))
        .join(', ');
      conditions.push(`${key} IN (${values})`);
    }
  }

  return conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
}

/**
 * Helper function to convert MySQL syntax to PostgreSQL
 *
 * @param mysqlQuery - SQL query in MySQL syntax
 * @returns SQL query converted to PostgreSQL syntax
 */
export function convertMySqlToPostgreSql(mysqlQuery: string): string {
  let pgQuery = mysqlQuery;

  // Replace backticks with double quotes (for identifiers)
  pgQuery = pgQuery.replace(/`([^`]+)`/g, '"$1"');

  // Replace MySQL boolean values
  pgQuery = pgQuery.replace(/\s*=\s*1\s/g, ' = true ');
  pgQuery = pgQuery.replace(/\s*=\s*0\s/g, ' = false ');

  // Replace MySQL functions
  pgQuery = pgQuery.replace(/NOW\(\)/g, 'CURRENT_TIMESTAMP');
  pgQuery = pgQuery.replace(/IFNULL\(/g, 'COALESCE(');

  // Replace LIMIT syntax (MySQL allows LIMIT offset, count)
  pgQuery = pgQuery.replace(/LIMIT\s+(\d+)\s*,\s*(\d+)/gi, 'LIMIT $2 OFFSET $1');

  return pgQuery;
}

```


#### 📄 src\lib\supabase.ts

```typescript
import { createBrowserClient } from '@supabase/ssr'
import { createClient, SupabaseClient } from '@supabase/supabase-js'
import { Database } from '@/types/supabase'

// Supabase configuration from environment variables
const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.SUPABASE_API || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
const supabaseServiceRole = process.env.SUPABASE_SERVICE_ROLE!

// Browser client for client-side operations
export const createSupabaseBrowserClient = () =>
  createBrowserClient<Database>(supabaseUrl, supabaseAnonKey)

// Standard client for client-side operations
export const supabase: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
    db: {
      schema: 'public'
    },
    global: {
      headers: {
        'x-my-custom-header': 'taechang-erp'
      }
    }
  }
)

// Admin client for server-side operations with service role
export const supabaseAdmin: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl,
  supabaseServiceRole,
  {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
    },
    db: {
      schema: 'public'
    }
  }
)

// Helper functions for common operations
export const supabaseHelpers = {
  // Authentication helpers
  auth: {
    signUp: async (email: string, password: string) => {
      return await supabase.auth.signUp({ email, password })
    },
    signIn: async (email: string, password: string) => {
      return await supabase.auth.signInWithPassword({ email, password })
    },
    signOut: async () => {
      return await supabase.auth.signOut()
    },
    getUser: async () => {
      return await supabase.auth.getUser()
    },
    getSession: async () => {
      return await supabase.auth.getSession()
    },
  },

  // Database helpers
  db: {
    // Items operations
    items: {
      getAll: async () => {
        return await supabase
          .from('items')
          .select('*')
          .eq('is_active', true)
          .order('item_code')
      },
      getById: async (id: number) => {
        return await supabase
          .from('items')
          .select('*')
          .eq('id', id)
          .single()
      },
      create: async (item: Database['public']['Tables']['items']['Insert']) => {
        return await supabase
          .from('items')
          .insert(item)
          .select()
          .single()
      },
      update: async (id: number, item: Database['public']['Tables']['items']['Update']) => {
        return await supabase
          .from('items')
          .update(item)
          .eq('id', id)
          .select()
          .single()
      },
      delete: async (id: number) => {
        return await supabase
          .from('items')
          .update({ is_active: false })
          .eq('id', id)
      },
    },

    // Companies operations
    companies: {
      getAll: async () => {
        return await supabase
          .from('companies')
          .select('*')
          .eq('is_active', true)
          .order('company_code')
      },
      getById: async (id: number) => {
        return await supabase
          .from('companies')
          .select('*')
          .eq('id', id)
          .single()
      },
      create: async (company: Database['public']['Tables']['companies']['Insert']) => {
        return await supabase
          .from('companies')
          .insert(company)
          .select()
          .single()
      },
      update: async (id: number, company: Database['public']['Tables']['companies']['Update']) => {
        return await supabase
          .from('companies')
          .update(company)
          .eq('id', id)
          .select()
          .single()
      },
      delete: async (id: number) => {
        return await supabase
          .from('companies')
          .update({ is_active: false })
          .eq('id', id)
      },
    },

    // BOM operations
    bom: {
      getAll: async () => {
        return await supabase
          .from('bom')
          .select(`
            *,
            parent_item:items!bom_parent_item_id_fkey(id, item_code, item_name, spec),
            child_item:items!bom_child_item_id_fkey(id, item_code, item_name, spec)
          `)
          .eq('is_active', true)
      },
      getByParentId: async (parentId: number) => {
        return await supabase
          .from('bom')
          .select(`
            *,
            child_item:items!bom_child_item_id_fkey(id, item_code, item_name, spec, unit)
          `)
          .eq('parent_item_id', parentId)
          .eq('is_active', true)
          .order('operation_seq')
      },
      create: async (bom: Database['public']['Tables']['bom']['Insert']) => {
        return await supabase
          .from('bom')
          .insert(bom)
          .select()
          .single()
      },
      update: async (id: number, bom: Database['public']['Tables']['bom']['Update']) => {
        return await supabase
          .from('bom')
          .update(bom)
          .eq('id', id)
          .select()
          .single()
      },
      delete: async (id: number) => {
        return await supabase
          .from('bom')
          .update({ is_active: false })
          .eq('id', id)
      },
    },

    // Inventory transactions
    inventoryTransactions: {
      getAll: async (filters?: {
        dateFrom?: string
        dateTo?: string
        itemId?: number
        transactionType?: string
        limit?: number
      }) => {
        let query = supabase
          .from('inventory_transactions')
          .select(`
            *,
            item:items(id, item_code, name, specification, unit),
            company:companies(id, company_code, name),
            user:users(id, name)
          `)
          .order('transaction_date', { ascending: false })

        if (filters?.dateFrom) {
          query = query.gte('transaction_date', filters.dateFrom)
        }
        if (filters?.dateTo) {
          query = query.lte('transaction_date', filters.dateTo)
        }
        if (filters?.itemId) {
          query = query.eq('item_id', filters.itemId)
        }
        if (filters?.transactionType) {
          query = query.eq('transaction_type', filters.transactionType as Database['public']['Enums']['transaction_type'])
        }
        if (filters?.limit) {
          query = query.limit(filters.limit)
        }

        return await query
      },
      create: async (transaction: Database['public']['Tables']['inventory_transactions']['Insert']) => {
        return await supabase
          .from('inventory_transactions')
          .insert(transaction)
          .select()
          .single()
      },
      update: async (id: number, transaction: Database['public']['Tables']['inventory_transactions']['Update']) => {
        return await supabase
          .from('inventory_transactions')
          .update(transaction)
          .eq('id', id)
          .select()
          .single()
      },
      delete: async (id: number) => {
        return await supabase
          .from('inventory_transactions')
          .delete()
          .eq('id', id)
      },
    },

    // Current stock view
    currentStock: {
      getAll: async () => {
        return await supabase
          .from('current_stock_view')
          .select('*')
          .order('item_code')
      },
      getById: async (itemId: number) => {
        return await supabase
          .from('current_stock_view')
          .select('*')
          .eq('item_id', itemId)
          .single()
      },
      getLowStock: async () => {
        // Get items where current_stock < safety_stock
        // Using filter comparison instead of raw SQL
        return await supabase
          .from('items')
          .select('*')
          .eq('is_active', true)
          .order('current_stock')
      },
    },

    // Warehouses operations
    warehouses: {
      getAll: async () => {
        return await supabase
          .from('warehouses')
          .select('*')
          .eq('is_active', true)
          .order('warehouse_code')
      },
      getById: async (id: number) => {
        return await supabase
          .from('warehouses')
          .select('*')
          .eq('id', id)
          .single()
      },
      create: async (warehouse: Database['public']['Tables']['warehouses']['Insert']) => {
        return await supabase
          .from('warehouses')
          .insert(warehouse)
          .select()
          .single()
      },
      update: async (id: number, warehouse: Database['public']['Tables']['warehouses']['Update']) => {
        return await supabase
          .from('warehouses')
          .update(warehouse)
          .eq('id', id)
          .select()
          .single()
      },
      delete: async (id: number) => {
        return await supabase
          .from('warehouses')
          .update({ is_active: false })
          .eq('id', id)
      },
    },

    // Warehouse stock operations
    warehouseStock: {
      getAll: async () => {
        return await supabase
          .from('warehouse_stock')
          .select(`
            *,
            warehouse:warehouses(id, warehouse_code, warehouse_name),
            item:items(id, item_code, item_name, spec, unit)
          `)
          .order('warehouse_id, location')
      },
      getByWarehouse: async (warehouseId: number) => {
        return await supabase
          .from('warehouse_stock')
          .select(`
            *,
            item:items(id, item_code, item_name, spec, unit)
          `)
          .eq('warehouse_id', warehouseId)
          .order('location')
      },
      getByItem: async (itemId: number) => {
        return await supabase
          .from('warehouse_stock')
          .select(`
            *,
            warehouse:warehouses(id, warehouse_code, warehouse_name)
          `)
          .eq('item_id', itemId)
          .order('warehouse_id, location')
      },
      upsert: async (stock: Database['public']['Tables']['warehouse_stock']['Insert']) => {
        return await supabase
          .from('warehouse_stock')
          .upsert(stock)
          .select()
          .single()
      },
    },

    // Stock adjustments operations
    stockAdjustments: {
      getAll: async () => {
        return await supabase
          .from('stock_adjustments')
          .select(`
            *,
            item:items(id, item_code, item_name, spec),
            warehouse:warehouses(id, warehouse_code, warehouse_name),
            request_user:users!stock_adjustments_request_user_id_fkey(id, name),
            approval_user:users!stock_adjustments_approval_user_id_fkey(id, name)
          `)
          .order('created_at', { ascending: false })
      },
      getPending: async () => {
        return await supabase
          .from('stock_adjustments')
          .select(`
            *,
            item:items(id, item_code, item_name, spec),
            warehouse:warehouses(id, warehouse_code, warehouse_name),
            request_user:users!stock_adjustments_request_user_id_fkey(id, name)
          `)
          .is('approved_at', null)
          .order('created_at', { ascending: false })
      },
      create: async (adjustment: Database['public']['Tables']['stock_adjustments']['Insert']) => {
        return await supabase
          .from('stock_adjustments')
          .insert(adjustment)
          .select()
          .single()
      },
      approve: async (id: number, userId: number) => {
        return await supabase
          .from('stock_adjustments')
          .update({
            approved_by: userId,
            approval_date: new Date().toISOString()
          })
          .eq('adjustment_id', id)
          .select()
          .single()
      },
    },

    // Serials operations (document numbering)
    serials: {
      getNextSerial: async (prefix: string) => {
        const { data, error } = await supabase
          .rpc('get_next_serial', { prefix_param: prefix })

        if (error) throw error
        return data
      },
    },

    // Users operations
    users: {
      getAll: async () => {
        return await supabase
          .from('users')
          .select('id, username, name, email, department, role, is_active, created_at')
          .eq('is_active', true)
          .order('name')
      },
      getById: async (id: number) => {
        return await supabase
          .from('users')
          .select('id, username, name, email, department, role, is_active, created_at')
          .eq('id', id)
          .single()
      },
    },
  },
}

// Convert MySQL-style parameterized query to PostgreSQL format
// MySQL: 'SELECT * FROM items WHERE item_id = ? AND status = ?'
// PostgreSQL: 'SELECT * FROM items WHERE item_id = $1 AND status = $2'

// Using Supabase client with RPC for raw SQL execution
function convertQueryToPostgres(sqlString: string, params?: any[]): { sql: string; params: unknown[] } {
  if (!params || params.length === 0) {
    return { sql: sqlString, params: [] };
  }

  let paramIndex = 1;
  const convertedSql = sqlString.replace(/\?/g, () => `$${paramIndex++}`);

  return { sql: convertedSql, params };
}

// MySQL-compatible query function for backward compatibility
// Note: This requires a custom RPC function 'execute_sql' to be created in Supabase
export async function query<T = any>(sqlString: string, params?: any[]): Promise<T> {
  try {
    const { sql: pgSql, params: pgParams } = convertQueryToPostgres(sqlString, params);

    // Note: This requires creating a custom execute_sql function in Supabase
    // For now, throw an error with helpful message
    throw new Error('Raw SQL execution requires custom RPC function. Use Supabase client methods instead.');

    // When RPC is set up, use this:
    // const { data, error } = await supabaseAdmin.rpc('execute_sql' as any, {
    //   query_text: pgSql,
    //   params: pgParams
    // });
    //
    // if (error) {
    //   console.error('Supabase query error:', error);
    //   throw new Error(error.message || 'Database query failed');
    // }
    //
    // return data as T;
  } catch (error) {
    console.error('Database query error:', {
      sql: sqlString.substring(0, 200) + '...',
      error: error instanceof Error ? error.message : error
    });
    throw error;
  }
}

// MySQL-compatible transaction function
// Note: This requires a custom RPC function 'execute_transaction' to be created in Supabase
export async function transaction<T = any>(
  callback: (connection: unknown) => Promise<T>
): Promise<T> {
  try {
    // For Supabase, use TransactionManager class instead
    // This is a legacy compatibility function
    throw new Error('Transaction execution requires TransactionManager class. Use TransactionManager.execute() instead.');

    // When RPC is set up, use this:
    // const queries: Array<{ sql: string; params: unknown[] }> = [];
    //
    // const connection = {
    //   execute: async (sqlString: string, params?: any[]) => {
    //     const { sql: pgSql, params: pgParams } = convertQueryToPostgres(sqlString, params);
    //     queries.push({ sql: pgSql, params: pgParams });
    //     return [{ insertId: 0 }];
    //   }
    // };
    //
    // await callback(connection);
    //
    // const { data, error } = await supabaseAdmin.rpc('execute_transaction' as any, {
    //   queries: queries
    // });
    //
    // if (error) {
    //   console.error('Transaction error:', error);
    //   throw new Error(error.message || 'Transaction failed');
    // }
    //
    // return data as T;
  } catch (error) {
    console.error('Transaction error:', error instanceof Error ? error.message : error);
    throw error;
  }
}

// Test connection to Supabase
export async function testConnection(): Promise<boolean> {
  try {
    const { data, error } = await supabase.from('items').select('count').limit(1);

    if (error) {
      console.error('Supabase connection test failed:', error);
      return false;
    }

    return true;
  } catch (error) {
    console.error('Supabase connection failed:', error);
    return false;
  }
}

// Enhanced Transaction Manager adapted for Supabase
export interface TransactionResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  rollbackReason?: string;
}

export interface ValidationRule<T> {
  validate: (data: T, client: SupabaseClient<Database>) => Promise<boolean>;
  errorMessage: string;
}

export class TransactionManager {
  private client: SupabaseClient<Database>;
  private validationRules: ValidationRule<any>[] = [];

  constructor() {
    this.client = supabaseAdmin;
  }

  addValidationRule<T>(rule: ValidationRule<T>): void {
    this.validationRules.push(rule);
  }

  async execute<T>(
    callback: (client: SupabaseClient<Database>) => Promise<T>,
    validationData?: any
  ): Promise<TransactionResult<T>> {
    try {
      // Run validation rules if provided
      if (validationData && this.validationRules.length > 0) {
        for (const rule of this.validationRules) {
          const isValid = await rule.validate(validationData, this.client);
          if (!isValid) {
            return {
              success: false,
              error: rule.errorMessage,
              rollbackReason: rule.errorMessage
            };
          }
        }
      }

      const result = await callback(this.client);

      return {
        success: true,
        data: result
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      return {
        success: false,
        error: errorMessage,
        rollbackReason: errorMessage
      };
    }
  }

  // Atomic stock update with validation
  static async updateStock(
    itemId: number,
    quantityChange: number,
    transactionType: string,
    referenceId?: string
  ): Promise<TransactionResult<{ newStock: number; transaction_id: number }>> {
    const manager = new TransactionManager();

    // Add stock validation rule
    manager.addValidationRule({
      validate: async (data: { itemId: number; quantityChange: number; transactionType: string }, client) => {
        if (data.transactionType === '출고' && data.quantityChange < 0) {
          const { data: stockResult, error } = await client
            .from('items')
            .select('current_stock')
            .eq('item_id', data.itemId)
            .single();

          if (error || !stockResult) {
            return false;
          }

          const currentStock = stockResult.current_stock ?? 0;
          return currentStock >= Math.abs(data.quantityChange);
        }
        return true;
      },
      errorMessage: '재고가 부족합니다'
    });

    return await manager.execute(async (client) => {
      // Get current stock
      const { data: stockData, error: stockError } = await client
        .from('items')
        .select('current_stock')
        .eq('item_id', itemId)
        .single();

      if (stockError || !stockData) {
        throw new Error('품목을 찾을 수 없습니다');
      }

      const currentStock = stockData.current_stock ?? 0;
      const newStock = currentStock + quantityChange;

      if (newStock < 0) {
        throw new Error('재고가 음수가 될 수 없습니다');
      }

      // Update stock
      const { error: updateError } = await client
        .from('items')
        .update({
          current_stock: newStock,
          updated_at: new Date().toISOString()
        })
        .eq('item_id', itemId);

      if (updateError) {
        throw updateError;
      }

      // Create transaction record
      const { data: transactionData, error: transactionError } = await client
        .from('inventory_transactions')
        .insert({
          item_id: itemId,
          transaction_type: transactionType as Database['public']['Enums']['transaction_type'],
          quantity: quantityChange,
          transaction_date: new Date().toISOString(),
          reference_number: referenceId,
          created_at: new Date().toISOString()
        })
        .select('transaction_id')
        .single();

      if (transactionError || !transactionData) {
        throw new Error('트랜잭션 생성 실패');
      }

      return {
        newStock,
        transaction_id: transactionData.transaction_id
      };
    }, { itemId, quantityChange, transactionType });
  }

  // Atomic BOM creation with component validation
  static async createBOMWithValidation(
    parentItemId: number,
    components: Array<{ child_item_id: number; quantity: number; unit?: string; notes?: string }>
  ): Promise<TransactionResult<{ bom_ids: number[] }>> {
    const manager = new TransactionManager();

    // Add component existence validation
    manager.addValidationRule({
      validate: async (data: { components: any[] }, client) => {
        const componentIds = data.components.map(c => c.child_item_id);
        const { data: items, error } = await client
          .from('items')
          .select('item_id')
          .in('item_id', componentIds)
          .eq('is_active', true);

        if (error) return false;
        return items && items.length === componentIds.length;
      },
      errorMessage: '일부 구성품목이 존재하지 않거나 비활성 상태입니다'
    });

    return await manager.execute(async (client) => {
      // Deactivate existing BOM entries for this parent
      await client
        .from('bom')
        .update({
          is_active: false,
          updated_at: new Date().toISOString()
        })
        .eq('parent_item_id', parentItemId);

      const bomIds: number[] = [];

      // Insert new BOM entries
      for (const component of components) {
        const { data, error } = await client
          .from('bom')
          .insert({
            parent_item_id: parentItemId,
            child_item_id: component.child_item_id,
            quantity: component.quantity,
            unit: component.unit || 'EA',
            notes: component.notes || '',
            is_active: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .select('bom_id')
          .single();

        if (error) {
          throw error;
        }

        if (data) {
          bomIds.push(data.bom_id);
        }
      }

      return { bom_ids: bomIds };
    }, { parentItemId, components });
  }
}

// Legacy TypeScript interfaces for backward compatibility
// New code should use types from @/types/supabase.ts instead
export interface LegacyItem {
  item_id: number;
  item_code: string;
  item_name: string;
  item_type: 'MATERIAL' | 'PRODUCT' | 'SCRAP';
  car_model?: string;
  spec?: string;
  unit: string;
  current_stock: number;
  min_stock_level?: number;
  unit_price?: number;
  location?: string;
  description?: string;
  is_active: boolean;
  created_at: Date;
  updated_at: Date;
  safety_stock?: number;
}

export interface LegacyCompany {
  company_id: number;
  company_name: string;
  company_type: string;
  business_registration_no?: string;
  contact_person?: string;
  phone?: string;
  mobile?: string;
  email?: string;
  address?: string;
  payment_terms?: string;
  contact_info?: string;
  notes?: string;
  is_active: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface LegacyInventoryTransaction {
  transaction_id: number;
  item_id: number;
  company_id?: number;
  user_id: number;
  created_by?: number;
  transaction_type?: string;
  quantity: number;
  unit_price?: number;
  total_amount?: number;
  from_location?: string;
  to_location?: string;
  lot_no?: string;
  expiry_date?: Date;
  reference_id?: string;
  reference_no?: string;
  transaction_date: Date;
  note?: string;
  notes?: string;
  created_at: Date;
  updated_at?: Date;
  warehouse_from?: string;
  warehouse_to?: string;
  unit?: string;
  is_active?: boolean;
}

export interface LegacyBOM {
  bom_id: number;
  parent_item_id: number;
  child_item_id: number;
  quantity: number;
  unit?: string;
  level?: number;
  notes?: string;
  is_active: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface LegacyUser {
  user_id: number;
  username: string;
  full_name?: string;
  password: string;
  role?: string;
  name?: string;
  email?: string;
  is_active?: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface LegacyStockView {
  item_id: number;
  item_code: string;
  item_name: string;
  spec?: string;
  item_type: string;
  unit: string;
  current_stock: number;
  min_stock_level?: number;
  safety_stock?: number;
  stock_status: '정상' | '주의' | '부족';
}

// Re-export types from Database schema for convenience
export type {
  Item,
  ItemInsert,
  ItemUpdate,
  Company,
  CompanyInsert,
  CompanyUpdate,
  BOM,
  BOMInsert,
  BOMUpdate,
  InventoryTransaction,
  InventoryTransactionInsert,
  InventoryTransactionUpdate,
  User,
  UserInsert,
  UserUpdate
} from '@/types/supabase'

export default supabase
```


#### 📄 src\lib\tax.ts

```typescript
/**
 * 부가세 및 금액 계산 유틸리티
 * 한국 부가세법 기준 (기본 10%)
 */

export interface TaxCalculationInput {
  quantity: number;
  unitPrice: number;
  taxRate?: number; // 기본 10%
  currency?: string; // 기본 KRW
  exchangeRate?: number; // 외화 환율
}

export interface TaxCalculationResult {
  subtotalAmount: number; // 공급가액 (수량 × 단가)
  taxAmount: number; // 부가세액
  grandTotal: number; // 합계 (공급가액 + 부가세)
  totalAmount: number; // 원화 환산 금액
  currency: string;
  exchangeRate: number;
  taxRate: number;
}

export interface BulkTaxCalculationInput {
  items: Array<{
    quantity: number;
    unitPrice: number;
    taxRate?: number;
  }>;
  currency?: string;
  exchangeRate?: number;
  globalTaxRate?: number; // 전체 적용 세율
}

export interface BulkTaxCalculationResult {
  items: Array<{
    subtotalAmount: number;
    taxAmount: number;
    grandTotal: number;
  }>;
  totalSubtotal: number;
  totalTax: number;
  totalGrand: number;
  totalAmountKRW: number; // 원화 환산 총액
  currency: string;
  exchangeRate: number;
}

/**
 * 기본 부가세율 (10%)
 */
export const DEFAULT_TAX_RATE = 10.00;

/**
 * 지원 통화 목록
 */
export const SUPPORTED_CURRENCIES = {
  KRW: '원',
  USD: '달러',
  JPY: '엔',
  CNY: '위안',
  EUR: '유로'
} as const;

/**
 * 단일 항목 부가세 계산
 */
export function calculateTax(input: TaxCalculationInput): TaxCalculationResult {
  const {
    quantity,
    unitPrice,
    taxRate = DEFAULT_TAX_RATE,
    currency = 'KRW',
    exchangeRate = 1.0
  } = input;

  // 소계 계산 (수량 × 단가)
  const subtotalAmount = Math.round(quantity * unitPrice * 100) / 100;

  // 부가세 계산
  const taxAmount = Math.round(subtotalAmount * (taxRate / 100) * 100) / 100;

  // 합계 계산 (소계 + 부가세)
  const grandTotal = subtotalAmount + taxAmount;

  // 원화 환산 (외화인 경우)
  const totalAmount = currency !== 'KRW' && exchangeRate > 0
    ? Math.round(grandTotal * exchangeRate * 100) / 100
    : grandTotal;

  return {
    subtotalAmount,
    taxAmount,
    grandTotal,
    totalAmount,
    currency,
    exchangeRate,
    taxRate
  };
}

/**
 * 복수 항목 부가세 계산
 */
export function calculateBulkTax(input: BulkTaxCalculationInput): BulkTaxCalculationResult {
  const {
    items,
    currency = 'KRW',
    exchangeRate = 1.0,
    globalTaxRate
  } = input;

  let totalSubtotal = 0;
  let totalTax = 0;
  let totalGrand = 0;

  const calculatedItems = items.map(item => {
    const taxRate = globalTaxRate ?? item.taxRate ?? DEFAULT_TAX_RATE;

    // 항목별 계산
    const subtotalAmount = Math.round(item.quantity * item.unitPrice * 100) / 100;
    const taxAmount = Math.round(subtotalAmount * (taxRate / 100) * 100) / 100;
    const grandTotal = subtotalAmount + taxAmount;

    // 누적 합계
    totalSubtotal += subtotalAmount;
    totalTax += taxAmount;
    totalGrand += grandTotal;

    return {
      subtotalAmount,
      taxAmount,
      grandTotal
    };
  });

  // 원화 환산
  const totalAmountKRW = currency !== 'KRW' && exchangeRate > 0
    ? Math.round(totalGrand * exchangeRate * 100) / 100
    : totalGrand;

  return {
    items: calculatedItems,
    totalSubtotal: Math.round(totalSubtotal * 100) / 100,
    totalTax: Math.round(totalTax * 100) / 100,
    totalGrand: Math.round(totalGrand * 100) / 100,
    totalAmountKRW,
    currency,
    exchangeRate
  };
}

/**
 * 부가세 역계산 (총액에서 공급가액과 부가세 분리)
 */
export function reverseTaxCalculation(
  totalAmount: number,
  taxRate: number = DEFAULT_TAX_RATE
): { subtotal: number; tax: number } {
  // 공급가액 = 총액 / (1 + 세율)
  const subtotal = Math.round(totalAmount / (1 + taxRate / 100) * 100) / 100;

  // 부가세 = 총액 - 공급가액
  const tax = Math.round((totalAmount - subtotal) * 100) / 100;

  return { subtotal, tax };
}

/**
 * 세금계산서 번호 생성
 * 형식: YYYYMMDD-XXXX (일자-순번)
 */
export function generateTaxInvoiceNumber(date: Date = new Date(), sequence: number = 1): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const seq = String(sequence).padStart(4, '0');

  return `${year}${month}${day}-${seq}`;
}

/**
 * 금액을 한국 원화 형식으로 포맷팅
 */
export function formatKRW(amount: number): string {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount);
}

/**
 * 외화를 해당 통화 형식으로 포맷팅
 */
export function formatCurrency(amount: number, currency: string = 'KRW'): string {
  const locale = currency === 'KRW' ? 'ko-KR' :
                 currency === 'USD' ? 'en-US' :
                 currency === 'JPY' ? 'ja-JP' :
                 currency === 'CNY' ? 'zh-CN' :
                 currency === 'EUR' ? 'de-DE' : 'en-US';

  const decimals = currency === 'KRW' || currency === 'JPY' ? 0 : 2;

  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  }).format(amount);
}

/**
 * 부가세 포함/미포함 여부 확인
 */
export function isTaxIncluded(
  totalAmount: number,
  subtotalAmount: number,
  taxRate: number = DEFAULT_TAX_RATE
): boolean {
  const expectedTax = subtotalAmount * (taxRate / 100);
  const expectedTotal = subtotalAmount + expectedTax;

  // 1원 단위 오차 허용
  return Math.abs(totalAmount - expectedTotal) < 1;
}

/**
 * 세금계산서 발행 가능 여부 체크
 */
export function canIssueTaxInvoice(data: {
  supplierBusinessNumber?: string;
  buyerBusinessNumber?: string;
  amount: number;
}): { canIssue: boolean; reason?: string } {
  // 사업자번호 체크
  if (!data.supplierBusinessNumber) {
    return { canIssue: false, reason: '공급자 사업자번호가 없습니다.' };
  }

  if (!data.buyerBusinessNumber) {
    return { canIssue: false, reason: '공급받는자 사업자번호가 없습니다.' };
  }

  // 금액 체크
  if (data.amount <= 0) {
    return { canIssue: false, reason: '발행 금액이 0원 이하입니다.' };
  }

  return { canIssue: true };
}

/**
 * 사업자번호 유효성 검증 (간단한 형식 체크)
 */
export function validateBusinessNumber(businessNumber: string): boolean {
  // 하이픈 제거
  const cleaned = businessNumber.replace(/-/g, '');

  // 10자리 숫자인지 확인
  if (!/^\d{10}$/.test(cleaned)) {
    return false;
  }

  // TODO: 실제 사업자번호 검증 알고리즘 구현
  // 여기서는 형식만 체크

  return true;
}

/**
 * 세율 옵션 목록
 */
export const TAX_RATE_OPTIONS = [
  { value: 0, label: '영세율 (0%)' },
  { value: 10, label: '일반과세 (10%)' },
  { value: -1, label: '면세' }
];
```


#### 📄 src\lib\transactionManager.ts

```typescript
/**
 * Enhanced Transaction Manager for ERP System
 * Provides comprehensive atomic transaction support with rollback capabilities
 *
 * Note: This file contains legacy MySQL transaction code that is not used in the Supabase implementation.
 * All transaction management is handled by Supabase PostgreSQL.
 */

// Type definitions for compatibility (MySQL legacy types)
type PoolConnection = any;

// Enhanced interfaces with audit trail support
export interface TransactionOptions {
  isolationLevel?: 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SERIALIZABLE';
  timeout?: number; // in milliseconds
  retryAttempts?: number;
  retryDelay?: number; // in milliseconds
  enableAuditLog?: boolean;
  userId?: number;
  operation?: string;
}

export interface TransactionResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  rollbackReason?: string;
  executionTime?: number;
  auditLogId?: number;
  retryCount?: number;
}

export interface TransactionContext {
  connection: PoolConnection;
  rollback: () => Promise<void>;
  commit: () => Promise<void>;
  isActive: boolean;
  startTime: number;
  auditLogId?: number;
  userId?: number;
  operation?: string;
}

// Audit log interface
export interface AuditLog {
  id?: number;
  user_id?: number;
  operation: string;
  table_name: string;
  record_id?: number;
  old_values?: string;
  new_values?: string;
  status: 'SUCCESS' | 'FAILED' | 'ROLLBACK';
  error_message?: string;
  execution_time?: number;
  created_at?: string;
}

// Business rule validation interfaces
export interface StockValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  currentStock: number;
  requiredStock: number;
  availableStock: number;
}

export interface BOMValidationResult {
  isValid: boolean;
  errors: string[];
  circularDependency: boolean;
  materialShortages: MaterialShortage[];
  totalCost: number;
}

export interface MaterialShortage {
  item_id: number;
  item_name: string;
  required: number;
  available: number;
  shortage: number;
}

/**
 * Enhanced transaction manager with retry logic and error handling
 */
export class TransactionManager {
  private static defaultOptions: TransactionOptions = {
    isolationLevel: 'READ COMMITTED',
    timeout: 30000, // 30 seconds
    retryAttempts: 3,
    retryDelay: 1000, // 1 second
    enableAuditLog: true
  };

  /**
   * Create audit log entry (simplified version without audit_logs table)
   */
  private static async createAuditLog(
    connection: PoolConnection,
    data: Partial<AuditLog>
  ): Promise<number | null> {
    try {
      // For now, just log to console since audit_logs table doesn't exist
      // In production, you might want to create the audit_logs table

      // Return a mock ID for compatibility
      return Math.floor(Math.random() * 1000000);
    } catch (error) {
      console.error('Failed to create audit log:', error);
      return null;
    }
  }

  /**
   * Update audit log status (simplified version)
   */
  private static async updateAuditLog(
    connection: PoolConnection,
    auditLogId: number,
    status: 'SUCCESS' | 'FAILED' | 'ROLLBACK',
    errorMessage?: string,
    executionTime?: number
  ): Promise<void> {
    try {
      // For now, just log to console since audit_logs table doesn't exist
    } catch (error) {
      console.error('Failed to update audit log:', error);
    }
  }

  /**
   * Execute a transaction with enhanced error handling and retry logic
   */
  static async execute<T>(
    callback: (context: TransactionContext) => Promise<T>,
    options: TransactionOptions = {}
  ): Promise<TransactionResult<T>> {
    const finalOptions = { ...this.defaultOptions, ...options };
    const lastError: any = null;
    const auditLogId: number | null = null;

    // Create initial audit log if enabled
    // Note: This is legacy MySQL code - not used in Supabase implementation
    // if (finalOptions.enableAuditLog && finalOptions.operation) {
    //   try {
    //     const connection = await getPool().getConnection();
    //     auditLogId = await this.createAuditLog(connection, {
    //       user_id: finalOptions.userId,
    //       operation: finalOptions.operation,
    //       table_name: 'TRANSACTION',
    //       status: 'FAILED' // Will be updated on success
    //     });
    //     connection.release();
    //   } catch (error) {
    //     console.warn('Failed to create initial audit log:', error);
    //   }
    // }

    for (let attempt = 1; attempt <= finalOptions.retryAttempts!; attempt++) {
      const result = await this.executeAttempt(callback, finalOptions, attempt, auditLogId);

      if (result.success) {
        // Update audit log on success
        if (auditLogId && result.data) {
          try {
            // Note: Audit log updates disabled (MySQL legacy code)
            // const connection = await getPool().getConnection();
            // await this.updateAuditLog(connection, auditLogId, 'SUCCESS', undefined, result.executionTime);
            // connection.release();
          } catch (error) {
            console.warn('Failed to update audit log on success:', error);
          }
        }
        return { ...result, auditLogId: auditLogId || undefined, retryCount: attempt - 1 };
      }


      // Don't retry for certain types of errors
      if (this.isNonRetryableError(result.error)) {
        break;
      }
      // Exponential backoff with jitter
      if (attempt < finalOptions.retryAttempts!) {
        const backoffTime = this.calculateBackoff(finalOptions.retryDelay!, attempt);
        await this.delay(backoffTime);
      }
    }

    // Update audit log on final failure
    if (auditLogId) {
      try {
        // Note: Audit log updates disabled (MySQL legacy code)
        // const connection = await getPool().getConnection();
        // await this.updateAuditLog(connection, auditLogId, 'FAILED', `Transaction failed after ${finalOptions.retryAttempts} attempts: ${lastError}`);
        // connection.release();
      } catch (error) {
        console.warn('Failed to update audit log on failure:', error);
      }
    }

    return {
      success: false,
      error: `Transaction failed after ${finalOptions.retryAttempts} attempts: ${lastError}`,
      auditLogId: auditLogId || undefined,
      retryCount: finalOptions.retryAttempts! - 1
    };
  }

  /**
   * Calculate exponential backoff with jitter
   */
  private static calculateBackoff(baseDelay: number, attempt: number): number {
    // Exponential backoff: delay * 2^(attempt-1) with jitter
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    // Add random jitter (±25%)
    const jitter = exponentialDelay * 0.25 * (Math.random() * 2 - 1);
    return Math.round(exponentialDelay + jitter);
  }

  /**
   * Execute a single transaction attempt
   */
  private static async executeAttempt<T>(
    callback: (context: TransactionContext) => Promise<T>,
    options: TransactionOptions,
    attemptNumber: number,
    auditLogId?: number | null
  ): Promise<TransactionResult<T>> {
    const startTime = Date.now();
    const connection: PoolConnection | null = null;
    let isCommitted = false;
    let isRolledBack = false;

    try {
      // Note: MySQL connection pool disabled (using Supabase now)
      // Transaction management handled by Supabase

      // Set up timeout if specified
      let timeoutHandle: NodeJS.Timeout | null = null;
      if (options.timeout) {
        timeoutHandle = setTimeout(() => {
          throw new Error(`Transaction timeout after ${options.timeout}ms`);
        }, options.timeout);
      }

      // Ensure connection is not null before creating context
      if (!connection) {
        throw new Error('Failed to get database connection');
      }

      // Create enhanced transaction context
      const context: TransactionContext = {
        connection,
        rollback: async () => {
          if (!isRolledBack && !isCommitted) {
            // Note: Rollback disabled (MySQL legacy - using Supabase transactions)
            isRolledBack = true;
          }
        },
        commit: async () => {
          if (!isRolledBack && !isCommitted) {
            // Note: Commit disabled (MySQL legacy - using Supabase transactions)
            isCommitted = true;
          }
        },
        isActive: true,
        startTime,
        auditLogId: auditLogId || undefined,
        userId: options.userId,
        operation: options.operation
      };

      try {
        // Execute the callback
        const result = await callback(context);

        // Clear timeout
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }

        // Auto-commit if not already committed or rolled back
        if (!isCommitted && !isRolledBack) {
          // Note: Auto-commit disabled (MySQL legacy - using Supabase transactions)
          isCommitted = true;
        }

        const executionTime = Date.now() - startTime;

        return {
          success: true,
          data: result,
          executionTime
        };

      } catch (error) {
        // Clear timeout
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }

        // Auto-rollback if not already rolled back
        if (!isRolledBack && !isCommitted) {
          // Note: Auto-rollback disabled (MySQL legacy - using Supabase transactions)
          isRolledBack = true;
        }

        throw error;
      }

    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);

      console.error(`Transaction attempt ${attemptNumber} failed:`, {
        error: errorMessage,
        executionTime,
        isolationLevel: options.isolationLevel
      });

      return {
        success: false,
        error: errorMessage,
        rollbackReason: 'Exception during transaction execution',
        executionTime
      };

    } finally {
      // Note: Connection release disabled (MySQL legacy - using Supabase)
      // if (connection) {
      //   connection.release();
      // }
    }
  }

  /**
   * Check if an error should not be retried
   */
  private static isNonRetryableError(error: unknown): boolean {
    const errorMessage = String(error).toLowerCase();

    // Don't retry for validation errors, constraint violations, business logic errors
    const nonRetryablePatterns = [
      'duplicate entry',
      'foreign key constraint',
      'data too long',
      'out of range',
      'incorrect',
      'syntax error',
      'access denied',
      'table doesn\'t exist',
      'column cannot be null',
      'insufficient stock',
      'circular dependency',
      'business rule violation',
      'invalid transaction type',
      'bom relationship already exists',
      'parent item not found',
      'child item not found'
    ];

    return nonRetryablePatterns.some(pattern => errorMessage.includes(pattern));
  }

  /**
   * Validate stock availability for transaction
   */
  static async validateStock(
    connection: PoolConnection,
    itemId: number,
    requiredQuantity: number,
    transactionType: string
  ): Promise<StockValidationResult> {
    try {
      // Get current stock information
      const [stockData] = await connection.execute(
        'SELECT current_quantity as current_stock, name as item_name, safety_stock FROM current_stock WHERE id = ?',
        [itemId]
      ) as any[];

      if (!stockData || stockData.length === 0) {
        return {
          isValid: false,
          errors: ['Item not found or inactive'],
          warnings: [],
          currentStock: 0,
          requiredStock: requiredQuantity,
          availableStock: 0
        };
      }

      const stock = stockData[0];
      const currentStock = stock.current_stock || 0;
      const safetyStock = stock.safety_stock || 0;
      const availableStock = Math.max(0, currentStock - safetyStock);

      const errors: string[] = [];
      const warnings: string[] = [];

      // For outgoing transactions, check if we have enough stock
      if (['출고', 'SHIP', '생산출고', 'PRODUCTION_OUT'].includes(transactionType)) {
        if (currentStock < requiredQuantity) {
          errors.push(`Insufficient stock for ${stock.item_name}. Required: ${requiredQuantity}, Available: ${currentStock}`);
        } else if (currentStock - requiredQuantity < safetyStock) {
          warnings.push(`Transaction will reduce stock below safety level for ${stock.item_name}`);
        }
      }

      return {
        isValid: errors.length === 0,
        errors,
        warnings,
        currentStock,
        requiredStock: requiredQuantity,
        availableStock
      };

    } catch (error) {
      return {
        isValid: false,
        errors: [`Stock validation failed: ${error}`],
        warnings: [],
        currentStock: 0,
        requiredStock: requiredQuantity,
        availableStock: 0
      };
    }
  }

  /**
   * Validate BOM structure and material availability
   */
  static async validateBOM(
    connection: PoolConnection,
    parentItemId: number,
    productionQuantity: number
  ): Promise<BOMValidationResult> {
    try {
      // Get BOM structure
      const [bomData] = await connection.execute(
        `SELECT b.child_item_id, b.quantity as bom_quantity, i.name as item_name, cs.current_quantity as current_stock, i.unit_price
         FROM boms b
         JOIN items i ON b.child_item_id = i.id
         LEFT JOIN current_stock cs ON i.id = cs.id
         WHERE b.parent_item_id = ? AND b.is_active = 1 AND i.is_active = 1`,
        [parentItemId]
      ) as any[];

      if (!bomData || bomData.length === 0) {
        return {
          isValid: false,
          errors: ['No active BOM found for this item'],
          circularDependency: false,
          materialShortages: [],
          totalCost: 0
        };
      }

      const errors: string[] = [];
      const materialShortages: MaterialShortage[] = [];
      let totalCost = 0;

      // Check material availability
      for (const material of bomData) {
        const requiredQuantity = material.bom_quantity * productionQuantity;
        const currentStock = material.current_stock || 0;
        const unitPrice = material.unit_price || 0;

        totalCost += requiredQuantity * unitPrice;

        if (currentStock < requiredQuantity) {
          const shortage = requiredQuantity - currentStock;
          materialShortages.push({
            item_id: material.child_item_id,
            item_name: material.item_name,
            required: requiredQuantity,
            available: currentStock,
            shortage: shortage
          });
          errors.push(`Insufficient stock for ${material.item_name}. Required: ${requiredQuantity}, Available: ${currentStock}`);
        }
      }

      // Check for circular dependency
      const circularDependency = await this.checkCircularDependency(connection, parentItemId);

      return {
        isValid: errors.length === 0 && !circularDependency,
        errors: circularDependency ? [...errors, 'Circular dependency detected in BOM structure'] : errors,
        circularDependency,
        materialShortages,
        totalCost
      };

    } catch (error) {
      return {
        isValid: false,
        errors: [`BOM validation failed: ${error}`],
        circularDependency: false,
        materialShortages: [],
        totalCost: 0
      };
    }
  }

  /**
   * Check for circular dependencies in BOM
   */
  private static async checkCircularDependency(
    connection: PoolConnection,
    parentItemId: number,
    visited: Set<number> = new Set(),
    depth: number = 0
  ): Promise<boolean> {
    // Prevent infinite loops
    if (depth > 20) {
      return true;
    }

    if (visited.has(parentItemId)) {
      return true;
    }

    visited.add(parentItemId);

    try {
      const [children] = await connection.execute(
        'SELECT child_item_id FROM boms WHERE parent_item_id = ? AND is_active = 1',
        [parentItemId]
      ) as any[];

      for (const child of children) {
        if (await this.checkCircularDependency(connection, child.child_item_id, new Set(visited), depth + 1)) {
          return true;
        }
      }

      return false;
    } catch (error) {
      console.error('Error checking circular dependency:', error);
      return true; // Assume circular dependency on error for safety
    }
  }

  /**
   * Delay helper for retry logic
   */
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * Additional business logic validation functions
 */
export class BusinessRuleValidator {
  /**
   * Validate item transfer between locations
   */
  static async validateLocationTransfer(
    connection: PoolConnection,
    itemId: number,
    fromLocation: string,
    toLocation: string,
    quantity: number
  ): Promise<{ isValid: boolean; errors: string[]; warnings: string[] }> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Validate that locations are different
      if (fromLocation === toLocation) {
        errors.push('Source and destination locations cannot be the same');
      }

      // Check if item exists at source location with sufficient quantity
      const [locationStock] = await connection.execute(
        `SELECT SUM(
          CASE
            WHEN transaction_type IN ('입고', '생산입고') AND (to_location = ? OR to_location IS NULL) THEN quantity
            WHEN transaction_type IN ('출고', '생산출고', '폐기') AND (from_location = ? OR from_location IS NULL) THEN -quantity
            WHEN transaction_type = '이동' AND to_location = ? THEN quantity
            WHEN transaction_type = '이동' AND from_location = ? THEN -quantity
            ELSE 0
          END
        ) as location_stock
        FROM inventory_transactions
        WHERE item_id = ?`,
        [fromLocation, fromLocation, fromLocation, fromLocation, itemId]
      ) as any[];

      const locationQuantity = locationStock[0]?.location_stock || 0;
      if (locationQuantity < quantity) {
        errors.push(`Insufficient stock at location ${fromLocation}. Available: ${locationQuantity}, Required: ${quantity}`);
      }

      return { isValid: errors.length === 0, errors, warnings };
    } catch (error) {
      return {
        isValid: false,
        errors: [`Location validation failed: ${error}`],
        warnings: []
      };
    }
  }

  /**
   * Validate expiry date for items with expiration tracking
   */
  static validateExpiryDate(
    expiryDate: string | null,
    transactionType: string,
    leadTimeDays: number = 0
  ): { isValid: boolean; errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!expiryDate) {
      return { isValid: true, errors, warnings };
    }

    const expiry = new Date(expiryDate);
    const today = new Date();
    const warningThreshold = new Date();
    warningThreshold.setDate(today.getDate() + 30); // 30 days warning

    // Check if already expired
    if (expiry < today) {
      errors.push(`Item has expired on ${expiryDate}`);
    }
    // Check if expiring soon for incoming transactions
    else if (['입고', '생산입고'].includes(transactionType) && expiry < warningThreshold) {
      warnings.push(`Item will expire soon on ${expiryDate}`);
    }

    return { isValid: errors.length === 0, errors, warnings };
  }

  /**
   * Validate lot number format and uniqueness
   */
  static async validateLotNumber(
    connection: PoolConnection,
    itemId: number,
    lotNo: string | null,
    transactionType: string
  ): Promise<{ isValid: boolean; errors: string[]; warnings: string[] }> {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!lotNo) {
      return { isValid: true, errors, warnings };
    }

    try {
      // Check lot number format (example: YYYYMMDD-XXXX)
      const lotPattern = /^\d{8}-\d{4}$/;
      if (!lotPattern.test(lotNo)) {
        warnings.push(`Lot number ${lotNo} does not follow standard format (YYYYMMDD-XXXX)`);
      }

      // For incoming transactions, check if lot already exists
      if (['입고', '생산입고'].includes(transactionType)) {
        const [existingLot] = await connection.execute(
          'SELECT COUNT(*) as count FROM inventory_transactions WHERE item_id = ? AND lot_no = ?',
          [itemId, lotNo]
        ) as any[];

        if (existingLot[0]?.count > 0) {
          warnings.push(`Lot number ${lotNo} already exists for this item`);
        }
      }

      return { isValid: errors.length === 0, errors, warnings };
    } catch (error) {
      return {
        isValid: false,
        errors: [`Lot validation failed: ${error}`],
        warnings: []
      };
    }
  }
}

/**
 * Specific transaction types for ERP operations
 */
export class ERPTransactions {
  /**
   * Create inventory transaction with comprehensive validation and stock update
   */
  static async createInventoryTransaction(data: {
    item_id: number;
    transaction_type: string;
    quantity: number;
    unit_price?: number;
    company_id?: number;
    reference_no?: string;
    notes?: string;
    created_by: number;
    transaction_date?: string;
    from_location?: string;
    to_location?: string;
    lot_no?: string;
    expiry_date?: string;
  }): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Validate item exists and is active
      const [itemCheck] = await connection.execute(
        'SELECT id, name, unit FROM items WHERE id = ? AND is_active = 1',
        [data.item_id]
      ) as any[];

      if (!itemCheck || itemCheck.length === 0) {
        throw new Error('Item not found or inactive');
      }

      const item = itemCheck[0];

      // Validate transaction type
      const validTypes = ['입고', '출고', '생산입고', '생산출고', '이동', '조정', '폐기'];
      if (!validTypes.includes(data.transaction_type)) {
        throw new Error(`Invalid transaction type: ${data.transaction_type}`);
      }

      // Pre-validate stock for outgoing transactions
      if (['출고', '생산출고', '폐기'].includes(data.transaction_type)) {
        const stockValidation = await TransactionManager.validateStock(
          connection,
          data.item_id,
          data.quantity,
          data.transaction_type
        );

        if (!stockValidation.isValid) {
          throw new Error(`Business rule violation: ${stockValidation.errors.join(', ')}`);
        }

        // Log warnings
        if (stockValidation.warnings.length > 0) {
          console.warn('Stock warnings:', stockValidation.warnings);
        }
      }

      // Validate location transfer if it's a movement transaction
      if (data.transaction_type === '이동' && data.from_location && data.to_location) {
        const locationValidation = await BusinessRuleValidator.validateLocationTransfer(
          connection,
          data.item_id,
          data.from_location,
          data.to_location,
          data.quantity
        );

        if (!locationValidation.isValid) {
          throw new Error(`Location transfer validation failed: ${locationValidation.errors.join(', ')}`);
        }

        if (locationValidation.warnings.length > 0) {
          console.warn('Location transfer warnings:', locationValidation.warnings);
        }
      }

      // Validate expiry date if provided
      if (data.expiry_date) {
        const expiryValidation = BusinessRuleValidator.validateExpiryDate(
          data.expiry_date,
          data.transaction_type
        );

        if (!expiryValidation.isValid) {
          throw new Error(`Expiry date validation failed: ${expiryValidation.errors.join(', ')}`);
        }

        if (expiryValidation.warnings.length > 0) {
          console.warn('Expiry date warnings:', expiryValidation.warnings);
        }
      }

      // Validate lot number if provided
      if (data.lot_no) {
        const lotValidation = await BusinessRuleValidator.validateLotNumber(
          connection,
          data.item_id,
          data.lot_no,
          data.transaction_type
        );

        if (!lotValidation.isValid) {
          throw new Error(`Lot number validation failed: ${lotValidation.errors.join(', ')}`);
        }

        if (lotValidation.warnings.length > 0) {
          console.warn('Lot number warnings:', lotValidation.warnings);
        }
      }

      // Validate company if provided
      if (data.company_id) {
        const [companyCheck] = await connection.execute(
          'SELECT id FROM companies WHERE id = ? AND is_active = 1',
          [data.company_id]
        ) as any[];

        if (!companyCheck || companyCheck.length === 0) {
          throw new Error('Company not found or inactive');
        }
      }

      // Calculate total amount
      const total_amount = data.quantity * (data.unit_price || 0);

      // Insert inventory transaction with correct field names
      const [insertResult] = await connection.execute(
        `INSERT INTO inventory_transactions (
          transaction_date, transaction_type, item_id, quantity,
          unit_price, total_amount, company_id, reference_no,
          from_location, to_location, lot_no, expiry_date,
          notes, created_by, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
        [
          data.transaction_date || new Date().toISOString().split('T')[0],
          data.transaction_type,
          data.item_id,
          data.quantity,
          data.unit_price || 0,
          total_amount,
          data.company_id || null,
          data.reference_no || null,
          data.from_location || null,
          data.to_location || null,
          data.lot_no || null,
          data.expiry_date || null,
          data.notes || null,
          data.created_by
        ]
      );

      const transactionId = (insertResult as any).insertId;

      // Note: Stock is managed by the current_stock view, not directly updating items table
      // The view automatically calculates current stock from inventory_transactions

      // Get updated stock information
      const [stockInfo] = await connection.execute(
        'SELECT current_quantity, stock_status FROM current_stock WHERE id = ?',
        [data.item_id]
      ) as any[];

      const newStock = stockInfo[0]?.current_quantity || 0;
      const stockStatus = stockInfo[0]?.stock_status || '알수없음';

      return {
        transaction_id: transactionId,
        item_name: item.name,
        transaction_type: data.transaction_type,
        quantity: data.quantity,
        unit_price: data.unit_price || 0,
        total_amount,
        new_stock: newStock,
        stock_status: stockStatus
      };
    }, {
      enableAuditLog: true,
      userId: data.created_by,
      operation: 'CREATE_INVENTORY_TRANSACTION'
    });
  }

  /**
   * Update inventory transaction with comprehensive validation and stock adjustment
   */
  static async updateInventoryTransaction(
    transaction_id: number,
    updateData: any,
    user_id: number
  ): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Get current transaction data
      const [currentData] = await connection.execute(
        'SELECT * FROM inventory_transactions WHERE id = ?',
        [transaction_id]
      ) as any[];

      if (!currentData || currentData.length === 0) {
        throw new Error('Transaction not found');
      }

      const current = currentData[0];

      // Store original values for audit trail
      const originalValues = { ...current };

      // Validate that quantity/type changes won't cause business rule violations
      if (updateData.quantity !== undefined || updateData.transaction_type !== undefined) {
        const newQuantity = updateData.quantity ?? current.quantity;
        const newType = updateData.transaction_type ?? current.transaction_type;

        // For outgoing transactions, validate stock availability
        if (['출고', '생산출고', '폐기'].includes(newType)) {
          // Get current stock before this transaction
          const [stockBeforeUpdate] = await connection.execute(
            'SELECT current_quantity FROM current_stock WHERE id = ?',
            [current.item_id]
          ) as any[];

          const currentStock = stockBeforeUpdate[0]?.current_quantity || 0;

          // Calculate what the stock would be without the original transaction
          let stockWithoutOriginal = currentStock;
          if (['입고', '생산입고'].includes(current.transaction_type)) {
            stockWithoutOriginal -= current.quantity;
          } else if (['출고', '생산출고', '폐기'].includes(current.transaction_type)) {
            stockWithoutOriginal += current.quantity;
          }

          // Check if the new transaction would be valid
          if (['출고', '생산출고', '폐기'].includes(newType) && stockWithoutOriginal < newQuantity) {
            throw new Error(`Insufficient stock for updated transaction. Available: ${stockWithoutOriginal}, Required: ${newQuantity}`);
          }
        }
      }

      // Calculate total amount if price or quantity changed
      if (updateData.quantity !== undefined || updateData.unit_price !== undefined) {
        const quantity = updateData.quantity ?? current.quantity;
        const unit_price = updateData.unit_price ?? current.unit_price;
        updateData.total_amount = quantity * unit_price;
      }

      // Add updated_at timestamp
      updateData.updated_at = new Date();

      // Build dynamic update query
      const updateFields = Object.keys(updateData)
        .filter(key => key !== 'id') // Don't update ID
        .map(key => `${key} = ?`)
        .join(', ');

      const updateValues = Object.keys(updateData)
        .filter(key => key !== 'id')
        .map(key => updateData[key]);

      await connection.execute(
        `UPDATE inventory_transactions SET ${updateFields} WHERE id = ?`,
        [...updateValues, transaction_id]
      );

      // Get updated stock information (automatically calculated by view)
      const [stockInfo] = await connection.execute(
        'SELECT current_quantity, stock_status FROM current_stock WHERE id = ?',
        [current.item_id]
      ) as any[];

      const newStock = stockInfo[0]?.current_quantity || 0;
      const stockStatus = stockInfo[0]?.stock_status || '알수없음';

      return {
        transaction_id,
        updated_fields: Object.keys(updateData).filter(key => key !== 'updated_at'),
        original_values: originalValues,
        new_stock: newStock,
        stock_status: stockStatus
      };
    }, {
      enableAuditLog: true,
      userId: user_id,
      operation: 'UPDATE_INVENTORY_TRANSACTION'
    });
  }

  /**
   * Delete inventory transaction with comprehensive validation and stock reversal
   */
  static async deleteInventoryTransaction(
    transaction_id: number,
    user_id: number
  ): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Get transaction data before deletion
      const [transactionData] = await connection.execute(
        'SELECT * FROM inventory_transactions WHERE id = ?',
        [transaction_id]
      ) as any[];

      if (!transactionData || transactionData.length === 0) {
        throw new Error('Transaction not found');
      }

      const transaction = transactionData[0];

      // Store original transaction for audit trail
      const originalTransaction = { ...transaction };

      // Business rule: Check if deleting this transaction would cause negative stock
      const [currentStockData] = await connection.execute(
        'SELECT current_quantity FROM current_stock WHERE id = ?',
        [transaction.item_id]
      ) as any[];

      const currentStock = currentStockData[0]?.current_quantity || 0;

      // Calculate what stock would be after deletion
      let stockAfterDeletion = currentStock;
      if (['입고', '생산입고'].includes(transaction.transaction_type)) {
        stockAfterDeletion -= transaction.quantity; // Removing an incoming transaction decreases stock
      } else if (['출고', '생산출고', '폐기'].includes(transaction.transaction_type)) {
        stockAfterDeletion += transaction.quantity; // Removing an outgoing transaction increases stock
      }

      if (stockAfterDeletion < 0) {
        throw new Error(`Cannot delete transaction: would result in negative stock (${stockAfterDeletion})`);
      }

      // Check if this transaction is referenced by other transactions
      const [referencedTransactions] = await connection.execute(
        'SELECT COUNT(*) as count FROM inventory_transactions WHERE reference_no = ? AND id != ?',
        [transaction.reference_no, transaction_id]
      ) as any[];

      if (referencedTransactions[0]?.count > 0 && transaction.reference_no) {
        console.warn(`Warning: Deleting transaction that is part of a group (reference: ${transaction.reference_no})`);
      }

      // Delete the transaction (stock will be automatically recalculated by the view)
      const [deleteResult] = await connection.execute(
        'DELETE FROM inventory_transactions WHERE id = ?',
        [transaction_id]
      );

      if ((deleteResult as any).affectedRows === 0) {
        throw new Error('Failed to delete transaction');
      }

      // Get updated stock information
      const [newStockData] = await connection.execute(
        'SELECT current_quantity, stock_status FROM current_stock WHERE id = ?',
        [transaction.item_id]
      ) as any[];

      const newStock = newStockData[0]?.current_quantity || 0;
      const stockStatus = newStockData[0]?.stock_status || '알수없음';

      return {
        deleted_transaction_id: transaction_id,
        original_transaction: originalTransaction,
        new_stock: newStock,
        stock_status: stockStatus,
        stock_change: newStock - currentStock
      };
    }, {
      enableAuditLog: true,
      userId: user_id,
      operation: 'DELETE_INVENTORY_TRANSACTION'
    });
  }

  /**
   * Create BOM with validation
   */
  static async createBOM(data: {
    parent_item_id: number;
    child_item_id: number;
    quantity: number;
    notes?: string;
    user_id: number;
  }): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Validate parent and child items exist
      const [parentCheck] = await connection.execute(
        'SELECT id, name FROM items WHERE id = ? AND is_active = 1',
        [data.parent_item_id]
      ) as any[];

      const [childCheck] = await connection.execute(
        'SELECT id, name FROM items WHERE id = ? AND is_active = 1',
        [data.child_item_id]
      ) as any[];

      if (!parentCheck || parentCheck.length === 0) {
        throw new Error('Parent item not found or inactive');
      }

      if (!childCheck || childCheck.length === 0) {
        throw new Error('Child item not found or inactive');
      }

      // Check for circular dependency
      const [circularCheck] = await connection.execute(
        `WITH RECURSIVE bom_tree AS (
          SELECT child_item_id, parent_item_id, 1 as level
          FROM boms
          WHERE parent_item_id = ? AND is_active = 1

          UNION ALL

          SELECT b.child_item_id, b.parent_item_id, bt.level + 1
          FROM boms b
          INNER JOIN bom_tree bt ON b.parent_item_id = bt.child_item_id
          WHERE bt.level < 10 AND b.is_active = 1
        )
        SELECT 1 FROM bom_tree WHERE child_item_id = ?`,
        [data.child_item_id, data.parent_item_id]
      ) as any[];

      if (circularCheck && circularCheck.length > 0) {
        throw new Error('Circular dependency detected in BOM structure');
      }

      // Check for duplicate BOM entry
      const [duplicateCheck] = await connection.execute(
        'SELECT id FROM boms WHERE parent_item_id = ? AND child_item_id = ? AND is_active = 1',
        [data.parent_item_id, data.child_item_id]
      ) as any[];

      if (duplicateCheck && duplicateCheck.length > 0) {
        throw new Error('BOM relationship already exists');
      }

      // Insert BOM record
      const [insertResult] = await connection.execute(
        `INSERT INTO boms (parent_item_id, child_item_id, quantity, notes, is_active, created_by, created_at, updated_at)
         VALUES (?, ?, ?, ?, 1, ?, NOW(), NOW())`,
        [data.parent_item_id, data.child_item_id, data.quantity, data.notes, data.user_id]
      );

      return {
        bom_id: (insertResult as any).insertId,
        parent_item: parentCheck[0].name,
        child_item: childCheck[0].name,
        quantity: data.quantity
      };
    }, {
      enableAuditLog: true,
      userId: data.user_id,
      operation: 'CREATE_BOM'
    });
  }

  /**
   * Bulk create multiple inventory transactions atomically
   */
  static async createBulkInventoryTransactions(
    transactions: Array<{
      item_id: number;
      transaction_type: string;
      quantity: number;
      unit_price?: number;
      company_id?: number;
      reference_no?: string;
      notes?: string;
      from_location?: string;
      to_location?: string;
      lot_no?: string;
      expiry_date?: string;
    }>,
    user_id: number
  ): Promise<TransactionResult<any[]>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;
      const results = [];

      for (const txData of transactions) {
        // Use the same validation logic as single transaction
        const result = await ERPTransactions.createInventoryTransaction({
          ...txData,
          created_by: user_id
        });

        if (!result.success) {
          throw new Error(`Failed to create transaction for item ${txData.item_id}: ${result.error}`);
        }

        results.push(result.data);
      }

      return results;
    }, {
      enableAuditLog: true,
      userId: user_id,
      operation: 'CREATE_BULK_INVENTORY_TRANSACTIONS'
    });
  }

  /**
   * Stock adjustment transaction with comprehensive audit trail
   */
  static async createStockAdjustment(data: {
    item_id: number;
    adjustment_quantity: number; // Can be positive or negative
    reason: string;
    reference_no?: string;
    notes?: string;
    user_id: number;
  }): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Get current stock
      const [currentStockData] = await connection.execute(
        'SELECT current_quantity, name FROM current_stock WHERE id = ?',
        [data.item_id]
      ) as any[];

      if (!currentStockData || currentStockData.length === 0) {
        throw new Error('Item not found');
      }

      const currentStock = currentStockData[0].current_quantity || 0;
      const itemName = currentStockData[0].name;
      const newStock = currentStock + data.adjustment_quantity;

      // Prevent negative stock unless explicitly allowed
      if (newStock < 0) {
        throw new Error(`Stock adjustment would result in negative stock. Current: ${currentStock}, Adjustment: ${data.adjustment_quantity}`);
      }

      // Create adjustment transaction
      const [insertResult] = await connection.execute(
        `INSERT INTO inventory_transactions (
          transaction_date, transaction_type, item_id, quantity,
          unit_price, total_amount, reference_no, notes, created_by
        ) VALUES (CURDATE(), '조정', ?, ?, 0, 0, ?, ?, ?)`,
        [
          data.item_id,
          data.adjustment_quantity,
          data.reference_no || `ADJ-${Date.now()}`,
          `${data.reason}: ${data.notes || ''}`,
          data.user_id
        ]
      );

      return {
        transaction_id: (insertResult as any).insertId,
        item_name: itemName,
        previous_stock: currentStock,
        adjustment_quantity: data.adjustment_quantity,
        new_stock: newStock,
        reason: data.reason
      };
    }, {
      enableAuditLog: true,
      userId: data.user_id,
      operation: 'CREATE_STOCK_ADJUSTMENT'
    });
  }

  /**
   * Production transaction with BOM consumption
   */
  static async createProductionTransaction(data: {
    parent_item_id: number;
    production_quantity: number;
    reference_id?: string;
    note?: string;
    user_id: number;
  }): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Get BOM for the parent item
      const [bomData] = await connection.execute(
        `SELECT b.child_item_id, b.quantity, i.name as item_name, cs.current_quantity as current_stock
         FROM boms b
         JOIN items i ON b.child_item_id = i.id
         LEFT JOIN current_stock cs ON i.id = cs.id
         WHERE b.parent_item_id = ? AND b.is_active = 1 AND i.is_active = 1`,
        [data.parent_item_id]
      ) as any[];

      if (!bomData || bomData.length === 0) {
        throw new Error('No active BOM found for this item');
      }

      // Check if we have enough materials
      for (const material of bomData) {
        const requiredQuantity = material.quantity * data.production_quantity;
        if (material.current_stock < requiredQuantity) {
          throw new Error(`Insufficient stock for ${material.item_name}. Required: ${requiredQuantity}, Available: ${material.current_stock}`);
        }
      }

      // Create production transaction (increases finished goods stock)
      const [productionResult] = await connection.execute(
        `INSERT INTO inventory_transactions (
          transaction_date, transaction_type, item_id, quantity,
          unit_price, total_amount, reference_no, notes, created_by
        ) VALUES (CURDATE(), '생산입고', ?, ?, 0, 0, ?, ?, ?)`,
        [data.parent_item_id, data.production_quantity, data.reference_id, data.note, data.user_id]
      );

      // Consume materials
      const consumedMaterials = [];
      for (const material of bomData) {
        const consumedQuantity = material.quantity * data.production_quantity;

        // Create consumption transaction
        await connection.execute(
          `INSERT INTO inventory_transactions (
            transaction_date, transaction_type, item_id, quantity,
            unit_price, total_amount, reference_no, notes, created_by
          ) VALUES (CURDATE(), '생산출고', ?, ?, 0, 0, ?, ?, ?)`,
          [material.child_item_id, consumedQuantity, data.reference_id,
           `Production consumption for ${data.reference_id}`, data.user_id]
        );

        consumedMaterials.push({
          item_id: material.child_item_id,
          item_name: material.item_name,
          consumed_quantity: consumedQuantity,
          remaining_stock: material.current_stock - consumedQuantity
        });
      }

      return {
        production_transaction_id: (productionResult as any).insertId,
        produced_quantity: data.production_quantity,
        consumed_materials: consumedMaterials
      };
    }, {
      enableAuditLog: true,
      userId: data.user_id,
      operation: 'CREATE_PRODUCTION_TRANSACTION'
    });
  }

  /**
   * Create scrap transaction with detailed tracking
   */
  static async createScrapTransaction(data: {
    item_id: number;
    quantity: number;
    reason: '불량' | '파손' | '유효기간만료' | '기타';
    description?: string;
    disposal_method?: '폐기' | '반품' | '재활용' | '기타';
    cost_amount?: number;
    reference_no?: string;
    user_id: number;
  }): Promise<TransactionResult<any>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;

      // Validate stock availability
      const stockValidation = await TransactionManager.validateStock(
        connection,
        data.item_id,
        data.quantity,
        '폐기'
      );

      if (!stockValidation.isValid) {
        throw new Error(`Insufficient stock for scrap: ${stockValidation.errors.join(', ')}`);
      }

      // Create scrap record
      const [scrapResult] = await connection.execute(
        `INSERT INTO scraps (
          scrap_date, item_id, quantity, reason, description,
          disposal_method, cost_amount, reference_no, created_by
        ) VALUES (CURDATE(), ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          data.item_id,
          data.quantity,
          data.reason,
          data.description || null,
          data.disposal_method || null,
          data.cost_amount || 0,
          data.reference_no || `SCRAP-${Date.now()}`,
          data.user_id
        ]
      );

      // Create inventory transaction for stock reduction
      const [inventoryResult] = await connection.execute(
        `INSERT INTO inventory_transactions (
          transaction_date, transaction_type, item_id, quantity,
          unit_price, total_amount, reference_no, notes, created_by
        ) VALUES (CURDATE(), '폐기', ?, ?, 0, 0, ?, ?, ?)`,
        [
          data.item_id,
          data.quantity,
          data.reference_no || `SCRAP-${Date.now()}`,
          `Scrap - ${data.reason}: ${data.description || ''}`,
          data.user_id
        ]
      );

      // Get updated stock
      const [stockInfo] = await connection.execute(
        'SELECT current_quantity, stock_status FROM current_stock WHERE id = ?',
        [data.item_id]
      ) as any[];

      return {
        scrap_id: (scrapResult as any).insertId,
        inventory_transaction_id: (inventoryResult as any).insertId,
        scrapped_quantity: data.quantity,
        reason: data.reason,
        new_stock: stockInfo[0]?.current_quantity || 0,
        stock_status: stockInfo[0]?.stock_status || '알수없음'
      };
    }, {
      enableAuditLog: true,
      userId: data.user_id,
      operation: 'CREATE_SCRAP_TRANSACTION'
    });
  }

  /**
   * Complex multi-location inventory transfer
   */
  static async createMultiLocationTransfer(data: {
    transfers: Array<{
      item_id: number;
      quantity: number;
      from_location: string;
      to_location: string;
      lot_no?: string;
      notes?: string;
    }>;
    reference_no?: string;
    user_id: number;
  }): Promise<TransactionResult<any[]>> {
    return TransactionManager.execute(async (context) => {
      const { connection } = context;
      const results = [];

      for (const transfer of data.transfers) {
        // Validate location transfer
        const locationValidation = await BusinessRuleValidator.validateLocationTransfer(
          connection,
          transfer.item_id,
          transfer.from_location,
          transfer.to_location,
          transfer.quantity
        );

        if (!locationValidation.isValid) {
          throw new Error(`Location transfer failed for item ${transfer.item_id}: ${locationValidation.errors.join(', ')}`);
        }

        // Create movement transaction
        const [moveResult] = await connection.execute(
          `INSERT INTO inventory_transactions (
            transaction_date, transaction_type, item_id, quantity,
            unit_price, total_amount, from_location, to_location,
            lot_no, reference_no, notes, created_by
          ) VALUES (CURDATE(), '이동', ?, ?, 0, 0, ?, ?, ?, ?, ?, ?)`,
          [
            transfer.item_id,
            transfer.quantity,
            transfer.from_location,
            transfer.to_location,
            transfer.lot_no || null,
            data.reference_no || `MOVE-${Date.now()}`,
            transfer.notes || `Transfer from ${transfer.from_location} to ${transfer.to_location}`,
            data.user_id
          ]
        );

        results.push({
          transaction_id: (moveResult as any).insertId,
          item_id: transfer.item_id,
          quantity: transfer.quantity,
          from_location: transfer.from_location,
          to_location: transfer.to_location
        });
      }

      return results;
    }, {
      enableAuditLog: true,
      userId: data.user_id,
      operation: 'CREATE_MULTI_LOCATION_TRANSFER'
    });
  }
}

/**
 * Advanced stock analysis and reporting functions
 */
export class StockAnalyzer {
  /**
   * Get stock turnover analysis
   */
  static async getStockTurnoverAnalysis(
    connection: PoolConnection,
    itemId?: number,
    startDate?: string,
    endDate?: string
  ): Promise<any[]> {
    const dateFilter = startDate && endDate
      ? 'AND it.transaction_date BETWEEN ? AND ?'
      : '';
    const itemFilter = itemId ? 'AND i.id = ?' : '';

    const params = [];
    if (startDate && endDate) {
      params.push(startDate, endDate);
    }
    if (itemId) {
      params.push(itemId);
    }

    const [results] = await connection.execute(
      `SELECT
        i.id as item_id,
        i.name as item_name,
        i.category,
        cs.current_quantity,
        COALESCE(SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END), 0) as total_outgoing,
        COALESCE(SUM(CASE WHEN it.transaction_type IN ('입고', '생산입고') THEN it.quantity ELSE 0 END), 0) as total_incoming,
        CASE
          WHEN cs.current_quantity > 0 AND SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END) > 0
          THEN SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END) / cs.current_quantity
          ELSE 0
        END as turnover_ratio
      FROM items i
      LEFT JOIN current_stock cs ON i.id = cs.id
      LEFT JOIN inventory_transactions it ON i.id = it.item_id ${dateFilter}
      WHERE i.is_active = 1 ${itemFilter}
      GROUP BY i.id, i.name, i.category, cs.current_quantity
      ORDER BY turnover_ratio DESC`,
      params
    ) as any[];

    return results;
  }

  /**
   * Get ABC analysis based on value and movement
   */
  static async getABCAnalysis(
    connection: PoolConnection,
    analysisType: 'value' | 'movement' | 'combined' = 'combined'
  ): Promise<any[]> {
    const [results] = await connection.execute(
      `SELECT
        i.id as item_id,
        i.name as item_name,
        i.category,
        cs.current_quantity,
        i.unit_price,
        (cs.current_quantity * i.unit_price) as stock_value,
        COALESCE(SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END), 0) as total_movement,
        (cs.current_quantity * i.unit_price) + COALESCE(SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END), 0) as combined_score
      FROM items i
      LEFT JOIN current_stock cs ON i.id = cs.id
      LEFT JOIN inventory_transactions it ON i.id = it.item_id
        AND it.transaction_date >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH)
      WHERE i.is_active = 1
      GROUP BY i.id, i.name, i.category, cs.current_quantity, i.unit_price
      ORDER BY
        CASE
          WHEN ? = 'value' THEN (cs.current_quantity * i.unit_price)
          WHEN ? = 'movement' THEN COALESCE(SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END), 0)
          ELSE (cs.current_quantity * i.unit_price) + COALESCE(SUM(CASE WHEN it.transaction_type IN ('출고', '생산출고') THEN it.quantity ELSE 0 END), 0)
        END DESC`,
      [analysisType, analysisType]
    ) as any[];

    // Add ABC classification with proper type assertions
    const totalValue = results.reduce((sum: number, item: unknown) => {
      const itemData = item as Record<string, any>;
      const value = analysisType === 'value' ? (itemData.stock_value || 0) :
                   analysisType === 'movement' ? (itemData.total_movement || 0) :
                   (itemData.combined_score || 0);
      return sum + value;
    }, 0);

    let cumulativeValue = 0;
    return results.map((item: unknown) => {
      const itemData = item as Record<string, any>;
      const value = analysisType === 'value' ? (itemData.stock_value || 0) :
                   analysisType === 'movement' ? (itemData.total_movement || 0) :
                   (itemData.combined_score || 0);
      cumulativeValue += value;
      const percentage = (cumulativeValue / totalValue) * 100;

      let classification = 'C';
      if (percentage <= 80) classification = 'A';
      else if (percentage <= 95) classification = 'B';

      return {
        ...itemData,
        abc_classification: classification,
        cumulative_percentage: percentage.toFixed(2)
      };
    });
  }
}

/**
 * Legacy transaction function for backward compatibility
 */
export async function transaction<T = any>(
  callback: (connection: PoolConnection) => Promise<T>
): Promise<T> {
  const result = await TransactionManager.execute(async (context) => {
    return await callback(context.connection);
  });

  if (result.success) {
    return result.data!;
  } else {
    throw new Error(result.error);
  }
}
```


#### 📄 src\lib\validation.ts

```typescript
/**
 * Zod validation schemas for ERP system
 * Comprehensive input validation for all API endpoints
 */
import { z } from 'zod';

// Common validation patterns
const koreanTextPattern = /^[\uac00-\ud7af\u1100-\u11ff\u3130-\u318f\ua960-\ua97f\uac00-\ud7af0-9a-zA-Z\s\-_.()]+$/;
const englishTextPattern = /^[a-zA-Z0-9\s\-_.()]+$/;
const mixedTextPattern = /^[\uac00-\ud7af\u1100-\u11ff\u3130-\u318f\ua960-\ua97f\uac00-\ud7af0-9a-zA-Z\s\-_.()]+$/;

// Base schemas for common types
export const IdSchema = z.number().int().positive();
export const PositiveNumberSchema = z.number().positive();
export const NonNegativeNumberSchema = z.number().min(0);
export const KoreanTextSchema = z.string().min(1).max(255).regex(koreanTextPattern, '한글, 영문, 숫자만 입력 가능합니다');
export const EnglishTextSchema = z.string().min(1).max(255).regex(englishTextPattern, '영문, 숫자만 입력 가능합니다');
export const MixedTextSchema = z.string().min(1).max(255).regex(mixedTextPattern, '한글, 영문, 숫자만 입력 가능합니다');
export const OptionalTextSchema = z.string().max(500).optional();

// Common enum schemas
export const ItemStatusSchema = z.enum(['ACTIVE', 'INACTIVE', 'DISCONTINUED']);
export const CompanyTypeSchema = z.enum(['CUSTOMER', 'SUPPLIER', 'BOTH', '고객사', '공급사', '양방향']);
export const TransactionTypeSchema = z.enum(['입고', '생산', '출고', 'RECEIVE', 'PRODUCTION', 'SHIP']);
export const UserRoleSchema = z.enum(['admin', 'manager', 'operator', 'viewer']);

// Item validation schemas (matching actual database schema)
export const ItemCreateSchema = z.object({
  item_code: EnglishTextSchema.max(50),
  item_name: KoreanTextSchema,
  item_type: z.string().max(50).optional(),
  car_model: z.string().max(100).optional(),
  spec: MixedTextSchema.optional(),
  unit: KoreanTextSchema.max(20),
  current_stock: NonNegativeNumberSchema.default(0),
  min_stock_level: NonNegativeNumberSchema.optional(),
  safety_stock: NonNegativeNumberSchema.optional(),
  unit_price: PositiveNumberSchema.optional(),
  location: OptionalTextSchema,
  description: OptionalTextSchema
});

export const ItemUpdateSchema = ItemCreateSchema.partial().extend({
  id: IdSchema  // Using 'id' as expected by the API
});

export const ItemQuerySchema = z.object({
  type: z.string().max(50).optional(),
  search: z.string().max(255).optional(),
  with_stock: z.enum(['true', 'false']).optional()
});

export const ItemDeleteSchema = z.object({
  id: IdSchema
});

// Company validation schemas
export const CompanyCreateSchema = z.object({
  company_name: KoreanTextSchema,
  company_type: CompanyTypeSchema,
  business_number: z.string().regex(/^\d{3}-\d{2}-\d{5}$/, '사업자번호 형식: 000-00-00000').optional(),
  contact_person: KoreanTextSchema.optional(),
  phone: z.string().regex(/^[\d\-+().\s]+$/, '올바른 전화번호 형식을 입력하세요').optional(),
  email: z.string().email('올바른 이메일 형식을 입력하세요').optional(),
  address: OptionalTextSchema,
  notes: OptionalTextSchema
});

export const CompanyUpdateSchema = CompanyCreateSchema.partial().extend({
  company_id: IdSchema
});

export const CompanyQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  search: z.string().max(255).optional(),
  company_type: CompanyTypeSchema.optional()
});

// BOM validation schemas
export const BOMCreateSchema = z.object({
  parent_item_id: IdSchema,
  child_item_id: IdSchema,
  quantity: PositiveNumberSchema,
  notes: OptionalTextSchema
}).refine((data) => data.parent_item_id !== data.child_item_id, {
  message: '부모 항목과 자식 항목이 같을 수 없습니다',
  path: ['child_item_id']
});

export const BOMUpdateSchema = BOMCreateSchema.partial().extend({
  bom_id: IdSchema
});

export const BOMQuerySchema = z.object({
  parent_item_id: IdSchema.optional(),
  child_item_id: IdSchema.optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20)
});

// Inventory transaction validation schemas
export const InventoryTransactionCreateSchema = z.object({
  item_id: IdSchema,
  transaction_type: TransactionTypeSchema,
  quantity: PositiveNumberSchema,
  unit_cost: PositiveNumberSchema.optional(),
  total_cost: PositiveNumberSchema.optional(),
  company_id: IdSchema.optional(),
  reference_number: z.string().max(50).optional(),
  notes: OptionalTextSchema
}).refine((data) => {
  // For receive transactions, company_id should be provided
  if (data.transaction_type === '입고' || data.transaction_type === 'RECEIVE') {
    return data.company_id !== undefined;
  }
  return true;
}, {
  message: '입고 거래에는 회사 정보가 필요합니다',
  path: ['company_id']
}).refine((data) => {
  // If unit_cost is provided, total_cost should match or be calculated
  if (data.unit_cost && data.total_cost) {
    return Math.abs(data.total_cost - (data.unit_cost * data.quantity)) < 0.01;
  }
  return true;
}, {
  message: '총 비용이 단가 × 수량과 일치하지 않습니다',
  path: ['total_cost']
});

export const InventoryTransactionUpdateSchema = InventoryTransactionCreateSchema.partial().extend({
  transaction_id: IdSchema
});

export const InventoryTransactionQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  item_id: IdSchema.optional(),
  transaction_type: TransactionTypeSchema.optional(),
  company_id: IdSchema.optional(),
  start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional(),
  end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional(),
  reference_number: z.string().max(50).optional()
});

// Stock adjustment validation schemas
export const StockAdjustmentCreateSchema = z.object({
  item_id: IdSchema,
  adjustment_type: z.enum(['INCREASE', 'DECREASE', 'SET']),
  quantity: PositiveNumberSchema,
  reason: z.enum(['DAMAGED', 'LOST', 'FOUND', 'COUNT_CORRECTION', 'OTHER']),
  notes: OptionalTextSchema
});

export const StockAdjustmentQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  item_id: IdSchema.optional(),
  adjustment_type: z.enum(['INCREASE', 'DECREASE', 'SET']).optional(),
  reason: z.enum(['DAMAGED', 'LOST', 'FOUND', 'COUNT_CORRECTION', 'OTHER']).optional(),
  start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional(),
  end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional()
});

// User validation schemas
export const UserCreateSchema = z.object({
  username: EnglishTextSchema.min(3).max(50),
  password: z.string().min(8).max(128),
  name: KoreanTextSchema.max(100),
  email: z.string().email('올바른 이메일 형식을 입력하세요').optional(),
  department: KoreanTextSchema.max(100).optional(),
  role: UserRoleSchema
});

export const UserUpdateSchema = UserCreateSchema.partial().extend({
  user_id: IdSchema
}).omit({ password: true });

export const UserPasswordUpdateSchema = z.object({
  user_id: IdSchema,
  current_password: z.string().min(1),
  new_password: z.string().min(8).max(128)
});

export const UserQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  search: z.string().max(255).optional(),
  role: UserRoleSchema.optional(),
  is_active: z.coerce.boolean().optional()
});

// Authentication validation schemas
export const LoginSchema = z.object({
  username: z.string().min(1).max(50),
  password: z.string().min(1).max(128)
});

export const TokenRefreshSchema = z.object({
  refresh_token: z.string().min(1)
});

// Dashboard and reporting schemas
export const DashboardQuerySchema = z.object({
  start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional(),
  end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'YYYY-MM-DD 형식').optional(),
  period: z.enum(['today', 'week', 'month', 'quarter', 'year']).optional()
});

// Bulk operation schemas
export const BulkDeleteSchema = z.object({
  ids: z.array(IdSchema).min(1).max(100)
});

export const BulkUpdateSchema = z.object({
  updates: z.array(z.object({
    id: IdSchema,
    data: z.record(z.string(), z.any())
  })).min(1).max(100)
});

// Excel import validation schemas
export const ExcelImportSchema = z.object({
  file_type: z.enum(['items', 'companies', 'inventory']),
  overwrite_existing: z.boolean().default(false),
  validate_only: z.boolean().default(false)
});

// File upload validation schemas
export const FileUploadSchema = z.object({
  file_size: z.number().max(10 * 1024 * 1024, '파일 크기는 10MB 이하여야 합니다'),
  file_type: z.enum(['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel']),
  file_name: z.string().max(255)
});

// Export schemas for easy access
export type ItemCreate = z.infer<typeof ItemCreateSchema>;
export type ItemUpdate = z.infer<typeof ItemUpdateSchema>;
export type ItemQuery = z.infer<typeof ItemQuerySchema>;
export type CompanyCreate = z.infer<typeof CompanyCreateSchema>;
export type CompanyUpdate = z.infer<typeof CompanyUpdateSchema>;
export type CompanyQuery = z.infer<typeof CompanyQuerySchema>;
export type BOMCreate = z.infer<typeof BOMCreateSchema>;
export type BOMUpdate = z.infer<typeof BOMUpdateSchema>;
export type BOMQuery = z.infer<typeof BOMQuerySchema>;
export type InventoryTransactionCreate = z.infer<typeof InventoryTransactionCreateSchema>;
export type InventoryTransactionUpdate = z.infer<typeof InventoryTransactionUpdateSchema>;
export type InventoryTransactionQuery = z.infer<typeof InventoryTransactionQuerySchema>;
export type StockAdjustmentCreate = z.infer<typeof StockAdjustmentCreateSchema>;
export type StockAdjustmentQuery = z.infer<typeof StockAdjustmentQuerySchema>;
export type UserCreate = z.infer<typeof UserCreateSchema>;
export type UserUpdate = z.infer<typeof UserUpdateSchema>;
export type UserPasswordUpdate = z.infer<typeof UserPasswordUpdateSchema>;
export type UserQuery = z.infer<typeof UserQuerySchema>;
export type Login = z.infer<typeof LoginSchema>;
export type TokenRefresh = z.infer<typeof TokenRefreshSchema>;
export type DashboardQuery = z.infer<typeof DashboardQuerySchema>;
export type BulkDelete = z.infer<typeof BulkDeleteSchema>;
export type BulkUpdate = z.infer<typeof BulkUpdateSchema>;
export type ExcelImport = z.infer<typeof ExcelImportSchema>;
export type FileUpload = z.infer<typeof FileUploadSchema>;
```


#### 📄 src\lib\validationMiddleware.ts

```typescript
/**
 * Validation middleware for API routes
 * Integrates Zod validation with Next.js API routes and authentication
 */
import { NextRequest, NextResponse } from 'next/server';
import { z, ZodSchema } from 'zod';
import { User, UserRole } from '@/types/auth';

export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface ValidationResult<T> {
  success: boolean;
  data?: T;
  errors?: ValidationError[];
}

/**
 * Parse and validate request body with Zod schema
 */
export async function validateRequestBody<T>(
  request: NextRequest,
  schema: ZodSchema<T>
): Promise<ValidationResult<T>> {
  try {
    // Use request.text() + JSON.parse() for proper Korean character handling
    const textBody = await request.text();
    const jsonBody = textBody ? JSON.parse(textBody) : {};

    const result = schema.safeParse(jsonBody);

    if (result.success) {
      return {
        success: true,
        data: result.data
      };
    } else {
      const errors: ValidationError[] = result.error.issues.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code
      }));

      return {
        success: false,
        errors
      };
    }
  } catch (error) {
    return {
      success: false,
      errors: [{
        field: 'body',
        message: error instanceof Error ? error.message : 'Invalid JSON format',
        code: 'invalid_json'
      }]
    };
  }
}

/**
 * Validate URL search parameters with Zod schema
 */
export function validateSearchParams<T>(
  request: NextRequest,
  schema: ZodSchema<T>
): ValidationResult<T> {
  try {
    const { searchParams } = new URL(request.url);
    const params: Record<string, any> = {};

    // Convert URLSearchParams to plain object
    for (const [key, value] of searchParams.entries()) {
      params[key] = value;
    }

    const result = schema.safeParse(params);

    if (result.success) {
      return {
        success: true,
        data: result.data
      };
    } else {
      const errors: ValidationError[] = result.error.issues.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code
      }));

      return {
        success: false,
        errors
      };
    }
  } catch (error) {
    return {
      success: false,
      errors: [{
        field: 'searchParams',
        message: error instanceof Error ? error.message : 'Invalid search parameters',
        code: 'invalid_params'
      }]
    };
  }
}

/**
 * Validate dynamic route parameters with Zod schema
 */
export function validateRouteParams<T>(
  params: Record<string, string>,
  schema: ZodSchema<T>
): ValidationResult<T> {
  try {
    // Convert string values to appropriate types for validation
    const processedParams: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      // Try to convert to number if it looks like a number
      if (/^\d+$/.test(value)) {
        processedParams[key] = parseInt(value, 10);
      } else {
        processedParams[key] = value;
      }
    }

    const result = schema.safeParse(processedParams);

    if (result.success) {
      return {
        success: true,
        data: result.data
      };
    } else {
      const errors: ValidationError[] = result.error.issues.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code
      }));

      return {
        success: false,
        errors
      };
    }
  } catch (error) {
    return {
      success: false,
      errors: [{
        field: 'routeParams',
        message: error instanceof Error ? error.message : 'Invalid route parameters',
        code: 'invalid_route_params'
      }]
    };
  }
}

/**
 * Create a validation response for API errors
 */
export function createValidationErrorResponse(errors: ValidationError[]): NextResponse {
  return NextResponse.json({
    success: false,
    error: 'Validation failed',
    validation_errors: errors
  }, { status: 400 });
}

/**
 * Enhanced middleware wrapper that combines authentication and validation
 */
export interface ValidatedRouteOptions<TBody = any, TQuery = any, TParams = any> {
  // Authentication options
  roles?: UserRole | UserRole[];
  resource?: string;
  action?: string;

  // Validation schemas
  bodySchema?: ZodSchema<TBody>;
  querySchema?: ZodSchema<TQuery>;
  paramsSchema?: ZodSchema<TParams>;

  // Validation options
  requireBody?: boolean;
  requireAuth?: boolean;
}

export interface ValidatedRequest<TBody = any, TQuery = any, TParams = any> extends NextRequest {
  validatedBody?: TBody;
  validatedQuery?: TQuery;
  validatedParams?: TParams;
  user?: User;
}

/**
 * Create a validated and authenticated route handler
 */
export function createValidatedRoute<TBody = any, TQuery = any, TParams = any>(
  handler: (
    request: ValidatedRequest<TBody, TQuery, TParams>,
    context?: { params: Promise<Record<string, string>> }
  ) => Promise<NextResponse>,
  options: ValidatedRouteOptions<TBody, TQuery, TParams> = {}
) {
  return async (
    request: NextRequest,
    context?: { params: Promise<Record<string, string>> }
  ): Promise<NextResponse> => {
    const validatedRequest = request as ValidatedRequest<TBody, TQuery, TParams>;

    try {
      // 1. Validate route parameters if schema provided
      if (options.paramsSchema && context?.params) {
        const params = await context.params;
        const paramsResult = validateRouteParams(params, options.paramsSchema);
        if (!paramsResult.success) {
          return createValidationErrorResponse(paramsResult.errors!);
        }
        validatedRequest.validatedParams = paramsResult.data;
      }

      // 2. Validate query parameters if schema provided
      if (options.querySchema) {
        const queryResult = validateSearchParams(request, options.querySchema);
        if (!queryResult.success) {
          return createValidationErrorResponse(queryResult.errors!);
        }
        validatedRequest.validatedQuery = queryResult.data;
      }

      // 3. Validate request body if schema provided
      if (options.bodySchema) {
        // Only validate body for methods that typically have a body
        const method = request.method.toUpperCase();
        if (['POST', 'PUT', 'PATCH'].includes(method) || options.requireBody) {
          const bodyResult = await validateRequestBody(request, options.bodySchema);
          if (!bodyResult.success) {
            return createValidationErrorResponse(bodyResult.errors!);
          }
          validatedRequest.validatedBody = bodyResult.data;
        }
      }

      // 4. Apply authentication if required (integrate with existing auth middleware)
      if (options.requireAuth !== false) {
        // Import auth middleware dynamically to avoid circular dependencies
        const { withAuth, withRole, withPermission } = await import('./middleware');

        // Apply authentication
        const authResult = await withAuth(request);
        if (authResult instanceof NextResponse) {
          return authResult; // Auth failed
        }
        validatedRequest.user = authResult.user;

        // Apply role-based authorization if specified
        if (options.roles) {
          const roleResult = await withRole(options.roles)(request, authResult.user);
          if (roleResult instanceof NextResponse) {
            return roleResult; // Role check failed
          }
        }

        // Apply permission-based authorization if specified
        if (options.resource && options.action) {
          const permissionResult = await withPermission(options.resource, options.action)(request, authResult.user);
          if (permissionResult instanceof NextResponse) {
            return permissionResult; // Permission check failed
          }
        }
      }

      // 5. Call the actual handler with validated data
      return await handler(validatedRequest, context);

    } catch (error) {
      console.error('Validation middleware error:', error);
      return NextResponse.json({
        success: false,
        error: 'Internal server error during validation'
      }, { status: 500 });
    }
  };
}

/**
 * Simplified validation-only wrapper (without authentication)
 */
export function validateOnly<TBody = any, TQuery = any, TParams = any>(
  handler: (
    request: ValidatedRequest<TBody, TQuery, TParams>,
    context?: { params: Promise<Record<string, string>> }
  ) => Promise<NextResponse>,
  options: {
    bodySchema?: ZodSchema<TBody>;
    querySchema?: ZodSchema<TQuery>;
    paramsSchema?: ZodSchema<TParams>;
    requireBody?: boolean;
  }
) {
  return createValidatedRoute(handler, {
    ...options,
    requireAuth: false
  });
}

/**
 * Helper function to extract validated data from request
 */
export function getValidatedData<TBody = any, TQuery = any, TParams = any>(
  request: ValidatedRequest<TBody, TQuery, TParams>
): {
  body?: TBody;
  query?: TQuery;
  params?: TParams;
  user?: User;
} {
  return {
    body: request.validatedBody,
    query: request.validatedQuery,
    params: request.validatedParams,
    user: request.user
  };
}

/**
 * Utility to create consistent error responses
 */
export function createErrorResponse(
  message: string,
  status: number = 400,
  details?: any
): NextResponse {
  return NextResponse.json({
    success: false,
    error: message,
    ...(details && { details })
  }, { status });
}

/**
 * Utility to create consistent success responses
 */
export function createSuccessResponse<T>(
  data: T,
  message?: string,
  status: number = 200
): NextResponse {
  return NextResponse.json({
    success: true,
    data,
    ...(message && { message })
  }, { status });
}
```


#### 📄 src\lib\workflow.ts

```typescript
// 문서 상태 관리 및 워크플로우 시스템
import { supabaseAdmin, handleSupabaseError, createSuccessResponse } from './db-unified';

export type DocState = "DRAFT" | "APPROVED" | "CONFIRMED" | "CANCELED";

export type DocumentType = "INVENTORY_TRANSACTION";

export interface StatusHistoryRecord {
  id: number;
  document_type: DocumentType;
  document_id: number;
  document_number: string;
  previous_status: DocState | null;
  new_status: DocState;
  changed_by: number;
  change_reason: string | null;
  created_at: Date;
}

/**
 * 상태 전이 규칙 정의
 */
export const canTransit: Record<DocState, DocState[]> = {
  DRAFT: ["APPROVED", "CANCELED"],
  APPROVED: ["CONFIRMED", "CANCELED"],
  CONFIRMED: [], // 확정 후에는 변경 불가
  CANCELED: [], // 취소 후에는 변경 불가
};

/**
 * 상태 전이가 가능한지 검증합니다
 */
export function canTransitTo(currentStatus: DocState, newStatus: DocState): boolean {
  return canTransit[currentStatus].includes(newStatus);
}

/**
 * 상태 전이를 수행하고 이력을 기록합니다
 *
 * NOTE: Supabase doesn't support automatic transaction rollback like MySQL.
 * If the history insert fails, the status update is already committed.
 * Consider implementing compensating transactions or using PostgreSQL functions
 * with proper transaction handling for critical operations.
 */
export async function transitDocumentStatus(
  documentType: DocumentType,
  documentId: number,
  documentNumber: string,
  currentStatus: DocState,
  newStatus: DocState,
  changedBy: number,
  changeReason?: string
): Promise<void> {
  // 상태 전이 가능성 검증
  if (!canTransitTo(currentStatus, newStatus)) {
    throw new Error(
      `상태 전이가 불가능합니다: ${currentStatus} → ${newStatus}. ` +
      `가능한 상태: ${canTransit[currentStatus].join(', ')}`
    );
  }

  // Step 1: Update document status
  let updateError: any;

  switch (documentType) {
    case 'INVENTORY_TRANSACTION':
      const { error } = await supabaseAdmin
        .from('inventory_transactions')
        .update({
          document_status: newStatus,
          updated_at: new Date().toISOString()
        })
        .eq('transaction_id', documentId);
      updateError = error;
      break;
    default:
      throw new Error(`지원하지 않는 문서 유형: ${documentType}`);
  }

  if (updateError) {
    throw new Error(`상태 업데이트 실패: ${updateError.message}`);
  }

  // Step 2: Insert history record
  // NOTE: document_status_history table doesn't exist in Supabase yet
  // This functionality is disabled until the table is created
  /*
  const { error: historyError } = await supabaseAdmin
    .from('document_status_history')
    .insert({
      document_type: documentType,
      document_id: documentId,
      document_number: documentNumber,
      previous_status: currentStatus as string,
      new_status: newStatus as string,
      changed_by: changedBy,
      change_reason: changeReason || null
    } as any);

  if (historyError) {
    // Log error - status update is already committed, cannot rollback
    console.error('History insert failed after status update:', historyError);
    throw new Error(`이력 기록 실패: ${historyError.message}`);
  }
  */
}

/**
 * 문서의 상태 변경 이력을 조회합니다
 * NOTE: document_status_history table doesn't exist - returns empty array
 */
export async function getDocumentStatusHistory(
  documentType: DocumentType,
  documentId: number
): Promise<StatusHistoryRecord[]> {
  // Table doesn't exist yet, return empty array
  return [];

  /*
  const { data, error } = await supabaseAdmin
    .from('document_status_history')
    .select<'*', StatusHistoryRecord>('*')
    .eq('document_type', documentType)
    .eq('document_id', documentId)
    .order('created_at', { ascending: true });

  if (error) {
    throw new Error(`상태 이력 조회 실패: ${error.message}`);
  }

  return data || [];
  */
}

/**
 * 문서 번호로 상태 변경 이력을 조회합니다
 * NOTE: document_status_history table doesn't exist - returns empty array
 */
export async function getDocumentStatusHistoryByNumber(
  documentNumber: string
): Promise<StatusHistoryRecord[]> {
  // Table doesn't exist yet, return empty array
  return [];

  /*
  const { data, error } = await supabaseAdmin
    .from('document_status_history')
    .select<'*', StatusHistoryRecord>('*')
    .eq('document_number', documentNumber)
    .order('created_at', { ascending: true });

  if (error) {
    throw new Error(`상태 이력 조회 실패: ${error.message}`);
  }

  return data || [];
  */
}

/**
 * 상태별 문서 수를 조회합니다
 */
export async function getDocumentStatusSummary(
  documentType: DocumentType
): Promise<Record<DocState, number>> {
  let data: any[] | null = null;
  let error: any = null;

  switch (documentType) {
    case 'INVENTORY_TRANSACTION':
      const result = await supabaseAdmin
        .from('inventory_transactions')
        .select('document_status')
        .eq('is_active', true);
      data = result.data;
      error = result.error;
      break;
    default:
      throw new Error(`지원하지 않는 문서 유형: ${documentType}`);
  }

  if (error) {
    throw new Error(`상태 요약 조회 실패: ${error.message}`);
  }

  // 모든 상태를 0으로 초기화
  const summary: Record<DocState, number> = {
    DRAFT: 0,
    APPROVED: 0,
    CONFIRMED: 0,
    CANCELED: 0
  };

  // 실제 데이터로 업데이트 (TypeScript에서 수동으로 집계)
  data?.forEach((row) => {
    if (row.document_status in summary) {
      summary[row.document_status as DocState]++;
    }
  });

  return summary;
}

/**
 * 상태 한국어 라벨을 반환합니다
 */
export function getStatusLabel(status: DocState): string {
  const statusLabels: Record<DocState, string> = {
    DRAFT: '초안',
    APPROVED: '승인',
    CONFIRMED: '확정',
    CANCELED: '취소'
  };

  return statusLabels[status];
}

/**
 * 상태 색상을 반환합니다 (UI용)
 */
export function getStatusColor(status: DocState): string {
  const statusColors: Record<DocState, string> = {
    DRAFT: 'bg-gray-100 text-gray-800',
    APPROVED: 'bg-blue-100 text-blue-800',
    CONFIRMED: 'bg-green-100 text-green-800',
    CANCELED: 'bg-red-100 text-red-800'
  };

  return statusColors[status];
}

/**
 * 다음 가능한 상태들을 반환합니다
 */
export function getNextPossibleStates(currentStatus: DocState): DocState[] {
  return canTransit[currentStatus];
}

/**
 * 상태 전이 권한을 검증합니다 (향후 확장 가능)
 */
export function canUserTransitStatus(
  userId: number,
  currentStatus: DocState,
  newStatus: DocState
): boolean {
  // 기본적으로 모든 사용자가 상태 전이 가능
  // 향후 역할 기반 권한 시스템 구현 시 확장
  return canTransitTo(currentStatus, newStatus);
}

/**
 * 상태 전이 사유를 검증합니다
 */
export function validateTransitionReason(
  currentStatus: DocState,
  newStatus: DocState,
  reason?: string
): boolean {
  // 취소로 전이할 때는 사유가 필수
  if (newStatus === 'CANCELED' && (!reason || reason.trim().length === 0)) {
    return false;
  }

  // 확정으로 전이할 때는 사유가 권장 (선택사항)
  return true;
}
```


---

### TYPES 코드


#### 📄 src\types\auth.ts

```typescript
// 인증 관련 타입 정의
export interface User {
  id: number;
  username: string;
  name: string;
  email?: string;
  department?: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export type UserRole = 'admin' | 'manager' | 'operator' | 'viewer';

export interface JWTPayload {
  userId: number;
  username: string;
  role: UserRole;
  iat?: number;
  exp?: number;
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface LoginResponse {
  success: boolean;
  user?: Omit<User, 'id'>;
  token?: string;
  error?: string;
}

export interface AuthSession {
  userId: number;
  username: string;
  role: UserRole;
  isLoggedIn: boolean;
}

// 권한 매트릭스
export const ROLE_PERMISSIONS = {
  admin: {
    users: { read: true, create: true, update: true, delete: true },
    items: { read: true, create: true, update: true, delete: true },
    companies: { read: true, create: true, update: true, delete: true },
    inventory: { read: true, create: true, update: true, delete: true },
    production: { read: true, create: true, update: true, delete: true },
    reports: { read: true, create: true, update: true, delete: true },
  },
  manager: {
    users: { read: true, create: false, update: false, delete: false },
    items: { read: true, create: true, update: true, delete: true },
    companies: { read: true, create: true, update: true, delete: true },
    inventory: { read: true, create: true, update: true, delete: true },
    production: { read: true, create: true, update: true, delete: true },
    reports: { read: true, create: true, update: true, delete: false },
  },
  operator: {
    users: { read: false, create: false, update: false, delete: false },
    items: { read: true, create: true, update: true, delete: false },
    companies: { read: true, create: true, update: true, delete: false },
    inventory: { read: true, create: true, update: true, delete: false },
    production: { read: true, create: true, update: true, delete: false },
    reports: { read: true, create: false, update: false, delete: false },
  },
  viewer: {
    users: { read: false, create: false, update: false, delete: false },
    items: { read: true, create: false, update: false, delete: false },
    companies: { read: true, create: false, update: false, delete: false },
    inventory: { read: true, create: false, update: false, delete: false },
    production: { read: true, create: false, update: false, delete: false },
    reports: { read: true, create: false, update: false, delete: false },
  },
} as const;

export type Permission = 'read' | 'create' | 'update' | 'delete';
export type Resource = 'users' | 'items' | 'companies' | 'inventory' | 'production' | 'reports';

// 권한 체크 함수
export function hasPermission(role: UserRole, resource: Resource, permission: Permission): boolean {
  return ROLE_PERMISSIONS[role][resource][permission];
}

// API 에러 타입
export interface AuthError {
  code: string;
  message: string;
}

export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: { code: 'INVALID_CREDENTIALS', message: '아이디 또는 비밀번호가 틀렸습니다.' },
  TOKEN_EXPIRED: { code: 'TOKEN_EXPIRED', message: '로그인 세션이 만료되었습니다.' },
  TOKEN_INVALID: { code: 'TOKEN_INVALID', message: '유효하지 않은 토큰입니다.' },
  ACCESS_DENIED: { code: 'ACCESS_DENIED', message: '접근 권한이 없습니다.' },
  USER_INACTIVE: { code: 'USER_INACTIVE', message: '비활성화된 사용자입니다.' },
  USER_NOT_FOUND: { code: 'USER_NOT_FOUND', message: '사용자를 찾을 수 없습니다.' },
} as const;
```


#### 📄 src\types\inventory.ts

```typescript
// Shared types and interfaces for inventory management system

// Base inventory transaction interface
export interface InventoryTransaction {
  id?: number;
  transaction_id?: number;
  transaction_date: string;
  transaction_type: 'incoming' | 'production_in' | 'production_out' | 'outgoing' | '입고' | '생산입고' | '생산출고' | '출고';
  item_id: number;
  item_code?: string;
  item_name?: string;
  quantity: number;
  unit_price: number;
  total_amount: number;
  company_id?: number;
  company_name?: string;
  reference_no?: string;
  user_name?: string;
  created_at?: string;
  updated_at?: string;
}

// Item/Product interfaces
export interface Item {
  id: number;
  item_id?: number;
  item_code: string;
  name: string;
  item_name?: string;
  category?: string;
  item_type?: string;
  material_type?: string;
  vehicle_model?: string;
  material?: string;
  specification?: string;
  spec?: string;
  unit: string;
  thickness?: number;
  width?: number;
  height?: number;
  specific_gravity?: number;
  mm_weight?: number;
  daily_requirement?: number;
  blank_size?: number;
  current_stock?: number;
  safety_stock?: number;
  min_stock_level?: number;
  max_stock_level?: number;
  price?: number;
  unit_price?: number;
  description?: string;
  location?: string;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
}

export interface Product extends Item {
  // Products inherit all Item properties
  // Additional product-specific properties can be added here
  item_type?: string; // For ProductionForm compatibility
}

// Component-specific compatibility interfaces
// These extend the base interfaces to match component expectations
export interface ItemForComponent extends Item {
  item_id: number; // Alias for id
  item_code: string; // Already exists
  item_name: string; // Alias for name
  unit: string; // Already exists
  unit_price: number; // Make required for components
}

// Company interface
export interface Company {
  id: number;
  company_code: string;
  name: string;
  business_type: 'supplier' | 'customer' | 'both' | '공급업체' | '고객' | '둘다';
  contact_person?: string;
  phone?: string;
  email?: string;
  address?: string;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
}

// Component-specific compatibility interface for Company
export interface CompanyForComponent extends Company {
  company_id: number; // Alias for id
  company_name: string; // Alias for name
  company_type: string; // Alias for business_type
}

// Stock information interface
export interface StockInfo {
  item_id: number;
  item_code: string;
  item_name: string;
  current_stock: number;
  unit: string;
  min_stock_level?: number;
  max_stock_level?: number;
  unit_price?: number;
  location?: string;
  last_updated?: string;
}

// BOM (Bill of Materials) interfaces
export interface BOMItem {
  id?: number;
  parent_item_id?: number;
  child_item_id: number;
  child_item_code: string;
  child_item_name: string;
  bom_quantity: number; // Also include original BOM quantity field
  required_quantity: number;
  unit: string;
  scrap_rate?: number; // Add scrap rate field from ProductionForm
  current_stock: number;
  needed_quantity?: number;
  sufficient_stock: boolean;
  shortage?: number;
}

export interface BOMStructure {
  product_id: number;
  product_code: string;
  product_name: string;
  materials: BOMItem[];
  total_materials: number;
  all_sufficient: boolean;
}

// Form data interfaces for each inventory operation
export interface ReceivingFormData {
  transaction_date: string;
  item_id: number;
  quantity: number;
  unit_price: number;
  company_id?: number;
  reference_no?: string;
  lot_no?: string;
  expiry_date?: string;
  to_location?: string;
  notes?: string;
  created_by: number;
}

export interface ProductionFormData {
  transaction_date: string;
  product_item_id: number;
  quantity: number;
  reference_no?: string;
  notes?: string;
  use_bom: boolean;
  scrap_quantity?: number;
  created_by: number;
}

export interface ShippingItem {
  item_id: number;
  item_code: string;
  item_name: string;
  unit: string;
  unit_price: number;
  current_stock: number;
  quantity: number;
  total_amount: number;
  sufficient_stock: boolean;
}

export interface ShippingFormData {
  transaction_date: string;
  customer_id?: number;
  items: ShippingItem[];
  reference_no?: string;
  delivery_address?: string;
  delivery_date?: string;
  notes?: string;
  created_by: number;
}

// Search and dropdown interfaces
export interface SearchOption {
  id: number;
  code: string;
  name: string;
  specification?: string;
  unit?: string;
  current_stock?: number;
  unit_price?: number;
  business_type?: string;
}

// API response interfaces
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginationInfo {
  total: number;
  limit: number;
  offset: number;
  hasMore: boolean;
}

export interface TransactionListResponse {
  transactions: InventoryTransaction[];
  pagination?: PaginationInfo;
}

export interface StockListResponse {
  stocks: StockInfo[];
  pagination?: PaginationInfo;
}

// Form validation interfaces
export interface FormError {
  field: string;
  message: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: FormError[];
}

// Stock status enums and types
export type StockStatus = 'normal' | 'low' | 'empty' | 'excess';

export interface StockStatusInfo {
  status: StockStatus;
  message: string;
  icon: React.ComponentType<{ className?: string }>;
  color: string;
}

// Inventory transaction types
export const TRANSACTION_TYPES = {
  RECEIVING: '입고',
  PRODUCTION_IN: '생산입고',
  PRODUCTION_OUT: '생산출고',
  SHIPPING: '출고'
} as const;

export type TransactionType = typeof TRANSACTION_TYPES[keyof typeof TRANSACTION_TYPES];

// Business types for companies
export const BUSINESS_TYPES = {
  SUPPLIER: '공급업체',
  CUSTOMER: '고객',
  BOTH: '둘다'
} as const;

export type BusinessType = typeof BUSINESS_TYPES[keyof typeof BUSINESS_TYPES];

// Form submission handlers
export type FormSubmitHandler<T> = (data: T) => Promise<void> | void;
export type FormCancelHandler = () => void;

// Common props for form components
export interface BaseFormProps<T> {
  onSubmit: FormSubmitHandler<T>;
  onCancel: FormCancelHandler;
  initialData?: Partial<T>;
  isEdit?: boolean;
  isLoading?: boolean;
}

// Props for specific form components
export interface ReceivingFormProps extends BaseFormProps<ReceivingFormData> {}
export interface ProductionFormProps extends BaseFormProps<ProductionFormData> {}
export interface ShippingFormProps extends BaseFormProps<ShippingFormData> {}

// Tab configuration interface
export interface InventoryTab {
  id: 'receiving' | 'production' | 'shipping';
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  description: string;
  color: string;
  bgColor: string;
}

// Filter and search interfaces
export interface InventoryFilters {
  start_date?: string;
  end_date?: string;
  item_id?: number;
  company_id?: number;
  transaction_type?: TransactionType;
  reference_no?: string;
  limit?: number;
  offset?: number;
}

export interface SearchFilters {
  query?: string;
  category?: string;
  is_active?: boolean;
  business_type?: BusinessType;
  limit?: number;
}

// Utility types
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;


```


#### 📄 src\types\supabase.ts

```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      bom: {
        Row: {
          bom_id: number
          child_item_id: number
          created_at: string | null
          created_by: number | null
          is_active: boolean | null
          parent_item_id: number
          quantity: number
          unit: string | null
          updated_at: string | null
          updated_by: number | null
        }
        Insert: {
          bom_id?: number
          child_item_id: number
          created_at?: string | null
          created_by?: number | null
          is_active?: boolean | null
          parent_item_id: number
          quantity?: number
          unit?: string | null
          updated_at?: string | null
          updated_by?: number | null
        }
        Update: {
          bom_id?: number
          child_item_id?: number
          created_at?: string | null
          created_by?: number | null
          is_active?: boolean | null
          parent_item_id?: number
          quantity?: number
          unit?: string | null
          updated_at?: string | null
          updated_by?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "bom_child_item_id_fkey"
            columns: ["child_item_id"]
            isOneToOne: false
            referencedRelation: "items"
            referencedColumns: ["item_id"]
          },
          {
            foreignKeyName: "bom_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "bom_parent_item_id_fkey"
            columns: ["parent_item_id"]
            isOneToOne: false
            referencedRelation: "items"
            referencedColumns: ["item_id"]
          },
          {
            foreignKeyName: "bom_updated_by_fkey"
            columns: ["updated_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
        ]
      }
      companies: {
        Row: {
          address: string | null
          business_number: string | null
          business_registration_no: string | null // Alias for business_number
          company_code: string
          company_id: number
          company_name: string
          company_type: Database["public"]["Enums"]["company_type"]
          contact_person: string | null // Alias for representative
          created_at: string | null
          created_by: number | null
          description: string | null
          email: string | null
          fax: string | null
          is_active: boolean | null
          phone: string | null
          representative: string | null
          updated_at: string | null
          updated_by: number | null
        }
        Insert: {
          address?: string | null
          business_number?: string | null
          business_registration_no?: string | null // Alias for business_number
          company_code: string
          company_id?: number
          company_name: string
          company_type: Database["public"]["Enums"]["company_type"]
          contact_person?: string | null // Alias for representative
          created_at?: string | null
          created_by?: number | null
          description?: string | null
          email?: string | null
          fax?: string | null
          is_active?: boolean | null
          phone?: string | null
          representative?: string | null
          updated_at?: string | null
          updated_by?: number | null
        }
        Update: {
          address?: string | null
          business_number?: string | null
          business_registration_no?: string | null // Alias for business_number
          company_code?: string
          company_id?: number
          company_name?: string
          company_type?: Database["public"]["Enums"]["company_type"]
          contact_person?: string | null // Alias for representative
          created_at?: string | null
          created_by?: number | null
          description?: string | null
          email?: string | null
          fax?: string | null
          is_active?: boolean | null
          phone?: string | null
          representative?: string | null
          updated_at?: string | null
          updated_by?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "companies_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "companies_updated_by_fkey"
            columns: ["updated_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
        ]
      }
      inventory_transactions: {
        Row: {
          company_id: number | null
          created_at: string | null
          created_by: number | null
          description: string | null
          document_number: string | null
          expiry_date: string | null
          grand_total: number | null
          item_id: number
          location: string | null
          lot_number: string | null
          notes: string | null
          quantity: number
          reference_number: string | null
          status: Database["public"]["Enums"]["transaction_status"] | null
          tax_amount: number | null
          total_amount: number | null
          transaction_date: string
          transaction_id: number
          transaction_number: string | null
          transaction_type: Database["public"]["Enums"]["transaction_type"]
          unit_price: number | null
          updated_at: string | null
          updated_by: number | null
          warehouse_id: number | null
        }
        Insert: {
          company_id?: number | null
          created_at?: string | null
          created_by?: number | null
          description?: string | null
          document_number?: string | null
          expiry_date?: string | null
          grand_total?: number | null
          item_id: number
          location?: string | null
          lot_number?: string | null
          notes?: string | null
          quantity: number
          reference_number?: string | null
          status?: Database["public"]["Enums"]["transaction_status"] | null
          tax_amount?: number | null
          total_amount?: number | null
          transaction_date: string
          transaction_id?: number
          transaction_number?: string | null
          transaction_type: Database["public"]["Enums"]["transaction_type"]
          unit_price?: number | null
          updated_at?: string | null
          updated_by?: number | null
          warehouse_id?: number | null
        }
        Update: {
          company_id?: number | null
          created_at?: string | null
          created_by?: number | null
          description?: string | null
          document_number?: string | null
          expiry_date?: string | null
          grand_total?: number | null
          item_id?: number
          location?: string | null
          lot_number?: string | null
          notes?: string | null
          quantity?: number
          reference_number?: string | null
          status?: Database["public"]["Enums"]["transaction_status"] | null
          tax_amount?: number | null
          total_amount?: number | null
          transaction_date?: string
          transaction_id?: number
          transaction_number?: string | null
          transaction_type?: Database["public"]["Enums"]["transaction_type"]
          unit_price?: number | null
          updated_at?: string | null
          updated_by?: number | null
          warehouse_id?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "inventory_transactions_company_id_fkey"
            columns: ["company_id"]
            isOneToOne: false
            referencedRelation: "companies"
            referencedColumns: ["company_id"]
          },
          {
            foreignKeyName: "inventory_transactions_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "inventory_transactions_item_id_fkey"
            columns: ["item_id"]
            isOneToOne: false
            referencedRelation: "items"
            referencedColumns: ["item_id"]
          },
          {
            foreignKeyName: "inventory_transactions_updated_by_fkey"
            columns: ["updated_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
        ]
      }
            items: {
        Row: {
          category: Database["public"]["Enums"]["item_category"]
          created_at: string | null
          created_by: number | null
          current_stock: number | null
          daily_requirement: number | null
          description: string | null
          height: number | null
          is_active: boolean | null
          item_code: string
          item_id: number
          item_name: string
          item_type: string | null
          location: string | null
          material: string | null
          material_type: string | null
          mm_weight: number | null
          price: number | null
          safety_stock: number | null
          specific_gravity: number | null
          spec: string | null
          thickness: number | null
          unit: string
          updated_at: string | null
          updated_by: number | null
          vehicle_model: string | null
          width: number | null
          blank_size: number | null
        }
        Insert: {
          category: Database["public"]["Enums"]["item_category"]
          created_at?: string | null
          created_by?: number | null
          current_stock?: number | null
          daily_requirement?: number | null
          description?: string | null
          height?: number | null
          is_active?: boolean | null
          item_code: string
          item_id?: number
          item_name: string
          item_type?: string | null
          location?: string | null
          material?: string | null
          material_type?: string | null
          mm_weight?: number | null
          price?: number | null
          safety_stock?: number | null
          specific_gravity?: number | null
          spec?: string | null
          thickness?: number | null
          unit?: string
          updated_at?: string | null
          updated_by?: number | null
          vehicle_model?: string | null
          width?: number | null
          blank_size?: number | null
        }
        Update: {
          category?: Database["public"]["Enums"]["item_category"]
          created_at?: string | null
          created_by?: number | null
          current_stock?: number | null
          daily_requirement?: number | null
          description?: string | null
          height?: number | null
          is_active?: boolean | null
          item_code?: string
          item_id?: number
          item_name?: string
          item_type?: string | null
          location?: string | null
          material?: string | null
          material_type?: string | null
          mm_weight?: number | null
          price?: number | null
          safety_stock?: number | null
          specific_gravity?: number | null
          spec?: string | null
          thickness?: number | null
          unit?: string
          updated_at?: string | null
          updated_by?: number | null
          vehicle_model?: string | null
          width?: number | null
          blank_size?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "items_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "items_updated_by_fkey"
            columns: ["updated_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
        ]
      }
      serials: {
        Row: {
          created_at: string | null
          current_number: number
          prefix: string
          serial_id: number
          updated_at: string | null
          year_month: string
        }
        Insert: {
          created_at?: string | null
          current_number?: number
          prefix: string
          serial_id?: number
          updated_at?: string | null
          year_month: string
        }
        Update: {
          created_at?: string | null
          current_number?: number
          prefix?: string
          serial_id?: number
          updated_at?: string | null
          year_month?: string
        }
        Relationships: []
      }
      stock_adjustments: {
        Row: {
          adjustment_date: string
          adjustment_id: number
          adjustment_number: string
          adjustment_quantity: number | null
          adjustment_type: Database["public"]["Enums"]["adjustment_type"]
          approval_date: string | null
          approved_by: number | null
          created_at: string | null
          created_by: number
          item_id: number
          quantity_after: number
          quantity_before: number
          reason: string
          status: string | null
          total_cost_impact: number | null
          unit_cost: number | null
          updated_at: string | null
          warehouse_id: number
        }
        Insert: {
          adjustment_date?: string
          adjustment_id?: number
          adjustment_number: string
          adjustment_quantity?: number | null
          adjustment_type: Database["public"]["Enums"]["adjustment_type"]
          approval_date?: string | null
          approved_by?: number | null
          created_at?: string | null
          created_by: number
          item_id: number
          quantity_after: number
          quantity_before: number
          reason: string
          status?: string | null
          total_cost_impact?: number | null
          unit_cost?: number | null
          updated_at?: string | null
          warehouse_id: number
        }
        Update: {
          adjustment_date?: string
          adjustment_id?: number
          adjustment_number?: string
          adjustment_quantity?: number | null
          adjustment_type?: Database["public"]["Enums"]["adjustment_type"]
          approval_date?: string | null
          approved_by?: number | null
          created_at?: string | null
          created_by?: number
          item_id?: number
          quantity_after?: number
          quantity_before?: number
          reason?: string
          status?: string | null
          total_cost_impact?: number | null
          unit_cost?: number | null
          updated_at?: string | null
          warehouse_id?: number
        }
        Relationships: [
          {
            foreignKeyName: "stock_adjustments_approved_by_fkey"
            columns: ["approved_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "stock_adjustments_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
          {
            foreignKeyName: "stock_adjustments_item_id_fkey"
            columns: ["item_id"]
            isOneToOne: false
            referencedRelation: "items"
            referencedColumns: ["item_id"]
          },
          {
            foreignKeyName: "stock_adjustments_warehouse_id_fkey"
            columns: ["warehouse_id"]
            isOneToOne: false
            referencedRelation: "warehouses"
            referencedColumns: ["warehouse_id"]
          },
        ]
      }
      users: {
        Row: {
          created_at: string | null
          email: string | null
          is_active: boolean | null
          name: string
          password: string
          phone: string | null
          role: string
          updated_at: string | null
          user_id: number
          username: string
        }
        Insert: {
          created_at?: string | null
          email?: string | null
          is_active?: boolean | null
          name: string
          password: string
          phone?: string | null
          role?: string
          updated_at?: string | null
          user_id?: number
          username: string
        }
        Update: {
          created_at?: string | null
          email?: string | null
          is_active?: boolean | null
          name?: string
          password?: string
          phone?: string | null
          role?: string
          updated_at?: string | null
          user_id?: number
          username?: string
        }
        Relationships: []
      }
      warehouse_stock: {
        Row: {
          available_quantity: number | null
          created_at: string | null
          current_quantity: number | null
          item_id: number
          last_in_date: string | null
          last_out_date: string | null
          location_code: string | null
          max_stock: number | null
          min_stock: number | null
          reserved_quantity: number | null
          updated_at: string | null
          warehouse_id: number
          warehouse_stock_id: number
        }
        Insert: {
          available_quantity?: number | null
          created_at?: string | null
          current_quantity?: number | null
          item_id: number
          last_in_date?: string | null
          last_out_date?: string | null
          location_code?: string | null
          max_stock?: number | null
          min_stock?: number | null
          reserved_quantity?: number | null
          updated_at?: string | null
          warehouse_id: number
          warehouse_stock_id?: number
        }
        Update: {
          available_quantity?: number | null
          created_at?: string | null
          current_quantity?: number | null
          item_id?: number
          last_in_date?: string | null
          last_out_date?: string | null
          location_code?: string | null
          max_stock?: number | null
          min_stock?: number | null
          reserved_quantity?: number | null
          updated_at?: string | null
          warehouse_id?: number
          warehouse_stock_id?: number
        }
        Relationships: [
          {
            foreignKeyName: "warehouse_stock_item_id_fkey"
            columns: ["item_id"]
            isOneToOne: false
            referencedRelation: "items"
            referencedColumns: ["item_id"]
          },
          {
            foreignKeyName: "warehouse_stock_warehouse_id_fkey"
            columns: ["warehouse_id"]
            isOneToOne: false
            referencedRelation: "warehouses"
            referencedColumns: ["warehouse_id"]
          },
        ]
      }
      warehouses: {
        Row: {
          address: string | null
          created_at: string | null
          created_by: number | null
          current_usage: number | null
          is_active: boolean | null
          manager_name: string | null
          manager_phone: string | null
          max_capacity: number | null
          temperature_controlled: boolean | null
          updated_at: string | null
          warehouse_code: string
          warehouse_id: number
          warehouse_name: string
          warehouse_type: Database["public"]["Enums"]["warehouse_type"]
        }
        Insert: {
          address?: string | null
          created_at?: string | null
          created_by?: number | null
          current_usage?: number | null
          is_active?: boolean | null
          manager_name?: string | null
          manager_phone?: string | null
          max_capacity?: number | null
          temperature_controlled?: boolean | null
          updated_at?: string | null
          warehouse_code: string
          warehouse_id?: number
          warehouse_name: string
          warehouse_type: Database["public"]["Enums"]["warehouse_type"]
        }
        Update: {
          address?: string | null
          created_at?: string | null
          created_by?: number | null
          current_usage?: number | null
          is_active?: boolean | null
          manager_name?: string | null
          manager_phone?: string | null
          max_capacity?: number | null
          temperature_controlled?: boolean | null
          updated_at?: string | null
          warehouse_code?: string
          warehouse_id?: number
          warehouse_name?: string
          warehouse_type?: Database["public"]["Enums"]["warehouse_type"]
        }
        Relationships: [
          {
            foreignKeyName: "warehouses_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["user_id"]
          },
        ]
      }
    }
    Views: {
      current_stock_view: {
        Row: {
          category: Database["public"]["Enums"]["item_category"] | null
          current_stock: number | null
          is_active: boolean | null
          item_code: string | null
          item_id: number | null
          item_name: string | null
          location: string | null
          safety_stock: number | null
          spec: string | null
          stock_status: string | null
          unit: string | null
        }
        Relationships: []
      }
    }
    Functions: {
      get_next_serial: {
        Args: { prefix_param: string }
        Returns: string
      }
    }
    Enums: {
      adjustment_type: "증가" | "감소" | "정정" | "손실" | "발견" | "기타"
      company_type: "고객사" | "공급사" | "협력사" | "기타"
      item_category: "원자재" | "부자재" | "반제품" | "제품" | "상품"
      transaction_status: "대기" | "진행중" | "완료" | "취소"
      transaction_type:
        | "입고"
        | "출고"
        | "생산입고"
        | "생산출고"
        | "이동"
        | "조정"
        | "폐기"
        | "재고조정"
      warehouse_type: "원자재" | "반제품" | "제품" | "기타"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
      PublicSchema["Views"])
  ? (PublicSchema["Tables"] &
      PublicSchema["Views"])[PublicTableNameOrOptions] extends {
      Row: infer R
    }
    ? R
    : never
  : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
  ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
      Insert: infer I
    }
    ? I
    : never
  : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
  ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
      Update: infer U
    }
    ? U
    : never
  : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
  ? PublicSchema["Enums"][PublicEnumNameOrOptions]
  : never

// Additional type helpers for the ERP system
export type Item = Tables<'items'>
export type ItemInsert = TablesInsert<'items'>
export type ItemUpdate = TablesUpdate<'items'>

export type Company = Tables<'companies'>
export type CompanyInsert = TablesInsert<'companies'>
export type CompanyUpdate = TablesUpdate<'companies'>

export type BOM = Tables<'bom'>
export type BOMInsert = TablesInsert<'bom'>
export type BOMUpdate = TablesUpdate<'bom'>

export type InventoryTransaction = Tables<'inventory_transactions'>
export type InventoryTransactionInsert = TablesInsert<'inventory_transactions'>
export type InventoryTransactionUpdate = TablesUpdate<'inventory_transactions'>

export type User = Tables<'users'>
export type UserInsert = TablesInsert<'users'>
export type UserUpdate = TablesUpdate<'users'>

export type Warehouse = Tables<'warehouses'>
export type WarehouseInsert = TablesInsert<'warehouses'>
export type WarehouseUpdate = TablesUpdate<'warehouses'>

export type WarehouseStock = Tables<'warehouse_stock'>
export type WarehouseStockInsert = TablesInsert<'warehouse_stock'>
export type WarehouseStockUpdate = TablesUpdate<'warehouse_stock'>

export type StockAdjustment = Tables<'stock_adjustments'>
export type StockAdjustmentInsert = TablesInsert<'stock_adjustments'>
export type StockAdjustmentUpdate = TablesUpdate<'stock_adjustments'>

export type Serial = Tables<'serials'>
export type SerialInsert = TablesInsert<'serials'>
export type SerialUpdate = TablesUpdate<'serials'>

// Enum types for better type safety
export type ItemCategory = "원자재" | "부자재" | "반제품" | "제품" | "상품"
export type CompanyType = "고객사" | "공급사" | "협력사" | "기타"
export type UserRole = "admin" | "manager" | "operator" | "viewer"
export type TransactionType = "입고" | "출고" | "생산입고" | "생산출고" | "이동" | "조정" | "폐기" | "재고조정"
export type TransactionStatus = "대기" | "진행중" | "완료" | "취소"
export type WarehouseType = "원자재" | "반제품" | "제품" | "기타"
export type AdjustmentType = "증가" | "감소" | "정정" | "손실" | "발견" | "기타"

export type ItemTypeCode = 'RAW' | 'SUB' | 'FINISHED'
export type MaterialTypeCode = 'COIL' | 'SHEET' | 'OTHER'

```


#### 📄 src\types\upload.ts

```typescript
// Excel 업로드 관련 타입 정의

export interface ValidationError {
  row: number;
  field: string;
  value: unknown;
  message: string;
}

export interface UploadResult {
  success: boolean;
  total_rows: number;
  success_count: number;
  error_count: number;
  errors: ValidationError[];
  duplicates: string[];
}

export interface ExcelItemData {
  item_code: string;
  item_name: string;
  item_type: string;
  car_model?: string;
  spec?: string;
  unit: string;
  unit_price?: number;
  min_stock_level?: number;
  location?: string;
}

export interface ExcelCompanyData {
  company_name: string;
  company_type: string;
  business_registration_no?: string;
  contact_person?: string;
  phone?: string;
  mobile?: string;
  email?: string;
  address?: string;
  payment_terms?: string;
  contact_info?: string;
  notes?: string;
}

// 유효한 값들
export const VALID_ITEM_TYPES = ['원자재', '부자재', '반제품', '제품', '상품'] as const;
export const VALID_COMPANY_TYPES = ['고객사', '공급사', '협력사', '기타'] as const;

export type ItemType = typeof VALID_ITEM_TYPES[number];
export type CompanyType = typeof VALID_COMPANY_TYPES[number];
```


---

### HOOKS 코드


#### 📄 src\hooks\useAdvancedFilter.tsx

```typescript
/**
 * 고급 필터링 훅
 * Advanced Filtering Hook with debounced search and localStorage persistence
 */

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  SearchQueryParams,
  buildSearchQuery,
  createDebouncedSearch,
  normalizeKoreanText,
  validateFilterCombination,
  trackSearch,
  prepareFilterStateForExport
} from '@/utils/searchUtils';

export interface FilterState {
  searchTerm: string;
  dateRange: {
    startDate?: string;
    endDate?: string;
  };
  filters: Record<string, any>;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface UseAdvancedFilterOptions {
  persistKey?: string; // localStorage 키
  debounceMs?: number; // 디바운스 시간
  enableUrlSync?: boolean; // URL 동기화 여부
  maxSearchHistory?: number; // 최대 검색 기록 수
  onFilterChange?: (state: FilterState) => void; // 필터 변경 콜백
}

export interface UseAdvancedFilterReturn {
  // 상태
  filterState: FilterState;
  isFiltering: boolean;
  hasActiveFilters: boolean;

  // 액션
  setSearchTerm: (term: string) => void;
  setDateRange: (range: { startDate?: string; endDate?: string }) => void;
  setFilter: (key: string, value: unknown) => void;
  setFilters: (filters: Record<string, any>) => void;
  setSorting: (sortBy: string, sortOrder: 'asc' | 'desc') => void;
  clearAllFilters: () => void;
  clearFilter: (key: string) => void;

  // 필터 관리
  saveFilter: (name: string) => void;
  loadFilter: (name: string) => void;
  deleteSavedFilter: (name: string) => void;
  getSavedFilters: () => Array<{ name: string; filters: FilterState; createdAt: string }>;

  // 유틸리티
  buildQueryParams: () => URLSearchParams;
  exportFilterState: () => any;
  getFilteredData: <T>(data: T[], searchFields: string[]) => T[];
}

export const useAdvancedFilter = (
  options: UseAdvancedFilterOptions = {}
): UseAdvancedFilterReturn => {
  const {
    persistKey = 'advancedFilter',
    debounceMs = 300,
    enableUrlSync = true,
    maxSearchHistory = 50,
    onFilterChange
  } = options;

  const router = useRouter();
  const searchParams = useSearchParams();

  const [filterState, setFilterState] = useState<FilterState>({
    searchTerm: '',
    dateRange: {},
    filters: {},
    sortBy: undefined,
    sortOrder: 'desc'
  });

  const [isFiltering, setIsFiltering] = useState(false);

  // URL에서 초기 상태 로드
  useEffect(() => {
    if (enableUrlSync && searchParams) {
      const initialState: FilterState = {
        searchTerm: searchParams.get('search') || '',
        dateRange: {
          startDate: searchParams.get('startDate') || undefined,
          endDate: searchParams.get('endDate') || undefined
        },
        filters: {},
        sortBy: searchParams.get('sortBy') || undefined,
        sortOrder: (searchParams.get('sortOrder') as 'asc' | 'desc') || 'desc'
      };

      // 다른 필터 파라미터들 로드
      searchParams.forEach((value, key) => {
        if (!['search', 'startDate', 'endDate', 'sortBy', 'sortOrder'].includes(key)) {
          try {
            initialState.filters[key] = JSON.parse(value);
          } catch {
            initialState.filters[key] = value;
          }
        }
      });

      setFilterState(initialState);
    } else {
      // localStorage에서 로드
      loadPersistedState();
    }
  }, [searchParams, enableUrlSync]);

  // localStorage 상태 로드
  const loadPersistedState = useCallback(() => {
    if (typeof window !== 'undefined') {
      try {
        const saved = localStorage.getItem(persistKey);
        if (saved) {
          const parsedState = JSON.parse(saved);
          setFilterState(prev => ({ ...prev, ...parsedState }));
        }
      } catch (error) {
        console.warn('Failed to load persisted filter state:', error);
      }
    }
  }, [persistKey]);

  // localStorage에 상태 저장
  const persistState = useCallback((state: FilterState) => {
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem(persistKey, JSON.stringify(state));
      } catch (error) {
        console.warn('Failed to persist filter state:', error);
      }
    }
  }, [persistKey]);

  // URL 업데이트
  const updateUrl = useCallback((state: FilterState) => {
    if (!enableUrlSync) return;

    const queryParams = buildSearchQuery({
      searchText: state.searchTerm,
      dateRange: state.dateRange,
      filters: state.filters,
      sortBy: state.sortBy,
      sortOrder: state.sortOrder
    });

    const url = `${window.location.pathname}?${queryParams.toString()}`;
    router.replace(url, { scroll: false });
  }, [enableUrlSync, router]);

  // 디바운스된 검색
  const debouncedSearch = useMemo(
    () => createDebouncedSearch((searchTerm: string) => {
      setFilterState(prev => {
        const newState = { ...prev, searchTerm };
        persistState(newState);
        updateUrl(newState);
        onFilterChange?.(newState);
        setIsFiltering(false);

        // 검색 분석 추적
        if (searchTerm) {
          trackSearch({
            searchTerm,
            resultCount: 0, // 실제 구현에서는 결과 수를 전달받아야 함
            timestamp: new Date(),
            filters: newState.filters
          });
        }

        return newState;
      });
    }, debounceMs),
    [debounceMs, persistState, updateUrl, onFilterChange]
  );

  // 활성 필터 여부 계산
  const hasActiveFilters = useMemo((): boolean => {
    return (
      filterState.searchTerm !== '' ||
      !!filterState.dateRange.startDate ||
      !!filterState.dateRange.endDate ||
      Object.values(filterState.filters).some(
        value => value !== '' && value !== null && value !== undefined
      )
    );
  }, [filterState]);

  // 액션 함수들
  const setSearchTerm = useCallback((term: string) => {
    setIsFiltering(true);
    debouncedSearch(term);
  }, [debouncedSearch]);

  const setDateRange = useCallback((range: { startDate?: string; endDate?: string }) => {
    setFilterState(prev => {
      const newState = { ...prev, dateRange: range };

      if (!validateFilterCombination({ ...newState.filters, ...range })) {
        console.warn('Invalid filter combination');
        return prev;
      }

      persistState(newState);
      updateUrl(newState);
      onFilterChange?.(newState);
      return newState;
    });
  }, [persistState, updateUrl, onFilterChange]);

  const setFilter = useCallback((key: string, value: unknown) => {
    setFilterState(prev => {
      const newFilters = { ...prev.filters, [key]: value };
      const newState = { ...prev, filters: newFilters };

      if (!validateFilterCombination({ ...newFilters, ...prev.dateRange })) {
        console.warn('Invalid filter combination');
        return prev;
      }

      persistState(newState);
      updateUrl(newState);
      onFilterChange?.(newState);
      return newState;
    });
  }, [persistState, updateUrl, onFilterChange]);

  const setFilters = useCallback((filters: Record<string, any>) => {
    setFilterState(prev => {
      const newState = { ...prev, filters };

      if (!validateFilterCombination({ ...filters, ...prev.dateRange })) {
        console.warn('Invalid filter combination');
        return prev;
      }

      persistState(newState);
      updateUrl(newState);
      onFilterChange?.(newState);
      return newState;
    });
  }, [persistState, updateUrl, onFilterChange]);

  const setSorting = useCallback((sortBy: string, sortOrder: 'asc' | 'desc') => {
    setFilterState(prev => {
      const newState = { ...prev, sortBy, sortOrder };
      persistState(newState);
      updateUrl(newState);
      onFilterChange?.(newState);
      return newState;
    });
  }, [persistState, updateUrl, onFilterChange]);

  const clearAllFilters = useCallback(() => {
    const clearedState: FilterState = {
      searchTerm: '',
      dateRange: {},
      filters: {},
      sortBy: undefined,
      sortOrder: 'desc'
    };

    setFilterState(clearedState);
    persistState(clearedState);
    updateUrl(clearedState);
    onFilterChange?.(clearedState);
  }, [persistState, updateUrl, onFilterChange]);

  const clearFilter = useCallback((key: string) => {
    setFilterState(prev => {
      if (key === 'searchTerm') {
        const newState = { ...prev, searchTerm: '' };
        persistState(newState);
        updateUrl(newState);
        onFilterChange?.(newState);
        return newState;
      } else if (key === 'dateRange') {
        const newState = { ...prev, dateRange: {} };
        persistState(newState);
        updateUrl(newState);
        onFilterChange?.(newState);
        return newState;
      } else {
        const newFilters = { ...prev.filters };
        delete newFilters[key];
        const newState = { ...prev, filters: newFilters };
        persistState(newState);
        updateUrl(newState);
        onFilterChange?.(newState);
        return newState;
      }
    });
  }, [persistState, updateUrl, onFilterChange]);

  // 저장된 필터 관리
  const saveFilter = useCallback((name: string) => {
    if (typeof window !== 'undefined') {
      try {
        const savedFilters = JSON.parse(localStorage.getItem(`${persistKey}_saved`) || '[]');
        const newFilter = {
          name,
          filters: filterState,
          createdAt: new Date().toISOString()
        };

        const existingIndex = savedFilters.findIndex((f: any) => f.name === name);
        if (existingIndex >= 0) {
          savedFilters[existingIndex] = newFilter;
        } else {
          savedFilters.push(newFilter);
        }

        // 최대 개수 제한
        if (savedFilters.length > maxSearchHistory) {
          savedFilters.splice(0, savedFilters.length - maxSearchHistory);
        }

        localStorage.setItem(`${persistKey}_saved`, JSON.stringify(savedFilters));
      } catch (error) {
        console.warn('Failed to save filter:', error);
      }
    }
  }, [filterState, persistKey, maxSearchHistory]);

  const loadFilter = useCallback((name: string) => {
    if (typeof window !== 'undefined') {
      try {
        const savedFilters = JSON.parse(localStorage.getItem(`${persistKey}_saved`) || '[]');
        const filter = savedFilters.find((f: any) => f.name === name);

        if (filter) {
          setFilterState(filter.filters);
          persistState(filter.filters);
          updateUrl(filter.filters);
          onFilterChange?.(filter.filters);
        }
      } catch (error) {
        console.warn('Failed to load filter:', error);
      }
    }
  }, [persistKey, persistState, updateUrl, onFilterChange]);

  const deleteSavedFilter = useCallback((name: string) => {
    if (typeof window !== 'undefined') {
      try {
        const savedFilters = JSON.parse(localStorage.getItem(`${persistKey}_saved`) || '[]');
        const filteredSaved = savedFilters.filter((f: any) => f.name !== name);
        localStorage.setItem(`${persistKey}_saved`, JSON.stringify(filteredSaved));
      } catch (error) {
        console.warn('Failed to delete saved filter:', error);
      }
    }
  }, [persistKey]);

  const getSavedFilters = useCallback(() => {
    if (typeof window !== 'undefined') {
      try {
        return JSON.parse(localStorage.getItem(`${persistKey}_saved`) || '[]');
      } catch (error) {
        console.warn('Failed to get saved filters:', error);
        return [];
      }
    }
    return [];
  }, [persistKey]);

  // 유틸리티 함수들
  const buildQueryParams = useCallback(() => {
    return buildSearchQuery({
      searchText: filterState.searchTerm,
      dateRange: filterState.dateRange,
      filters: filterState.filters,
      sortBy: filterState.sortBy,
      sortOrder: filterState.sortOrder
    });
  }, [filterState]);

  const exportFilterState = useCallback(() => {
    return prepareFilterStateForExport(
      filterState.filters,
      filterState.searchTerm,
      filterState.dateRange
    );
  }, [filterState]);

  const getFilteredData = useCallback(<T,>(data: T[], searchFields: string[]): T[] => {
    if (!hasActiveFilters) return data;

    let filtered = [...data];

    // 텍스트 검색 적용
    if (filterState.searchTerm) {
      const normalizedTerm = normalizeKoreanText(filterState.searchTerm);
      filtered = filtered.filter(item =>
        searchFields.some(field => {
          const value = (item as any)[field];
          if (value && typeof value === 'string') {
            return normalizeKoreanText(value).includes(normalizedTerm);
          }
          return false;
        })
      );
    }

    // 기타 필터 적용
    Object.entries(filterState.filters).forEach(([key, value]) => {
      if (value !== '' && value !== null && value !== undefined) {
        filtered = filtered.filter(item => {
          const itemValue = (item as any)[key];
          if (Array.isArray(value)) {
            return value.includes(itemValue);
          }
          return itemValue === value;
        });
      }
    });

    // 날짜 범위 필터 적용 (필요시 구현)
    // 정렬 적용
    if (filterState.sortBy) {
      filtered.sort((a, b) => {
        const aValue = (a as any)[filterState.sortBy!];
        const bValue = (b as any)[filterState.sortBy!];

        if (aValue < bValue) return filterState.sortOrder === 'asc' ? -1 : 1;
        if (aValue > bValue) return filterState.sortOrder === 'asc' ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [filterState, hasActiveFilters]);

  return {
    // 상태
    filterState,
    isFiltering,
    hasActiveFilters,

    // 액션
    setSearchTerm,
    setDateRange,
    setFilter,
    setFilters,
    setSorting,
    clearAllFilters,
    clearFilter,

    // 필터 관리
    saveFilter,
    loadFilter,
    deleteSavedFilter,
    getSavedFilters,

    // 유틸리티
    buildQueryParams,
    exportFilterState,
    getFilteredData
  };
};
```


#### 📄 src\hooks\useAdvancedSearch.tsx

```typescript
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { DateRange } from '@/components/DateRangePicker';

// Search filter types for different entities
export interface BaseSearchFilters {
  search: string;
  dateRange: DateRange;
  sortBy: string;
  sortOrder: 'asc' | 'desc';
}

export interface ItemSearchFilters extends BaseSearchFilters {
  itemType: string;
  carModel: string;
  stockLevel: {
    min: number | null;
    max: number | null;
  };
  priceRange: {
    min: number | null;
    max: number | null;
  };
  location: string;
  hasMinStock: boolean | null;
  isLowStock: boolean | null;
}

export interface CompanySearchFilters extends BaseSearchFilters {
  companyType: string;
  region: string;
  paymentTerms: string;
  contactPerson: string;
  isActive: boolean | null;
}

export interface BOMSearchFilters extends BaseSearchFilters {
  parentItem: string;
  childItem: string;
  hierarchyLevel: number | null;
  quantityRange: {
    min: number | null;
    max: number | null;
  };
}

export interface TransactionSearchFilters extends BaseSearchFilters {
  transactionType: string;
  itemCode: string;
  companyCode: string;
  amountRange: {
    min: number | null;
    max: number | null;
  };
  status: string;
}

// Search preset interface
export interface SearchPreset {
  id: string;
  name: string;
  description?: string;
  filters: any;
  entityType: 'items' | 'companies' | 'bom' | 'transactions';
  isDefault?: boolean;
  createdAt: Date;
}

// Default presets for each entity type
export const DEFAULT_PRESETS: Record<string, SearchPreset[]> = {
  items: [
    {
      id: 'low-stock-items',
      name: '재고부족품목',
      description: '현재고가 최소재고 이하인 품목',
      filters: { isLowStock: true },
      entityType: 'items',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'high-value-items',
      name: '고가품목',
      description: '단가 100만원 이상 품목',
      filters: { priceRange: { min: 1000000, max: null } },
      entityType: 'items',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'material-items',
      name: '자재품목',
      description: '자재 타입 품목만',
      filters: { itemType: 'MATERIAL' },
      entityType: 'items',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'product-items',
      name: '제품품목',
      description: '제품 타입 품목만',
      filters: { itemType: 'PRODUCT' },
      entityType: 'items',
      isDefault: true,
      createdAt: new Date()
    }
  ],
  companies: [
    {
      id: 'customer-companies',
      name: '고객사',
      description: '고객사만 표시',
      filters: { companyType: 'CUSTOMER' },
      entityType: 'companies',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'supplier-companies',
      name: '공급사',
      description: '공급사만 표시',
      filters: { companyType: 'SUPPLIER' },
      entityType: 'companies',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'recent-companies',
      name: '최근거래처',
      description: '최근 1개월 거래한 거래처',
      filters: {
        dateRange: {
          startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          endDate: new Date()
        }
      },
      entityType: 'companies',
      isDefault: true,
      createdAt: new Date()
    }
  ],
  transactions: [
    {
      id: 'recent-receiving',
      name: '최근입고',
      description: '최근 1주일 입고 내역',
      filters: {
        transactionType: '입고',
        dateRange: {
          startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          endDate: new Date()
        }
      },
      entityType: 'transactions',
      isDefault: true,
      createdAt: new Date()
    },
    {
      id: 'large-transactions',
      name: '대량거래',
      description: '수량 1000개 이상 거래',
      filters: { amountRange: { min: 1000, max: null } },
      entityType: 'transactions',
      isDefault: true,
      createdAt: new Date()
    }
  ]
};

// Debounce hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Local storage utilities
const STORAGE_KEYS = {
  SEARCH_PRESETS: 'erp_search_presets',
  SEARCH_HISTORY: 'erp_search_history'
};

function loadFromStorage<T>(key: string, defaultValue: T): T {
  if (typeof window === 'undefined') return defaultValue;

  try {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : defaultValue;
  } catch {
    return defaultValue;
  }
}

function saveToStorage<T>(key: string, value: T): void {
  if (typeof window === 'undefined') return;

  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    console.warn('Failed to save to localStorage:', error);
  }
}

// Main hook
export function useAdvancedSearch<T extends BaseSearchFilters>(
  entityType: 'items' | 'companies' | 'bom' | 'transactions',
  initialFilters: T,
  searchFn?: (filters: T) => Promise<any[]>,
  debounceMs: number = 300
) {
  const router = useRouter();
  const searchParams = useSearchParams();

  // State
  const [filters, setFilters] = useState<T>(initialFilters);
  const [results, setResults] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchHistory, setSearchHistory] = useState<string[]>([]);
  const [savedPresets, setSavedPresets] = useState<SearchPreset[]>([]);

  // Debounced filters
  const debouncedFilters = useDebounce(filters, debounceMs);

  // Load initial data from localStorage
  useEffect(() => {
    const history = loadFromStorage(STORAGE_KEYS.SEARCH_HISTORY, []);
    const presets = loadFromStorage(STORAGE_KEYS.SEARCH_PRESETS, {}) as Record<string, SearchPreset[]>;

    setSearchHistory(history);
    setSavedPresets(presets[entityType] || DEFAULT_PRESETS[entityType] || []);
  }, [entityType]);

  // URL synchronization
  useEffect(() => {
    if (typeof window === 'undefined') return;

    // Read filters from URL on mount
    const urlFilters = { ...initialFilters };
    let hasUrlParams = false;

    searchParams?.forEach((value, key) => {
      if (key in urlFilters) {
        hasUrlParams = true;
        try {
          // Handle different filter types
          if (key === 'dateRange') {
            const range = JSON.parse(value);
            urlFilters[key as keyof T] = {
              startDate: range.startDate ? new Date(range.startDate) : null,
              endDate: range.endDate ? new Date(range.endDate) : null
            } as any;
          } else if (key.includes('Range') || key === 'stockLevel') {
            urlFilters[key as keyof T] = JSON.parse(value) as T[keyof T];
          } else if (typeof urlFilters[key as keyof T] === 'boolean') {
            urlFilters[key as keyof T] = (value === 'true') as T[keyof T];
          } else if (typeof urlFilters[key as keyof T] === 'number') {
            urlFilters[key as keyof T] = Number(value) as T[keyof T];
          } else {
            urlFilters[key as keyof T] = value as T[keyof T];
          }
        } catch {
          // Skip invalid JSON values
        }
      }
    });

    if (hasUrlParams) {
      setFilters(urlFilters);
    }
  }, [searchParams, initialFilters]);

  // Update URL when filters change
  const updateURL = useCallback((newFilters: T) => {
    const params = new URLSearchParams();

    Object.entries(newFilters).forEach(([key, value]) => {
      if (value !== null && value !== undefined && value !== '' &&
          !(Array.isArray(value) && value.length === 0) &&
          !(typeof value === 'object' && Object.values(value).every(v => v === null || v === undefined || v === ''))) {

        if (typeof value === 'object') {
          params.set(key, JSON.stringify(value));
        } else {
          params.set(key, String(value));
        }
      }
    });

    const newUrl = params.toString() ? `?${params.toString()}` : window.location.pathname;
    router.replace(newUrl, { scroll: false });
  }, [router]);

  // Execute search
  const executeSearch = useCallback(async (searchFilters: T) => {
    if (!searchFn) return;

    setLoading(true);
    setError(null);

    try {
      const searchResults = await searchFn(searchFilters);
      setResults(searchResults);

      // Add to search history if there's a search term
      if (searchFilters.search.trim()) {
        const newHistory = [
          searchFilters.search.trim(),
          ...searchHistory.filter(term => term !== searchFilters.search.trim())
        ].slice(0, 10); // Keep only 10 recent searches

        setSearchHistory(newHistory);
        saveToStorage(STORAGE_KEYS.SEARCH_HISTORY, newHistory);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : '검색 중 오류가 발생했습니다.');
      setResults([]);
    } finally {
      setLoading(false);
    }
  }, [searchFn, searchHistory]);

  // Auto-search when debounced filters change
  useEffect(() => {
    executeSearch(debouncedFilters);
    updateURL(debouncedFilters);
  }, [debouncedFilters, executeSearch, updateURL]);

  // Filter manipulation functions
  const updateFilter = useCallback(<K extends keyof T>(key: K, value: T[K]) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);

  const updateFilters = useCallback((newFilters: Partial<T>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  }, []);

  const resetFilters = useCallback(() => {
    setFilters(initialFilters);
  }, [initialFilters]);

  const clearFilter = useCallback(<K extends keyof T>(key: K) => {
    const clearedValue = (() => {
      const initialValue = initialFilters[key];
      if (typeof initialValue === 'string') return '' as T[K];
      if (typeof initialValue === 'boolean') return null as T[K];
      if (typeof initialValue === 'number') return null as T[K];
      if (Array.isArray(initialValue)) return [] as T[K];
      if (typeof initialValue === 'object' && initialValue !== null) {
        return Object.keys(initialValue).reduce((acc, k) => {
          acc[k] = null;
          return acc;
        }, {} as any) as T[K];
      }
      return null as T[K];
    })();

    updateFilter(key, clearedValue);
  }, [initialFilters, updateFilter]);

  // Preset management
  const savePreset = useCallback((name: string, description?: string) => {
    const preset: SearchPreset = {
      id: Date.now().toString(),
      name,
      description,
      filters: { ...filters },
      entityType,
      createdAt: new Date()
    };

    const newPresets = [...savedPresets, preset];
    setSavedPresets(newPresets);

    const allPresets = loadFromStorage(STORAGE_KEYS.SEARCH_PRESETS, {}) as Record<string, SearchPreset[]>;
    allPresets[entityType] = newPresets;
    saveToStorage(STORAGE_KEYS.SEARCH_PRESETS, allPresets);

    return preset;
  }, [filters, savedPresets, entityType]);

  const loadPreset = useCallback((preset: SearchPreset) => {
    setFilters({ ...initialFilters, ...preset.filters });
  }, [initialFilters]);

  const deletePreset = useCallback((presetId: string) => {
    const newPresets = savedPresets.filter(p => p.id !== presetId && !p.isDefault);
    setSavedPresets(newPresets);

    const allPresets = loadFromStorage(STORAGE_KEYS.SEARCH_PRESETS, {}) as Record<string, SearchPreset[]>;
    allPresets[entityType] = newPresets;
    saveToStorage(STORAGE_KEYS.SEARCH_PRESETS, allPresets);
  }, [savedPresets, entityType]);

  // Helper functions
  const hasActiveFilters = useMemo(() => {
    return Object.entries(filters).some(([key, value]) => {
      const initial = initialFilters[key as keyof T];

      if (value === initial) return false;
      if (value === null || value === undefined || value === '') return false;
      if (Array.isArray(value) && value.length === 0) return false;
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        return Object.values(value).some(v => v !== null && v !== undefined && v !== '');
      }

      return true;
    });
  }, [filters, initialFilters]);

  const getActiveFilterCount = useMemo(() => {
    return Object.entries(filters).reduce((count, [key, value]) => {
      const initial = initialFilters[key as keyof T];

      if (value === initial) return count;
      if (value === null || value === undefined || value === '') return count;
      if (Array.isArray(value) && value.length === 0) return count;
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const hasActiveValues = Object.values(value).some(v => v !== null && v !== undefined && v !== '');
        return hasActiveValues ? count + 1 : count;
      }

      return count + 1;
    }, 0);
  }, [filters, initialFilters]);

  return {
    // State
    filters,
    results,
    loading,
    error,
    searchHistory,
    savedPresets,

    // Actions
    updateFilter,
    updateFilters,
    resetFilters,
    clearFilter,
    executeSearch: () => executeSearch(filters),

    // Preset management
    savePreset,
    loadPreset,
    deletePreset,

    // Helpers
    hasActiveFilters,
    getActiveFilterCount,

    // For external components
    setResults,
    setLoading,
    setError
  };
}
```


#### 📄 src\hooks\useCompanies.ts

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// API Response types
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Company interface matching the actual database schema
export interface Company {
  company_id: number;
  company_code: string;
  company_name: string;
  company_type: 'CUSTOMER' | 'SUPPLIER' | 'PARTNER' | 'OTHER';
  business_number?: string;
  ceo_name?: string;
  phone?: string;
  fax?: string;
  email?: string;
  address?: string;
  contact_person?: string;
  contact_phone?: string;
  payment_terms?: string;
  credit_limit?: number;
  notes?: string;
  is_active: boolean;
}

// Create company data type (without company_id)
export type CreateCompanyData = Omit<Company, 'company_id'>;

// Update company data type
export type UpdateCompanyData = Partial<CreateCompanyData> & { id: number };

// Companies query parameters
export interface CompaniesQueryParams {
  type?: string;
  search?: string;
}

// Query key factory for companies
export const companiesKeys = {
  all: ['companies'] as const,
  lists: () => [...companiesKeys.all, 'list'] as const,
  list: (params: CompaniesQueryParams) => [...companiesKeys.lists(), params] as const,
  details: () => [...companiesKeys.all, 'detail'] as const,
  detail: (id: number) => [...companiesKeys.details(), id] as const,
};

// Fetch companies with optional filtering
async function fetchCompanies(params: CompaniesQueryParams = {}): Promise<Company[]> {
  const searchParams = new URLSearchParams();

  if (params.type) {
    searchParams.append('type', params.type);
  }

  if (params.search) {
    searchParams.append('search', params.search);
  }

  const response = await fetch(`/api/companies?${searchParams}`);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<Company[]> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch companies');
  }

  return data.data || [];
}

// Create new company
async function createCompany(companyData: CreateCompanyData): Promise<Company> {
  const response = await fetch('/api/companies', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(companyData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<Company> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to create company');
  }

  return data.data!;
}

// Update existing company
async function updateCompany(companyData: UpdateCompanyData): Promise<Company> {
  const response = await fetch('/api/companies', {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(companyData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<Company> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to update company');
  }

  return data.data!;
}

// Delete company (soft delete)
async function deleteCompany(id: number): Promise<void> {
  const response = await fetch(`/api/companies?id=${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<void> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to delete company');
  }
}

// Hook for fetching companies with caching and error handling
export function useCompanies(params: CompaniesQueryParams = {}) {
  return useQuery({
    queryKey: companiesKeys.list(params),
    queryFn: () => fetchCompanies(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

// Hook for creating companies with optimistic updates
export function useCreateCompany() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createCompany,
    onSuccess: (newCompany) => {
      // Invalidate and refetch companies queries
      queryClient.invalidateQueries({ queryKey: companiesKeys.lists() });

      // Optionally add optimistic update
      queryClient.setQueriesData<Company[]>(
        { queryKey: companiesKeys.lists() },
        (oldCompanies) => {
          if (!oldCompanies) return [newCompany];
          return [newCompany, ...oldCompanies];
        }
      );
    },
    onError: (error) => {
      console.error('Failed to create company:', error);
    },
  });
}

// Hook for updating companies with optimistic updates
export function useUpdateCompany() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateCompany,
    onSuccess: (updatedCompany) => {
      // Invalidate and refetch companies queries
      queryClient.invalidateQueries({ queryKey: companiesKeys.lists() });

      // Update specific company in cache
      queryClient.setQueriesData<Company[]>(
        { queryKey: companiesKeys.lists() },
        (oldCompanies) => {
          if (!oldCompanies) return [updatedCompany];
          return oldCompanies.map(company =>
            company.company_id === updatedCompany.company_id ? updatedCompany : company
          );
        }
      );
    },
    onError: (error) => {
      console.error('Failed to update company:', error);
    },
  });
}

// Hook for deleting companies with optimistic updates
export function useDeleteCompany() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteCompany,
    onSuccess: (_, deletedId) => {
      // Invalidate and refetch companies queries
      queryClient.invalidateQueries({ queryKey: companiesKeys.lists() });

      // Remove company from cache
      queryClient.setQueriesData<Company[]>(
        { queryKey: companiesKeys.lists() },
        (oldCompanies) => {
          if (!oldCompanies) return [];
          return oldCompanies.filter(company => company.company_id !== deletedId);
        }
      );
    },
    onError: (error) => {
      console.error('Failed to delete company:', error);
    },
  });
}

// Hook for prefetching companies (useful for hover states, etc.)
export function usePrefetchCompanies() {
  const queryClient = useQueryClient();

  return (params: CompaniesQueryParams = {}) => {
    queryClient.prefetchQuery({
      queryKey: companiesKeys.list(params),
      queryFn: () => fetchCompanies(params),
      staleTime: 5 * 60 * 1000,
    });
  };
}
```


#### 📄 src\hooks\useConfirm.tsx

```typescript
'use client';

import { useState, useCallback } from 'react';
import ConfirmModal, { ConfirmType } from '@/components/ConfirmModal';
import { useToast } from '@/contexts/ToastContext';

interface ConfirmOptions {
  title?: string;
  message?: string;
  confirmText?: string;
  cancelText?: string;
  type?: ConfirmType;
}

interface ConfirmState {
  isOpen: boolean;
  options: ConfirmOptions;
  resolve: ((value: boolean) => void) | null;
  loading: boolean;
}

export const useConfirm = () => {
  const [state, setState] = useState<ConfirmState>({
    isOpen: false,
    options: {},
    resolve: null,
    loading: false
  });
  const { success, error } = useToast();

  const confirm = useCallback(async (options: ConfirmOptions = {}): Promise<boolean> => {
    return new Promise((resolve) => {
      setState({
        isOpen: true,
        options,
        resolve,
        loading: false
      });
    });
  }, []);

  // Korean convenience methods
  const deleteConfirm = useCallback(async (
    title: string = '삭제 확인',
    message: string = '정말 삭제하시겠습니까?'
  ): Promise<boolean> => {
    return confirm({
      title,
      message,
      type: 'delete',
      confirmText: '삭제',
      cancelText: '취소'
    });
  }, [confirm]);

  const warningConfirm = useCallback(async (
    title: string = '확인 필요',
    message: string = '이 작업을 진행하시겠습니까?'
  ): Promise<boolean> => {
    return confirm({
      title,
      message,
      type: 'warning',
      confirmText: '확인',
      cancelText: '취소'
    });
  }, [confirm]);

  const dangerConfirm = useCallback(async (
    title: string = '위험한 작업',
    message: string = '이 작업을 계속하시겠습니까?'
  ): Promise<boolean> => {
    return confirm({
      title,
      message,
      type: 'danger',
      confirmText: '계속',
      cancelText: '취소'
    });
  }, [confirm]);

  // Enhanced delete confirm with automatic toast notifications
  const deleteWithToast = useCallback(async (
    deleteAction: () => Promise<void>,
    options: {
      title?: string;
      message?: string;
      itemName?: string;
      successMessage?: string;
      errorMessage?: string;
    } = {}
  ): Promise<boolean> => {
    const {
      title = '삭제 확인',
      message = options.itemName
        ? `"${options.itemName}"을(를) 정말 삭제하시겠습니까?`
        : '정말 삭제하시겠습니까?',
      successMessage = '성공적으로 삭제되었습니다.',
      errorMessage = '삭제에 실패했습니다.'
    } = options;

    try {
      const confirmed = await deleteConfirm(title, message);

      if (!confirmed) {
        return false;
      }

      setState(prev => ({ ...prev, loading: true }));

      await deleteAction();

      setState(prev => ({ ...prev, loading: false, isOpen: false }));
      success('삭제 완료', successMessage);

      return true;
    } catch (err) {
      setState(prev => ({ ...prev, loading: false }));
      console.error('Delete action failed:', err);
      error('삭제 실패', errorMessage);
      return false;
    }
  }, [deleteConfirm, success, error]);

  const handleConfirm = useCallback(() => {
    if (state.resolve && !state.loading) {
      state.resolve(true);
      setState({
        isOpen: false,
        options: {},
        resolve: null,
        loading: false
      });
    }
  }, [state.resolve, state.loading]);

  const handleCancel = useCallback(() => {
    if (state.resolve && !state.loading) {
      state.resolve(false);
      setState({
        isOpen: false,
        options: {},
        resolve: null,
        loading: false
      });
    }
  }, [state.resolve, state.loading]);

  const setLoading = useCallback((loading: boolean) => {
    setState(prev => ({ ...prev, loading }));
  }, []);

  const ConfirmDialog = useCallback(() => (
    <ConfirmModal
      isOpen={state.isOpen}
      onConfirm={handleConfirm}
      onCancel={handleCancel}
      type={state.options.type}
      title={state.options.title}
      message={state.options.message}
      confirmText={state.options.confirmText}
      cancelText={state.options.cancelText}
      loading={state.loading}
    />
  ), [state, handleConfirm, handleCancel]);

  return {
    confirm,
    deleteConfirm,
    warningConfirm,
    dangerConfirm,
    deleteWithToast,
    setLoading,
    ConfirmDialog
  };
};

export default useConfirm;
```


#### 📄 src\hooks\useDashboardData.tsx

```typescript
/**
 * Dashboard data hooks for real-time data fetching
 * Handles auto-refresh, error handling, and state management
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { calculateKPIs } from '../utils/chartUtils';

// Types for dashboard data
export interface DashboardStats {
  totalItems: number;
  activeCompanies: number;
  monthlyVolume: number;
  lowStockItems: number;
  volumeChange: number;
  trends: {
    items: number;
    companies: number;
    volume: number;
    lowStock: number;
  };
}

export interface ChartData {
  stocks: Array<{
    name: string;
    현재고: number;
    최소재고: number;
    안전재고: number;
    code: string;
  }>;
  transactions: Array<{
    date: string;
    입고: number;
    출고: number;
    생산: number;
  }>;
  monthlyTrends: Array<{
    month: string;
    입고: number;
    출고: number;
    생산: number;
  }>;
}

export interface AlertData {
  lowStockItems: Array<{
    item_id: number;
    item_code: string;
    item_name: string;
    current_stock: number;
    minimum_stock: number;
    status: '위험' | '주의';
  }>;
  recentTransactions: Array<{
    transaction_id: number;
    transaction_type: string;
    item_name: string;
    quantity: number;
    transaction_date: string;
    status: string;
  }>;
}

export interface DashboardData {
  stats: DashboardStats;
  charts: ChartData;
  alerts: AlertData;
  lastUpdated: Date;
}

// Refresh intervals in milliseconds
export const REFRESH_INTERVALS = {
  '30초': 30000,
  '1분': 60000,
  '5분': 300000,
  '수동': 0
} as const;

export type RefreshInterval = keyof typeof REFRESH_INTERVALS;

// Custom hook for dashboard data management
export const useDashboardData = (
  initialInterval: RefreshInterval = '1분',
  autoStart: boolean = true
) => {
  const [data, setData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const [refreshInterval, setRefreshInterval] = useState<RefreshInterval>(initialInterval);
  const [isAutoRefreshEnabled, setIsAutoRefreshEnabled] = useState(autoStart);
  const [retryCount, setRetryCount] = useState(0);

  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  // Fetch dashboard data
  const fetchDashboardData = useCallback(async (showLoading: boolean = true) => {
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    try {
      if (showLoading) {
        setLoading(true);
      }
      setError(null);

      // Fetch all required data in parallel
      const [statsResponse, chartsResponse, alertsResponse] = await Promise.all([
        fetch('/api/dashboard/stats', { signal }),
        fetch('/api/dashboard/charts', { signal }),
        fetch('/api/dashboard/alerts', { signal })
      ]);

      // Check if any request failed
      if (!statsResponse.ok || !chartsResponse.ok || !alertsResponse.ok) {
        throw new Error('Failed to fetch dashboard data');
      }

      const [statsResult, chartsResult, alertsResult] = await Promise.all([
        statsResponse.json(),
        chartsResponse.json(),
        alertsResponse.json()
      ]);

      // Validate responses
      if (!statsResult.success || !chartsResult.success || !alertsResult.success) {
        throw new Error(
          statsResult.error || chartsResult.error || alertsResult.error || 'Unknown error'
        );
      }

      const newData: DashboardData = {
        stats: statsResult.data,
        charts: chartsResult.data,
        alerts: alertsResult.data,
        lastUpdated: new Date()
      };

      setData(newData);
      setLastUpdated(new Date());
      setRetryCount(0);

    } catch (err: any) {
      if (err.name === 'AbortError') {
        return; // Request was cancelled, ignore
      }

      console.error('Dashboard data fetch error:', err);
      setError(err.message || 'Failed to fetch dashboard data');
      setRetryCount(prev => prev + 1);
    } finally {
      if (showLoading) {
        setLoading(false);
      }
    }
  }, []);

  // Manual refresh function
  const refresh = useCallback(() => {
    fetchDashboardData(true);
  }, [fetchDashboardData]);

  // Auto-refresh with exponential backoff on errors
  useEffect(() => {
    if (!isAutoRefreshEnabled || refreshInterval === '수동') {
      return;
    }

    const interval = REFRESH_INTERVALS[refreshInterval];
    if (interval <= 0) return;

    // Calculate delay with exponential backoff for errors
    const baseDelay = interval;
    const errorDelay = retryCount > 0 ? Math.min(baseDelay * Math.pow(2, retryCount - 1), 300000) : baseDelay;

    intervalRef.current = setTimeout(() => {
      fetchDashboardData(false); // Silent refresh for auto-updates
    }, errorDelay);

    return () => {
      if (intervalRef.current) {
        clearTimeout(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [fetchDashboardData, refreshInterval, isAutoRefreshEnabled, retryCount]);

  // Initial data fetch
  useEffect(() => {
    fetchDashboardData(true);

    return () => {
      // Cleanup on unmount
      if (intervalRef.current) {
        clearTimeout(intervalRef.current);
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchDashboardData]);

  // Pause auto-refresh when tab is not visible
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        setIsAutoRefreshEnabled(false);
      } else {
        setIsAutoRefreshEnabled(true);
        // Refresh data when tab becomes visible again
        fetchDashboardData(false);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [fetchDashboardData]);

  return {
    data,
    loading,
    error,
    lastUpdated,
    refreshInterval,
    isAutoRefreshEnabled,
    retryCount,
    setRefreshInterval,
    setIsAutoRefreshEnabled,
    refresh
  };
};

// Hook for real-time stats updates
export const useRealTimeStats = (refreshInterval: RefreshInterval = '1분') => {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchStats = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/dashboard/stats');
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Failed to fetch stats');
      }

      setStats(result.data);
    } catch (err: any) {
      console.error('Stats fetch error:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStats();

    if (refreshInterval === '수동') return;

    const interval = REFRESH_INTERVALS[refreshInterval];
    const timer = setInterval(fetchStats, interval);

    return () => clearInterval(timer);
  }, [fetchStats, refreshInterval]);

  return { stats, loading, error, refresh: fetchStats };
};

// Hook for chart data updates
export const useChartData = (refreshInterval: RefreshInterval = '5분') => {
  const [chartData, setChartData] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchChartData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/dashboard/charts');
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Failed to fetch chart data');
      }

      setChartData(result.data);
    } catch (err: any) {
      console.error('Chart data fetch error:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChartData();

    if (refreshInterval === '수동') return;

    const interval = REFRESH_INTERVALS[refreshInterval];
    const timer = setInterval(fetchChartData, interval);

    return () => clearInterval(timer);
  }, [fetchChartData, refreshInterval]);

  return { chartData, loading, error, refresh: fetchChartData };
};

// Hook for alerts and notifications
export const useAlerts = (refreshInterval: RefreshInterval = '1분') => {
  const [alerts, setAlerts] = useState<AlertData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAlerts = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/dashboard/alerts');
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Failed to fetch alerts');
      }

      setAlerts(result.data);
    } catch (err: any) {
      console.error('Alerts fetch error:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchAlerts();

    if (refreshInterval === '수동') return;

    const interval = REFRESH_INTERVALS[refreshInterval];
    const timer = setInterval(fetchAlerts, interval);

    return () => clearInterval(timer);
  }, [fetchAlerts, refreshInterval]);

  return { alerts, loading, error, refresh: fetchAlerts };
};

// WebSocket hook for real-time updates (optional)
export const useWebSocketUpdates = (enabled: boolean = false) => {
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [connected, setConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);

  useEffect(() => {
    if (!enabled) return;

    const websocket = new WebSocket(`ws://localhost:3001/api/dashboard/ws`);

    websocket.onopen = () => {
      setConnected(true);
      console.log('WebSocket connected');
    };

    websocket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        setLastMessage(message);
      } catch (err) {
        console.error('WebSocket message parse error:', err);
      }
    };

    websocket.onclose = () => {
      setConnected(false);
      console.log('WebSocket disconnected');
    };

    websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
      setConnected(false);
    };

    setWs(websocket);

    return () => {
      websocket.close();
    };
  }, [enabled]);

  return { ws, connected, lastMessage };
};
```


#### 📄 src\hooks\useItems.ts

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// API Response types

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Item interface matching the actual database schema
export interface Item {
  item_id: number;
  item_code: string;
  item_name: string;
  category: string | null;
  item_type: string | null;
  material_type: string | null;
  vehicle_model?: string | null;
  material?: string | null;
  spec?: string | null;
  unit: string;
  thickness?: number | null;
  width?: number | null;
  height?: number | null;
  specific_gravity?: number | null;
  mm_weight?: number | null;
  daily_requirement?: number | null;
  blank_size?: number | null;
  current_stock: number;
  safety_stock?: number | null;
  price?: number | null;
  unit_price?: number | null;
  min_stock_level?: number | null;
  location?: string | null;
  description?: string | null;
  is_active: boolean;
}

export type CreateItemData = Omit<Item, 'item_id'>;
export type UpdateItemData = Partial<CreateItemData> & { id: number };

export interface ItemsQueryParams {
  category?: string;
  itemType?: string;
  materialType?: string;
  vehicleModel?: string;
  search?: string;
}

// Query key factory for items
export const itemsKeys = {
  all: ['items'] as const,
  lists: () => [...itemsKeys.all, 'list'] as const,
  list: (params: ItemsQueryParams) => [...itemsKeys.lists(), params] as const,
  details: () => [...itemsKeys.all, 'detail'] as const,
  detail: (id: number) => [...itemsKeys.details(), id] as const,
};

// Fetch items with optional filtering
async function fetchItems(params: ItemsQueryParams = {}): Promise<Item[]> {
  const searchParams = new URLSearchParams();

  if (params.category) {
    searchParams.append('category', params.category);
  }

  if (params.itemType && params.itemType !== 'ALL') {
    searchParams.append('itemType', params.itemType);
  }

  if (params.materialType && params.materialType !== 'ALL') {
    searchParams.append('materialType', params.materialType);
  }

  if (params.vehicleModel) {
    searchParams.append('vehicleModel', params.vehicleModel);
  }

  if (params.search) {
    searchParams.append('search', params.search);
  }

  const queryString = searchParams.toString();
  const response = await fetch(queryString ? `/api/items?${queryString}` : '/api/items');

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<{ items?: Item[] }> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch items');
  }

  if (Array.isArray(data.data)) {
    return data.data as unknown as Item[];
  }

  if (data.data && Array.isArray((data.data as any).items)) {
    return (data.data as any).items as Item[];
  }

  return [];
}

// Create new item
async function createItem(itemData: CreateItemData): Promise<Item> {
  const response = await fetch('/api/items', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(itemData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<Item> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to create item');
  }

  return data.data!;
}

// Update existing item
async function updateItem(itemData: UpdateItemData): Promise<Item> {
  const response = await fetch('/api/items', {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(itemData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<Item> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to update item');
  }

  return data.data!;
}

// Delete item (soft delete)
async function deleteItem(id: number): Promise<void> {
  const response = await fetch(`/api/items?id=${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<void> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to delete item');
  }
}

// Hook for fetching items with caching and error handling
export function useItems(params: ItemsQueryParams = {}) {
  return useQuery({
    queryKey: itemsKeys.list(params),
    queryFn: () => fetchItems(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

// Hook for creating items with optimistic updates
export function useCreateItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createItem,
    onSuccess: (newItem) => {
      // Invalidate and refetch items queries
      queryClient.invalidateQueries({ queryKey: itemsKeys.lists() });

      // Optionally add optimistic update
      queryClient.setQueriesData<Item[]>(
        { queryKey: itemsKeys.lists() },
        (oldItems) => {
          if (!oldItems) return [newItem];
          return [newItem, ...oldItems];
        }
      );
    },
    onError: (error) => {
      console.error('Failed to create item:', error);
    },
  });
}

// Hook for updating items with optimistic updates
export function useUpdateItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateItem,
    onSuccess: (updatedItem) => {
      // Invalidate and refetch items queries
      queryClient.invalidateQueries({ queryKey: itemsKeys.lists() });

      // Update specific item in cache
      queryClient.setQueriesData<Item[]>(
        { queryKey: itemsKeys.lists() },
        (oldItems) => {
          if (!oldItems) return [updatedItem];
          return oldItems.map(item =>
            item.item_id === updatedItem.item_id ? updatedItem : item
          );
        }
      );
    },
    onError: (error) => {
      console.error('Failed to update item:', error);
    },
  });
}

// Hook for deleting items with optimistic updates
export function useDeleteItem() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteItem,
    onSuccess: (_, deletedId) => {
      // Invalidate and refetch items queries
      queryClient.invalidateQueries({ queryKey: itemsKeys.lists() });

      // Remove item from cache
      queryClient.setQueriesData<Item[]>(
        { queryKey: itemsKeys.lists() },
        (oldItems) => {
          if (!oldItems) return [];
          return oldItems.filter(item => item.item_id !== deletedId);
        }
      );
    },
    onError: (error) => {
      console.error('Failed to delete item:', error);
    },
  });
}

// Hook for prefetching items (useful for hover states, etc.)
export function usePrefetchItems() {
  const queryClient = useQueryClient();

  return (params: ItemsQueryParams = {}) => {
    queryClient.prefetchQuery({
      queryKey: itemsKeys.list(params),
      queryFn: () => fetchItems(params),
      staleTime: 5 * 60 * 1000,
    });
  };
}
```


#### 📄 src\hooks\useStockStatus.ts

```typescript
import { useQuery, useQueryClient } from '@tanstack/react-query';

// API Response types
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Stock status interface
export interface StockStatus {
  item_id: number;
  item_code: string;
  item_name: string;
  item_type: string;
  spec?: string;
  unit: string;
  current_stock: number;
  min_stock_level?: number;
  max_stock_level?: number;
  stock_status: '정상' | '주의' | '부족' | '과재고';
  last_transaction_date?: string;
  location?: string;
}

// Stock summary interface
export interface StockSummary {
  total_items: number;
  normal_stock: number;
  low_stock: number;
  out_of_stock: number;
  excess_stock: number;
  total_value: number;
  categories: {
    category: string;
    count: number;
    value: number;
  }[];
}

// Stock movement interface
export interface StockMovement {
  item_id: number;
  item_code: string;
  item_name: string;
  date: string;
  type: '입고' | '출고' | '생산입고' | '생산출고' | '이동' | '조정';
  quantity: number;
  running_total: number;
}

// Stock query parameters
export interface StockQueryParams {
  item_type?: string;
  status?: string;
  location?: string;
  search?: string;
  low_stock_only?: boolean;
}

// Query key factory for stock data
export const stockKeys = {
  all: ['stock'] as const,
  status: () => [...stockKeys.all, 'status'] as const,
  statusList: (params: StockQueryParams) => [...stockKeys.status(), params] as const,
  summary: () => [...stockKeys.all, 'summary'] as const,
  movements: () => [...stockKeys.all, 'movements'] as const,
  movement: (itemId: number, period?: string) => [...stockKeys.movements(), itemId, period] as const,
  alerts: () => [...stockKeys.all, 'alerts'] as const,
};

// Fetch stock status with optional filtering
async function fetchStockStatus(params: StockQueryParams = {}): Promise<StockStatus[]> {
  const searchParams = new URLSearchParams();

  if (params.item_type) searchParams.append('item_type', params.item_type);
  if (params.status) searchParams.append('status', params.status);
  if (params.location) searchParams.append('location', params.location);
  if (params.search) searchParams.append('search', params.search);
  if (params.low_stock_only) searchParams.append('low_stock_only', 'true');

  const response = await fetch(`/api/inventory/stock?${searchParams}`);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<StockStatus[]> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch stock status');
  }

  return data.data || [];
}

// Fetch stock summary/analytics
async function fetchStockSummary(): Promise<StockSummary> {
  const response = await fetch('/api/inventory/stock/summary');

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<StockSummary> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch stock summary');
  }

  return data.data!;
}

// Fetch stock movements for a specific item
async function fetchStockMovements(itemId: number, period: string = '30d'): Promise<StockMovement[]> {
  const response = await fetch(`/api/inventory/stock/movements?item_id=${itemId}&period=${period}`);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<StockMovement[]> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch stock movements');
  }

  return data.data || [];
}

// Fetch low stock alerts
async function fetchStockAlerts(): Promise<StockStatus[]> {
  const response = await fetch('/api/inventory/stock/alerts');

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<StockStatus[]> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch stock alerts');
  }

  return data.data || [];
}

// Hook for fetching stock status with caching and error handling
export function useStockStatus(params: StockQueryParams = {}) {
  return useQuery({
    queryKey: stockKeys.statusList(params),
    queryFn: () => fetchStockStatus(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

// Hook for fetching stock summary
export function useStockSummary() {
  return useQuery({
    queryKey: stockKeys.summary(),
    queryFn: fetchStockSummary,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
  });
}

// Hook for fetching stock movements for a specific item
export function useStockMovements(itemId: number, period: string = '30d') {
  return useQuery({
    queryKey: stockKeys.movement(itemId, period),
    queryFn: () => fetchStockMovements(itemId, period),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    enabled: !!itemId, // Only run query if itemId is provided
    retry: 2,
  });
}

// Hook for fetching stock alerts (low stock items)
export function useStockAlerts() {
  return useQuery({
    queryKey: stockKeys.alerts(),
    queryFn: fetchStockAlerts,
    staleTime: 2 * 60 * 1000, // 2 minutes (more frequent for alerts)
    gcTime: 5 * 60 * 1000,    // 5 minutes
    refetchOnWindowFocus: true,
    retry: 2,
    refetchInterval: 5 * 60 * 1000, // Auto-refetch every 5 minutes for alerts
  });
}

// Hook for fetching low stock items specifically
export function useLowStockItems() {
  return useStockStatus({ low_stock_only: true });
}

// Hook for prefetching stock data (useful for dashboard or navigation)
export function usePrefetchStock() {
  const queryClient = useQueryClient();

  return {
    prefetchStockStatus: (params: StockQueryParams = {}) => {
      queryClient.prefetchQuery({
        queryKey: stockKeys.statusList(params),
        queryFn: () => fetchStockStatus(params),
        staleTime: 5 * 60 * 1000,
      });
    },
    prefetchStockSummary: () => {
      queryClient.prefetchQuery({
        queryKey: stockKeys.summary(),
        queryFn: fetchStockSummary,
        staleTime: 5 * 60 * 1000,
      });
    },
    prefetchStockAlerts: () => {
      queryClient.prefetchQuery({
        queryKey: stockKeys.alerts(),
        queryFn: fetchStockAlerts,
        staleTime: 2 * 60 * 1000,
      });
    },
  };
}

// Utility function to invalidate all stock-related queries
export function useInvalidateStock() {
  const queryClient = useQueryClient();

  return () => {
    queryClient.invalidateQueries({ queryKey: stockKeys.all });
  };
}

// Utility function to refresh critical stock data
export function useRefreshStockData() {
  const queryClient = useQueryClient();

  return async () => {
    await Promise.all([
      queryClient.invalidateQueries({ queryKey: stockKeys.summary() }),
      queryClient.invalidateQueries({ queryKey: stockKeys.alerts() }),
      queryClient.invalidateQueries({ queryKey: stockKeys.status() }),
    ]);
  };
}
```


#### 📄 src\hooks\useToast.tsx

```typescript
'use client';

import { useContext } from 'react';
import { Undo2, ExternalLink, RotateCcw } from 'lucide-react';
import { ToastContext } from '../contexts/ToastContext';

// Re-export the hook and context for easier imports
export { useToast, ToastProvider } from '../contexts/ToastContext';

// Convenience hook that returns toast methods as an object
export const useToastNotification = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToastNotification must be used within a ToastProvider');
  }

  return {
    // Standard methods
    success: context.success,
    error: context.error,
    warning: context.warning,
    info: context.info,

    // Utility methods
    clear: context.clearToasts,

    // Enhanced methods with actions
    successWithAction: context.successWithAction,
    errorWithAction: context.errorWithAction,
    warningWithAction: context.warningWithAction,
    infoWithAction: context.infoWithAction,
    persistent: context.persistent,

    // Korean-specific convenience methods
    저장완료: (message?: string) => context.success('저장 완료', message),
    삭제완료: (message?: string) => context.success('삭제 완료', message),
    저장실패: (message?: string) => context.error('저장 실패', message),
    삭제실패: (message?: string) => context.error('삭제 실패', message),
    입력오류: (message?: string) => context.error('입력 오류', message),
    경고: (message?: string) => context.warning('경고', message),
    알림: (message?: string) => context.info('알림', message),

    // Common business operations
    업로드완료: (message?: string) => context.success('업로드 완료', message),
    업로드실패: (message?: string) => context.error('업로드 실패', message),
    연결오류: (message?: string) => context.error('연결 오류', message),
    권한없음: (message?: string) => context.warning('권한 없음', message),
    데이터없음: (message?: string) => context.info('데이터 없음', message),

    // Enhanced Korean methods with undo functionality
    삭제완료_실행취소: (message?: string, onUndo?: () => void) => {
      const actions = onUndo ? [{
        label: '실행 취소',
        onClick: onUndo,
        style: 'secondary' as const,
        icon: Undo2
      }] : undefined;
      return context.successWithAction('삭제 완료', message, actions, 5000);
    },

    저장완료_상세보기: (message?: string, onViewDetails?: () => void) => {
      const actions = onViewDetails ? [{
        label: '상세 보기',
        onClick: onViewDetails,
        style: 'primary' as const,
        icon: ExternalLink
      }] : undefined;
      return context.successWithAction('저장 완료', message, actions);
    },

    업로드완료_결과보기: (message?: string, onViewResults?: () => void) => {
      const actions = onViewResults ? [{
        label: '결과 보기',
        onClick: onViewResults,
        style: 'primary' as const,
        icon: ExternalLink
      }] : undefined;
      return context.successWithAction('업로드 완료', message, actions);
    },

    오류발생_재시도: (message?: string, onRetry?: () => void) => {
      const actions = onRetry ? [{
        label: '다시 시도',
        onClick: onRetry,
        style: 'primary' as const,
        icon: RotateCcw
      }] : undefined;
      return context.errorWithAction('오류 발생', message, actions, 8000);
    },

    // Persistent notifications for critical operations
    중요알림: (message?: string, actions?: any[]) => context.persistent('warning', '중요 알림', message, actions),
    시스템오류: (message?: string, actions?: any[]) => context.persistent('error', '시스템 오류', message, actions),
  };
};
```


#### 📄 src\hooks\useTransactions.ts

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// API Response types
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// Transaction interface matching the actual database schema
export interface InventoryTransaction {
  transaction_id: number;
  transaction_date: string; // ISO date string
  transaction_type: '입고' | '출고' | '생산입고' | '생산출고' | '이동' | '조정' | '폐기';
  item_id: number;
  item_code?: string;
  item_name?: string;
  quantity: number;
  unit_price: number;
  total_amount: number;
  from_location?: string;
  to_location?: string;
  company_id?: number;
  company_name?: string;
  reference_no?: string;
  lot_no?: string;
  expiry_date?: string; // ISO date string
  notes?: string;
  created_by: number;
  created_at: string; // ISO date string
  updated_at: string; // ISO date string
}

// Create transaction data type (without transaction_id and timestamps)
export type CreateTransactionData = Omit<InventoryTransaction, 'transaction_id' | 'created_at' | 'updated_at' | 'item_code' | 'item_name' | 'company_name'>;

// Update transaction data type
export type UpdateTransactionData = Partial<CreateTransactionData> & { id: number };

// Transactions query parameters
export interface TransactionsQueryParams {
  type?: string;
  item_id?: number;
  company_id?: number;
  date_from?: string;
  date_to?: string;
  search?: string;
  page?: number;
  limit?: number;
}

// Query key factory for transactions
export const transactionsKeys = {
  all: ['transactions'] as const,
  lists: () => [...transactionsKeys.all, 'list'] as const,
  list: (params: TransactionsQueryParams) => [...transactionsKeys.lists(), params] as const,
  details: () => [...transactionsKeys.all, 'detail'] as const,
  detail: (id: number) => [...transactionsKeys.details(), id] as const,
  summary: () => [...transactionsKeys.all, 'summary'] as const,
};

// Fetch transactions with optional filtering
async function fetchTransactions(params: TransactionsQueryParams = {}): Promise<InventoryTransaction[]> {
  const searchParams = new URLSearchParams();

  if (params.type) searchParams.append('type', params.type);
  if (params.item_id) searchParams.append('item_id', params.item_id.toString());
  if (params.company_id) searchParams.append('company_id', params.company_id.toString());
  if (params.date_from) searchParams.append('date_from', params.date_from);
  if (params.date_to) searchParams.append('date_to', params.date_to);
  if (params.search) searchParams.append('search', params.search);
  if (params.page) searchParams.append('page', params.page.toString());
  if (params.limit) searchParams.append('limit', params.limit.toString());

  const response = await fetch(`/api/inventory/transactions?${searchParams}`);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<InventoryTransaction[]> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch transactions');
  }

  return data.data || [];
}

// Create new transaction
async function createTransaction(transactionData: CreateTransactionData): Promise<InventoryTransaction> {
  const response = await fetch('/api/inventory/transactions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(transactionData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<InventoryTransaction> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to create transaction');
  }

  return data.data!;
}

// Update existing transaction
async function updateTransaction(transactionData: UpdateTransactionData): Promise<InventoryTransaction> {
  const response = await fetch('/api/inventory/transactions', {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
    },
    body: JSON.stringify(transactionData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<InventoryTransaction> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to update transaction');
  }

  return data.data!;
}

// Delete transaction
async function deleteTransaction(id: number): Promise<void> {
  const response = await fetch(`/api/inventory/transactions?id=${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<void> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to delete transaction');
  }
}

// Fetch transaction summary/statistics
async function fetchTransactionSummary(params: Omit<TransactionsQueryParams, 'page' | 'limit'> = {}) {
  const searchParams = new URLSearchParams();

  if (params.type) searchParams.append('type', params.type);
  if (params.item_id) searchParams.append('item_id', params.item_id.toString());
  if (params.company_id) searchParams.append('company_id', params.company_id.toString());
  if (params.date_from) searchParams.append('date_from', params.date_from);
  if (params.date_to) searchParams.append('date_to', params.date_to);

  const response = await fetch(`/api/inventory/transactions/summary?${searchParams}`);

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse<any> = await response.json();

  if (!data.success) {
    throw new Error(data.error || 'Failed to fetch transaction summary');
  }

  return data.data;
}

// Hook for fetching transactions with caching and error handling
export function useTransactions(params: TransactionsQueryParams = {}) {
  return useQuery({
    queryKey: transactionsKeys.list(params),
    queryFn: () => fetchTransactions(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

// Hook for creating transactions with optimistic updates
export function useCreateTransaction() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createTransaction,
    onSuccess: (newTransaction) => {
      // Invalidate transactions queries
      queryClient.invalidateQueries({ queryKey: transactionsKeys.lists() });

      // Invalidate summary data
      queryClient.invalidateQueries({ queryKey: transactionsKeys.summary() });

      // Invalidate stock status as transactions affect inventory
      queryClient.invalidateQueries({ queryKey: ['stock'] });

      // Optionally add optimistic update
      queryClient.setQueriesData<InventoryTransaction[]>(
        { queryKey: transactionsKeys.lists() },
        (oldTransactions) => {
          if (!oldTransactions) return [newTransaction];
          return [newTransaction, ...oldTransactions];
        }
      );
    },
    onError: (error) => {
      console.error('Failed to create transaction:', error);
    },
  });
}

// Hook for updating transactions with optimistic updates
export function useUpdateTransaction() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateTransaction,
    onSuccess: (updatedTransaction) => {
      // Invalidate transactions queries
      queryClient.invalidateQueries({ queryKey: transactionsKeys.lists() });

      // Invalidate summary data
      queryClient.invalidateQueries({ queryKey: transactionsKeys.summary() });

      // Invalidate stock status as transactions affect inventory
      queryClient.invalidateQueries({ queryKey: ['stock'] });

      // Update specific transaction in cache
      queryClient.setQueriesData<InventoryTransaction[]>(
        { queryKey: transactionsKeys.lists() },
        (oldTransactions) => {
          if (!oldTransactions) return [updatedTransaction];
          return oldTransactions.map(transaction =>
            transaction.transaction_id === updatedTransaction.transaction_id
              ? updatedTransaction
              : transaction
          );
        }
      );
    },
    onError: (error) => {
      console.error('Failed to update transaction:', error);
    },
  });
}

// Hook for deleting transactions with optimistic updates
export function useDeleteTransaction() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteTransaction,
    onSuccess: (_, deletedId) => {
      // Invalidate transactions queries
      queryClient.invalidateQueries({ queryKey: transactionsKeys.lists() });

      // Invalidate summary data
      queryClient.invalidateQueries({ queryKey: transactionsKeys.summary() });

      // Invalidate stock status as transactions affect inventory
      queryClient.invalidateQueries({ queryKey: ['stock'] });

      // Remove transaction from cache
      queryClient.setQueriesData<InventoryTransaction[]>(
        { queryKey: transactionsKeys.lists() },
        (oldTransactions) => {
          if (!oldTransactions) return [];
          return oldTransactions.filter(transaction => transaction.transaction_id !== deletedId);
        }
      );
    },
    onError: (error) => {
      console.error('Failed to delete transaction:', error);
    },
  });
}

// Hook for fetching transaction summary
export function useTransactionSummary(params: Omit<TransactionsQueryParams, 'page' | 'limit'> = {}) {
  return useQuery({
    queryKey: [...transactionsKeys.summary(), params],
    queryFn: () => fetchTransactionSummary(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000,   // 10 minutes
    refetchOnWindowFocus: true,
    retry: 2,
  });
}

// Hook for prefetching transactions (useful for hover states, etc.)
export function usePrefetchTransactions() {
  const queryClient = useQueryClient();

  return (params: TransactionsQueryParams = {}) => {
    queryClient.prefetchQuery({
      queryKey: transactionsKeys.list(params),
      queryFn: () => fetchTransactions(params),
      staleTime: 5 * 60 * 1000,
    });
  };
}
```


---

### UTILS 코드


#### 📄 src\utils\chartUtils.d.ts

```typescript
/**
 * TypeScript declarations for chartUtils.js
 * Supports both CommonJS (require) and ES6 (import) usage
 */

export interface ColorScheme {
  primary: string;
  secondary: string;
  accent: string;
  warning: string;
  danger: string;
  background: string;
  surface: string;
  text: string;
  textSecondary: string;
  border: string;
  gridLines: string;
}

export interface ColorSchemes {
  light: ColorScheme;
  dark: ColorScheme;
}

export interface ChartDefaults {
  responsive: boolean;
  maintainAspectRatio: boolean;
  plugins: any;
  scales: any;
}

export interface RechartsTheme {
  colors: string[];
  tooltip: {
    contentStyle: any;
  };
  cartesianGrid: {
    stroke: string;
  };
  xAxis: {
    tick: { fill: string };
    axisLine: { stroke: string };
  };
  yAxis: {
    tick: { fill: string };
    axisLine: { stroke: string };
  };
}

export interface AnimationPreset {
  animateRotate: boolean;
  animateScale: boolean;
  duration: number;
  easing?: string;
}

export interface AnimationPresets {
  smooth: AnimationPreset;
  fast: AnimationPreset;
  none: AnimationPreset;
}

export interface KPIData {
  items: any[];
  transactions: unknown[];
  companies: any[];
}

export interface KPIResult {
  totalItems: number;
  activeCompanies: number;
  monthlyVolume: number;
  lowStockItems: number;
  volumeChange: number;
  trends: {
    items: number;
    companies: number;
    volume: number;
    lowStock: number;
  };
}

// Korean formatting functions
export function formatKoreanNumber(value: number): string;
export function formatKoreanCurrency(value: number): string;
export function formatKoreanPercent(value: number): string;
export function formatKoreanDate(date: string | Date): string;

// Color schemes and themes
export const colorSchemes: ColorSchemes;
export function getChartDefaults(isDark?: boolean): ChartDefaults;
export function getRechartsTheme(isDark?: boolean): RechartsTheme;
export function getTransactionTypeColor(type: string, isDark?: boolean): string;
export function getStockLevelColor(current: number, minimum: number, isDark?: boolean): string;

// Data transformation utilities
export function transformStockData(items: any[]): any[];
export function transformTransactionData(transactions: unknown[]): any[];

// Chart utilities
export function exportChartAsImage(chartRef: any, filename?: string): void;
export function printChart(chartRef: any): void;

// Performance utilities
export function debounce<T extends (...args: any[]) => any>(func: T, wait: number): T;
export function throttle<T extends (...args: any[]) => any>(func: T, limit: number): T;

// Animation presets
export const animationPresets: AnimationPresets;

// KPI calculation
export function calculateKPIs(data: KPIData): KPIResult;

// Default export interface for default imports and CommonJS
interface ChartUtils {
  // Korean formatting functions
  formatKoreanNumber: typeof formatKoreanNumber;
  formatKoreanCurrency: typeof formatKoreanCurrency;
  formatKoreanPercent: typeof formatKoreanPercent;
  formatKoreanDate: typeof formatKoreanDate;

  // Color schemes and themes
  colorSchemes: ColorSchemes;
  getChartDefaults: typeof getChartDefaults;
  getRechartsTheme: typeof getRechartsTheme;
  getTransactionTypeColor: typeof getTransactionTypeColor;
  getStockLevelColor: typeof getStockLevelColor;

  // Data transformation utilities
  transformStockData: typeof transformStockData;
  transformTransactionData: typeof transformTransactionData;

  // Chart utilities
  exportChartAsImage: typeof exportChartAsImage;
  printChart: typeof printChart;

  // Performance utilities
  debounce: typeof debounce;
  throttle: typeof throttle;

  // Animation presets
  animationPresets: AnimationPresets;

  // KPI calculation
  calculateKPIs: typeof calculateKPIs;
}

// Default export for ES6 import chartUtils from './chartUtils'
declare const chartUtils: ChartUtils;
export default chartUtils;
```


#### 📄 src\utils\chartUtils.js

```typescript
/**
 * Chart utilities for ERP dashboard
 * Universal module supporting both CommonJS and ES6 imports
 * Works for both API routes (require) and client components (import)
 */

// Korean number formatting
function formatKoreanNumber(value) {
  // Null safety guard for undefined, null, and NaN values
  if (value === null || value === undefined || isNaN(value)) {
    return '0';
  }

  const num = Number(value);

  if (num >= 100000000) {
    return `${(num / 100000000).toFixed(1)}억`;
  } else if (num >= 10000) {
    return `${(num / 10000).toFixed(1)}만`;
  } else if (num >= 1000) {
    return `${(num / 1000).toFixed(1)}천`;
  }
  return num.toLocaleString('ko-KR');
}

// Korean currency formatting
function formatKoreanCurrency(value) {
  return `₩${formatKoreanNumber(value)}`;
}

// Korean percentage formatting
function formatKoreanPercent(value) {
  return `${value.toFixed(1)}%`;
}

// Date formatting for Korean locale
function formatKoreanDate(date) {
  const d = new Date(date);
  return d.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
}

// Color schemes for different themes
const colorSchemes = {
  light: {
    primary: '#3B82F6',
    secondary: '#10B981',
    accent: '#8B5CF6',
    warning: '#F59E0B',
    danger: '#EF4444',
    background: '#FFFFFF',
    surface: '#F8FAFC',
    text: '#1F2937',
    textSecondary: '#6B7280',
    border: '#E5E7EB',
    gridLines: '#F3F4F6'
  },
  dark: {
    primary: '#60A5FA',
    secondary: '#34D399',
    accent: '#A78BFA',
    warning: '#FBBF24',
    danger: '#F87171',
    background: '#111827',
    surface: '#1F2937',
    text: '#F9FAFB',
    textSecondary: '#9CA3AF',
    border: '#374151',
    gridLines: '#374151'
  }
};

// Chart.js configuration presets
function getChartDefaults(isDark = false) {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  return {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: {
          color: theme.text,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      },
      tooltip: {
        backgroundColor: theme.surface,
        titleColor: theme.text,
        bodyColor: theme.text,
        borderColor: theme.border,
        borderWidth: 1,
        cornerRadius: 8,
        titleFont: {
          family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
        },
        bodyFont: {
          family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
        }
      }
    },
    scales: {
      x: {
        grid: {
          color: theme.gridLines
        },
        ticks: {
          color: theme.textSecondary,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      },
      y: {
        grid: {
          color: theme.gridLines
        },
        ticks: {
          color: theme.textSecondary,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      }
    }
  };
}

// Recharts configuration presets
function getRechartsTheme(isDark = false) {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  return {
    colors: [
      theme.primary,
      theme.secondary,
      theme.accent,
      theme.warning,
      theme.danger,
      '#06B6D4',
      '#84CC16',
      '#F97316'
    ],
    tooltip: {
      contentStyle: {
        backgroundColor: theme.surface,
        color: theme.text,
        border: `1px solid ${theme.border}`,
        borderRadius: '8px',
        fontFamily: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
      }
    },
    cartesianGrid: {
      stroke: theme.gridLines
    },
    xAxis: {
      tick: { fill: theme.textSecondary },
      axisLine: { stroke: theme.border }
    },
    yAxis: {
      tick: { fill: theme.textSecondary },
      axisLine: { stroke: theme.border }
    }
  };
}

// Transaction type colors
function getTransactionTypeColor(type, isDark = false) {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  switch (type) {
    case '입고':
      return theme.secondary;
    case '출고':
      return theme.primary;
    case '생산':
      return theme.warning;
    case '조정':
      return theme.accent;
    default:
      return theme.textSecondary;
  }
}

// Stock level colors
function getStockLevelColor(current, minimum, isDark = false) {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;
  const ratio = current / minimum;

  if (ratio < 0.5) return theme.danger;
  if (ratio < 1) return theme.warning;
  if (ratio < 1.5) return theme.secondary;
  return theme.primary;
}

// Chart data transformation utilities
function transformStockData(items) {
  return items.map(item => ({
    name: item.item_name || item.name,
    현재고: item.current_stock || item.current || 0,
    최소재고: item.minimum_stock || item.minimum || 0,
    안전재고: (item.minimum_stock || item.minimum || 0) * 1.5,
    code: item.item_code || item.code
  }));
}

function transformTransactionData(transactions) {
  const grouped = transactions.reduce((acc, transaction) => {
    const date = transaction.transaction_date || transaction.date;
    const dateStr = formatKoreanDate(date);

    if (!acc[dateStr]) {
      acc[dateStr] = { date: dateStr, 입고: 0, 출고: 0, 생산: 0 };
    }

    const type = transaction.transaction_type || transaction.type;
    const quantity = transaction.quantity || 0;

    if (type === '입고') acc[dateStr].입고 += quantity;
    else if (type === '출고') acc[dateStr].출고 += quantity;
    else if (type === '생산') acc[dateStr].생산 += quantity;

    return acc;
  }, {});

  return Object.values(grouped).sort((a, b) =>
    new Date(a.date).getTime() - new Date(b.date).getTime()
  );
}

// Export chart as image
function exportChartAsImage(chartRef, filename = 'chart.png') {
  if (!chartRef?.current) return;

  const canvas = chartRef.current.canvas || chartRef.current.querySelector('canvas');
  if (!canvas) return;

  const link = document.createElement('a');
  link.download = filename;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// Print chart
function printChart(chartRef) {
  if (!chartRef?.current) return;

  const canvas = chartRef.current.canvas || chartRef.current.querySelector('canvas');
  if (!canvas) return;

  const printWindow = window.open('', '_blank');
  if (!printWindow) return;

  printWindow.document.write(`
    <html>
      <head><title>차트 인쇄</title></head>
      <body style="margin: 0; text-align: center;">
        <img src="${canvas.toDataURL('image/png')}" style="max-width: 100%; height: auto;" />
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.print();
}

// Performance optimization utilities
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Chart animation presets
const animationPresets = {
  smooth: {
    animateRotate: true,
    animateScale: true,
    duration: 1000,
    easing: 'easeInOutQuart'
  },
  fast: {
    animateRotate: true,
    animateScale: true,
    duration: 300,
    easing: 'easeOutQuart'
  },
  none: {
    animateRotate: false,
    animateScale: false,
    duration: 0
  }
};

// KPI calculation function
function calculateKPIs(data) {
  const { items, transactions, companies } = data;

  // Calculate total items
  const totalItems = items.filter(item => item.is_active).length;

  // Calculate active companies
  const activeCompanies = companies.filter(company => company.is_active).length;

  // Calculate monthly transaction volume
  const currentMonth = new Date().getMonth();
  const currentYear = new Date().getFullYear();
  const monthlyTransactions = transactions.filter(transaction => {
    const date = new Date(transaction.transaction_date);
    return date.getMonth() === currentMonth && date.getFullYear() === currentYear;
  });

  const monthlyVolume = monthlyTransactions.reduce((sum, transaction) => {
    return sum + (parseFloat(transaction.quantity) || 0);
  }, 0);

  // Calculate low stock items
  const lowStockItems = items.filter(item => {
    const current = item.current_stock || 0;
    const minimum = item.minimum_stock || item.min_stock_level || 0;
    return current < minimum && item.is_active;
  }).length;

  // Calculate trends (previous month comparison)
  const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
  const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;

  const previousMonthTransactions = transactions.filter(transaction => {
    const date = new Date(transaction.transaction_date);
    return date.getMonth() === previousMonth && date.getFullYear() === previousYear;
  });

  const previousMonthVolume = previousMonthTransactions.reduce((sum, transaction) => {
    return sum + (parseFloat(transaction.quantity) || 0);
  }, 0);

  const volumeChange = previousMonthVolume > 0
    ? ((monthlyVolume - previousMonthVolume) / previousMonthVolume * 100)
    : 0;

  return {
    totalItems,
    activeCompanies,
    monthlyVolume,
    lowStockItems,
    volumeChange,
    trends: {
      items: 0, // Calculate based on historical data if available
      companies: 0, // Calculate based on historical data if available
      volume: volumeChange,
      lowStock: 0 // Calculate based on historical data if available
    }
  };
}

// ES6 Named Exports (for import statements)
export {
  formatKoreanNumber,
  formatKoreanCurrency,
  formatKoreanPercent,
  formatKoreanDate,
  colorSchemes,
  getChartDefaults,
  getRechartsTheme,
  getTransactionTypeColor,
  getStockLevelColor,
  transformStockData,
  transformTransactionData,
  exportChartAsImage,
  printChart,
  debounce,
  throttle,
  animationPresets,
  calculateKPIs
};

// Default export (for default import)
const chartUtils = {
  formatKoreanNumber,
  formatKoreanCurrency,
  formatKoreanPercent,
  formatKoreanDate,
  colorSchemes,
  getChartDefaults,
  getRechartsTheme,
  getTransactionTypeColor,
  getStockLevelColor,
  transformStockData,
  transformTransactionData,
  exportChartAsImage,
  printChart,
  debounce,
  throttle,
  animationPresets,
  calculateKPIs
};

export default chartUtils;

// CommonJS compatibility for API routes
if (typeof module !== 'undefined' && module.exports) {
  module.exports = chartUtils;

  // Also expose individual exports for CommonJS
  Object.assign(module.exports, {
    formatKoreanNumber,
    formatKoreanCurrency,
    formatKoreanPercent,
    formatKoreanDate,
    colorSchemes,
    getChartDefaults,
    getRechartsTheme,
    getTransactionTypeColor,
    getStockLevelColor,
    transformStockData,
    transformTransactionData,
    exportChartAsImage,
    printChart,
    debounce,
    throttle,
    animationPresets,
    calculateKPIs
  });
}
```


#### 📄 src\utils\chartUtils.ts

```typescript
/**
 * Chart utilities for ERP dashboard
 * Handles Korean formatting, themes, and chart configurations
 */

import type { ChartData, ChartOptions } from 'chart.js';

// Korean number formatting
export const formatKoreanNumber = (value: number): string => {
  if (value >= 100000000) {
    return `${(value / 100000000).toFixed(1)}억`;
  } else if (value >= 10000) {
    return `${(value / 10000).toFixed(1)}만`;
  } else if (value >= 1000) {
    return `${(value / 1000).toFixed(1)}천`;
  }
  return value.toLocaleString('ko-KR');
};

// Korean currency formatting
export const formatKoreanCurrency = (value: number): string => {
  return `₩${formatKoreanNumber(value)}`;
};

// Korean percentage formatting
export const formatKoreanPercent = (value: number): string => {
  return `${value.toFixed(1)}%`;
};

// Date formatting for Korean locale
export const formatKoreanDate = (date: Date | string): string => {
  const d = new Date(date);
  return d.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
};

// Color schemes for different themes
export const colorSchemes = {
  light: {
    primary: '#3B82F6',
    secondary: '#10B981',
    accent: '#8B5CF6',
    warning: '#F59E0B',
    danger: '#EF4444',
    background: '#FFFFFF',
    surface: '#F8FAFC',
    text: '#1F2937',
    textSecondary: '#6B7280',
    border: '#E5E7EB',
    gridLines: '#F3F4F6'
  },
  dark: {
    primary: '#60A5FA',
    secondary: '#34D399',
    accent: '#A78BFA',
    warning: '#FBBF24',
    danger: '#F87171',
    background: '#111827',
    surface: '#1F2937',
    text: '#F9FAFB',
    textSecondary: '#9CA3AF',
    border: '#374151',
    gridLines: '#374151'
  }
};

// Chart.js configuration presets
export const getChartDefaults = (isDark: boolean = false): Partial<ChartOptions<any>> => {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  return {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: {
          color: theme.text,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      },
      tooltip: {
        backgroundColor: theme.surface,
        titleColor: theme.text,
        bodyColor: theme.text,
        borderColor: theme.border,
        borderWidth: 1,
        cornerRadius: 8,
        titleFont: {
          family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
        },
        bodyFont: {
          family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
        }
      }
    },
    scales: {
      x: {
        grid: {
          color: theme.gridLines
        },
        ticks: {
          color: theme.textSecondary,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      },
      y: {
        grid: {
          color: theme.gridLines
        },
        ticks: {
          color: theme.textSecondary,
          font: {
            family: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
          }
        }
      }
    }
  };
};

// Recharts configuration presets
export const getRechartsTheme = (isDark: boolean = false) => {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  return {
    colors: [
      theme.primary,
      theme.secondary,
      theme.accent,
      theme.warning,
      theme.danger,
      '#06B6D4',
      '#84CC16',
      '#F97316'
    ],
    tooltip: {
      contentStyle: {
        backgroundColor: theme.surface,
        color: theme.text,
        border: `1px solid ${theme.border}`,
        borderRadius: '8px',
        fontFamily: 'Pretendard, -apple-system, BlinkMacSystemFont, sans-serif'
      }
    },
    cartesianGrid: {
      stroke: theme.gridLines
    },
    xAxis: {
      tick: { fill: theme.textSecondary },
      axisLine: { stroke: theme.border }
    },
    yAxis: {
      tick: { fill: theme.textSecondary },
      axisLine: { stroke: theme.border }
    }
  };
};

// Transaction type colors
export const getTransactionTypeColor = (type: string, isDark: boolean = false) => {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;

  switch (type) {
    case '입고':
      return theme.secondary;
    case '출고':
      return theme.primary;
    case '생산':
      return theme.warning;
    case '조정':
      return theme.accent;
    default:
      return theme.textSecondary;
  }
};

// Stock level colors
export const getStockLevelColor = (current: number, minimum: number, isDark: boolean = false) => {
  const theme = isDark ? colorSchemes.dark : colorSchemes.light;
  const ratio = current / minimum;

  if (ratio < 0.5) return theme.danger;
  if (ratio < 1) return theme.warning;
  if (ratio < 1.5) return theme.secondary;
  return theme.primary;
};

// Chart data transformation utilities
export const transformStockData = (items: any[]) => {
  return items.map(item => ({
    name: item.item_name || item.name,
    현재고: item.current_stock || item.current || 0,
    최소재고: item.minimum_stock || item.minimum || 0,
    안전재고: (item.minimum_stock || item.minimum || 0) * 1.5,
    code: item.item_code || item.code
  }));
};

interface Transaction {
  transaction_date?: string;
  date?: string;
  transaction_type?: string;
  type?: string;
  quantity?: number;
}

interface GroupedData {
  date: string;
  입고: number;
  출고: number;
  생산: number;
}

export const transformTransactionData = (transactions: Transaction[]) => {
  const grouped = transactions.reduce((acc, transaction) => {
    const date = transaction.transaction_date || transaction.date || '';
    const dateStr = formatKoreanDate(date);

    if (!acc[dateStr]) {
      acc[dateStr] = { date: dateStr, 입고: 0, 출고: 0, 생산: 0 };
    }

    const type = transaction.transaction_type || transaction.type;
    const quantity = transaction.quantity || 0;

    if (type === '입고') acc[dateStr].입고 += quantity;
    else if (type === '출고') acc[dateStr].출고 += quantity;
    else if (type === '생산') acc[dateStr].생산 += quantity;

    return acc;
  }, {} as Record<string, GroupedData>);

  return Object.values(grouped).sort((a, b) =>
    new Date(a.date).getTime() - new Date(b.date).getTime()
  );
};

// Export chart as image
export const exportChartAsImage = (chartRef: any, filename: string = 'chart.png') => {
  if (!chartRef?.current) return;

  const canvas = chartRef.current.canvas || chartRef.current.querySelector('canvas');
  if (!canvas) return;

  const link = document.createElement('a');
  link.download = filename;
  link.href = canvas.toDataURL('image/png');
  link.click();
};

// Print chart
export const printChart = (chartRef: any) => {
  if (!chartRef?.current) return;

  const canvas = chartRef.current.canvas || chartRef.current.querySelector('canvas');
  if (!canvas) return;

  const printWindow = window.open('', '_blank');
  if (!printWindow) return;

  printWindow.document.write(`
    <html>
      <head><title>차트 인쇄</title></head>
      <body style="margin: 0; text-align: center;">
        <img src="${canvas.toDataURL('image/png')}" style="max-width: 100%; height: auto;" />
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.print();
};

// Performance optimization utilities
export const debounce = <T extends (...args: any[]) => void>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(null, args), wait);
  };
};

export const throttle = <T extends (...args: any[]) => void>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func.apply(null, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

// Chart animation presets
export const animationPresets = {
  smooth: {
    animateRotate: true,
    animateScale: true,
    duration: 1000,
    easing: 'easeInOutQuart'
  },
  fast: {
    animateRotate: true,
    animateScale: true,
    duration: 300,
    easing: 'easeOutQuart'
  },
  none: {
    animateRotate: false,
    animateScale: false,
    duration: 0
  }
};

// KPI calculation utilities
export const calculateKPIs = (data: {
  items: any[];
  transactions: Transaction[];
  companies: any[];
}) => {
  const { items, transactions, companies } = data;

  // Calculate total items
  const totalItems = items.filter(item => item.is_active).length;

  // Calculate active companies
  const activeCompanies = companies.filter(company => company.is_active).length;

  // Calculate monthly transaction volume
  const currentMonth = new Date().getMonth();
  const currentYear = new Date().getFullYear();
  const monthlyTransactions = transactions.filter(transaction => {
    const date = new Date(transaction.transaction_date || transaction.date || '');
    return date.getMonth() === currentMonth && date.getFullYear() === currentYear;
  });

  const monthlyVolume = monthlyTransactions.reduce((sum, transaction) => {
    return sum + (transaction.quantity || 0);
  }, 0);

  // Calculate low stock items
  const lowStockItems = items.filter(item => {
    const current = item.current_stock || 0;
    const minimum = item.minimum_stock || 0;
    return current < minimum && item.is_active;
  }).length;

  // Calculate trends (previous month comparison)
  const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
  const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;

  const previousMonthTransactions = transactions.filter(transaction => {
    const date = new Date(transaction.transaction_date || transaction.date || '');
    return date.getMonth() === previousMonth && date.getFullYear() === previousYear;
  });

  const previousMonthVolume = previousMonthTransactions.reduce((sum, transaction) => {
    return sum + (transaction.quantity || 0);
  }, 0);

  const volumeChange = previousMonthVolume > 0
    ? ((monthlyVolume - previousMonthVolume) / previousMonthVolume * 100)
    : 0;

  return {
    totalItems,
    activeCompanies,
    monthlyVolume,
    lowStockItems,
    volumeChange,
    trends: {
      items: 0, // Calculate based on historical data if available
      companies: 0, // Calculate based on historical data if available
      volume: volumeChange,
      lowStock: 0 // Calculate based on historical data if available
    }
  };
};
```


#### 📄 src\utils\excelExport.ts

```typescript
import * as XLSX from 'xlsx';

// Generic interfaces for export data
interface ExportColumn {
  key: string;
  header: string;
  width?: number;
  format?: 'text' | 'number' | 'currency' | 'date';
}

interface ExportOptions {
  filename?: string;
  sheetName?: string;
  columns?: ExportColumn[];
  format?: 'xlsx' | 'csv';
  includeTimestamp?: boolean;
}

// Format date for Korean locale
const formatKoreanDate = (date: string | Date): string => {
  const d = new Date(date);
  return d.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
};

// Format currency for Korean locale
const formatKoreanCurrency = (amount: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW'
  }).format(amount);
};

// Generic export function
export const exportToExcel = (
  data: Record<string, any>[],
  options: ExportOptions = {}
): void => {
  const {
    filename = '데이터_내보내기',
    sheetName = 'Sheet1',
    columns = [],
    format = 'xlsx',
    includeTimestamp = true
  } = options;

  if (!data || data.length === 0) {
    throw new Error('내보낼 데이터가 없습니다.');
  }

  // Process data based on columns configuration
  let processedData = data;

  if (columns.length > 0) {
    processedData = data.map((row: Record<string, any>) => {
      const processedRow: Record<string, any> = {};
      columns.forEach(col => {
        let value = row[col.key];

        // Apply formatting based on column type
        switch (col.format) {
          case 'date':
            value = value ? formatKoreanDate(value) : '';
            break;
          case 'currency':
            value = typeof value === 'number' ? formatKoreanCurrency(value) : value;
            break;
          case 'number':
            value = typeof value === 'number' ? value.toLocaleString('ko-KR') : value;
            break;
          default:
            // Keep original value for text
            break;
        }

        processedRow[col.header] = value;
      });
      return processedRow;
    });
  }

  // Create workbook and worksheet
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.json_to_sheet(processedData);

  // Set column widths
  if (columns.length > 0) {
    const colWidths = columns.map(col => ({
      wch: col.width || 15
    }));
    ws['!cols'] = colWidths;
  }

  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, sheetName);

  // Generate filename with timestamp
  const timestamp = includeTimestamp
    ? `_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '_')}`
    : '';

  const finalFilename = `${filename}${timestamp}.${format}`;

  // Write and download file
  XLSX.writeFile(wb, finalFilename);
};

// Specialized export functions

// Export items with Korean headers
export const exportItems = (items: any[]): void => {
  const columns: ExportColumn[] = [
    { key: 'item_id', header: '품번', width: 15 },
    { key: 'item_name', header: '품명', width: 25 },
    { key: 'item_type', header: '타입', width: 12 },
    { key: 'car_model', header: '차종', width: 15 },
    { key: 'spec', header: '규격', width: 20 },
    { key: 'unit', header: '단위', width: 10 },
    { key: 'current_stock', header: '현재고', width: 12, format: 'number' },
    { key: 'min_stock', header: '최소재고', width: 12, format: 'number' },
    { key: 'unit_price', header: '단가', width: 15, format: 'currency' },
    { key: 'location', header: '위치', width: 15 },
    { key: 'created_at', header: '등록일시', width: 18, format: 'date' }
  ];

  exportToExcel(items, {
    filename: '품목_목록',
    sheetName: '품목',
    columns,
    format: 'xlsx'
  });
};

// Export companies with Korean headers
export const exportCompanies = (companies: any[]): void => {
  const columns: ExportColumn[] = [
    { key: 'company_id', header: '거래처코드', width: 15 },
    { key: 'company_name', header: '거래처명', width: 25 },
    { key: 'company_type', header: '타입', width: 12 },
    { key: 'business_number', header: '사업자등록번호', width: 18 },
    { key: 'contact_person', header: '담당자', width: 15 },
    { key: 'phone', header: '전화번호', width: 15 },
    { key: 'email', header: '이메일', width: 20 },
    { key: 'address', header: '주소', width: 30 },
    { key: 'created_at', header: '등록일시', width: 18, format: 'date' }
  ];

  exportToExcel(companies, {
    filename: '거래처_목록',
    sheetName: '거래처',
    columns,
    format: 'xlsx'
  });
};

// Export BOM with Korean headers
export const exportBOM = (bomData: any[]): void => {
  const columns: ExportColumn[] = [
    { key: 'parent_item_name', header: '모품목', width: 25 },
    { key: 'child_item_name', header: '자품목', width: 25 },
    { key: 'quantity', header: '소요량', width: 12, format: 'number' },
    { key: 'unit', header: '단위', width: 10 },
    { key: 'notes', header: '비고', width: 20 },
    { key: 'created_at', header: '등록일시', width: 18, format: 'date' }
  ];

  exportToExcel(bomData, {
    filename: 'BOM_목록',
    sheetName: 'BOM',
    columns,
    format: 'xlsx'
  });
};

// Export inventory transactions with Korean headers
export const exportTransactions = (transactions: Record<string, any>[]): void => {
  const columns: ExportColumn[] = [
    { key: 'transaction_id', header: '거래번호', width: 15 },
    { key: 'item_name', header: '품목명', width: 25 },
    { key: 'transaction_type', header: '거래유형', width: 12 },
    { key: 'quantity', header: '수량', width: 12, format: 'number' },
    { key: 'unit_price', header: '단가', width: 15, format: 'currency' },
    { key: 'total_amount', header: '총금액', width: 15, format: 'currency' },
    { key: 'company_name', header: '거래처', width: 20 },
    { key: 'reference_number', header: '참조번호', width: 15 },
    { key: 'notes', header: '비고', width: 20 },
    { key: 'transaction_date', header: '거래일시', width: 18, format: 'date' },
    { key: 'created_at', header: '등록일시', width: 18, format: 'date' }
  ];

  exportToExcel(transactions, {
    filename: '재고_거래내역',
    sheetName: '거래내역',
    columns,
    format: 'xlsx'
  });
};

// Export stock status with Korean headers
export const exportStockStatus = (stockData: any[]): void => {
  const columns: ExportColumn[] = [
    { key: 'item_name', header: '품목명', width: 25 },
    { key: 'current_stock', header: '현재고', width: 12, format: 'number' },
    { key: 'min_stock', header: '최소재고', width: 12, format: 'number' },
    { key: 'stock_status', header: '재고상태', width: 12 },
    { key: 'unit_price', header: '단가', width: 15, format: 'currency' },
    { key: 'stock_value', header: '재고가치', width: 15, format: 'currency' },
    { key: 'location', header: '위치', width: 15 },
    { key: 'last_updated', header: '최종업데이트', width: 18, format: 'date' }
  ];

  exportToExcel(stockData, {
    filename: '재고_현황',
    sheetName: '재고현황',
    columns,
    format: 'xlsx'
  });
};

// Multi-sheet export function
export const exportMultipleSheets = (
  sheetsData: { data: Record<string, any>[], options: ExportOptions }[]
): void => {
  const wb = XLSX.utils.book_new();

  sheetsData.forEach(({ data, options }) => {
    if (!data || data.length === 0) return;

    const {
      sheetName = 'Sheet',
      columns = []
    } = options;

    // Process data based on columns configuration
    let processedData = data;

    if (columns.length > 0) {
      processedData = data.map((row: Record<string, any>) => {
        const processedRow: Record<string, any> = {};
        columns.forEach(col => {
          let value = row[col.key];

          // Apply formatting based on column type
          switch (col.format) {
            case 'date':
              value = value ? formatKoreanDate(value) : '';
              break;
            case 'currency':
              value = typeof value === 'number' ? formatKoreanCurrency(value) : value;
              break;
            case 'number':
              value = typeof value === 'number' ? value.toLocaleString('ko-KR') : value;
              break;
            default:
              break;
          }

          processedRow[col.header] = value;
        });
        return processedRow;
      });
    }

    const ws = XLSX.utils.json_to_sheet(processedData);

    // Set column widths
    if (columns.length > 0) {
      const colWidths = columns.map(col => ({
        wch: col.width || 15
      }));
      ws['!cols'] = colWidths;
    }

    XLSX.utils.book_append_sheet(wb, ws, sheetName);
  });

  const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '_');
  const filename = `종합_데이터_${timestamp}.xlsx`;

  XLSX.writeFile(wb, filename);
};
```


#### 📄 src\utils\printUtils.ts

```typescript
/**
 * Print Utilities for Korean ERP System
 * 태창 자동차 부품 제조 ERP 시스템 인쇄 유틸리티
 */

export interface PrintOptions {
  orientation?: 'portrait' | 'landscape';
  pageSize?: 'A4' | 'A3';
  includeHeader?: boolean;
  includeFooter?: boolean;
  showPageNumbers?: boolean;
  title?: string;
  subtitle?: string;
}

export interface PrintPreviewOptions extends PrintOptions {
  onPrint?: () => void;
  onCancel?: () => void;
}

export interface TableColumn {
  key: string;
  label: string;
  align?: 'left' | 'center' | 'right';
  width?: string;
  type?: 'text' | 'number' | 'currency' | 'date';
}

/**
 * 한국어 날짜/시간 포맷팅
 */
export function formatKoreanDateTime(date: Date = new Date()): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');

  return `${year}년 ${month}월 ${day}일 ${hours}:${minutes}`;
}

/**
 * 한국어 날짜 포맷팅
 */
export function formatKoreanDate(date: Date = new Date()): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');

  return `${year}년 ${month}월 ${day}일`;
}

/**
 * 숫자 한국어 포맷팅 (천 단위 쉼표)
 */
export function formatKoreanNumber(value: number | string): string {
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '-';
  return num.toLocaleString('ko-KR');
}

/**
 * 통화 한국어 포맷팅
 */
export function formatKoreanCurrency(value: number | string): string {
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) return '-';
  return `₩${num.toLocaleString('ko-KR')}`;
}

/**
 * 회사 정보 헤더 생성
 */
function createCompanyHeader(title: string, subtitle?: string): string {
  const printDate = formatKoreanDateTime();

  return `
    <div class="print-header">
      <h1>태창 자동차 부품 제조 ERP 시스템</h1>
      <div class="company-info">경기도 안산시 단원구 신길동 1234-5 | TEL: 031-123-4567</div>
      <div class="report-title">${title}</div>
      ${subtitle ? `<div class="subtitle">${subtitle}</div>` : ''}
      <div class="print-date">인쇄일시: ${printDate}</div>
    </div>
  `;
}

/**
 * 테이블 HTML 생성
 */
function createTableHTML(
  data: Record<string, any>[],
  columns: TableColumn[],
  className: string = 'print-table'
): string {
  if (data.length === 0) {
    return `<div class="no-data">인쇄할 데이터가 없습니다.</div>`;
  }

  const tableHeader = columns.map(col =>
    `<th class="text-${col.align || 'left'}" ${col.width ? `style="width: ${col.width}"` : ''}>${col.label}</th>`
  ).join('');

  const tableRows = data.map((row: Record<string, any>) => {
    const cells = columns.map(col => {
      let value = row[col.key] || '-';

      // 타입별 포맷팅
      switch (col.type) {
        case 'number':
          value = formatKoreanNumber(value);
          break;
        case 'currency':
          value = formatKoreanCurrency(value);
          break;
        case 'date':
          if (value && value !== '-') {
            const date = new Date(value);
            value = formatKoreanDate(date);
          }
          break;
      }

      return `<td class="text-${col.align || 'left'} ${col.type || ''}">${value}</td>`;
    }).join('');

    return `<tr>${cells}</tr>`;
  }).join('');

  return `
    <table class="${className}">
      <thead>
        <tr>${tableHeader}</tr>
      </thead>
      <tbody>
        ${tableRows}
      </tbody>
    </table>
  `;
}

/**
 * 인쇄용 콘텐츠 생성
 */
export function generatePrintableContent(
  content: string,
  options: PrintOptions = {}
): string {
  const {
    orientation = 'portrait',
    includeHeader = true,
    includeFooter = true,
    title = '보고서',
    subtitle
  } = options;

  const layoutClass = orientation === 'landscape' ? 'print-landscape' : 'print-portrait';
  const header = includeHeader ? createCompanyHeader(title, subtitle) : '';
  const footer = includeFooter ? `
    <div class="print-footer">
      <div>태창 자동차 부품 제조 © ${new Date().getFullYear()} | 기밀문서</div>
    </div>
  ` : '';

  return `
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${title} - 태창 ERP</title>
      <link rel="stylesheet" href="/styles/print.css">
      <style>
        body { margin: 0; padding: 0; }
        .print-container {
          font-family: 'Malgun Gothic', '맑은 고딕', sans-serif;
        }
      </style>
    </head>
    <body class="${layoutClass}">
      <div class="print-container">
        ${header}
        <div class="content">
          ${content}
        </div>
        ${footer}
      </div>
    </body>
    </html>
  `;
}

/**
 * 기본 페이지 인쇄
 */
export async function printPage(options: PrintOptions = {}): Promise<void> {
  const {
    orientation = 'portrait',
    title = '페이지 인쇄'
  } = options;

  // 현재 페이지의 인쇄 가능한 내용 추출
  const printContent = document.body.innerHTML;
  const htmlContent = generatePrintableContent(printContent, { ...options, title });

  // 새 창에서 인쇄
  const printWindow = window.open('', '_blank');
  if (!printWindow) {
    throw new Error('팝업이 차단되었습니다. 팝업을 허용하고 다시 시도해 주세요.');
  }

  printWindow.document.write(htmlContent);
  printWindow.document.close();

  // 스타일시트 로드 완료 후 인쇄
  printWindow.onload = () => {
    setTimeout(() => {
      printWindow.print();
      printWindow.close();
    }, 500);
  };
}

/**
 * 테이블 데이터 인쇄
 */
export async function printTable(
  data: Record<string, any>[],
  columns: TableColumn[],
  options: PrintOptions = {}
): Promise<void> {
  const {
    title = '데이터 목록',
    orientation = 'landscape'
  } = options;

  const tableHTML = createTableHTML(data, columns,
    orientation === 'landscape' ? 'print-table print-landscape-table' : 'print-table'
  );

  const summary = `
    <div class="print-summary">
      <h3>요약 정보</h3>
      <div class="summary-grid">
        <div class="summary-item">
          <span class="summary-label">총 항목 수:</span>
          <span class="summary-value">${formatKoreanNumber(data.length)}건</span>
        </div>
        <div class="summary-item">
          <span class="summary-label">인쇄일시:</span>
          <span class="summary-value">${formatKoreanDateTime()}</span>
        </div>
      </div>
    </div>
  `;

  const content = summary + tableHTML;
  const htmlContent = generatePrintableContent(content, { ...options, title });

  const printWindow = window.open('', '_blank');
  if (!printWindow) {
    throw new Error('팝업이 차단되었습니다. 팝업을 허용하고 다시 시도해 주세요.');
  }

  printWindow.document.write(htmlContent);
  printWindow.document.close();

  printWindow.onload = () => {
    setTimeout(() => {
      printWindow.print();
      printWindow.close();
    }, 500);
  };
}

/**
 * 인쇄 미리보기 모달 생성
 */
export function createPrintPreview(
  content: string,
  options: PrintPreviewOptions = {}
): HTMLElement {
  const {
    title = '인쇄 미리보기',
    orientation = 'portrait',
    onPrint,
    onCancel
  } = options;

  const htmlContent = generatePrintableContent(content, options);

  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';

  modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl max-w-4xl max-h-[90vh] overflow-hidden">
      <div class="flex items-center justify-between p-4 border-b">
        <h3 class="text-lg font-semibold text-gray-900">${title}</h3>
        <div class="flex gap-2">
          <select id="orientation-select" class="px-3 py-1 border rounded text-sm">
            <option value="portrait" ${orientation === 'portrait' ? 'selected' : ''}>세로</option>
            <option value="landscape" ${orientation === 'landscape' ? 'selected' : ''}>가로</option>
          </select>
          <button id="print-btn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">
            인쇄
          </button>
          <button id="cancel-btn" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm">
            취소
          </button>
        </div>
      </div>

      <div class="p-4 overflow-auto max-h-[70vh]">
        <div class="print-preview" id="preview-content">
          ${content}
        </div>
      </div>
    </div>
  `;

  // 이벤트 핸들러
  const printBtn = modal.querySelector('#print-btn');
  const cancelBtn = modal.querySelector('#cancel-btn');
  const orientationSelect = modal.querySelector('#orientation-select') as HTMLSelectElement;

  printBtn?.addEventListener('click', () => {
    const currentOrientation = orientationSelect.value as 'portrait' | 'landscape';
    printTable([], [], { ...options, orientation: currentOrientation });
    onPrint?.();
    document.body.removeChild(modal);
  });

  cancelBtn?.addEventListener('click', () => {
    onCancel?.();
    document.body.removeChild(modal);
  });

  // ESC 키로 닫기
  const handleEscape = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      document.body.removeChild(modal);
      document.removeEventListener('keydown', handleEscape);
    }
  };
  document.addEventListener('keydown', handleEscape);

  return modal;
}

/**
 * 인쇄 미리보기와 함께 인쇄
 */
export async function printWithPreview(
  data: Record<string, any>[],
  columns: TableColumn[],
  options: PrintPreviewOptions = {}
): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      const tableHTML = createTableHTML(data, columns);
      const modal = createPrintPreview(tableHTML, {
        ...options,
        onPrint: () => {
          printTable(data, columns, options);
          resolve();
        },
        onCancel: () => {
          resolve();
        }
      });

      document.body.appendChild(modal);
    } catch (error) {
      reject(error);
    }
  });
}

// 특화된 인쇄 함수들

/**
 * 품목 목록 인쇄
 */
export async function printItems(items: any[], options: PrintOptions = {}): Promise<void> {
  const columns: TableColumn[] = [
    { key: 'item_code', label: '품번', align: 'left', width: '12%' },
    { key: 'item_name', label: '품명', align: 'left', width: '20%' },
    { key: 'car_model', label: '차종', align: 'left', width: '12%' },
    { key: 'spec', label: '규격', align: 'left', width: '15%' },
    { key: 'item_type', label: '타입', align: 'center', width: '8%' },
    { key: 'unit', label: '단위', align: 'center', width: '6%' },
    { key: 'current_stock', label: '현재고', align: 'right', width: '8%', type: 'number' },
    { key: 'min_stock_level', label: '최소재고', align: 'right', width: '8%', type: 'number' },
    { key: 'unit_price', label: '단가', align: 'right', width: '11%', type: 'currency' }
  ];

  await printTable(items, columns, {
    ...options,
    title: '품목 목록',
    orientation: 'landscape'
  });
}

/**
 * 회사 목록 인쇄
 */
export async function printCompanies(companies: any[], options: PrintOptions = {}): Promise<void> {
  const columns: TableColumn[] = [
    { key: 'company_code', label: '회사코드', align: 'left', width: '15%' },
    { key: 'company_name', label: '회사명', align: 'left', width: '25%' },
    { key: 'company_type', label: '구분', align: 'center', width: '10%' },
    { key: 'contact_person', label: '담당자', align: 'left', width: '15%' },
    { key: 'phone', label: '전화번호', align: 'left', width: '15%' },
    { key: 'address', label: '주소', align: 'left', width: '20%' }
  ];

  await printTable(companies, columns, {
    ...options,
    title: '거래처 목록',
    orientation: 'portrait'
  });
}

/**
 * BOM 구조 인쇄
 */
export async function printBOM(bomData: any[], options: PrintOptions = {}): Promise<void> {
  const columns: TableColumn[] = [
    { key: 'level_display', label: '레벨', align: 'left', width: '8%' },
    { key: 'item_code', label: '품번', align: 'left', width: '15%' },
    { key: 'item_name', label: '품명', align: 'left', width: '25%' },
    { key: 'quantity', label: '소요량', align: 'right', width: '10%', type: 'number' },
    { key: 'unit', label: '단위', align: 'center', width: '8%' },
    { key: 'unit_price', label: '단가', align: 'right', width: '12%', type: 'currency' },
    { key: 'total_cost', label: '총비용', align: 'right', width: '12%', type: 'currency' },
    { key: 'notes', label: '비고', align: 'left', width: '10%' }
  ];

  await printTable(bomData, columns, {
    ...options,
    title: 'BOM 구조도',
    orientation: 'landscape'
  });
}

/**
 * 재고 거래 내역 인쇄
 */
export async function printTransactions(transactions: Record<string, any>[], options: PrintOptions = {}): Promise<void> {
  const columns: TableColumn[] = [
    { key: 'transaction_date', label: '거래일', align: 'center', width: '12%', type: 'date' },
    { key: 'transaction_type', label: '구분', align: 'center', width: '8%' },
    { key: 'item_code', label: '품번', align: 'left', width: '12%' },
    { key: 'item_name', label: '품명', align: 'left', width: '18%' },
    { key: 'quantity', label: '수량', align: 'right', width: '10%', type: 'number' },
    { key: 'unit_price', label: '단가', align: 'right', width: '12%', type: 'currency' },
    { key: 'total_amount', label: '금액', align: 'right', width: '12%', type: 'currency' },
    { key: 'company_name', label: '거래처', align: 'left', width: '12%' },
    { key: 'notes', label: '비고', align: 'left', width: '14%' }
  ];

  await printTable(transactions, columns, {
    ...options,
    title: '재고 거래 내역',
    orientation: 'landscape'
  });
}

/**
 * 재고 현황 보고서 인쇄
 */
export async function printStockReport(stockData: any[], options: PrintOptions = {}): Promise<void> {
  const columns: TableColumn[] = [
    { key: 'item_code', label: '품번', align: 'left', width: '15%' },
    { key: 'item_name', label: '품명', align: 'left', width: '25%' },
    { key: 'current_stock', label: '현재고', align: 'right', width: '12%', type: 'number' },
    { key: 'min_stock_level', label: '최소재고', align: 'right', width: '12%', type: 'number' },
    { key: 'stock_value', label: '재고금액', align: 'right', width: '15%', type: 'currency' },
    { key: 'location', label: '위치', align: 'left', width: '10%' },
    { key: 'status', label: '상태', align: 'center', width: '11%' }
  ];

  await printTable(stockData, columns, {
    ...options,
    title: '재고 현황 보고서',
    orientation: 'landscape'
  });
}

export default {
  printPage,
  printTable,
  printWithPreview,
  printItems,
  printCompanies,
  printBOM,
  printTransactions,
  printStockReport,
  formatKoreanDateTime,
  formatKoreanDate,
  formatKoreanNumber,
  formatKoreanCurrency
};
```


#### 📄 src\utils\searchUtils.ts

```typescript
/**
 * 고급 검색 및 필터링 유틸리티
 * Advanced Search and Filtering Utilities for Korean ERP System
 */

// 한글 텍스트 정규화 함수 (검색 성능 향상)
export const normalizeKoreanText = (text: string): string => {
  return text
    .toLowerCase()
    .replace(/[\s\-_]/g, '') // 공백, 하이픈, 언더스코어 제거
    .normalize('NFD') // 한글 자모 분리
    .replace(/[\u0300-\u036f]/g, ''); // 결합 문자 제거
};

// 검색 쿼리 빌더
export interface SearchQueryParams {
  searchText?: string;
  dateRange?: {
    startDate?: string;
    endDate?: string;
  };
  filters?: Record<string, any>;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

export const buildSearchQuery = (params: SearchQueryParams): URLSearchParams => {
  const query = new URLSearchParams();

  if (params.searchText) {
    query.append('search', params.searchText);
  }

  if (params.dateRange?.startDate) {
    query.append('startDate', params.dateRange.startDate);
  }

  if (params.dateRange?.endDate) {
    query.append('endDate', params.dateRange.endDate);
  }

  if (params.filters) {
    Object.entries(params.filters).forEach(([key, value]) => {
      if (value !== '' && value !== null && value !== undefined) {
        query.append(key, value.toString());
      }
    });
  }

  if (params.sortBy) {
    query.append('sortBy', params.sortBy);
  }

  if (params.sortOrder) {
    query.append('sortOrder', params.sortOrder);
  }

  if (params.page) {
    query.append('page', params.page.toString());
  }

  if (params.limit) {
    query.append('limit', params.limit.toString());
  }

  return query;
};

// 필터 URL 인코딩/디코딩
export const encodeFiltersToUrl = (filters: Record<string, any>): string => {
  const params = new URLSearchParams();

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== '' && value !== null && value !== undefined) {
      params.append(key, JSON.stringify(value));
    }
  });

  return params.toString();
};

export const decodeFiltersFromUrl = (urlParams: URLSearchParams): Record<string, any> => {
  const filters: Record<string, any> = {};

  urlParams.forEach((value, key) => {
    try {
      filters[key] = JSON.parse(value);
    } catch {
      filters[key] = value;
    }
  });

  return filters;
};

// 검색 결과 하이라이팅
export const highlightSearchTerm = (text: string, searchTerm: string): string => {
  if (!searchTerm || !text) return text;

  const normalizedText = normalizeKoreanText(text);
  const normalizedTerm = normalizeKoreanText(searchTerm);

  if (!normalizedText.includes(normalizedTerm)) return text;

  const regex = new RegExp(`(${searchTerm})`, 'gi');
  return text.replace(regex, '<mark class="bg-yellow-200 dark:bg-yellow-800">$1</mark>');
};

// 자동완성 데이터 준비
export const prepareAutocompleteData = (
  items: any[],
  fields: string[]
): string[] => {
  const suggestions = new Set<string>();

  items.forEach(item => {
    fields.forEach(field => {
      const value = item[field];
      if (value && typeof value === 'string') {
        suggestions.add(value);
        // 부분 문자열도 추가 (2글자 이상)
        if (value.length >= 2) {
          for (let i = 0; i <= value.length - 2; i++) {
            const substring = value.substring(i, i + 2);
            if (substring.trim().length === 2) {
              suggestions.add(substring);
            }
          }
        }
      }
    });
  });

  return Array.from(suggestions).sort();
};

// 디바운스된 검색 함수
export const createDebouncedSearch = (
  searchFn: (query: string) => void,
  delay: number = 300
) => {
  let timeoutId: NodeJS.Timeout;

  return (query: string) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => searchFn(query), delay);
  };
};

// 빠른 필터 프리셋
export interface QuickFilter {
  id: string;
  label: string;
  filters: Record<string, any>;
  dateRange?: {
    startDate: string;
    endDate: string;
  };
}

export const getQuickFilters = (): QuickFilter[] => {
  const today = new Date();
  const startOfWeek = new Date(today.setDate(today.getDate() - today.getDay()));
  const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  const startOfYear = new Date(today.getFullYear(), 0, 1);

  const formatDate = (date: Date) => date.toISOString().split('T')[0];

  return [
    {
      id: 'today',
      label: '오늘',
      filters: {},
      dateRange: {
        startDate: formatDate(new Date()),
        endDate: formatDate(new Date())
      }
    },
    {
      id: 'thisWeek',
      label: '이번주',
      filters: {},
      dateRange: {
        startDate: formatDate(startOfWeek),
        endDate: formatDate(new Date())
      }
    },
    {
      id: 'thisMonth',
      label: '이번달',
      filters: {},
      dateRange: {
        startDate: formatDate(startOfMonth),
        endDate: formatDate(new Date())
      }
    },
    {
      id: 'thisYear',
      label: '올해',
      filters: {},
      dateRange: {
        startDate: formatDate(startOfYear),
        endDate: formatDate(new Date())
      }
    },
    {
      id: 'all',
      label: '전체',
      filters: {},
      dateRange: undefined
    }
  ];
};

// 검색 성능 최적화
export const optimizeSearchPerformance = <T>(
  items: T[],
  searchTerm: string,
  searchFields: string[],
  maxResults: number = 100
): T[] => {
  if (!searchTerm) return items.slice(0, maxResults);

  const normalizedTerm = normalizeKoreanText(searchTerm);
  const results: T[] = [];

  for (let i = 0; i < items.length && results.length < maxResults; i++) {
    const item = items[i];
    const matched = searchFields.some(field => {
      const value = (item as any)[field];
      if (value && typeof value === 'string') {
        return normalizeKoreanText(value).includes(normalizedTerm);
      }
      return false;
    });

    if (matched) {
      results.push(item);
    }
  }

  return results;
};

// 검색 분석 데이터
export interface SearchAnalytics {
  searchTerm: string;
  resultCount: number;
  timestamp: Date;
  filters: Record<string, any>;
}

export const trackSearch = (analytics: SearchAnalytics): void => {
  try {
    const searches = JSON.parse(localStorage.getItem('searchAnalytics') || '[]');
    searches.push({
      ...analytics,
      timestamp: analytics.timestamp.toISOString()
    });

    // 최근 100개만 유지
    if (searches.length > 100) {
      searches.splice(0, searches.length - 100);
    }

    localStorage.setItem('searchAnalytics', JSON.stringify(searches));
  } catch (error) {
    console.warn('Failed to track search analytics:', error);
  }
};

export const getPopularSearches = (limit: number = 10): string[] => {
  try {
    const searches = JSON.parse(localStorage.getItem('searchAnalytics') || '[]');
    const searchCounts: Record<string, number> = {};

    searches.forEach((search: any) => {
      if (search.searchTerm) {
        searchCounts[search.searchTerm] = (searchCounts[search.searchTerm] || 0) + 1;
      }
    });

    return Object.entries(searchCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, limit)
      .map(([term]) => term);
  } catch (error) {
    console.warn('Failed to get popular searches:', error);
    return [];
  }
};

// 필터 조합 유효성 검사
export const validateFilterCombination = (filters: Record<string, any>): boolean => {
  // 비즈니스 로직에 따른 필터 조합 검증
  if (filters.startDate && filters.endDate) {
    const startDate = new Date(filters.startDate);
    const endDate = new Date(filters.endDate);

    if (startDate > endDate) {
      return false;
    }

    // 최대 1년 범위 제한
    const oneYearInMs = 365 * 24 * 60 * 60 * 1000;
    if (endDate.getTime() - startDate.getTime() > oneYearInMs) {
      return false;
    }
  }

  return true;
};

// 내보내기용 필터 상태 준비
export const prepareFilterStateForExport = (
  filters: Record<string, any>,
  searchTerm: string,
  dateRange?: { startDate?: string; endDate?: string }
) => {
  return {
    appliedFilters: Object.entries(filters)
      .filter(([, value]) => value !== '' && value !== null && value !== undefined)
      .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {}),
    searchTerm: searchTerm || '',
    dateRange: dateRange || {},
    exportTimestamp: new Date().toISOString(),
    totalFilterCount: Object.keys(filters).length
  };
};
```


---

### PAGES 코드


#### 📄 src\app\dashboard\page.tsx

```typescript
'use client';

import { useState, useEffect, Suspense } from 'react';
import dynamic from 'next/dynamic';
import MainLayout from '@/components/layout/MainLayout';
import {
  Package,
  TrendingUp,
  AlertTriangle,
  CheckCircle,
  BarChart3,
  Clock,
  Zap,
  RefreshCw
} from 'lucide-react';
import { CardSkeleton, StatsSkeleton } from '@/components/ui/Skeleton';

// Dynamic imports for dashboard components with loading fallbacks
const StockStatusWidget = dynamic(() => import('@/components/dashboard/StockStatusWidget'), {
  loading: () => <CardSkeleton showTitle={true} contentLines={5} />,
  ssr: false
});

const RecentActivityWidget = dynamic(() => import('@/components/dashboard/RecentActivityWidget'), {
  loading: () => <CardSkeleton showTitle={true} contentLines={6} />,
  ssr: false
});

const QuickActionsWidget = dynamic(() => import('@/components/dashboard/QuickActionsWidget'), {
  loading: () => <CardSkeleton showTitle={true} contentLines={4} />,
  ssr: false
});

const StockSummaryCard = dynamic(() => import('@/components/dashboard/StockSummaryCard'), {
  loading: () => <StatsSkeleton />,
  ssr: false
});

export default function DashboardPage() {
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);

  // Set initial time on client-side only
  useEffect(() => {
    setLastUpdated(new Date());

    // Auto refresh every 5 minutes
    const interval = setInterval(() => {
      setLastUpdated(new Date());
    }, 5 * 60 * 1000); // 5 minutes

    return () => clearInterval(interval);
  }, []);

  // Simulate initial loading
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsInitialLoading(false);
    }, 2000);

    return () => clearTimeout(timer);
  }, []);

  const handleRefresh = () => {
    setIsRefreshing(true);
    setLastUpdated(new Date());
    setTimeout(() => {
      setIsRefreshing(false);
    }, 1000);
  };

  const handleQuickAction = (action: string) => {
    // Navigate to respective pages
    switch(action) {
      case 'receiving':
        window.location.href = '/inventory/in';
        break;
      case 'shipping':
        window.location.href = '/inventory/out';
        break;
      case 'production':
        window.location.href = '/inventory';
        break;
      case 'adjustment':
        window.location.href = '/stock';
        break;
      case 'item':
        window.location.href = '/master/items';
        break;
      case 'report':
        window.location.href = '/stock/reports';
        break;
    }
  };

  return (
    <MainLayout>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 dark:text-white flex items-center gap-2">
              <BarChart3 className="h-8 w-8" />
              대시보드
            </h1>
            <p className="text-gray-600 dark:text-gray-400 mt-1">
              태창 ERP 시스템 실시간 현황
            </p>
          </div>

          <div className="flex items-center gap-4">
            <div className="text-sm text-gray-500 dark:text-gray-400">
              <Clock className="inline h-4 w-4 mr-1" />
              마지막 업데이트: {lastUpdated ? lastUpdated.toLocaleTimeString('ko-KR') : '-'}
            </div>
            <button
              onClick={handleRefresh}
              className={`p-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors ${
                isRefreshing ? 'animate-spin' : ''
              }`}
            >
              <RefreshCw className="h-5 w-5" />
            </button>
          </div>
        </div>

        {/* Summary Cards */}
        <div className="mb-6">
          {isInitialLoading ? (
            <StatsSkeleton />
          ) : (
            <StockSummaryCard />
          )}
        </div>

        {/* Main Grid Layout */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Left Column - Stock Status */}
          <div className="lg:col-span-1">
            {isInitialLoading ? (
              <CardSkeleton showTitle={true} contentLines={5} />
            ) : (
              <StockStatusWidget
                limit={10}
                showValue={true}
                key={lastUpdated ? lastUpdated.getTime() : 'initial'}
              />
            )}
          </div>

          {/* Middle Column - Recent Activity */}
          <div className="lg:col-span-1">
            {isInitialLoading ? (
              <CardSkeleton showTitle={true} contentLines={6} />
            ) : (
              <RecentActivityWidget
                limit={10}
                hoursRange={24}
                key={lastUpdated ? lastUpdated.getTime() : 'initial'}
              />
            )}
          </div>

          {/* Right Column - Quick Actions */}
          <div className="lg:col-span-1">
            {isInitialLoading ? (
              <CardSkeleton showTitle={true} contentLines={4} />
            ) : (
              <QuickActionsWidget
                onReceivingClick={() => handleQuickAction('receiving')}
                onShippingClick={() => handleQuickAction('shipping')}
                onProductionClick={() => handleQuickAction('production')}
                onAdjustmentClick={() => handleQuickAction('adjustment')}
                onNewItemClick={() => handleQuickAction('item')}
                onReportsClick={() => handleQuickAction('report')}
              />
            )}
          </div>
        </div>

        {/* Additional Insights Section */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
          {/* Performance Metrics */}
          {isInitialLoading ? (
            <CardSkeleton showTitle={true} contentLines={3} />
          ) : (
            <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-gray-200 dark:border-gray-700">
              <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                <TrendingUp className="h-5 w-5 text-blue-500" />
                주요 지표
              </h3>
              <div className="space-y-3">
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">일일 입고량</span>
                  <span className="font-semibold">0 건</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">일일 출고량</span>
                  <span className="font-semibold">0 건</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">재고 회전율</span>
                  <span className="font-semibold">-</span>
                </div>
              </div>
            </div>
          )}

          {/* System Status */}
          {isInitialLoading ? (
            <CardSkeleton showTitle={true} contentLines={3} />
          ) : (
            <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-gray-200 dark:border-gray-700">
              <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                <Zap className="h-5 w-5 text-green-500" />
                시스템 상태
              </h3>
              <div className="space-y-3">
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">데이터베이스</span>
                  <span className="flex items-center gap-1 text-green-600">
                    <CheckCircle className="h-4 w-4" />
                    정상
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">서버 상태</span>
                  <span className="flex items-center gap-1 text-green-600">
                    <CheckCircle className="h-4 w-4" />
                    정상
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-gray-600 dark:text-gray-400">마지막 백업</span>
                  <span className="font-semibold">-</span>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </MainLayout>
  );
}
```


#### 📄 src\app\inventory\page.tsx

```typescript
'use client';

import { Suspense, useState, useEffect } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';

// Dynamic import to prevent SSR issues
import dynamic from 'next/dynamic';
import { Package, TrendingUp, Truck, Plus, AlertCircle, CheckCircle, Clock, Printer } from 'lucide-react';
import Modal from '@/components/Modal';
import ReceivingForm from '@/components/ReceivingForm';
import ProductionForm from '@/components/ProductionForm';
import ShippingForm from '@/components/ShippingForm';
import { TransactionsExportButton, StockExportButton } from '@/components/ExcelExportButton';
import PrintButton from '@/components/PrintButton';
import { printTransactions, printStockReport } from '@/utils/printUtils';
import {
  InventoryTransaction,
  StockInfo,
  InventoryTab,
  StockStatus,
  ReceivingFormData,
  ProductionFormData,
  ShippingFormData,
  TRANSACTION_TYPES
} from '@/types/inventory';

// Search params를 사용하는 내부 컴포넌트
function InventoryContent() {
  const searchParams = useSearchParams();
  const router = useRouter();

  // URL 파라미터에서 탭 가져오기, 기본값은 'receiving'
  const tabFromUrl = searchParams?.get('tab') as 'receiving' | 'production' | 'shipping' | null;
  const initialTab = tabFromUrl || 'receiving';

  const [activeTab, setActiveTab] = useState<'receiving' | 'production' | 'shipping'>(initialTab);
  const [transactions, setTransactions] = useState<InventoryTransaction[]>([]);
  const [stockInfo, setStockInfo] = useState<StockInfo[]>([]);
  const [loading, setLoading] = useState(true);
  const [showModal, setShowModal] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);

  const tabs: InventoryTab[] = [
    {
      id: 'receiving',
      label: '입고 관리',
      icon: Package,
      description: '자재 및 제품 입고 처리',
      color: 'text-blue-500',
      bgColor: 'bg-blue-50 dark:bg-blue-900/20'
    },
    {
      id: 'production',
      label: '생산 관리',
      icon: TrendingUp,
      description: 'BOM 기반 생산 처리',
      color: 'text-green-500',
      bgColor: 'bg-green-50 dark:bg-green-900/20'
    },
    {
      id: 'shipping',
      label: '출고 관리',
      icon: Truck,
      description: '제품 출고 및 배송',
      color: 'text-orange-500',
      bgColor: 'bg-orange-50 dark:bg-orange-900/20'
    }
  ];

  const activeTabInfo = tabs.find(tab => tab.id === activeTab)!;

  // 인쇄용 컬럼 정의 - 거래 내역
  const transactionPrintColumns = [
    { key: 'transaction_date', label: '거래일', align: 'center' as const, width: '12%', type: 'date' as const },
    { key: 'transaction_type', label: '구분', align: 'center' as const, width: '8%' },
    { key: 'item_code', label: '품번', align: 'left' as const, width: '12%' },
    { key: 'item_name', label: '품명', align: 'left' as const, width: '18%' },
    { key: 'quantity', label: '수량', align: 'right' as const, width: '10%', type: 'number' as const },
    { key: 'unit_price', label: '단가', align: 'right' as const, width: '12%', type: 'currency' as const },
    { key: 'total_amount', label: '금액', align: 'right' as const, width: '12%', type: 'currency' as const },
    { key: 'company_name', label: '거래처', align: 'left' as const, width: '12%' },
    { key: 'reference_no', label: '참조번호', align: 'left' as const, width: '14%' }
  ];

  // 인쇄용 컬럼 정의 - 재고 현황
  const stockPrintColumns = [
    { key: 'item_code', label: '품번', align: 'left' as const, width: '15%' },
    { key: 'item_name', label: '품명', align: 'left' as const, width: '25%' },
    { key: 'current_stock', label: '현재고', align: 'right' as const, width: '12%', type: 'number' as const },
    { key: 'min_stock_level', label: '최소재고', align: 'right' as const, width: '12%', type: 'number' as const },
    { key: 'stock_value', label: '재고금액', align: 'right' as const, width: '15%', type: 'currency' as const },
    { key: 'location', label: '위치', align: 'left' as const, width: '10%' },
    { key: 'status', label: '상태', align: 'center' as const, width: '11%' }
  ];

  // URL 파라미터가 변경되면 activeTab 업데이트
  useEffect(() => {
    const tab = searchParams?.get('tab') as 'receiving' | 'production' | 'shipping' | null;
    if (tab && ['receiving', 'production', 'shipping'].includes(tab)) {
      setActiveTab(tab);
    }
  }, [searchParams]);

  // activeTab이 변경되면 URL 업데이트
  const handleTabChange = (tab: 'receiving' | 'production' | 'shipping') => {
    setActiveTab(tab);
    router.push(`/inventory?tab=${tab}`);
  };

  useEffect(() => {
    fetchData();
  }, [activeTab, refreshKey]);

  const fetchData = async () => {
    setLoading(true);
    try {
      await Promise.all([
        fetchTransactions(),
        fetchStockInfo()
      ]);
    } catch (error) {
      console.error('Failed to fetch data:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchTransactions = async () => {
    try {
      let url = '/api/inventory';
      const params = new URLSearchParams();

      switch (activeTab) {
        case 'receiving':
          params.append('type', '입고');
          break;
        case 'production':
          url = '/api/inventory/production';
          break;
        case 'shipping':
          url = '/api/inventory/shipping';
          break;
      }

      const response = await fetch(`${url}?${params}`);
      const data = await response.json();

      if (data.success) {
        // Handle paginated response structure
        const transactionsData = data.data?.data || data.data?.transactions || data.data || [];
        setTransactions(Array.isArray(transactionsData) ? transactionsData : []);
      }
    } catch (error) {
      console.error('Failed to fetch transactions:', error);
    }
  };

  const fetchStockInfo = async () => {
    try {
      const response = await fetch('/api/stock');
      const data = await response.json();

      if (data.success) {
        setStockInfo(data.data || []);
      }
    } catch (error) {
      console.error('Failed to fetch stock info:', error);
    }
  };

  const handleFormSubmit = async (formData: any) => {
    try {
      let url = '';
      switch (activeTab) {
        case 'receiving':
          url = '/api/inventory/receiving';
          break;
        case 'production':
          url = '/api/inventory/production';
          break;
        case 'shipping':
          url = '/api/inventory/shipping';
          break;
      }

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify(formData),
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setShowModal(false);
        setRefreshKey(prev => prev + 1);

        // Show success notification
        alert(`${activeTabInfo.label} 처리가 완료되었습니다.`);
      } else {
        alert(`오류: ${data.error || '처리에 실패했습니다'}`);
      }
    } catch (error) {
      console.error('Failed to submit form:', error);
      alert('처리 중 오류가 발생했습니다');
    }
  };

  const getTransactionTypeColor = (type: string) => {
    switch (type) {
      case '입고':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300';
      case '생산입고':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
      case '생산출고':
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300';
      case '출고':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }
  };

  const getStockStatus = (item: StockInfo) => {
    if (!item.min_stock_level) return 'normal';
    if (item.current_stock <= 0) return 'empty';
    if (item.current_stock <= item.min_stock_level) return 'low';
    return 'normal';
  };

  const getStockStatusLabel = (status: string) => {
    switch (status) {
      case 'empty':
        return '재고없음';
      case 'low':
        return '재고부족';
      case 'normal':
        return '정상';
      default:
        return '정상';
    }
  };

  // 인쇄용 재고 데이터 변환
  const printableStockData = stockInfo.map(item => {
    const status = getStockStatus(item);
    return {
      ...item,
      status: getStockStatusLabel(status),
      stock_value: (item.current_stock * (item.unit_price || 0)),
      location: item.location || '-'
    };
  });

  const getStockStatusIcon = (status: string) => {
    switch (status) {
      case 'empty':
        return <AlertCircle className="w-4 h-4 text-red-500" />;
      case 'low':
        return <Clock className="w-4 h-4 text-yellow-500" />;
      default:
        return <CheckCircle className="w-4 h-4 text-green-500" />;
    }
  };

  const renderForm = () => {
    switch (activeTab) {
      case 'receiving':
        return (
          <ReceivingForm
            onSubmit={handleFormSubmit}
            onCancel={() => setShowModal(false)}
          />
        );
      case 'production':
        return (
          <ProductionForm
            onSubmit={handleFormSubmit}
            onCancel={() => setShowModal(false)}
          />
        );
      case 'shipping':
        return (
          <ShippingForm
            onSubmit={handleFormSubmit}
            onCancel={() => setShowModal(false)}
          />
        );
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Package className="w-8 h-8 text-blue-500" />
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">재고 관리</h1>
              <p className="text-gray-600 dark:text-gray-400 mt-1">입고, 생산, 출고 통합 관리</p>
            </div>
          </div>
          <div className="flex gap-2">
            <PrintButton
              data={printableStockData}
              columns={stockPrintColumns}
              title="재고 현황 보고서"
              orientation="landscape"
              variant="icon"
              className="bg-purple-500 hover:bg-purple-600"
            />
            <StockExportButton
              stockData={stockInfo}
              className="text-sm"
            />
          </div>
        </div>
      </div>

      {/* Tab Navigation */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-4 shadow-sm">
        <div className="flex space-x-1 rounded-lg bg-gray-100 dark:bg-gray-800 p-1">
          {tabs.map((tab) => {
            const Icon = tab.icon;
            return (
              <button
                key={tab.id}
                onClick={() => handleTabChange(tab.id)}
                className={`flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-md text-sm font-medium transition-all ${
                  activeTab === tab.id
                    ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                    : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
                }`}
              >
                <Icon className="w-5 h-5" />
                {tab.label}
              </button>
            );
          })}
        </div>
      </div>

      {/* Active Tab Content */}
      <div className={`rounded-lg p-6 shadow-sm ${activeTabInfo.bgColor}`}>
        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center gap-3">
            <activeTabInfo.icon className={`w-6 h-6 ${activeTabInfo.color}`} />
            <div>
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
                {activeTabInfo.label}
              </h2>
              <p className="text-gray-600 dark:text-gray-400 text-sm">
                {activeTabInfo.description}
              </p>
            </div>
          </div>
          <div className="flex gap-2">
            <PrintButton
              data={transactions}
              columns={transactionPrintColumns}
              title={`${activeTabInfo.label} 거래 내역`}
              orientation="landscape"
              variant="icon"
              className="bg-purple-500 hover:bg-purple-600"
            />
            <TransactionsExportButton
              transactions={transactions}
              type={activeTabInfo.label}
              className="text-sm"
            />
            <button
              onClick={() => setShowModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
            >
              <Plus className="w-5 h-5" />
              {activeTab === 'receiving' && '입고 등록'}
              {activeTab === 'production' && '생산 등록'}
              {activeTab === 'shipping' && '출고 등록'}
            </button>
          </div>
        </div>

        {/* Real-time Stock Display */}
        {stockInfo.length > 0 && (
          <div className="mb-6">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">실시간 재고 현황</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {stockInfo.slice(0, 8).map((item) => {
                const status = getStockStatus(item);
                return (
                  <div
                    key={item.item_id}
                    className="bg-white dark:bg-gray-800 rounded-lg p-4 border border-gray-200 dark:border-gray-700"
                  >
                    <div className="flex items-start justify-between">
                      <div className="flex-1 min-w-0">
                        <h4 className="text-sm font-medium text-gray-900 dark:text-white truncate">
                          {item.item_code}
                        </h4>
                        <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                          {item.item_name}
                        </p>
                        <div className="mt-2 flex items-center gap-2">
                          <span className="text-lg font-bold text-gray-900 dark:text-white">
                            {(item.current_stock || 0).toLocaleString()}
                          </span>
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            {item.unit}
                          </span>
                        </div>
                        {item.min_stock_level && (
                          <p className="text-xs text-gray-400">
                            최소: {item.min_stock_level.toLocaleString()} {item.unit}
                          </p>
                        )}
                      </div>
                      <div className="ml-2">
                        {getStockStatusIcon(status)}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Transaction History */}
        <div className="bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden">
          <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">최근 거래 내역</h3>
          </div>
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 dark:bg-gray-800">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    거래일자
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    구분
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    품번/품명
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    수량
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    단가
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    금액
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    거래처
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    참조번호
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                {loading ? (
                  <tr>
                    <td colSpan={8} className="px-6 py-12 text-center text-gray-500">
                      데이터를 불러오는 중...
                    </td>
                  </tr>
                ) : transactions.length === 0 ? (
                  <tr>
                    <td colSpan={8} className="px-6 py-12 text-center text-gray-500">
                      거래 내역이 없습니다
                    </td>
                  </tr>
                ) : (
                  transactions.slice(0, 10).map((transaction) => (
                    <tr key={transaction.transaction_id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
                        {new Date(transaction.transaction_date).toLocaleDateString('ko-KR')}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${getTransactionTypeColor(transaction.transaction_type)}`}>
                          {transaction.transaction_type}
                        </span>
                      </td>
                      <td className="px-6 py-4">
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            {transaction.item_code}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            {transaction.item_name}
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                        {parseFloat(transaction.quantity.toString()).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                        ₩{parseFloat(transaction.unit_price.toString()).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                        ₩{parseFloat(transaction.total_amount.toString()).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                        {transaction.company_name || '-'}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                        {transaction.reference_no || '-'}
                      </td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>
      </div>

      {/* Modal for Forms */}
      <Modal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        title={
          activeTab === 'receiving' ? '입고 등록' :
          activeTab === 'production' ? '생산 등록' :
          '출고 등록'
        }
        size="xl"
      >
        {renderForm()}
      </Modal>
    </div>
  );
}

// 메인 페이지 컴포넌트 - Suspense로 감싸기
export default function InventoryPage() {
  return (
    <Suspense fallback={
      <div className="flex items-center justify-center h-screen">
        <div className="text-gray-600 dark:text-gray-400">로딩 중...</div>
      </div>
    }>
      <InventoryContent />
    </Suspense>
  );
}
```


#### 📄 src\app\inventory\receiving\page.tsx

```typescript
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export default function ReceivingRedirect() {
  const router = useRouter();

  useEffect(() => {
    // Redirect to the main inventory page with receiving tab
    router.replace('/inventory');
  }, [router]);

  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
        <p className="mt-4 text-gray-600">입고 관리 페이지로 이동 중...</p>
      </div>
    </div>
  );
}
```


#### 📄 src\app\layout.tsx

```typescript
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import MainLayout from "@/components/layout/MainLayout";
import { ToastProvider } from "@/contexts/ToastContext";
import QueryProvider from "@/providers/QueryProvider";
import "./globals.css";
import "../styles/print.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "태창 ERP 시스템",
  description: "태창 자동차 부품 제조 ERP 시스템",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <QueryProvider>
          <ToastProvider>
            <MainLayout>{children}</MainLayout>
          </ToastProvider>
        </QueryProvider>
      </body>
    </html>
  );
}

```


#### 📄 src\app\login\page.tsx

```typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2 } from 'lucide-react';

export default function LoginPage() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({ username, password }),
      });

      const data = await response.json();

      if (data.success) {
        // 로그인 성공 시 대시보드로 이동
        router.push('/');
      } else {
        setError(data.error || '로그인에 실패했습니다.');
      }
    } catch (error) {
      console.error('Login error:', error);
      setError('로그인 중 오류가 발생했습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold text-center">태창 ERP 시스템</CardTitle>
          <CardDescription className="text-center">
            계정에 로그인하세요
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            
            <div className="space-y-2">
              <Label htmlFor="username">사용자명</Label>
              <Input
                id="username"
                type="text"
                placeholder="사용자명을 입력하세요"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <Input
                id="password"
                type="password"
                placeholder="비밀번호를 입력하세요"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  로그인 중...
                </>
              ) : (
                '로그인'
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

```


#### 📄 src\app\master\bom\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Network, Plus, Search, Edit2, Trash2, Filter, Copy, FileDown, Printer } from 'lucide-react';
import Modal from '@/components/Modal';
import BOMForm from '@/components/BOMForm';
import { useToast } from '@/contexts/ToastContext';
import { useConfirm } from '@/hooks/useConfirm';
import { BOMExportButton } from '@/components/ExcelExportButton';
import PrintButton from '@/components/PrintButton';
import { printBOM } from '@/utils/printUtils';

interface BOM {
  bom_id: number;
  parent_item_id: number;
  child_item_id: number;
  parent_item_name?: string;
  child_item_name?: string;
  parent_item_code?: string;
  child_item_code?: string;
  quantity: number;
  level: number;
  notes?: string;
  is_active: boolean;
}

export default function BOMPage() {
  const [bomData, setBomData] = useState<BOM[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedParentItem, setSelectedParentItem] = useState('');
  const [showAddModal, setShowAddModal] = useState(false);
  const [editingBOM, setEditingBOM] = useState<BOM | null>(null);
  const [showActiveOnly, setShowActiveOnly] = useState(true);
  const [items, setItems] = useState<any[]>([]);
  const [deletingBomId, setDeletingBomId] = useState<number | null>(null);
  const { success, error } = useToast();
  const { deleteWithToast, ConfirmDialog } = useConfirm();

  // 인쇄용 컬럼 정의
  const printColumns = [
    { key: 'level_display', label: '레벨', align: 'left' as const, width: '8%' },
    { key: 'parent_item_code', label: '모품번', align: 'left' as const, width: '15%' },
    { key: 'parent_item_name', label: '모품명', align: 'left' as const, width: '20%' },
    { key: 'child_item_code', label: '자품번', align: 'left' as const, width: '15%' },
    { key: 'child_item_name', label: '자품명', align: 'left' as const, width: '20%' },
    { key: 'quantity', label: '소요량', align: 'right' as const, width: '10%', type: 'number' as const },
    { key: 'unit', label: '단위', align: 'center' as const, width: '6%' },
    { key: 'notes', label: '비고', align: 'left' as const, width: '6%' }
  ];

  useEffect(() => {
    fetchBOMData();
    fetchItems();
  }, [selectedParentItem, showActiveOnly]);

  const fetchItems = async () => {
    try {
      const response = await fetch('/api/items');
      const data = await response.json();
      if (data.success) {
        setItems(data.data.items || []);
      }
    } catch (error) {
      console.error('Failed to fetch items:', error);
    }
  };

  const fetchBOMData = async () => {
    try {
      const params = new URLSearchParams();
      if (selectedParentItem) params.append('parent_item_id', selectedParentItem);

      const response = await fetch(`/api/bom?${params}`);
      const data = await response.json();

      if (data.success) {
        // Handle nested API response structure
        const bomArray = data.data.bomEntries || [];
        // Filter active items if needed
        const bomList = showActiveOnly
          ? bomArray.filter((item: BOM) => item.is_active)
          : bomArray;

        setBomData(bomList);
      }
    } catch (error) {
      console.error('Failed to fetch BOM data:', error);
    } finally {
      setLoading(false);
    }
  };


  const handleDelete = async (bom: BOM) => {
    const deleteAction = async () => {
      setDeletingBomId(bom.bom_id);
      try {
        const response = await fetch(`/api/bom?bom_id=${bom.bom_id}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'BOM 삭제에 실패했습니다.');
        }

        fetchBOMData();
      } catch (err) {
        console.error('Failed to delete BOM item:', err);
        throw err;
      } finally {
        setDeletingBomId(null);
      }
    };

    await deleteWithToast(deleteAction, {
      title: 'BOM 삭제',
      itemName: `${bom.parent_item_name || '알 수 없는 품목'} → ${bom.child_item_name || '알 수 없는 품목'}`,
      successMessage: 'BOM 항목이 성공적으로 삭제되었습니다.',
      errorMessage: 'BOM 삭제에 실패했습니다.'
    });
  };

  const handleSaveBOM = async (bomData: Omit<BOM, 'bom_id' | 'is_active' | 'level'>) => {
    try {
      const method = editingBOM ? 'PUT' : 'POST';
      const body = editingBOM
        ? { ...bomData, bom_id: editingBOM.bom_id }
        : bomData;

      const response = await fetch('/api/bom', {
        method,
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify(body),
      });

      if (response.ok) {
        const successMessage = editingBOM ? 'BOM이 성공적으로 수정되었습니다.' : 'BOM이 성공적으로 등록되었습니다.';
        success(editingBOM ? 'BOM 수정 완료' : 'BOM 등록 완료', successMessage);
        setShowAddModal(false);
        setEditingBOM(null);
        fetchBOMData();
      } else {
        const errorData = await response.json();
        error('저장 실패', errorData.error || '저장에 실패했습니다.');
      }
    } catch (err) {
      console.error('Failed to save BOM:', err);
      error('네트워크 오류', '서버와의 연결에 문제가 발생했습니다.');
    }
  };

  const handleCloseModal = () => {
    setShowAddModal(false);
    setEditingBOM(null);
  };

  const handleCopyBOM = (bom: BOM) => {
    const confirmCopy = confirm(`${bom.parent_item_name || '알 수 없는 품목'}의 BOM 구조를 복사하시겠습니까?`);
    if (confirmCopy) {
      // TODO: Implement BOM copy functionality
      alert('BOM 복사 기능은 준비 중입니다.');
    }
  };

  const renderBOMRows = (bomList: BOM[]): React.ReactElement[] => {
    return bomList.map((bom) => (
      <tr key={bom.bom_id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
        <td className="px-6 py-4 whitespace-nowrap">
          <div className="flex items-center" style={{ paddingLeft: `${(bom.level || 0) * 20}px` }}>
            <span className="text-sm font-medium text-gray-900 dark:text-white">
              {bom.parent_item_code || '-'}
            </span>
          </div>
        </td>
        <td className="px-6 py-4">
          <span className="text-sm text-gray-900 dark:text-white">
            {bom.parent_item_name || '-'}
          </span>
        </td>
        <td className="px-6 py-4">
          <span className="text-sm text-gray-600 dark:text-gray-400">
            {bom.child_item_code || '-'}
          </span>
        </td>
        <td className="px-6 py-4">
          <span className="text-sm text-gray-600 dark:text-gray-400">
            {bom.child_item_name || '-'}
          </span>
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
          {parseFloat((bom.quantity || 0).toString()).toLocaleString()}
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
          EA
        </td>
        <td className="px-6 py-4 text-sm text-gray-600 dark:text-gray-400">
          {bom.notes || '-'}
        </td>
        <td className="px-6 py-4 whitespace-nowrap">
          <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
            bom.is_active
              ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300'
              : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300'
          }`}>
            {bom.is_active ? '활성' : '비활성'}
          </span>
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-center">
          <div className="flex items-center justify-center gap-2">
            <button
              onClick={() => handleCopyBOM(bom)}
              className="text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300"
              title="BOM 복사"
            >
              <Copy className="w-4 h-4" />
            </button>
            <button
              onClick={() => {
                setEditingBOM(bom);
                setShowAddModal(true);
              }}
              className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
              title="수정"
            >
              <Edit2 className="w-4 h-4" />
            </button>
            <button
              onClick={() => handleDelete(bom)}
              disabled={deletingBomId === bom.bom_id}
              className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 disabled:opacity-50 disabled:cursor-not-allowed"
              title="삭제"
            >
              {deletingBomId === bom.bom_id ? (
                <div className="w-4 h-4 border-2 border-red-600 border-t-transparent rounded-full animate-spin"></div>
              ) : (
                <Trash2 className="w-4 h-4" />
              )}
            </button>
          </div>
        </td>
      </tr>
    ));
  };

  const filteredBOMData = bomData.filter(bom =>
    bom.parent_item_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    bom.child_item_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    bom.parent_item_code?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    bom.child_item_code?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // 인쇄용 데이터 변환 (레벨 표시 추가)
  const printableBOMData = filteredBOMData.map(bom => ({
    ...bom,
    level_display: '├─'.repeat((bom.level || 0)) + (bom.level ? ' ' : ''),
    unit: 'EA' // BOM에서는 일반적으로 EA 단위 사용
  }));

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Network className="w-8 h-8 text-blue-500" />
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">BOM 관리</h1>
              <p className="text-gray-600 dark:text-gray-400 mt-1">부품 구성표(Bill of Materials)를 관리합니다</p>
            </div>
          </div>
          <div className="flex gap-2">
            <PrintButton
              data={printableBOMData}
              columns={printColumns}
              title="BOM 구조도"
              subtitle={selectedParentItem ? `모품목 필터 적용` : undefined}
              orientation="landscape"
              className="bg-purple-500 hover:bg-purple-600"
            />
            <BOMExportButton
              bomData={filteredBOMData}
              filtered={searchTerm !== '' || selectedParentItem !== '' || !showActiveOnly}
            />
            <button
              onClick={() => setShowAddModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
            >
              <Plus className="w-5 h-5" />
              BOM 등록
            </button>
          </div>
        </div>
      </div>

      {/* Filters and Search */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-4 shadow-sm">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="flex-1">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="text"
                placeholder="품번, 품명으로 검색..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>
          <div className="flex gap-2">
            <select
              value={selectedParentItem}
              onChange={(e) => setSelectedParentItem(e.target.value)}
              className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 모품목</option>
              {items.filter(item => item.category === '제품').map(item => (
                <option key={item.item_id} value={item.item_id}>
                  {item.item_code} - {item.item_name}
                </option>
              ))}
            </select>
            <div className="flex items-center gap-2 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg">
              <input
                type="checkbox"
                id="activeOnly"
                checked={showActiveOnly}
                onChange={(e) => setShowActiveOnly(e.target.checked)}
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <label htmlFor="activeOnly" className="text-sm text-gray-700 dark:text-gray-300">
                활성만 표시
              </label>
            </div>
            <button className="flex items-center gap-2 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
              <Filter className="w-5 h-5" />
              필터
            </button>
          </div>
        </div>
      </div>

      {/* BOM Tree Table */}
      <div className="bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-800">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  모품번
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  모품명
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  자품번
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  자품명
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  소요량
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  단위
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  비고
                </th>
                <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  상태
                </th>
                <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  작업
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {loading ? (
                <tr>
                  <td colSpan={9} className="px-6 py-12 text-center text-gray-500">
                    데이터를 불러오는 중...
                  </td>
                </tr>
              ) : filteredBOMData.length === 0 ? (
                <tr>
                  <td colSpan={9} className="px-6 py-12 text-center text-gray-500">
                    등록된 BOM이 없습니다
                  </td>
                </tr>
              ) : (
                renderBOMRows(filteredBOMData)
              )}
            </tbody>
          </table>
        </div>
      </div>

      {/* Modal for Add/Edit BOM */}
      <Modal
        isOpen={showAddModal || !!editingBOM}
        onClose={handleCloseModal}
        title={editingBOM ? 'BOM 수정' : 'BOM 등록'}
        size="lg"
      >
        <BOMForm
          bom={editingBOM}
          items={items}
          onSubmit={handleSaveBOM}
          onCancel={handleCloseModal}
        />
      </Modal>

      {/* Confirmation Dialog */}
      <ConfirmDialog />
    </div>
  );
}
```


#### 📄 src\app\master\companies\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { Building2, Plus, Search, Edit2, Trash2, Filter, Phone, Mail, Upload, Download, Printer } from 'lucide-react';
import { TableSkeleton } from '@/components/ui/Skeleton';
import { useToast } from '@/contexts/ToastContext';
import { useConfirm } from '@/hooks/useConfirm';
import { CompaniesExportButton } from '@/components/ExcelExportButton';
import PrintButton from '@/components/PrintButton';
import { printCompanies } from '@/utils/printUtils';

// Dynamic imports for form components
const Modal = dynamic(() => import('@/components/Modal'), {
  loading: () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl">
        <div className="animate-pulse">
          <div className="h-6 bg-gray-300 dark:bg-gray-600 rounded mb-4"></div>
          <div className="h-64 bg-gray-300 dark:bg-gray-600 rounded"></div>
        </div>
      </div>
    </div>
  ),
  ssr: false
});

const CompanyForm = dynamic(() => import('@/components/CompanyForm'), {
  loading: () => (
    <div className="animate-pulse">
      <div className="grid grid-cols-2 gap-4 mb-4">
        <div className="h-10 bg-gray-300 dark:bg-gray-600 rounded"></div>
        <div className="h-10 bg-gray-300 dark:bg-gray-600 rounded"></div>
      </div>
      <div className="h-32 bg-gray-300 dark:bg-gray-600 rounded mb-4"></div>
      <div className="flex justify-end gap-2">
        <div className="h-10 w-20 bg-gray-300 dark:bg-gray-600 rounded"></div>
        <div className="h-10 w-20 bg-gray-300 dark:bg-gray-600 rounded"></div>
      </div>
    </div>
  ),
  ssr: false
});

const ExcelUploadModal = dynamic(() => import('@/components/upload/ExcelUploadModal'), {
  loading: () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="animate-pulse">
          <div className="h-6 bg-gray-300 dark:bg-gray-600 rounded mb-4"></div>
          <div className="h-32 bg-gray-300 dark:bg-gray-600 rounded"></div>
        </div>
      </div>
    </div>
  ),
  ssr: false
});

interface Company {
  company_id: number;
  company_name: string;
  company_type: 'CUSTOMER' | 'SUPPLIER' | 'BOTH';
  business_registration_no?: string;
  contact_person?: string;
  phone?: string;
  mobile?: string;
  email?: string;
  address?: string;
  payment_terms?: number;
  contact_info?: string;
  notes?: string;
  is_active: boolean;
}

export default function CompaniesPage() {
  const [companies, setCompanies] = useState<Company[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedType, setSelectedType] = useState('');
  const [showAddModal, setShowAddModal] = useState(false);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [editingCompany, setEditingCompany] = useState<Company | null>(null);
  const [deletingCompanyId, setDeletingCompanyId] = useState<number | null>(null);
  const { success, error } = useToast();
  const { deleteWithToast, ConfirmDialog } = useConfirm();

  const companyTypes = [
    { value: 'CUSTOMER', label: '고객사' },
    { value: 'SUPPLIER', label: '공급사' },
    { value: 'BOTH', label: '고객사/공급사' }
  ];

  // 인쇄용 컬럼 정의
  const printColumns = [
    { key: 'company_name', label: '거래처명', align: 'left' as const, width: '25%' },
    { key: 'company_type', label: '구분', align: 'center' as const, width: '10%' },
    { key: 'business_registration_no', label: '사업자번호', align: 'left' as const, width: '15%' },
    { key: 'contact_person', label: '담당자', align: 'left' as const, width: '15%' },
    { key: 'phone', label: '전화번호', align: 'left' as const, width: '15%' },
    { key: 'address', label: '주소', align: 'left' as const, width: '20%' }
  ];

  useEffect(() => {
    fetchCompanies();
  }, [selectedType]);

  const fetchCompanies = async () => {
    try {
      const params = new URLSearchParams();
      if (selectedType) params.append('type', selectedType);

      const response = await fetch(`/api/companies?${params}`);
      const data = await response.json();

      if (data.success) {
        // Handle paginated response structure
        const companiesData = data.data?.data || [];
        setCompanies(Array.isArray(companiesData) ? companiesData : []);
      } else {
        error('데이터 로드 실패', '거래처 목록을 불러오는데 실패했습니다.');
      }
    } catch (err) {
      console.error('Failed to fetch companies:', err);
      error('네트워크 오류', '서버와의 연결에 문제가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (company: Company) => {
    const deleteAction = async () => {
      setDeletingCompanyId(company.company_id);
      try {
        const response = await fetch(`/api/companies?id=${company.company_id}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || '거래처 삭제에 실패했습니다.');
        }

        fetchCompanies();
      } catch (err) {
        console.error('Failed to delete company:', err);
        throw err;
      } finally {
        setDeletingCompanyId(null);
      }
    };

    await deleteWithToast(deleteAction, {
      title: '거래처 삭제',
      itemName: `${company.company_name}`,
      successMessage: '거래처가 성공적으로 삭제되었습니다.',
      errorMessage: '거래처 삭제에 실패했습니다.'
    });
  };

  const handleSaveCompany = async (companyData: Omit<Company, 'company_id' | 'is_active'>) => {
    try {
      const method = editingCompany ? 'PUT' : 'POST';
      const body = editingCompany
        ? { ...companyData, id: editingCompany.company_id }
        : companyData;

      const response = await fetch('/api/companies', {
        method,
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify(body),
      });

      if (response.ok) {
        const successMessage = editingCompany ? '거래처가 성공적으로 수정되었습니다.' : '거래처가 성공적으로 등록되었습니다.';
        success(editingCompany ? '거래처 수정 완료' : '거래처 등록 완료', successMessage);
        setShowAddModal(false);
        setEditingCompany(null);
        fetchCompanies();
      } else {
        const errorData = await response.json();
        error('저장 실패', errorData.error || '저장에 실패했습니다.');
      }
    } catch (err) {
      console.error('Failed to save company:', err);
      error('네트워크 오류', '서버와의 연결에 문제가 발생했습니다.');
    }
  };

  const handleCloseModal = () => {
    setShowAddModal(false);
    setEditingCompany(null);
  };

  const handleUploadSuccess = () => {
    success('엑셀 업로드 완료', '거래처 데이터가 성공적으로 업로드되었습니다.');
    setShowUploadModal(false);
    fetchCompanies();
  };

  const handleTemplateDownload = async () => {
    try {
      const response = await fetch('/api/download/template/companies');
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '거래처_템플릿.xlsx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      success('템플릿 다운로드 완료', '거래처 템플릿 파일이 다운로드되었습니다.');
    } catch (err) {
      console.error('Failed to download template:', err);
      error('다운로드 실패', '템플릿 다운로드에 실패했습니다.');
    }
  };

  const getTypeLabel = (type: string) => {
    const found = companyTypes.find(t => t.value === type);
    return found ? found.label : type;
  };

  const getTypeBadgeColor = (type: string) => {
    switch (type) {
      case 'CUSTOMER':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300';
      case 'SUPPLIER':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
      case 'BOTH':
        return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }
  };

  const filteredCompanies = companies.filter(company =>
    company.company_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    company.business_registration_no?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    company.contact_person?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // 인쇄용 데이터 변환 (타입 라벨 변환)
  const printableCompanies = filteredCompanies.map(company => ({
    ...company,
    company_type: getTypeLabel(company.company_type)
  }));

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Building2 className="w-8 h-8 text-blue-500" />
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">거래처 관리</h1>
              <p className="text-gray-600 dark:text-gray-400 mt-1">고객사 및 공급사 정보를 관리합니다</p>
            </div>
          </div>
          <div className="flex gap-2">
            <PrintButton
              data={printableCompanies}
              columns={printColumns}
              title="거래처 목록"
              subtitle={selectedType ? getTypeLabel(selectedType) : undefined}
              orientation="portrait"
              className="bg-purple-500 hover:bg-purple-600"
            />
            <button
              onClick={handleTemplateDownload}
              className="flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
            >
              <Download className="w-5 h-5" />
              템플릿 다운로드
            </button>
            <CompaniesExportButton
              companies={filteredCompanies}
              filtered={searchTerm !== '' || selectedType !== ''}
            />
            <button
              onClick={() => setShowUploadModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
            >
              <Upload className="w-5 h-5" />
              엑셀 업로드
            </button>
            <button
              onClick={() => setShowAddModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
            >
              <Plus className="w-5 h-5" />
              거래처 등록
            </button>
          </div>
        </div>
      </div>

      {/* Filters and Search */}
      <div className="bg-white dark:bg-gray-900 rounded-lg p-4 shadow-sm">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="flex-1">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="text"
                placeholder="거래처명, 사업자번호, 담당자로 검색..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>
          <div className="flex gap-2">
            <select
              value={selectedType}
              onChange={(e) => setSelectedType(e.target.value)}
              className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 타입</option>
              {companyTypes.map(type => (
                <option key={type.value} value={type.value}>{type.label}</option>
              ))}
            </select>
            <button className="flex items-center gap-2 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
              <Filter className="w-5 h-5" />
              필터
            </button>
          </div>
        </div>
      </div>

      {/* Companies Table */}
      <div className="bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-800">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  거래처명
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  타입
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  사업자번호
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  담당자
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  연락처
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  이메일
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  결제조건
                </th>
                <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  작업
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {loading ? (
                <tr>
                  <td colSpan={8} className="p-6">
                    <TableSkeleton rows={6} columns={8} showHeader={false} />
                  </td>
                </tr>
              ) : filteredCompanies.length === 0 ? (
                <tr>
                  <td colSpan={8} className="px-6 py-12 text-center text-gray-500">
                    등록된 거래처가 없습니다
                  </td>
                </tr>
              ) : (
                filteredCompanies.map((company) => (
                  <tr key={company.company_id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                    <td className="px-6 py-4">
                      <span className="text-sm font-medium text-gray-900 dark:text-white">
                        {company.company_name}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${getTypeBadgeColor(company.company_type)}`}>
                        {getTypeLabel(company.company_type)}
                      </span>
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-600 dark:text-gray-400">
                      {company.business_registration_no || '-'}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                      {company.contact_person || '-'}
                    </td>
                    <td className="px-6 py-4">
                      <div className="flex flex-col gap-1">
                        {company.phone && (
                          <div className="flex items-center gap-1 text-sm text-gray-600 dark:text-gray-400">
                            <Phone className="w-3 h-3" />
                            {company.phone}
                          </div>
                        )}
                        {company.mobile && (
                          <div className="text-sm text-gray-600 dark:text-gray-400">
                            {company.mobile}
                          </div>
                        )}
                        {!company.phone && !company.mobile && (
                          <span className="text-sm text-gray-400">-</span>
                        )}
                      </div>
                    </td>
                    <td className="px-6 py-4">
                      {company.email ? (
                        <div className="flex items-center gap-1 text-sm text-gray-600 dark:text-gray-400">
                          <Mail className="w-3 h-3" />
                          {company.email}
                        </div>
                      ) : (
                        <span className="text-sm text-gray-400">-</span>
                      )}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                      {company.payment_terms ? `${company.payment_terms}일` : '-'}
                    </td>
                    <td className="px-6 py-4 text-center">
                      <button
                        onClick={() => {
                          setEditingCompany(company);
                          setShowAddModal(true);
                        }}
                        className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 mr-3"
                      >
                        <Edit2 className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => handleDelete(company)}
                        disabled={deletingCompanyId === company.company_id}
                        className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        {deletingCompanyId === company.company_id ? (
                          <div className="w-4 h-4 border-2 border-red-600 border-t-transparent rounded-full animate-spin"></div>
                        ) : (
                          <Trash2 className="w-4 h-4" />
                        )}
                      </button>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>
      </div>

      {/* Modal for Add/Edit Company */}
      <Modal
        isOpen={showAddModal || !!editingCompany}
        onClose={handleCloseModal}
        title={editingCompany ? '거래처 수정' : '거래처 등록'}
        size="lg"
      >
        <CompanyForm
          company={editingCompany}
          onSubmit={handleSaveCompany}
          onCancel={handleCloseModal}
        />
      </Modal>

      {/* Excel Upload Modal */}
      <ExcelUploadModal
        isOpen={showUploadModal}
        onClose={() => setShowUploadModal(false)}
        uploadUrl="/api/upload/companies"
        title="거래처 엑셀 업로드"
        onUploadSuccess={handleUploadSuccess}
      />

      {/* Confirmation Dialog */}
      <ConfirmDialog />
    </div>
  );
}
```


#### 📄 src\app\master\items\page.tsx

```typescript
'use client';

import { useEffect, useMemo, useState } from 'react';
import dynamic from 'next/dynamic';
import { Package, Plus, Search, Edit2, Trash2, RotateCcw, Upload, Download, Printer } from 'lucide-react';
import { TableSkeleton } from '@/components/ui/Skeleton';
import { useToast } from '@/contexts/ToastContext';
import { useConfirm } from '@/hooks/useConfirm';
import { ItemsExportButton } from '@/components/ExcelExportButton';
import PrintButton from '@/components/PrintButton';
import type { ItemCategory, ItemTypeCode, MaterialTypeCode } from '@/types/supabase';

const Modal = dynamic(() => import('@/components/Modal'), { ssr: false });
const ItemForm = dynamic(() => import('@/components/ItemForm'), { ssr: false });
const ExcelUploadModal = dynamic(() => import('@/components/upload/ExcelUploadModal'), { ssr: false });

type Item = {
  item_id: number;
  item_code: string;
  item_name: string;
  category: ItemCategory | string;
  item_type?: ItemTypeCode | string | null;
  material_type?: MaterialTypeCode | string | null;
  vehicle_model?: string | null;
  material?: string | null;
  spec?: string | null;
  unit: string;
  thickness?: number | null;
  width?: number | null;
  height?: number | null;
  specific_gravity?: number | null;
  mm_weight?: number | null;
  daily_requirement?: number | null;
  blank_size?: number | null;
  current_stock?: number | null;
  safety_stock?: number | null;
  price?: number | null;
  location?: string | null;
  description?: string | null;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

const CATEGORY_OPTIONS: ItemCategory[] = ['원자재', '부자재', '반제품', '완제품', '폐제품'];
const ITEM_TYPE_OPTIONS: { value: ItemTypeCode; label: string }[] = [
  { value: 'RAW', label: '원자재 (RAW)' },
  { value: 'SUB', label: '부자재 (SUB)' },
  { value: 'FINISHED', label: '완제품 (FINISHED)' }
];
const MATERIAL_TYPE_OPTIONS: { value: MaterialTypeCode; label: string }[] = [
  { value: 'COIL', label: 'COIL' },
  { value: 'SHEET', label: 'SHEET' },
  { value: 'OTHER', label: '기타 (OTHER)' }
];

const ITEM_TYPE_LABEL: Record<string, string> = {
  RAW: 'RAW',
  SUB: 'SUB',
  FINISHED: 'FINISHED'
};

const formatNumberValue = (value?: number | null, fractionDigits = 0) => {
  if (value === null || value === undefined) {
    return '-';
  }

  return Number(value).toLocaleString(undefined, {
    minimumFractionDigits: fractionDigits,
    maximumFractionDigits: fractionDigits
  });
};

const formatCurrency = (value?: number | null) => {
  if (value === null || value === undefined) {
    return '-';
  }

  return `₩${Number(value).toLocaleString()}`;
};

const formatItemTypeLabel = (itemType?: string | null) => {
  if (!itemType) return '-';
  return ITEM_TYPE_LABEL[itemType] ?? itemType;
};

export default function ItemsPage() {
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('');
  const [selectedItemType, setSelectedItemType] = useState('');
  const [selectedMaterialType, setSelectedMaterialType] = useState('');
  const [vehicleFilter, setVehicleFilter] = useState('');
  const [showAddModal, setShowAddModal] = useState(false);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [editingItem, setEditingItem] = useState<Item | null>(null);
  const [deletingItemId, setDeletingItemId] = useState<number | null>(null);
  const { success, error } = useToast();
  const { deleteWithToast, ConfirmDialog } = useConfirm();

  useEffect(() => {
    fetchItems();
  }, [selectedCategory, selectedItemType, selectedMaterialType, vehicleFilter]);

  const fetchItems = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (selectedCategory) params.append('category', selectedCategory);
      if (selectedItemType) params.append('itemType', selectedItemType);
      if (selectedMaterialType) params.append('materialType', selectedMaterialType);
      if (vehicleFilter) params.append('vehicleModel', vehicleFilter);

      const response = await fetch(`/api/items?${params.toString()}`);
      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || '품목 정보를 불러오지 못했습니다.');
      }

      setItems(data.data?.items ?? []);
    } catch (err) {
      console.error('Failed to fetch items:', err);
      error('데이터 로드 실패', '품목 데이터를 가져오는 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (item: Item) => {
    const deleteAction = async () => {
      setDeletingItemId(item.item_id);
      try {
        const response = await fetch('/api/items', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json; charset=utf-8' },
          body: JSON.stringify({ item_id: item.item_id })
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || '품목 삭제에 실패했습니다.');
        }

        success('삭제 완료', '품목이 비활성화되었습니다.');
        fetchItems();
      } finally {
        setDeletingItemId(null);
      }
    };

    await deleteWithToast(deleteAction, {
      title: '품목 삭제',
      itemName: `${item.item_name} (${item.item_code})`,
      successMessage: '품목이 비활성화되었습니다.',
      errorMessage: '품목 삭제 중 오류가 발생했습니다.'
    });
  };

  const handleSaveItem = async (payload: Record<string, unknown>) => {
    try {
      const method = editingItem ? 'PUT' : 'POST';
      const body = editingItem ? { ...payload, item_id: editingItem.item_id } : payload;

      const response = await fetch('/api/items', {
        method,
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        },
        body: JSON.stringify(body)
      });

      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error || '품목 저장 요청에 실패했습니다.');
      }

      const message = editingItem ? '품목이 수정되었습니다.' : '품목이 등록되었습니다.';
      success(editingItem ? '수정 완료' : '등록 완료', message);
      setShowAddModal(false);
      setEditingItem(null);
      fetchItems();
    } catch (err) {
      console.error('Failed to save item:', err);
      error('요청 실패', '품목 정보를 저장하는 중 오류가 발생했습니다.');
    }
  };

  const handleCloseModal = () => {
    setShowAddModal(false);
    setEditingItem(null);
  };

  const handleUploadSuccess = () => {
    success('업로드 완료', '품목 데이터가 성공적으로 업로드되었습니다.');
    setShowUploadModal(false);
    fetchItems();
  };

  const handleTemplateDownload = async () => {
    try {
      const response = await fetch('/api/download/template/items');
      if (!response.ok) {
        throw new Error('템플릿 다운로드에 실패했습니다.');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = response.headers.get('Content-Disposition')?.split('filename=')[1]?.replace(/"/g, '') || 'items_template.xlsx';
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download template:', err);
      error('다운로드 실패', '템플릿 파일을 다운로드하지 못했습니다.');
    }
  };

  const resetFilters = () => {
    setSelectedCategory('');
    setSelectedItemType('');
    setSelectedMaterialType('');
    setVehicleFilter('');
    setSearchTerm('');
    fetchItems();
  };

  const normalizedSearch = searchTerm.trim().toLowerCase();

  const filteredItems = useMemo(() => {
    if (!normalizedSearch) {
      return items;
    }

    return items.filter((item) => {
      const codeMatch = item.item_code?.toLowerCase().includes(normalizedSearch);
      const nameMatch = item.item_name?.toLowerCase().includes(normalizedSearch);
      const specMatch = item.spec?.toLowerCase().includes(normalizedSearch);
      const materialMatch = item.material?.toLowerCase().includes(normalizedSearch);
      const vehicleMatch = item.vehicle_model?.toLowerCase().includes(normalizedSearch);
      return Boolean(codeMatch || nameMatch || specMatch || materialMatch || vehicleMatch);
    });
  }, [items, normalizedSearch]);

  const filtersApplied = Boolean(
    selectedCategory || selectedItemType || selectedMaterialType || vehicleFilter || normalizedSearch
  );

  const printColumns = [
    { key: 'item_code', label: '품목코드', align: 'left' as const, width: '12%' },
    { key: 'item_name', label: '품목명', align: 'left' as const, width: '18%' },
    { key: 'category', label: '분류', align: 'center' as const, width: '8%' },
    { key: 'item_type', label: '타입', align: 'center' as const, width: '8%' },
    { key: 'material_type', label: '소재형태', align: 'center' as const, width: '10%' },
    { key: 'vehicle_model', label: '차종', align: 'left' as const, width: '10%' },
    { key: 'spec', label: '규격', align: 'left' as const, width: '15%' },
    { key: 'mm_weight', label: '단위중량', align: 'right' as const, width: '8%', type: 'number' as const },
    { key: 'current_stock', label: '현재고', align: 'right' as const, width: '8%', type: 'number' as const },
    { key: 'safety_stock', label: '안전재고', align: 'right' as const, width: '8%', type: 'number' as const },
    { key: 'price', label: '기준단가', align: 'right' as const, width: '9%', type: 'currency' as const }
  ];

  return (
    <div className="space-y-6">
      <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Package className="w-8 h-8 text-blue-500" />
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark$text-white">품목 관리</h1>
              <p className="text-gray-600 dark:text-gray-400 mt-1">자동차 부품 및 원자재 품목을 관리합니다.</p>
            </div>
          </div>
          <div className="flex flex-wrap gap-2 justify-end">
            <PrintButton
              data={filteredItems}
              columns={printColumns}
              title="품목 목록"
              subtitle={filtersApplied ? '필터 적용됨' : undefined}
              orientation="landscape"
              className="bg-purple-500 hover:bg-purple-600"
            />
            <button
              onClick={handleTemplateDownload}
              className="flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
            >
              <Download className="w-5 h-5" />
              템플릿 다운로드
            </button>
            <ItemsExportButton items={filteredItems} filtered={filtersApplied} />
            <button
              onClick={() => setShowUploadModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
            >
              <Upload className="w-5 h-5" />
              일괄 업로드
            </button>
            <button
              onClick={() => setShowAddModal(true)}
              className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
            >
              <Plus className="w-5 h-5" />
              품목 등록
            </button>
          </div>
        </div>
      </div>

      <div className="bg-white dark:bg-gray-900 rounded-lg p-4 shadow-sm">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="flex-1">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="text"
                placeholder="품목코드, 품목명, 규격, 소재로 검색..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>
          <div className="flex flex-wrap gap-2 md:w-auto">
            <select
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
                className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 분류</option>
              {CATEGORY_OPTIONS.map((category) => (
                <option key={category} value={category}>
                  {category}
                </option>
              ))}
            </select>
            <select
              value={selectedItemType}
              onChange={(e) => setSelectedItemType(e.target.value)}
              className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 타입</option>
              {ITEM_TYPE_OPTIONS.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
            <select
              value={selectedMaterialType}
              onChange={(e) => setSelectedMaterialType(e.target.value)}
              className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 소재</option>
              {MATERIAL_TYPE_OPTIONS.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
            <input
              type="text"
              value={vehicleFilter}
              onChange={(e) => setVehicleFilter(e.target.value)}
              placeholder="차종 필터"
              className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <button
              type="button"
              onClick={resetFilters}
              className="flex items-center gap-2 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
            >
              <RotateCcw className="w-5 h-5" />
              초기화
            </button>
          </div>
        </div>
      </div>

      <div className="bg-white dark:bg-gray-900 rounded-lg shadow-sm overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-800">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  품목코드
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  품목명
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  분류
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  타입
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  소재형태
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  차종
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  규격 / 소재
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  단위중량(kg)
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  현재고
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  안전재고
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  기준단가
                </th>
                <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  작업
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {loading ? (
                <tr>
                  <td colSpan={12} className="p-6">
                    <TableSkeleton rows={8} columns={12} showHeader={false} />
                  </td>
                </tr>
              ) : filteredItems.length === 0 ? (
                <tr>
                  <td colSpan={12} className="px-6 py-12 text-center text-gray-500">
                    조건에 맞는 품목이 없습니다.
                  </td>
                </tr>
              ) : (
                filteredItems.map((item) => (
                  <tr key={item.item_id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className="text-sm font-medium text-gray-900 dark:text-white">
                        {item.item_code}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className="text-sm text-gray-900 dark:text-white">
                        {item.item_name}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className="text-sm text-gray-600 dark:text-gray-400">
                        {item.category ?? '-'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span
                        className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                          item.item_type === 'FINISHED'
                            ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300'
                            : item.item_type === 'SUB'
                            ? 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300'
                            : item.item_type === 'RAW'
                            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300'
                            : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                        }`}
                      >
                        {formatItemTypeLabel(item.item_type)}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className="text-sm text-gray-600 dark:text-gray-400">
                        {item.material_type ?? '-'}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className="text-sm text-gray-600 dark:text-gray-400">
                        {item.vehicle_model || '-'}
                      </span>
                    </td>
                    <td className="px-6 py-4">
                      <span className="text-sm text-gray-600 dark:text-gray-400">
                        {item.spec || item.material || '-'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                      {formatNumberValue(item.mm_weight, 4)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                      {formatNumberValue(item.current_stock)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                      {formatNumberValue(item.safety_stock)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-900 dark:text-white">
                      {formatCurrency(item.price)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-center">
                      <button
                        onClick={() => {
                          setEditingItem(item);
                          setShowAddModal(true);
                        }}
                        className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 mr-3"
                      >
                        <Edit2 className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => handleDelete(item)}
                        disabled={deletingItemId === item.item_id}
                        className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        {deletingItemId === item.item_id ? (
                          <div className="w-4 h-4 border-2 border-red-600 border-t-transparent rounded-full animate-spin"></div>
                        ) : (
                          <Trash2 className="w-4 h-4" />
                        )}
                      </button>
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>
      </div>

      <Modal
        isOpen={showAddModal || !!editingItem}
        onClose={handleCloseModal}
        title={editingItem ? '품목 수정' : '품목 등록'}
        size="lg"
      >
        <ItemForm item={editingItem} onSubmit={handleSaveItem} onCancel={handleCloseModal} />
      </Modal>

      <ExcelUploadModal
        isOpen={showUploadModal}
        onClose={() => setShowUploadModal(false)}
        uploadUrl="/api/upload/items"
        title="품목 데이터 업로드"
        onUploadSuccess={handleUploadSuccess}
      />

      <ConfirmDialog />
    </div>
  );
}


```


#### 📄 src\app\monitoring\health\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import {
  CheckCircle,
  XCircle,
  AlertTriangle,
  RefreshCw,
  Database,
  MemoryStick,
  HardDrive,
  Settings,
  Clock,
  Activity
} from 'lucide-react';

interface DetailedHealthCheck {
  status: string;
  timestamp: string;
  uptime: number;
  version: string;
  responseTime: number;
  basicChecks: {
    database: {
      status: string;
      responseTime: number;
      connections: number;
      error?: string;
    };
    memory: {
      usage: number;
      heap: number;
      external: number;
    };
  };
  detailedChecks: {
    databaseTables: {
      status: string;
      tablesChecked: number;
      failedTables: number;
      responseTime: number;
      error?: string;
    };
    filesystem: {
      status: string;
      logsDirectory: string;
      writable: boolean;
      error?: string;
    };
    environment: {
      status: string;
      requiredVariables: number;
      missingVariables: string[];
      nodeEnv: string;
    };
  };
  correlationId: string;
}

export default function HealthCheckPage() {
  const [healthData, setHealthData] = useState<DetailedHealthCheck | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Fetch detailed health check
  const fetchDetailedHealth = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/health', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      setHealthData(data);
    } catch (err) {
      console.error('Error fetching detailed health:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  // Initial load
  useEffect(() => {
    fetchDetailedHealth();
  }, []);

  // Get status icon
  const getStatusIcon = (status: string, size = 'w-5 h-5') => {
    switch (status) {
      case 'healthy':
        return <CheckCircle className={`${size} text-green-500`} />;
      case 'degraded':
        return <AlertTriangle className={`${size} text-yellow-500`} />;
      case 'unhealthy':
        return <XCircle className={`${size} text-red-500`} />;
      default:
        return <AlertTriangle className={`${size} text-gray-500`} />;
    }
  };

  // Get status color class
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'healthy':
        return 'border-green-200 bg-green-50 dark:bg-green-900/20';
      case 'degraded':
        return 'border-yellow-200 bg-yellow-50 dark:bg-yellow-900/20';
      case 'unhealthy':
        return 'border-red-200 bg-red-50 dark:bg-red-900/20';
      default:
        return 'border-gray-200 bg-gray-50 dark:bg-gray-900/20';
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-start">
        <div>
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">시스템 헬스체크</h1>
          <p className="mt-2 text-gray-600 dark:text-gray-400">
            상세한 시스템 상태 검사 및 진단
          </p>
        </div>

        <button
          onClick={fetchDetailedHealth}
          disabled={loading}
          className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
          <span>헬스체크 실행</span>
        </button>
      </div>

      {/* Error Display */}
      {error && (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
          <div className="flex items-center space-x-2">
            <XCircle className="w-5 h-5 text-red-500" />
            <span className="text-red-700 dark:text-red-400">오류: {error}</span>
          </div>
        </div>
      )}

      {/* Loading State */}
      {loading && (
        <div className="flex items-center justify-center py-12">
          <div className="flex items-center space-x-3">
            <RefreshCw className="w-6 h-6 animate-spin text-blue-500" />
            <span className="text-gray-600 dark:text-gray-400">상세 헬스체크를 실행하는 중...</span>
          </div>
        </div>
      )}

      {/* Health Data */}
      {healthData && !loading && (
        <>
          {/* Overall Status */}
          <div className={`border rounded-lg p-6 ${getStatusColor(healthData.status)}`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3">
                {getStatusIcon(healthData.status, 'w-8 h-8')}
                <div>
                  <h2 className="text-2xl font-bold">전체 시스템 상태</h2>
                  <p className="text-gray-600 dark:text-gray-400">
                    {new Date(healthData.timestamp).toLocaleString('ko-KR')}
                  </p>
                </div>
              </div>
              <div className="text-right">
                <div className="text-3xl font-bold text-gray-900 dark:text-white">
                  {healthData.status.toUpperCase()}
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">
                  응답시간: {healthData.responseTime}ms
                </div>
              </div>
            </div>
          </div>

          {/* Basic Checks */}
          <div>
            <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">기본 상태 검사</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Database Check */}
              <div className={`border rounded-lg p-6 ${getStatusColor(healthData.basicChecks.database.status)}`}>
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-3">
                    <Database className="w-6 h-6 text-blue-500" />
                    <div>
                      <h4 className="font-semibold">데이터베이스</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">연결 및 응답성</p>
                    </div>
                  </div>
                  {getStatusIcon(healthData.basicChecks.database.status)}
                </div>
                <div className="mt-4 space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>응답시간</span>
                    <span className="font-medium">{healthData.basicChecks.database.responseTime}ms</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>연결 수</span>
                    <span className="font-medium">{healthData.basicChecks.database.connections}</span>
                  </div>
                  {healthData.basicChecks.database.error && (
                    <div className="text-sm text-red-600 dark:text-red-400">
                      오류: {healthData.basicChecks.database.error}
                    </div>
                  )}
                </div>
              </div>

              {/* Memory Check */}
              <div className="border rounded-lg p-6 bg-white dark:bg-gray-800">
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-3">
                    <MemoryStick className="w-6 h-6 text-green-500" />
                    <div>
                      <h4 className="font-semibold">메모리</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">사용량 및 힙 상태</p>
                    </div>
                  </div>
                  <CheckCircle className="w-5 h-5 text-green-500" />
                </div>
                <div className="mt-4 space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>RSS 메모리</span>
                    <span className="font-medium">{Math.round(healthData.basicChecks.memory.usage)}MB</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>힙 메모리</span>
                    <span className="font-medium">{Math.round(healthData.basicChecks.memory.heap)}MB</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>외부 메모리</span>
                    <span className="font-medium">{Math.round(healthData.basicChecks.memory.external)}MB</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Detailed Checks */}
          <div>
            <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">상세 상태 검사</h3>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {/* Database Tables Check */}
              <div className={`border rounded-lg p-6 ${getStatusColor(healthData.detailedChecks.databaseTables.status)}`}>
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-3">
                    <Database className="w-6 h-6 text-blue-500" />
                    <div>
                      <h4 className="font-semibold">데이터베이스 테이블</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">테이블 접근성</p>
                    </div>
                  </div>
                  {getStatusIcon(healthData.detailedChecks.databaseTables.status)}
                </div>
                <div className="mt-4 space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>검사한 테이블</span>
                    <span className="font-medium">{healthData.detailedChecks.databaseTables.tablesChecked}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>실패한 테이블</span>
                    <span className="font-medium">{healthData.detailedChecks.databaseTables.failedTables}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>응답시간</span>
                    <span className="font-medium">{healthData.detailedChecks.databaseTables.responseTime}ms</span>
                  </div>
                  {healthData.detailedChecks.databaseTables.error && (
                    <div className="text-sm text-red-600 dark:text-red-400">
                      {healthData.detailedChecks.databaseTables.error}
                    </div>
                  )}
                </div>
              </div>

              {/* Filesystem Check */}
              <div className={`border rounded-lg p-6 ${getStatusColor(healthData.detailedChecks.filesystem.status)}`}>
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-3">
                    <HardDrive className="w-6 h-6 text-purple-500" />
                    <div>
                      <h4 className="font-semibold">파일시스템</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">로그 디렉토리 접근</p>
                    </div>
                  </div>
                  {getStatusIcon(healthData.detailedChecks.filesystem.status)}
                </div>
                <div className="mt-4 space-y-2">
                  <div className="text-sm">
                    <span className="text-gray-600 dark:text-gray-400">로그 디렉토리:</span>
                    <div className="font-mono text-xs mt-1 p-2 bg-gray-100 dark:bg-gray-700 rounded">
                      {healthData.detailedChecks.filesystem.logsDirectory}
                    </div>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>쓰기 가능</span>
                    <span className="font-medium">
                      {healthData.detailedChecks.filesystem.writable ? '예' : '아니오'}
                    </span>
                  </div>
                  {healthData.detailedChecks.filesystem.error && (
                    <div className="text-sm text-red-600 dark:text-red-400">
                      {healthData.detailedChecks.filesystem.error}
                    </div>
                  )}
                </div>
              </div>

              {/* Environment Check */}
              <div className={`border rounded-lg p-6 ${getStatusColor(healthData.detailedChecks.environment.status)}`}>
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-3">
                    <Settings className="w-6 h-6 text-orange-500" />
                    <div>
                      <h4 className="font-semibold">환경 변수</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">필수 설정 확인</p>
                    </div>
                  </div>
                  {getStatusIcon(healthData.detailedChecks.environment.status)}
                </div>
                <div className="mt-4 space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>필수 변수</span>
                    <span className="font-medium">{healthData.detailedChecks.environment.requiredVariables}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>누락된 변수</span>
                    <span className="font-medium">{healthData.detailedChecks.environment.missingVariables.length}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>환경</span>
                    <span className="font-medium">{healthData.detailedChecks.environment.nodeEnv}</span>
                  </div>
                  {healthData.detailedChecks.environment.missingVariables.length > 0 && (
                    <div className="text-sm text-red-600 dark:text-red-400">
                      누락: {healthData.detailedChecks.environment.missingVariables.join(', ')}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* System Information */}
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">시스템 정보</h3>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center">
                <Clock className="w-8 h-8 text-blue-500 mx-auto mb-2" />
                <div className="text-2xl font-bold text-gray-900 dark:text-white">
                  {Math.floor(healthData.uptime / 1000 / 60)}분
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">가동시간</div>
              </div>
              <div className="text-center">
                <Activity className="w-8 h-8 text-green-500 mx-auto mb-2" />
                <div className="text-2xl font-bold text-gray-900 dark:text-white">
                  {healthData.responseTime}ms
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">응답시간</div>
              </div>
              <div className="text-center">
                <Settings className="w-8 h-8 text-purple-500 mx-auto mb-2" />
                <div className="text-2xl font-bold text-gray-900 dark:text-white">
                  {healthData.version}
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">버전</div>
              </div>
              <div className="text-center">
                <Database className="w-8 h-8 text-orange-500 mx-auto mb-2" />
                <div className="text-2xl font-bold text-gray-900 dark:text-white">
                  {healthData.basicChecks.database.connections}
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">DB 연결</div>
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="text-center text-sm text-gray-500 dark:text-gray-400">
            <p>상관관계 ID: {healthData.correlationId}</p>
            <p className="mt-1">검사 완료: {new Date(healthData.timestamp).toLocaleString('ko-KR')}</p>
          </div>
        </>
      )}
    </div>
  );
}
```


#### 📄 src\app\monitoring\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Activity,
  Database,
  MemoryStick,
  Clock,
  AlertTriangle,
  CheckCircle,
  XCircle,
  RefreshCw,
  Monitor,
  Cpu,
  HardDrive,
  Network,
  Users,
  TrendingUp,
  TrendingDown,
  Minus
} from 'lucide-react';

// Type definitions
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  uptime: number;
  version: string;
  responseTime: number;
  checks: {
    database: {
      status: string;
      responseTime: number;
      connectionPool: {
        active: number;
        idle: number;
        total: number;
        limit: number;
        utilizationPercent: number;
      };
      error?: string;
    };
    memory: {
      status: string;
      usage: number;
      heap: number;
      external: number;
      limit: number;
    };
    system: {
      status: string;
      nodeVersion: string;
      platform: string;
      architecture: string;
      pid: number;
      uptime: number;
      environment: string;
    };
  };
  timestamp: string;
  correlationId: string;
}

interface Metrics {
  timestamp: number;
  requestCount: number;
  responseTime: {
    avg: number;
    min: number;
    max: number;
    p95: number;
  };
  errorRate: number;
  dbConnections: {
    active: number;
    idle: number;
    total: number;
  };
  memory: {
    usage: number;
    heap: number;
    external: number;
  };
  businessMetrics: {
    totalItems: number;
    totalCompanies: number;
    totalTransactions: number;
    lowStockItems: number;
  };
}

export default function MonitoringDashboard() {
  const [healthStatus, setHealthStatus] = useState<HealthStatus | null>(null);
  const [metrics, setMetrics] = useState<Metrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [autoRefresh, setAutoRefresh] = useState(true);
  const [refreshInterval, setRefreshInterval] = useState(30000); // 30 seconds

  // Fetch health status
  const fetchHealthStatus = async () => {
    try {
      const response = await fetch('/api/health');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setHealthStatus(data);
    } catch (err) {
      console.error('Error fetching health status:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
    }
  };

  // Fetch metrics
  const fetchMetrics = async () => {
    try {
      const response = await fetch('/api/metrics?detailed=true');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      setMetrics(data);
    } catch (err) {
      console.error('Error fetching metrics:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
    }
  };

  // Initial load
  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      setError(null);

      try {
        await Promise.all([fetchHealthStatus(), fetchMetrics()]);
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, []);

  // Auto refresh
  useEffect(() => {
    if (!autoRefresh) return;

    const interval = setInterval(async () => {
      try {
        await Promise.all([fetchHealthStatus(), fetchMetrics()]);
      } catch (err) {
        console.error('Auto refresh error:', err);
      }
    }, refreshInterval);

    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval]);

  // Manual refresh
  const handleRefresh = async () => {
    setLoading(true);
    setError(null);

    try {
      await Promise.all([fetchHealthStatus(), fetchMetrics()]);
    } finally {
      setLoading(false);
    }
  };

  // Format uptime
  const formatUptime = (ms: number) => {
    const seconds = Math.floor(ms / 1000);
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (days > 0) return `${days}일 ${hours}시간 ${minutes}분`;
    if (hours > 0) return `${hours}시간 ${minutes}분`;
    return `${minutes}분`;
  };

  // Get status icon
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'healthy':
        return <CheckCircle className="w-5 h-5 text-green-500" />;
      case 'degraded':
        return <AlertTriangle className="w-5 h-5 text-yellow-500" />;
      case 'unhealthy':
        return <XCircle className="w-5 h-5 text-red-500" />;
      default:
        return <Minus className="w-5 h-5 text-gray-500" />;
    }
  };

  // Get status color
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'healthy':
        return 'bg-green-100 text-green-800 border-green-200';
      case 'degraded':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'unhealthy':
        return 'bg-red-100 text-red-800 border-red-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  // Get trend icon
  const getTrendIcon = (value: number, threshold: number) => {
    if (value > threshold) return <TrendingUp className="w-4 h-4 text-red-500" />;
    if (value < threshold * 0.5) return <TrendingDown className="w-4 h-4 text-green-500" />;
    return <Minus className="w-4 h-4 text-gray-500" />;
  };

  if (loading && !healthStatus) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="flex items-center space-x-2">
          <RefreshCw className="w-6 h-6 animate-spin" />
          <span>모니터링 데이터를 로드하는 중...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-start">
        <div>
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">시스템 모니터링</h1>
          <p className="mt-2 text-gray-600 dark:text-gray-400">실시간 시스템 상태 및 성능 지표</p>
        </div>

        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2">
            <label className="text-sm text-gray-600 dark:text-gray-400">자동 새로고침</label>
            <input
              type="checkbox"
              checked={autoRefresh}
              onChange={(e) => setAutoRefresh(e.target.checked)}
              className="rounded"
            />
          </div>

          <select
            value={refreshInterval}
            onChange={(e) => setRefreshInterval(Number(e.target.value))}
            className="text-sm border rounded px-2 py-1 bg-white dark:bg-gray-800 dark:border-gray-600"
            disabled={!autoRefresh}
          >
            <option value={10000}>10초</option>
            <option value={30000}>30초</option>
            <option value={60000}>1분</option>
            <option value={300000}>5분</option>
          </select>

          <button
            onClick={handleRefresh}
            disabled={loading}
            className="flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
            <span>새로고침</span>
          </button>
        </div>
      </div>

      {/* Error Display */}
      {error && (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
          <div className="flex items-center space-x-2">
            <XCircle className="w-5 h-5 text-red-500" />
            <span className="text-red-700 dark:text-red-400">오류: {error}</span>
          </div>
        </div>
      )}

      {/* Overall System Status */}
      {healthStatus && (
        <div className={`border rounded-lg p-6 ${getStatusColor(healthStatus.status)}`}>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              {getStatusIcon(healthStatus.status)}
              <div>
                <h2 className="text-xl font-semibold">전체 시스템 상태</h2>
                <p className="text-sm opacity-75">
                  마지막 확인: {new Date(healthStatus.timestamp).toLocaleString('ko-KR')}
                </p>
              </div>
            </div>
            <div className="text-right">
              <div className="text-2xl font-bold">{healthStatus.status.toUpperCase()}</div>
              <div className="text-sm">응답시간: {healthStatus.responseTime}ms</div>
            </div>
          </div>
        </div>
      )}

      {/* Key Metrics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Uptime */}
        {healthStatus && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600 dark:text-gray-400">시스템 가동시간</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  {formatUptime(healthStatus.uptime)}
                </p>
              </div>
              <Clock className="w-8 h-8 text-blue-500" />
            </div>
          </div>
        )}

        {/* Memory Usage */}
        {healthStatus && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600 dark:text-gray-400">메모리 사용량</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  {Math.round(healthStatus.checks.memory.usage)}MB
                </p>
                <p className="text-xs text-gray-500">
                  / {healthStatus.checks.memory.limit}MB
                </p>
              </div>
              <div className="flex items-center space-x-1">
                <MemoryStick className="w-8 h-8 text-green-500" />
                {getTrendIcon(healthStatus.checks.memory.usage, healthStatus.checks.memory.limit * 0.8)}
              </div>
            </div>
          </div>
        )}

        {/* Database Connections */}
        {healthStatus && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600 dark:text-gray-400">DB 연결</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  {healthStatus.checks.database.connectionPool.total}
                </p>
                <p className="text-xs text-gray-500">
                  활성: {healthStatus.checks.database.connectionPool.active} /
                  유휴: {healthStatus.checks.database.connectionPool.idle}
                </p>
              </div>
              <div className="flex items-center space-x-1">
                <Database className="w-8 h-8 text-purple-500" />
                {getTrendIcon(
                  healthStatus.checks.database.connectionPool.utilizationPercent,
                  80
                )}
              </div>
            </div>
          </div>
        )}

        {/* Request Count */}
        {metrics && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600 dark:text-gray-400">총 요청 수</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  {metrics.requestCount.toLocaleString()}
                </p>
                <p className="text-xs text-gray-500">
                  오류율: {metrics.errorRate.toFixed(2)}%
                </p>
              </div>
              <div className="flex items-center space-x-1">
                <Activity className="w-8 h-8 text-orange-500" />
                {getTrendIcon(metrics.errorRate, 5)}
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Detailed Status Cards */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* System Information */}
        {healthStatus && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center space-x-2 mb-4">
              <Monitor className="w-5 h-5 text-blue-500" />
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">시스템 정보</h3>
            </div>

            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">Node.js 버전</span>
                <span className="text-sm font-medium">{healthStatus.checks.system.nodeVersion}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">플랫폼</span>
                <span className="text-sm font-medium">{healthStatus.checks.system.platform}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">아키텍처</span>
                <span className="text-sm font-medium">{healthStatus.checks.system.architecture}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">환경</span>
                <span className="text-sm font-medium">{healthStatus.checks.system.environment}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">프로세스 ID</span>
                <span className="text-sm font-medium">{healthStatus.checks.system.pid}</span>
              </div>
            </div>
          </div>
        )}

        {/* Performance Metrics */}
        {metrics && (
          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
            <div className="flex items-center space-x-2 mb-4">
              <Cpu className="w-5 h-5 text-green-500" />
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">성능 지표</h3>
            </div>

            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">평균 응답시간</span>
                <span className="text-sm font-medium">{metrics.responseTime.avg.toFixed(2)}ms</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">95% 응답시간</span>
                <span className="text-sm font-medium">{metrics.responseTime.p95.toFixed(2)}ms</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">최소 응답시간</span>
                <span className="text-sm font-medium">{metrics.responseTime.min.toFixed(2)}ms</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">최대 응답시간</span>
                <span className="text-sm font-medium">{metrics.responseTime.max.toFixed(2)}ms</span>
              </div>
              <div className="flex justify-between">
                <span className="text-sm text-gray-600 dark:text-gray-400">힙 메모리</span>
                <span className="text-sm font-medium">{Math.round(metrics.memory.heap)}MB</span>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Business Metrics */}
      {metrics && (
        <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6">
          <div className="flex items-center space-x-2 mb-4">
            <Users className="w-5 h-5 text-purple-500" />
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white">비즈니스 지표</h3>
          </div>

          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-blue-600">
                {metrics.businessMetrics.totalItems.toLocaleString()}
              </div>
              <div className="text-sm text-gray-600 dark:text-gray-400">총 품목 수</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-green-600">
                {metrics.businessMetrics.totalCompanies.toLocaleString()}
              </div>
              <div className="text-sm text-gray-600 dark:text-gray-400">총 거래처 수</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-orange-600">
                {metrics.businessMetrics.totalTransactions.toLocaleString()}
              </div>
              <div className="text-sm text-gray-600 dark:text-gray-400">월간 거래 수</div>
            </div>
            <div className="text-center">
              <div className={`text-2xl font-bold ${
                metrics.businessMetrics.lowStockItems > 0 ? 'text-red-600' : 'text-green-600'
              }`}>
                {metrics.businessMetrics.lowStockItems.toLocaleString()}
              </div>
              <div className="text-sm text-gray-600 dark:text-gray-400">재고 부족 품목</div>
            </div>
          </div>
        </div>
      )}

      {/* Footer */}
      <div className="text-center text-sm text-gray-500 dark:text-gray-400">
        <p>마지막 업데이트: {new Date().toLocaleString('ko-KR')}</p>
        {healthStatus && (
          <p className="mt-1">시스템 버전: {healthStatus.version} | 상관관계 ID: {healthStatus.correlationId}</p>
        )}
      </div>
    </div>
  );
}
```


#### 📄 src\app\page.tsx

```typescript
'use client';

import React from 'react';
import { Package, BarChart3, Box, Truck } from 'lucide-react';
import { RealTimeDashboard } from '../components/dashboard/RealTimeDashboard';
import { ThemeProvider } from '../contexts/ThemeContext';

export default function Dashboard() {
  return (
    <ThemeProvider>
      <div className="space-y-6">
        {/* Page Header */}
        <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">대시보드</h1>
          <p className="text-gray-600 dark:text-gray-400 mt-1">
            태창 ERP 시스템 현황을 모니터링하세요
          </p>
        </div>

        {/* Real-Time Dashboard */}
        <RealTimeDashboard />

        {/* Quick Actions */}
        <div className="bg-white dark:bg-gray-900 rounded-lg p-6 shadow-sm">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">빠른 작업</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <button
              onClick={() => window.location.href = '/inventory?tab=receiving'}
              className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors"
            >
              <Truck className="w-8 h-8 text-gray-400 mb-2" />
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">입고 등록</span>
            </button>
            <button
              onClick={() => window.location.href = '/inventory?tab=shipping'}
              className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors"
            >
              <Box className="w-8 h-8 text-gray-400 mb-2" />
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">출고 등록</span>
            </button>
            <button
              onClick={() => window.location.href = '/stock'}
              className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors"
            >
              <BarChart3 className="w-8 h-8 text-gray-400 mb-2" />
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">재고 조회</span>
            </button>
            <button
              onClick={() => window.location.href = '/master/items'}
              className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors"
            >
              <Package className="w-8 h-8 text-gray-400 mb-2" />
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">품목 등록</span>
            </button>
          </div>
        </div>
      </div>
    </ThemeProvider>
  );
}
```


#### 📄 src\app\stock\current\page.tsx

```typescript
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

export default function CurrentStockPage() {
  const router = useRouter();

  useEffect(() => {
    // Redirect to the main stock page since it already shows current stock
    router.replace('/stock');
  }, [router]);

  return (
    <div className="flex items-center justify-center min-h-[400px]">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <p className="text-gray-600 dark:text-gray-400">현재고 조회 페이지로 이동 중...</p>
      </div>
    </div>
  );
}
```


#### 📄 src\app\stock\history\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Calendar, Search, Download, History, Package, TrendingUp, TrendingDown, RotateCcw } from 'lucide-react';

interface StockHistoryItem {
  transaction_id: number;
  transaction_date: string;
  item_code: string;
  item_name: string;
  transaction_type: string;
  quantity_change: number;
  stock_balance: number;
  company_name?: string;
  reference_number?: string;
  notes?: string;
}

interface StockItem {
  item_id: number;
  item_code: string;
  item_name: string;
}

export default function StockHistoryPage() {
  const [stockHistory, setStockHistory] = useState<StockHistoryItem[]>([]);
  const [stockItems, setStockItems] = useState<StockItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedItem, setSelectedItem] = useState<string>('');
  const [dateFrom, setDateFrom] = useState<string>('');
  const [dateTo, setDateTo] = useState<string>('');
  const [searchTerm, setSearchTerm] = useState<string>('');

  // Initialize date range (last 30 days)
  useEffect(() => {
    const today = new Date();
    const thirtyDaysAgo = new Date(today.getTime() - (30 * 24 * 60 * 60 * 1000));

    setDateTo(today.toISOString().split('T')[0]);
    setDateFrom(thirtyDaysAgo.toISOString().split('T')[0]);
  }, []);

  // Fetch stock items for dropdown
  useEffect(() => {
    const fetchStockItems = async () => {
      try {
        const response = await fetch('/api/stock/items');
        const result = await response.json();

        if (result.success) {
          setStockItems(result.data || []);
        }
      } catch (error) {
        console.error('품목 조회 오류:', error);
      }
    };

    fetchStockItems();
  }, []);

  // Fetch stock history
  const fetchStockHistory = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (selectedItem) params.append('item_id', selectedItem);
      if (dateFrom) params.append('date_from', dateFrom);
      if (dateTo) params.append('date_to', dateTo);

      const response = await fetch(`/api/stock/history?${params.toString()}`);
      const result = await response.json();

      if (result.success) {
        setStockHistory(result.data.history || []);
      } else {
        alert(`재고 이력 조회 실패: ${result.error}`);
        setStockHistory([]);
      }
    } catch (error) {
      console.error('재고 이력 조회 오류:', error);
      alert('재고 이력 조회 중 오류가 발생했습니다.');
      setStockHistory([]);
    } finally {
      setLoading(false);
    }
  };

  // Auto-fetch when filters change
  useEffect(() => {
    if (dateFrom && dateTo) {
      fetchStockHistory();
    }
  }, [selectedItem, dateFrom, dateTo]);

  // Filter history by search term
  const filteredHistory = stockHistory.filter(item =>
    item.item_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    item.item_code.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (item.company_name && item.company_name.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  // Get transaction type display info
  const getTransactionTypeInfo = (type: string) => {
    switch (type) {
      case 'IN':
        return { label: '입고', color: 'bg-blue-100 text-blue-800', icon: TrendingUp };
      case 'OUT':
        return { label: '출고', color: 'bg-red-100 text-red-800', icon: TrendingDown };
      case 'ADJUST':
        return { label: '조정', color: 'bg-yellow-100 text-yellow-800', icon: RotateCcw };
      default:
        return { label: type, color: 'bg-gray-100 text-gray-800', icon: Package };
    }
  };

  // Export to CSV
  const exportToCsv = () => {
    const csvContent = [
      ['일자', '품목코드', '품목명', '거래유형', '변동수량', '재고잔량', '거래처', '참조번호', '비고'],
      ...filteredHistory.map(item => [
        new Date(item.transaction_date).toLocaleDateString(),
        item.item_code,
        item.item_name,
        getTransactionTypeInfo(item.transaction_type).label,
        item.quantity_change,
        item.stock_balance,
        item.company_name || '',
        item.reference_no || '',
        item.notes || ''
      ])
    ].map(row => row.join(',')).join('\n');

    const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `재고이력_${new Date().toISOString().split('T')[0]}.csv`;
    link.click();
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">재고 이력</h1>
          <p className="text-gray-600 dark:text-gray-400">품목별 재고 변동 이력을 조회합니다</p>
        </div>

        <button
          onClick={exportToCsv}
          disabled={filteredHistory.length === 0}
          className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <Download className="w-5 h-5" />
          CSV 내보내기
        </button>
      </div>

      {/* Statistics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
          <div className="flex items-center gap-3">
            <History className="w-8 h-8 text-blue-500" />
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">총 거래 건수</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">{filteredHistory.length}</p>
            </div>
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
          <div className="flex items-center gap-3">
            <TrendingUp className="w-8 h-8 text-green-500" />
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">입고 건수</p>
              <p className="text-2xl font-bold text-green-600">
                {filteredHistory.filter(item => item.transaction_type === 'IN').length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
          <div className="flex items-center gap-3">
            <TrendingDown className="w-8 h-8 text-red-500" />
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">출고 건수</p>
              <p className="text-2xl font-bold text-red-600">
                {filteredHistory.filter(item => item.transaction_type === 'OUT').length}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
          <div className="flex items-center gap-3">
            <RotateCcw className="w-8 h-8 text-yellow-500" />
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">조정 건수</p>
              <p className="text-2xl font-bold text-yellow-600">
                {filteredHistory.filter(item => item.transaction_type === 'ADJUST').length}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Filters */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
          {/* Item Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              품목 선택
            </label>
            <select
              value={selectedItem}
              onChange={(e) => setSelectedItem(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">전체 품목</option>
              {stockItems.map((item) => (
                <option key={item.item_id} value={item.item_id}>
                  {item.item_code} - {item.item_name}
                </option>
              ))}
            </select>
          </div>

          {/* Date From */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              시작일
            </label>
            <div className="relative">
              <Calendar className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="date"
                value={dateFrom}
                onChange={(e) => setDateFrom(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>

          {/* Date To */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              종료일
            </label>
            <div className="relative">
              <Calendar className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="date"
                value={dateTo}
                onChange={(e) => setDateTo(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>

          {/* Search */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              검색
            </label>
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
              <input
                type="text"
                placeholder="품목명, 거래처..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>

          {/* Refresh Button */}
          <div className="flex items-end">
            <button
              onClick={fetchStockHistory}
              disabled={loading}
              className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? '조회 중...' : '조회'}
            </button>
          </div>
        </div>
      </div>

      {/* History Table */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  일자
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  품목코드
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  품목명
                </th>
                <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  거래유형
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  변동수량
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  재고잔량
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  거래처
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  비고
                </th>
              </tr>
            </thead>
            <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
              {loading ? (
                <tr>
                  <td colSpan={8} className="px-6 py-8 text-center">
                    <div className="flex items-center justify-center">
                      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mr-3"></div>
                      <span className="text-gray-500">재고 이력을 조회하고 있습니다...</span>
                    </div>
                  </td>
                </tr>
              ) : filteredHistory.length === 0 ? (
                <tr>
                  <td colSpan={8} className="px-6 py-8 text-center">
                    <div className="text-gray-500 dark:text-gray-400">
                      <History className="w-12 h-12 mx-auto mb-3 opacity-50" />
                      <p className="text-lg mb-1">재고 이력이 없습니다</p>
                      <p className="text-sm">조건을 변경하여 다시 조회해보세요</p>
                    </div>
                  </td>
                </tr>
              ) : (
                filteredHistory.map((item) => {
                  const typeInfo = getTransactionTypeInfo(item.transaction_type);
                  const TypeIcon = typeInfo.icon;

                  return (
                    <tr key={item.transaction_id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {new Date(item.transaction_date).toLocaleDateString('ko-KR')}
                      </td>
                      <td className="px-6 py-4 text-sm font-medium text-gray-900 dark:text-white">
                        {item.item_code}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {item.item_name}
                      </td>
                      <td className="px-6 py-4 text-center">
                        <div className="flex items-center justify-center gap-1">
                          <TypeIcon className="w-4 h-4" />
                          <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${typeInfo.color}`}>
                            {typeInfo.label}
                          </span>
                        </div>
                      </td>
                      <td className="px-6 py-4 text-right text-sm">
                        <span className={`font-medium ${
                          item.quantity_change > 0 ? 'text-green-600' :
                          item.quantity_change < 0 ? 'text-red-600' : 'text-gray-600'
                        }`}>
                          {item.quantity_change > 0 ? '+' : ''}{item.quantity_change.toLocaleString()}
                        </span>
                      </td>
                      <td className="px-6 py-4 text-right text-sm text-gray-900 dark:text-white">
                        {item.stock_balance.toLocaleString()}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {item.company_name || '-'}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500 dark:text-gray-400">
                        {item.notes || '-'}
                      </td>
                    </tr>
                  );
                })
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
```


#### 📄 src\app\stock\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import { BarChart3, Package, AlertTriangle, Download, Search, Plus } from 'lucide-react';
import StockAdjustmentForm from '@/components/StockAdjustmentForm';
import { StockExportButton } from '@/components/ExcelExportButton';

interface StockItem {
  item_id: number;
  item_code: string;
  item_name: string;
  spec: string;
  unit: string;
  item_type: string;
  current_stock: number;
  unit_price: number;
  stock_value: number;
  safety_stock: number;
  is_low_stock: boolean;
}

interface StockHistory {
  transaction_id: number;
  transaction_date: string;
  transaction_type: string;
  item_name: string;
  quantity: number;
  reference_no: string;
  company_name: string;
}

export default function StockPage() {
  const [activeTab, setActiveTab] = useState('current');
  const [stockItems, setStockItems] = useState<StockItem[]>([]);
  const [stockHistory, setStockHistory] = useState<StockHistory[]>([]);
  const [loading, setLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [stockFilter, setStockFilter] = useState('all');
  const [showAdjustmentForm, setShowAdjustmentForm] = useState(false);

  // 실시간 재고 현황 조회
  const fetchStockItems = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/stock');
      const result = await response.json();

      if (result.success) {
        setStockItems(Array.isArray(result.data) ? result.data : []);
      } else {
        alert(`재고 조회 실패: ${result.error}`);
        setStockItems([]);
      }
    } catch (error) {
      console.error('재고 조회 오류:', error);
      alert('재고 조회 중 오류가 발생했습니다.');
      setStockItems([]);
    } finally {
      setLoading(false);
    }
  };

  // 재고 이동 이력 조회
  const fetchStockHistory = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/stock/history');
      const result = await response.json();

      if (result.success) {
        setStockHistory(result.data.transactions || []);
      } else {
        alert(`이력 조회 실패: ${result.error}`);
        setStockHistory([]);
      }
    } catch (error) {
      console.error('이력 조회 오류:', error);
      alert('이력 조회 중 오류가 발생했습니다.');
      setStockHistory([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (activeTab === 'current') {
      fetchStockItems();
    } else if (activeTab === 'history') {
      fetchStockHistory();
    }
  }, [activeTab]);

  // 필터링된 재고 항목
  const filteredStockItems = Array.isArray(stockItems) ? stockItems.filter(item => {
    const matchesSearch = item.item_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         item.item_code.toLowerCase().includes(searchTerm.toLowerCase());

    const matchesFilter = stockFilter === 'all' ||
                         (stockFilter === 'low' && item.is_low_stock) ||
                         (stockFilter === 'normal' && !item.is_low_stock);

    return matchesSearch && matchesFilter;
  }) : [];

  // 통계 계산
  const totalItems = Array.isArray(stockItems) ? stockItems.length : 0;
  const lowStockItems = Array.isArray(stockItems) ? stockItems.filter(item => item.is_low_stock).length : 0;
  const totalValue = Array.isArray(stockItems) ? stockItems.reduce((sum, item) => sum + item.stock_value, 0) : 0;

  // 재고 조정 처리
  const handleAdjustmentSubmit = async (formData: any) => {
    try {
      const response = await fetch('/api/stock/adjustment', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert('재고 조정이 성공적으로 완료되었습니다.');
        setShowAdjustmentForm(false);
        // 현재 재고 정보 새로고침
        if (activeTab === 'current') {
          fetchStockItems();
        }
      } else {
        alert(`재고 조정 실패: ${result.error}`);
      }
    } catch (error) {
      console.error('재고 조정 오류:', error);
      alert('재고 조정 중 오류가 발생했습니다.');
    }
  };


  return (
    <div className="space-y-6">
      {/* 헤더 */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">재고 현황</h1>
          <p className="text-gray-600 dark:text-gray-400">실시간 재고 모니터링 및 이력 관리</p>
        </div>

        {activeTab === 'current' && (
          <StockExportButton
            stockData={filteredStockItems}
            className="bg-green-500 text-white hover:bg-green-600"
          />
        )}
      </div>

      {/* 통계 위젯 */}
      {activeTab === 'current' && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
            <div className="flex items-center gap-3">
              <Package className="w-8 h-8 text-blue-500" />
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">총 품목 수</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">{totalItems}</p>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
            <div className="flex items-center gap-3">
              <AlertTriangle className="w-8 h-8 text-red-500" />
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">재고 부족 품목</p>
                <p className="text-2xl font-bold text-red-600">{lowStockItems}</p>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
            <div className="flex items-center gap-3">
              <BarChart3 className="w-8 h-8 text-green-500" />
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">총 재고 금액</p>
                <p className="text-2xl font-bold text-gray-900 dark:text-white">
                  ₩{(totalValue || 0).toLocaleString()}
                </p>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* 탭 네비게이션 */}
      <div className="border-b border-gray-200 dark:border-gray-700">
        <nav className="-mb-px flex space-x-8">
          <button
            onClick={() => setActiveTab('current')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'current'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            }`}
          >
            현재 재고
          </button>
          <button
            onClick={() => setActiveTab('history')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'history'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            }`}
          >
            재고 이력
          </button>
          <button
            onClick={() => setActiveTab('adjustment')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'adjustment'
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
            }`}
          >
            재고 조정
          </button>
        </nav>
      </div>

      {/* 현재 재고 탭 */}
      {activeTab === 'current' && (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
          {/* 검색 및 필터 */}
          <div className="p-6 border-b border-gray-200 dark:border-gray-700">
            <div className="flex flex-col md:flex-row gap-4">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" />
                  <input
                    type="text"
                    placeholder="품번 또는 품명으로 검색..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
              </div>

              <select
                value={stockFilter}
                onChange={(e) => setStockFilter(e.target.value)}
                className="px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">전체</option>
                <option value="normal">정상 재고</option>
                <option value="low">재고 부족</option>
              </select>
            </div>
          </div>

          {/* 재고 테이블 */}
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 dark:bg-gray-700">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    품번/품명
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    규격
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    현재고
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    단가
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    재고금액
                  </th>
                  <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    상태
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {loading ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500">
                      로딩 중...
                    </td>
                  </tr>
                ) : filteredStockItems.length === 0 ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500">
                      재고 데이터가 없습니다.
                    </td>
                  </tr>
                ) : (
                  filteredStockItems.map((item) => (
                    <tr key={item.item_id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                      <td className="px-6 py-4">
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            {item.item_code}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            {item.item_name}
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {item.spec || '-'}
                      </td>
                      <td className="px-6 py-4 text-right text-sm text-gray-900 dark:text-white">
                        {(item.current_stock || 0).toLocaleString()} {item.unit}
                      </td>
                      <td className="px-6 py-4 text-right text-sm text-gray-900 dark:text-white">
                        ₩{(item.unit_price || 0).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 text-right text-sm text-gray-900 dark:text-white">
                        ₩{(item.stock_value || 0).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 text-center">
                        {item.is_low_stock ? (
                          <span className="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-800">
                            부족
                          </span>
                        ) : (
                          <span className="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800">
                            정상
                          </span>
                        )}
                      </td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* 재고 이력 탭 */}
      {activeTab === 'history' && (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">재고 이동 이력</h3>

          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 dark:bg-gray-700">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    일시
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    구분
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    품목
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    수량
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    거래처
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    참조번호
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {loading ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500">
                      로딩 중...
                    </td>
                  </tr>
                ) : stockHistory.length === 0 ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500">
                      재고 이력이 없습니다.
                    </td>
                  </tr>
                ) : (
                  stockHistory.map((history) => (
                    <tr key={history.transaction_id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {new Date(history.transaction_date).toLocaleDateString()}
                      </td>
                      <td className="px-6 py-4">
                        <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                          history.transaction_type === '입고' ? 'bg-blue-100 text-blue-800' :
                          history.transaction_type === '생산' ? 'bg-green-100 text-green-800' :
                          'bg-red-100 text-red-800'
                        }`}>
                          {history.transaction_type}
                        </span>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {history.item_name}
                      </td>
                      <td className="px-6 py-4 text-right text-sm text-gray-900 dark:text-white">
                        {(history.quantity || 0).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {history.company_name || '-'}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900 dark:text-white">
                        {history.reference_no || '-'}
                      </td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* 재고 조정 탭 */}
      {activeTab === 'adjustment' && (
        <div className="space-y-6">
          {!showAdjustmentForm ? (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
              <div className="flex justify-between items-center mb-6">
                <div>
                  <h3 className="text-lg font-medium text-gray-900 dark:text-white">재고 조정</h3>
                  <p className="text-sm text-gray-600 dark:text-gray-400">재고 수량을 조정합니다.</p>
                </div>
                <button
                  onClick={() => setShowAdjustmentForm(true)}
                  className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                >
                  <Plus className="w-5 h-5" />
                  재고 조정
                </button>
              </div>

              {/* 최근 조정 이력 */}
              <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                <h4 className="font-medium text-gray-900 dark:text-white mb-3">최근 조정 이력</h4>
                <div className="text-center py-8 text-gray-500 dark:text-gray-400">
                  <Package className="w-8 h-8 mx-auto mb-2 opacity-50" />
                  <p>조정 이력이 없습니다.</p>
                </div>
              </div>
            </div>
          ) : (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
              <div className="mb-6">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">새 재고 조정</h3>
                <p className="text-sm text-gray-600 dark:text-gray-400">재고 수량을 조정합니다.</p>
              </div>

              <StockAdjustmentForm
                onSubmit={handleAdjustmentSubmit}
                onCancel={() => setShowAdjustmentForm(false)}
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```


#### 📄 src\app\stock\reports\page.tsx

```typescript
'use client';

import { useState, useEffect } from 'react';
import {
  BarChart3,
  Package,
  AlertTriangle,
  TrendingUp,
  TrendingDown,
  Download,
  Calendar,
  PieChart,
  Activity
} from 'lucide-react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart as RechartsPieChart,
  Pie,
  Cell,
  LineChart,
  Line
} from 'recharts';

interface StockSummary {
  total_items: number;
  total_stock_value: number;
  low_stock_items: number;
  excess_stock_items: number;
  out_of_stock_items: number;
}

interface CategoryBreakdown {
  item_type: string;
  item_count: number;
  stock_value: number;
  percentage: number;
}

interface MonthlyTrend {
  month: string;
  stock_value: number;
  transaction_count: number;
  in_quantity: number;
  out_quantity: number;
}

interface TopItem {
  item_code: string;
  item_name: string;
  stock_value: number;
  current_stock: number;
  safety_stock: number;
}

export default function StockReportsPage() {
  const [stockSummary, setStockSummary] = useState<StockSummary | null>(null);
  const [categoryBreakdown, setCategoryBreakdown] = useState<CategoryBreakdown[]>([]);
  const [monthlyTrend, setMonthlyTrend] = useState<MonthlyTrend[]>([]);
  const [topValueItems, setTopValueItems] = useState<TopItem[]>([]);
  const [lowStockItems, setLowStockItems] = useState<TopItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [reportDate, setReportDate] = useState<string>('');

  // Initialize report date to today
  useEffect(() => {
    setReportDate(new Date().toISOString().split('T')[0]);
  }, []);

  // Fetch all report data
  const fetchReportData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/stock/reports?date=${reportDate}`);
      const result = await response.json();

      if (result.success) {
        const data = result.data;
        setStockSummary(data.summary || null);
        setCategoryBreakdown(data.categoryBreakdown || []);
        setMonthlyTrend(data.monthlyTrend || []);
        setTopValueItems(data.topValueItems || []);
        setLowStockItems(data.lowStockItems || []);
      } else {
        alert(`보고서 조회 실패: ${result.error}`);
      }
    } catch (error) {
      console.error('보고서 조회 오류:', error);
      alert('보고서 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  // Auto-fetch when report date changes
  useEffect(() => {
    if (reportDate) {
      fetchReportData();
    }
  }, [reportDate]);

  // Colors for pie chart
  const COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4', '#84CC16', '#F97316'];

  // Export report to CSV
  const exportReport = () => {
    if (!stockSummary) return;

    const reportData = [
      ['재고 보고서', ''],
      ['기준일', reportDate],
      ['', ''],
      ['요약 정보', ''],
      ['총 품목 수', stockSummary.total_items],
      ['총 재고 금액', stockSummary.total_stock_value.toLocaleString()],
      ['재고 부족 품목', stockSummary.low_stock_items],
      ['과잉 재고 품목', stockSummary.excess_stock_items],
      ['재고 없음 품목', stockSummary.out_of_stock_items],
      ['', ''],
      ['카테고리별 현황', ''],
      ['카테고리', '품목수', '재고금액', '비율(%)'],
      ...categoryBreakdown.map(cat => [
        cat.item_type,
        cat.item_count,
        cat.stock_value.toLocaleString(),
        cat.percentage.toFixed(1)
      ]),
      ['', ''],
      ['고가 품목 TOP 10', ''],
      ['품목코드', '품목명', '재고금액', '현재고', '안전재고'],
      ...topValueItems.map(item => [
        item.item_code,
        item.item_name,
        item.stock_value.toLocaleString(),
        item.current_stock,
        item.safety_stock
      ])
    ];

    const csvContent = reportData.map(row => row.join(',')).join('\n');
    const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `재고보고서_${reportDate}.csv`;
    link.click();
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">재고 보고서</h1>
          <p className="text-gray-600 dark:text-gray-400">재고 현황 분석 및 통계 리포트</p>
        </div>

        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <Calendar className="w-5 h-5 text-gray-400" />
            <input
              type="date"
              value={reportDate}
              onChange={(e) => setReportDate(e.target.value)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <button
            onClick={exportReport}
            disabled={!stockSummary || loading}
            className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Download className="w-5 h-5" />
            보고서 내보내기
          </button>
        </div>
      </div>

      {loading ? (
        <div className="flex items-center justify-center py-12">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mr-4"></div>
          <span className="text-gray-600 dark:text-gray-400">보고서를 생성하고 있습니다...</span>
        </div>
      ) : (
        <>
          {/* Summary Statistics */}
          {stockSummary && (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
              <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
                <div className="flex items-center gap-3">
                  <Package className="w-8 h-8 text-blue-500" />
                  <div>
                    <p className="text-sm text-gray-500 dark:text-gray-400">총 품목수</p>
                    <p className="text-2xl font-bold text-gray-900 dark:text-white">
                      {stockSummary.total_items.toLocaleString()}
                    </p>
                  </div>
                </div>
              </div>

              <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
                <div className="flex items-center gap-3">
                  <BarChart3 className="w-8 h-8 text-green-500" />
                  <div>
                    <p className="text-sm text-gray-500 dark:text-gray-400">총 재고금액</p>
                    <p className="text-2xl font-bold text-gray-900 dark:text-white">
                      ₩{stockSummary.total_stock_value.toLocaleString()}
                    </p>
                  </div>
                </div>
              </div>

              <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
                <div className="flex items-center gap-3">
                  <AlertTriangle className="w-8 h-8 text-red-500" />
                  <div>
                    <p className="text-sm text-gray-500 dark:text-gray-400">부족품목</p>
                    <p className="text-2xl font-bold text-red-600">
                      {stockSummary.low_stock_items.toLocaleString()}
                    </p>
                  </div>
                </div>
              </div>

              <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
                <div className="flex items-center gap-3">
                  <TrendingUp className="w-8 h-8 text-orange-500" />
                  <div>
                    <p className="text-sm text-gray-500 dark:text-gray-400">과잉재고</p>
                    <p className="text-2xl font-bold text-orange-600">
                      {stockSummary.excess_stock_items.toLocaleString()}
                    </p>
                  </div>
                </div>
              </div>

              <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg">
                <div className="flex items-center gap-3">
                  <TrendingDown className="w-8 h-8 text-gray-500" />
                  <div>
                    <p className="text-sm text-gray-500 dark:text-gray-400">품절품목</p>
                    <p className="text-2xl font-bold text-gray-600">
                      {stockSummary.out_of_stock_items.toLocaleString()}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Charts Row */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Category Breakdown Pie Chart */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
              <div className="flex items-center gap-2 mb-6">
                <PieChart className="w-6 h-6 text-blue-500" />
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white">카테고리별 재고금액</h3>
              </div>

              {categoryBreakdown.length > 0 ? (
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <RechartsPieChart>
                      <Pie
                        data={categoryBreakdown as any}
                        cx="50%"
                        cy="50%"
                        labelLine={false}
                        label={(props: any) => `${props.item_type} (${props.percentage?.toFixed(1)}%)`}
                        outerRadius={80}
                        fill="#8884d8"
                        dataKey="stock_value"
                      >
                        {categoryBreakdown.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                        ))}
                      </Pie>
                      <Tooltip formatter={(value: number) => [`₩${value.toLocaleString()}`, '재고금액']} />
                    </RechartsPieChart>
                  </ResponsiveContainer>
                </div>
              ) : (
                <div className="h-80 flex items-center justify-center text-gray-500 dark:text-gray-400">
                  데이터가 없습니다
                </div>
              )}
            </div>

            {/* Monthly Trend Chart */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
              <div className="flex items-center gap-2 mb-6">
                <Activity className="w-6 h-6 text-green-500" />
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white">월별 재고 추이</h3>
              </div>

              {monthlyTrend.length > 0 ? (
                <div className="h-80">
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={monthlyTrend}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="month" />
                      <YAxis />
                      <Tooltip
                        formatter={(value: number, name: string) => [
                          name === 'stock_value' ? `₩${value.toLocaleString()}` : value.toLocaleString(),
                          name === 'stock_value' ? '재고금액' :
                          name === 'transaction_count' ? '거래건수' :
                          name === 'in_quantity' ? '입고수량' : '출고수량'
                        ]}
                      />
                      <Legend />
                      <Line
                        type="monotone"
                        dataKey="stock_value"
                        stroke="#3B82F6"
                        strokeWidth={2}
                        name="재고금액"
                      />
                      <Line
                        type="monotone"
                        dataKey="transaction_count"
                        stroke="#10B981"
                        strokeWidth={2}
                        name="거래건수"
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </div>
              ) : (
                <div className="h-80 flex items-center justify-center text-gray-500 dark:text-gray-400">
                  데이터가 없습니다
                </div>
              )}
            </div>
          </div>

          {/* Tables Row */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Top Value Items */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700">
                <div className="flex items-center gap-2">
                  <TrendingUp className="w-6 h-6 text-blue-500" />
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">고가 품목 TOP 10</h3>
                </div>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-gray-50 dark:bg-gray-700">
                    <tr>
                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        품목코드
                      </th>
                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        품목명
                      </th>
                      <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        재고금액
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                    {topValueItems.length > 0 ? (
                      topValueItems.map((item, index) => (
                        <tr key={item.item_code} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                          <td className="px-4 py-3 text-sm font-medium text-gray-900 dark:text-white">
                            {item.item_code}
                          </td>
                          <td className="px-4 py-3 text-sm text-gray-900 dark:text-white truncate max-w-32">
                            {item.item_name}
                          </td>
                          <td className="px-4 py-3 text-sm text-right text-gray-900 dark:text-white">
                            ₩{item.stock_value.toLocaleString()}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td colSpan={3} className="px-4 py-8 text-center text-gray-500 dark:text-gray-400">
                          데이터가 없습니다
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Low Stock Items */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700">
                <div className="flex items-center gap-2">
                  <AlertTriangle className="w-6 h-6 text-red-500" />
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">재고 부족 품목</h3>
                </div>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-gray-50 dark:bg-gray-700">
                    <tr>
                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        품목코드
                      </th>
                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        품목명
                      </th>
                      <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        현재고
                      </th>
                      <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        안전재고
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                    {lowStockItems.length > 0 ? (
                      lowStockItems.map((item) => (
                        <tr key={item.item_code} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                          <td className="px-4 py-3 text-sm font-medium text-gray-900 dark:text-white">
                            {item.item_code}
                          </td>
                          <td className="px-4 py-3 text-sm text-gray-900 dark:text-white truncate max-w-32">
                            {item.item_name}
                          </td>
                          <td className="px-4 py-3 text-sm text-right text-red-600">
                            {item.current_stock.toLocaleString()}
                          </td>
                          <td className="px-4 py-3 text-sm text-right text-gray-900 dark:text-white">
                            {item.safety_stock.toLocaleString()}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td colSpan={4} className="px-4 py-8 text-center text-gray-500 dark:text-gray-400">
                          재고 부족 품목이 없습니다
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          {/* Category Breakdown Table */}
          {categoryBreakdown.length > 0 && (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700">
                <div className="flex items-center gap-2">
                  <BarChart3 className="w-6 h-6 text-green-500" />
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">카테고리별 상세 현황</h3>
                </div>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-gray-50 dark:bg-gray-700">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        카테고리
                      </th>
                      <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        품목 수
                      </th>
                      <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        재고 금액
                      </th>
                      <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase">
                        비율
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                    {categoryBreakdown.map((category, index) => (
                      <tr key={category.item_type} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                        <td className="px-6 py-4 text-sm font-medium text-gray-900 dark:text-white">
                          <div className="flex items-center gap-2">
                            <div
                              className="w-3 h-3 rounded-full"
                              style={{ backgroundColor: COLORS[index % COLORS.length] }}
                            ></div>
                            {category.item_type}
                          </div>
                        </td>
                        <td className="px-6 py-4 text-sm text-right text-gray-900 dark:text-white">
                          {category.item_count.toLocaleString()}
                        </td>
                        <td className="px-6 py-4 text-sm text-right text-gray-900 dark:text-white">
                          ₩{category.stock_value.toLocaleString()}
                        </td>
                        <td className="px-6 py-4 text-sm text-right text-gray-900 dark:text-white">
                          {category.percentage.toFixed(1)}%
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  );
}
```


#### 📄 src\app\toast-demo\page.tsx

```typescript
'use client';

import { useToast } from '@/contexts/ToastContext';

export default function ToastDemoPage() {
  const { success, error, warning, info } = useToast();

  return (
    <div className="p-8 space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
        Toast Notification Demo
      </h1>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <button
          onClick={() => success('성공!', '작업이 성공적으로 완료되었습니다.')}
          className="px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
        >
          Success Toast
        </button>

        <button
          onClick={() => error('오류 발생', '작업 중 오류가 발생했습니다.')}
          className="px-6 py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors"
        >
          Error Toast
        </button>

        <button
          onClick={() => warning('주의', '이 작업은 주의가 필요합니다.')}
          className="px-6 py-3 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors"
        >
          Warning Toast
        </button>

        <button
          onClick={() => info('정보', '새로운 정보를 확인하세요.')}
          className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
        >
          Info Toast
        </button>
      </div>

      <div className="mt-8 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg">
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
          Toast Features:
        </h2>
        <ul className="list-disc list-inside space-y-1 text-gray-700 dark:text-gray-300">
          <li>Auto-dismiss after 3 seconds (5s for errors, 4s for warnings)</li>
          <li>Manual close button</li>
          <li>Smooth slide-in/out animations</li>
          <li>Positioned at top-right of screen</li>
          <li>Support for success, error, warning, info types</li>
          <li>Korean language support</li>
        </ul>
      </div>
    </div>
  );
}
```


---

### MIDDLEWARE 코드


#### 📄 src\middleware\cors.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export interface CorsOptions {
  origin?: string | string[] | boolean;
  methods?: string[];
  allowedHeaders?: string[];
  credentials?: boolean;
  preflightContinue?: boolean;
  optionsSuccessStatus?: number;
}

const DEFAULT_CORS_OPTIONS: CorsOptions = {
  origin: process.env.NODE_ENV === 'development'
    ? ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002']
    : false, // Will be set to specific domains in production
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Accept',
    'Accept-Version',
    'Authorization',
    'Content-Length',
    'Content-MD5',
    'Content-Type',
    'Date',
    'X-Api-Version',
    'X-Requested-With',
    'X-CSRF-Token',
    'Cache-Control',
    'Accept-Encoding',
    'Accept-Language',
    'Accept-Charset'
  ],
  credentials: true,
  preflightContinue: false,
  optionsSuccessStatus: 204
};

/**
 * CORS 미들웨어 - 한국어 콘텐츠 지원 포함
 * Cross-Origin Resource Sharing 설정을 처리합니다.
 */
export function corsMiddleware(options: Partial<CorsOptions> = {}) {
  const corsOptions: CorsOptions = { ...DEFAULT_CORS_OPTIONS, ...options };

  return (request: NextRequest, response?: NextResponse): NextResponse => {
    // 기존 응답이 있으면 사용하고, 없으면 새로 생성
    const res = response || new NextResponse();

    const origin = request.headers.get('origin');
    const requestMethod = request.method;

    // Origin 검사
    if (corsOptions.origin !== false && origin) {
      let allowedOrigin = false;

      if (corsOptions.origin === true) {
        allowedOrigin = true;
      } else if (typeof corsOptions.origin === 'string') {
        allowedOrigin = origin === corsOptions.origin;
      } else if (Array.isArray(corsOptions.origin)) {
        allowedOrigin = corsOptions.origin.includes(origin);
      }

      if (allowedOrigin) {
        res.headers.set('Access-Control-Allow-Origin', origin);
      }
    } else if (corsOptions.origin === true) {
      res.headers.set('Access-Control-Allow-Origin', '*');
    }

    // Credentials 설정
    if (corsOptions.credentials) {
      res.headers.set('Access-Control-Allow-Credentials', 'true');
    }

    // Preflight 요청 처리
    if (requestMethod === 'OPTIONS') {
      // Methods 설정
      if (corsOptions.methods && corsOptions.methods.length > 0) {
        res.headers.set('Access-Control-Allow-Methods', corsOptions.methods.join(', '));
      }

      // Headers 설정
      if (corsOptions.allowedHeaders && corsOptions.allowedHeaders.length > 0) {
        res.headers.set('Access-Control-Allow-Headers', corsOptions.allowedHeaders.join(', '));
      }

      // 한국어 콘텐츠 지원을 위한 추가 헤더
      res.headers.set('Access-Control-Allow-Headers',
        [...(corsOptions.allowedHeaders || []), 'Content-Type', 'Accept-Language'].join(', ')
      );

      // Preflight 캐시 설정 (24시간)
      res.headers.set('Access-Control-Max-Age', '86400');

      // OPTIONS 요청에 대한 응답 상태 코드 설정
      return new NextResponse(null, {
        status: corsOptions.optionsSuccessStatus || 204,
        headers: res.headers
      });
    }

    // 일반 요청에 대한 CORS 헤더 설정
    if (corsOptions.methods && corsOptions.methods.length > 0) {
      res.headers.set('Access-Control-Allow-Methods', corsOptions.methods.join(', '));
    }

    // 한국어 콘텐츠 노출을 위한 헤더
    res.headers.set('Access-Control-Expose-Headers', 'Content-Range, X-Content-Range, Content-Language');

    return res;
  };
}

/**
 * 개발 환경용 CORS 설정
 */
export const developmentCorsOptions: CorsOptions = {
  origin: [
    'http://localhost:3000',
    'http://localhost:3001',
    'http://localhost:3002',
    'http://127.0.0.1:3000',
    'http://127.0.0.1:3001',
    'http://127.0.0.1:3002'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    ...DEFAULT_CORS_OPTIONS.allowedHeaders!,
    'X-Debug-Mode',
    'X-Test-Request'
  ]
};

/**
 * 프로덕션 환경용 CORS 설정
 */
export const productionCorsOptions: CorsOptions = {
  origin: [
    // 프로덕션 도메인들을 여기에 추가
    // 'https://your-domain.com',
    // 'https://www.your-domain.com'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: DEFAULT_CORS_OPTIONS.allowedHeaders
};

/**
 * API 전용 CORS 설정
 */
export const apiCorsOptions: CorsOptions = {
  origin: process.env.NODE_ENV === 'development'
    ? developmentCorsOptions.origin
    : productionCorsOptions.origin,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: [
    'Authorization',
    'Content-Type',
    'Accept',
    'X-Requested-With',
    'Accept-Language',
    'Accept-Charset'
  ]
};

/**
 * 정적 파일용 CORS 설정
 */
export const staticCorsOptions: CorsOptions = {
  origin: true,
  credentials: false,
  methods: ['GET', 'HEAD'],
  allowedHeaders: ['Accept', 'Accept-Encoding', 'Cache-Control']
};
```


#### 📄 src\middleware\error-handler.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import {
  ErrorCode,
  ERPError,
  createErrorResponse,
  convertMySQLError,
  isServerError
} from '@/lib/error-format';

/**
 * Error context for logging and debugging
 */
export interface ErrorContext {
  requestId?: string;
  userId?: string;
  userAgent?: string;
  path?: string;
  method?: string;
  ip?: string;
  timestamp?: string;
  resource?: string;
  action?: string;
}

/**
 * Global error handler middleware for API routes
 */
export function withErrorHandler<T extends any[]>(
  handler: (request: NextRequest, ...args: T) => Promise<NextResponse>
) {
  return async function errorHandlerWrapper(
    request: NextRequest,
    ...args: T
  ): Promise<NextResponse> {
    const startTime = Date.now();
    let requestId: string | undefined;

    try {
      // Generate request ID for tracking
      requestId = generateRequestId();

      // Add request ID to headers for downstream handlers
      request.headers.set('x-request-id', requestId);

      // Execute the handler
      const response = await handler(request, ...args);

      // Add request ID and processing time to response headers
      response.headers.set('x-request-id', requestId);
      response.headers.set('x-processing-time', `${Date.now() - startTime}ms`);

      return response;
    } catch (error) {
      const processingTime = Date.now() - startTime;
      const context = createErrorContext(request, requestId, processingTime);

      return handleError(error, context);
    }
  };
}

/**
 * Handle different types of errors and return appropriate responses
 */
export function handleError(error: unknown, context: ErrorContext = {}): NextResponse {
  let erpError: ERPError;

  // Convert different error types to ERPError
  if (error instanceof ERPError) {
    erpError = error;
  } else if (error && typeof error === 'object' && 'code' in error) {
    // MySQL or database errors
    erpError = convertMySQLError(error);
  } else if (error instanceof Error) {
    // Generic JavaScript errors
    erpError = categorizeGenericError(error);
  } else {
    // Unknown error types
    erpError = new ERPError(
      ErrorCode.INTERNAL_SERVER_ERROR,
      '알 수 없는 오류가 발생했습니다',
      { originalError: String(error) }
    );
  }

  // Log the error
  logError(erpError, context);

  // Create standardized error response
  const errorResponse = erpError.toErrorResponse({
    requestId: context.requestId,
    path: context.path,
  });

  // Add additional context in development
  if (process.env.NODE_ENV === 'development') {
    errorResponse.error.details = {
      ...errorResponse.error.details,
      stack: erpError.stack,
      context,
    };
  }

  return NextResponse.json(errorResponse, {
    status: erpError.statusCode,
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      'x-request-id': context.requestId || '',
      'x-error-code': erpError.code,
    },
  });
}

/**
 * Categorize generic JavaScript errors into appropriate ERP error codes
 */
function categorizeGenericError(error: Error): ERPError {
  const message = error.message.toLowerCase();

  // Timeout errors
  if (message.includes('timeout') || message.includes('etimedout')) {
    return new ERPError(
      ErrorCode.TIMEOUT_ERROR,
      '요청 시간이 초과되었습니다',
      { originalMessage: error.message }
    );
  }

  // Connection errors
  if (message.includes('connection') || message.includes('econnrefused')) {
    return new ERPError(
      ErrorCode.SERVICE_UNAVAILABLE,
      '서비스에 연결할 수 없습니다',
      { originalMessage: error.message }
    );
  }

  // Network errors
  if (message.includes('network') || message.includes('enotfound')) {
    return new ERPError(
      ErrorCode.EXTERNAL_SERVICE_ERROR,
      '네트워크 오류가 발생했습니다',
      { originalMessage: error.message }
    );
  }

  // Permission errors
  if (message.includes('permission') || message.includes('access denied')) {
    return new ERPError(
      ErrorCode.FORBIDDEN,
      '접근 권한이 없습니다',
      { originalMessage: error.message }
    );
  }

  // Validation errors (from libraries)
  if (message.includes('invalid') || message.includes('validation')) {
    return new ERPError(
      ErrorCode.VALIDATION_ERROR,
      '입력값 검증에 실패했습니다',
      { originalMessage: error.message }
    );
  }

  // Default to internal server error
  return new ERPError(
    ErrorCode.INTERNAL_SERVER_ERROR,
    '서버 내부 오류가 발생했습니다',
    { originalMessage: error.message }
  );
}

/**
 * Create error context from request information
 */
function createErrorContext(
  request: NextRequest,
  requestId?: string,
  processingTime?: number
): ErrorContext {
  return {
    requestId,
    userAgent: request.headers.get('user-agent') || undefined,
    path: request.nextUrl.pathname,
    method: request.method,
    ip: getClientIP(request),
    timestamp: new Date().toISOString(),
    userId: request.headers.get('x-user-id') || undefined,
  };
}

/**
 * Extract client IP address from request
 */
function getClientIP(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for');
  const realIp = request.headers.get('x-real-ip');
  const ip = forwarded?.split(',')[0]?.trim() || realIp || (request as any).ip || 'unknown';
  return ip;
}

/**
 * Generate unique request ID
 */
function generateRequestId(): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 8);
  return `req_${timestamp}_${random}`;
}

/**
 * Log error with appropriate level and context
 */
function logError(error: ERPError, context: ErrorContext): void {
  const logLevel = isServerError(error.code) ? 'error' : 'warn';

  const logData = {
    level: logLevel,
    message: error.message,
    code: error.code,
    statusCode: error.statusCode,
    details: error.details,
    context,
    stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
  };

  // Use console for now, can be replaced with proper logging service
  if (logLevel === 'error') {
    console.error('ERP Error:', JSON.stringify(logData, null, 2));
  } else {
    console.warn('ERP Warning:', JSON.stringify(logData, null, 2));
  }

  // Send to external logging service in production
  if (process.env.NODE_ENV === 'production' && isServerError(error.code)) {
    // TODO: Integrate with external logging service (e.g., Winston, DataDog, etc.)
    sendToLoggingService(logData);
  }
}

/**
 * Send error to external logging service (placeholder)
 */
function sendToLoggingService(logData: any): void {
  // TODO: Implement external logging service integration
  // Examples:
  // - Winston with file transport
  // - DataDog logs API
  // - CloudWatch logs
  // - Custom logging endpoint

  if (process.env.LOGGING_ENDPOINT) {
    fetch(process.env.LOGGING_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json; charset=utf-8' },
      body: JSON.stringify(logData),
    }).catch(err => {
      console.error('Failed to send log to external service:', err);
    });
  }
}

/**
 * Error boundary for async route handlers
 */
export function asyncErrorBoundary<T extends any[]>(
  handler: (...args: T) => Promise<NextResponse>
) {
  return async function boundaryWrapper(...args: T): Promise<NextResponse> {
    try {
      return await handler(...args);
    } catch (error) {
      const context = createErrorContext(
        args[0] as NextRequest, // First argument should be NextRequest
        generateRequestId()
      );
      return handleError(error, context);
    }
  };
}

/**
 * Create validation error handler
 */
export function handleValidationError(
  errors: string[] | Record<string, string[]>,
  context: ErrorContext = {}
): NextResponse {
  let details: unknown;
  let message = '입력값 검증에 실패했습니다';

  if (Array.isArray(errors)) {
    details = { errors };
    if (errors.length === 1) {
      message = errors[0];
    }
  } else {
    details = { fieldErrors: errors };
    const errorCount = Object.keys(errors).length;
    message = `${errorCount}개 필드에서 검증 오류가 발생했습니다`;
  }

  const erpError = new ERPError(
    ErrorCode.VALIDATION_ERROR,
    message,
    details
  );

  return handleError(erpError, context);
}

/**
 * Create business rule violation error handler
 */
export function handleBusinessError(
  message: string,
  details?: any,
  context: ErrorContext = {}
): NextResponse {
  const erpError = new ERPError(
    ErrorCode.BUSINESS_RULE_VIOLATION,
    message,
    details
  );

  return handleError(erpError, context);
}

/**
 * Create not found error handler
 */
export function handleNotFoundError(
  resource: string,
  id?: string | number,
  context: ErrorContext = {}
): NextResponse {
  const erpError = ERPError.notFound(resource, id, context.action);
  return handleError(erpError, context);
}

/**
 * Create unauthorized error handler
 */
export function handleUnauthorizedError(
  message = '인증이 필요합니다',
  context: ErrorContext = {}
): NextResponse {
  const erpError = new ERPError(
    ErrorCode.UNAUTHORIZED,
    message
  );

  return handleError(erpError, context);
}

/**
 * Create forbidden error handler
 */
export function handleForbiddenError(
  message = '접근 권한이 없습니다',
  context: ErrorContext = {}
): NextResponse {
  const erpError = new ERPError(
    ErrorCode.FORBIDDEN,
    message,
    { action: context.action, resource: context.resource }
  );

  return handleError(erpError, context);
}

/**
 * Database error handler with retry logic
 */
export function handleDatabaseError(
  error: any,
  context: ErrorContext = {},
  retryCount = 0
): NextResponse {
  const erpError = convertMySQLError(error);

  // Add retry information to context
  const enrichedContext = {
    ...context,
    retryCount,
    canRetry: retryCount < 3 && ['ER_LOCK_WAIT_TIMEOUT', 'ER_LOCK_DEADLOCK'].includes(error.code),
  };

  return handleError(erpError, enrichedContext);
}

/**
 * Rate limit error handler
 */
export function handleRateLimitError(
  limit: number,
  windowMs: number,
  retryAfter: number,
  context: ErrorContext = {}
): NextResponse {
  const erpError = new ERPError(
    ErrorCode.RATE_LIMIT_EXCEEDED,
    '요청 한도를 초과했습니다. 잠시 후 다시 시도해주세요',
    { limit, windowMs, retryAfter }
  );

  return handleError(erpError, context);
}
```


#### 📄 src\middleware\rate-limit.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

/**
 * Rate limiting configuration interface
 */
export interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  keyGenerator?: (request: NextRequest) => string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  message?: string;
  standardHeaders?: boolean;
  legacyHeaders?: boolean;
}

/**
 * Rate limit store interface
 */
export interface RateLimitStore {
  increment(key: string): Promise<{ totalHits: number; timeToExpire?: number }>;
  decrement(key: string): Promise<void>;
  resetKey(key: string): Promise<void>;
}

/**
 * In-memory rate limit store for development
 */
class MemoryStore implements RateLimitStore {
  private hits: Map<string, { count: number; resetTime: number }> = new Map();

  async increment(key: string): Promise<{ totalHits: number; timeToExpire?: number }> {
    const now = Date.now();
    const hit = this.hits.get(key);

    if (!hit || now > hit.resetTime) {
      // Reset or create new entry
      this.hits.set(key, { count: 1, resetTime: now + 60000 }); // 1 minute window
      return { totalHits: 1, timeToExpire: 60000 };
    }

    hit.count++;
    this.hits.set(key, hit);
    return {
      totalHits: hit.count,
      timeToExpire: hit.resetTime - now
    };
  }

  async decrement(key: string): Promise<void> {
    const hit = this.hits.get(key);
    if (hit && hit.count > 0) {
      hit.count--;
      this.hits.set(key, hit);
    }
  }

  async resetKey(key: string): Promise<void> {
    this.hits.delete(key);
  }

  // Cleanup expired entries
  cleanup(): void {
    const now = Date.now();
    for (const [key, hit] of this.hits.entries()) {
      if (now > hit.resetTime) {
        this.hits.delete(key);
      }
    }
  }
}

/**
 * Redis rate limit store for production
 */
class RedisStore implements RateLimitStore {
  private redis: any;

  constructor(redisClient: any) {
    this.redis = redisClient;
  }

  async increment(key: string): Promise<{ totalHits: number; timeToExpire?: number }> {
    const pipeline = this.redis.pipeline();
    const windowMs = 60000; // 1 minute

    pipeline.incr(key);
    pipeline.expire(key, Math.ceil(windowMs / 1000));
    pipeline.ttl(key);

    const results = await pipeline.exec();

    const totalHits = results[0][1];
    const ttl = results[2][1];
    const timeToExpire = ttl > 0 ? ttl * 1000 : windowMs;

    return { totalHits, timeToExpire };
  }

  async decrement(key: string): Promise<void> {
    const current = await this.redis.get(key);
    if (current && parseInt(current) > 0) {
      await this.redis.decr(key);
    }
  }

  async resetKey(key: string): Promise<void> {
    await this.redis.del(key);
  }
}

/**
 * Default rate limit configurations for different API routes
 */
export const RATE_LIMIT_CONFIGS = {
  // Authentication routes - stricter limits
  auth: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 5, // 5 attempts per 15 minutes
    message: '로그인 시도가 너무 많습니다. 15분 후 다시 시도해주세요.',
  },

  // Standard API routes
  api: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 100, // 100 requests per minute
    message: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
  },

  // Upload routes - more restrictive
  upload: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 10, // 10 uploads per minute
    message: '파일 업로드 요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
  },

  // Export routes
  export: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 20, // 20 exports per minute
    message: '파일 다운로드 요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
  },

  // Dashboard and analytics
  dashboard: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 60, // 60 requests per minute
    message: '대시보드 요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
  },

  // Health check - very permissive
  health: {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 1000, // 1000 requests per minute
    message: '헬스체크 요청이 너무 많습니다.',
  },
} as const;

// Global memory store instance
const memoryStore = new MemoryStore();

// Cleanup expired entries every 5 minutes
if (typeof window === 'undefined') {
  setInterval(() => {
    memoryStore.cleanup();
  }, 5 * 60 * 1000);
}

/**
 * Create rate limiter middleware
 */
export function createRateLimit(config: RateLimitConfig, store?: RateLimitStore) {
  const rateLimitStore = store || memoryStore;

  const {
    windowMs,
    maxRequests,
    keyGenerator = (request: NextRequest) => getClientIdentifier(request),
    message = '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
    standardHeaders = true,
    legacyHeaders = false,
  } = config;

  return async function rateLimitMiddleware(
    request: NextRequest
  ): Promise<NextResponse | null> {
    try {
      const key = keyGenerator(request);
      const { totalHits, timeToExpire } = await rateLimitStore.increment(key);

      const headers = new Headers();

      if (standardHeaders) {
        headers.set('RateLimit-Limit', maxRequests.toString());
        headers.set('RateLimit-Remaining', Math.max(0, maxRequests - totalHits).toString());
        if (timeToExpire) {
          headers.set('RateLimit-Reset', new Date(Date.now() + timeToExpire).toISOString());
        }
      }

      if (legacyHeaders) {
        headers.set('X-RateLimit-Limit', maxRequests.toString());
        headers.set('X-RateLimit-Remaining', Math.max(0, maxRequests - totalHits).toString());
        if (timeToExpire) {
          headers.set('X-RateLimit-Reset', Math.ceil((Date.now() + timeToExpire) / 1000).toString());
        }
      }

      if (totalHits > maxRequests) {
        const retryAfter = timeToExpire ? Math.ceil(timeToExpire / 1000) : Math.ceil(windowMs / 1000);
        headers.set('Retry-After', retryAfter.toString());

        return NextResponse.json(
          {
            success: false,
            error: message,
            code: 'RATE_LIMIT_EXCEEDED',
            details: {
              limit: maxRequests,
              windowMs,
              retryAfter,
            },
            timestamp: new Date().toISOString(),
          },
          {
            status: 429,
            headers,
          }
        );
      }

      // Add rate limit headers to successful responses
      const response = NextResponse.next();
      headers.forEach((value, key) => {
        response.headers.set(key, value);
      });

      return null; // Continue to next middleware
    } catch (error) {
      console.error('Rate limiting error:', error);
      // If rate limiting fails, allow the request to proceed
      return null;
    }
  };
}

/**
 * Get client identifier for rate limiting
 */
function getClientIdentifier(request: NextRequest): string {
  // Try to get user ID from headers (if authenticated)
  const userId = request.headers.get('x-user-id');
  if (userId) {
    return `user:${userId}`;
  }

  // Fall back to IP address
  const forwarded = request.headers.get('x-forwarded-for');
  const realIp = request.headers.get('x-real-ip');
  const ip = forwarded?.split(',')[0]?.trim() || realIp || (request as any).ip || 'unknown';

  return `ip:${ip}`;
}

/**
 * Create rate limiter with user-based key generation
 */
export function createUserRateLimit(config: RateLimitConfig, store?: RateLimitStore) {
  return createRateLimit({
    ...config,
    keyGenerator: (request: NextRequest) => {
      const userId = request.headers.get('x-user-id');
      const pathname = request.nextUrl.pathname;
      return userId ? `user:${userId}:${pathname}` : `ip:${getClientIdentifier(request)}:${pathname}`;
    },
  }, store);
}

/**
 * Create rate limiter with IP-based key generation
 */
export function createIPRateLimit(config: RateLimitConfig, store?: RateLimitStore) {
  return createRateLimit({
    ...config,
    keyGenerator: (request: NextRequest) => {
      const pathname = request.nextUrl.pathname;
      return `${getClientIdentifier(request)}:${pathname}`;
    },
  }, store);
}

/**
 * Apply rate limiting based on route patterns
 */
export function applyRouteBasedRateLimit(request: NextRequest): Promise<NextResponse | null> {
  const pathname = request.nextUrl.pathname;

  // Authentication routes
  if (pathname.includes('/api/auth/')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.auth)(request);
  }

  // Upload routes
  if (pathname.includes('/api/upload/')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.upload)(request);
  }

  // Export routes
  if (pathname.includes('/api/export/') || pathname.includes('/api/download/')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.export)(request);
  }

  // Dashboard routes
  if (pathname.includes('/api/dashboard/')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.dashboard)(request);
  }

  // Health check routes
  if (pathname.includes('/api/health')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.health)(request);
  }

  // Default API rate limiting
  if (pathname.startsWith('/api/')) {
    return createRateLimit(RATE_LIMIT_CONFIGS.api)(request);
  }

  // No rate limiting for non-API routes
  return Promise.resolve(null);
}

/**
 * Initialize Redis store (for production)
 */
export function createRedisStore(redisClient: any): RedisStore {
  return new RedisStore(redisClient);
}

/**
 * Get memory store instance (for development)
 */
export function getMemoryStore(): MemoryStore {
  return memoryStore;
}
```


#### 📄 src\middleware\security-headers.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export interface SecurityHeadersOptions {
  contentTypeOptions?: boolean;
  frameOptions?: 'DENY' | 'SAMEORIGIN' | string;
  xssProtection?: boolean;
  contentSecurityPolicy?: string | CSPDirectives;
  strictTransportSecurity?: string | boolean;
  referrerPolicy?: ReferrerPolicyValue;
  permissionsPolicy?: string;
  crossOriginEmbedderPolicy?: 'unsafe-none' | 'require-corp';
  crossOriginOpenerPolicy?: 'unsafe-none' | 'same-origin-allow-popups' | 'same-origin';
  crossOriginResourcePolicy?: 'same-site' | 'same-origin' | 'cross-origin';
}

export interface CSPDirectives {
  'default-src'?: string[];
  'script-src'?: string[];
  'style-src'?: string[];
  'img-src'?: string[];
  'connect-src'?: string[];
  'font-src'?: string[];
  'object-src'?: string[];
  'media-src'?: string[];
  'frame-src'?: string[];
  'worker-src'?: string[];
  'child-src'?: string[];
  'form-action'?: string[];
  'frame-ancestors'?: string[];
  'base-uri'?: string[];
  'upgrade-insecure-requests'?: boolean;
  'block-all-mixed-content'?: boolean;
}

export type ReferrerPolicyValue =
  | 'no-referrer'
  | 'no-referrer-when-downgrade'
  | 'origin'
  | 'origin-when-cross-origin'
  | 'same-origin'
  | 'strict-origin'
  | 'strict-origin-when-cross-origin'
  | 'unsafe-url';

const DEFAULT_SECURITY_OPTIONS: SecurityHeadersOptions = {
  contentTypeOptions: true,
  frameOptions: 'SAMEORIGIN',
  xssProtection: true,
  strictTransportSecurity: process.env.NODE_ENV === 'production',
  referrerPolicy: 'strict-origin-when-cross-origin',
  crossOriginEmbedderPolicy: 'unsafe-none',
  crossOriginOpenerPolicy: 'same-origin-allow-popups',
  crossOriginResourcePolicy: 'same-origin'
};

/**
 * 개발 환경용 CSP 설정 - 더 관대한 정책
 */
const DEVELOPMENT_CSP: CSPDirectives = {
  'default-src': ["'self'"],
  'script-src': [
    "'self'",
    "'unsafe-eval'",
    "'unsafe-inline'",
    'localhost:*',
    '127.0.0.1:*',
    'https://cdn.jsdelivr.net',
    'https://unpkg.com'
  ],
  'style-src': [
    "'self'",
    "'unsafe-inline'",
    'https://fonts.googleapis.com',
    'https://cdn.jsdelivr.net'
  ],
  'img-src': [
    "'self'",
    'data:',
    'blob:',
    'https:',
    'http://localhost:*',
    'http://127.0.0.1:*'
  ],
  'connect-src': [
    "'self'",
    'localhost:*',
    '127.0.0.1:*',
    'ws://localhost:*',
    'ws://127.0.0.1:*',
    'wss://localhost:*',
    'wss://127.0.0.1:*'
  ],
  'font-src': [
    "'self'",
    'https://fonts.gstatic.com',
    'https://cdn.jsdelivr.net',
    'data:'
  ],
  'object-src': ["'none'"],
  'media-src': ["'self'", 'data:', 'blob:'],
  'frame-src': ["'self'"],
  'worker-src': ["'self'", 'blob:'],
  'child-src': ["'self'", 'blob:'],
  'form-action': ["'self'"],
  'frame-ancestors': ["'self'"],
  'base-uri': ["'self'"],
  'upgrade-insecure-requests': false
};

/**
 * 프로덕션 환경용 CSP 설정 - 엄격한 정책
 */
const PRODUCTION_CSP: CSPDirectives = {
  'default-src': ["'self'"],
  'script-src': [
    "'self'",
    "'sha256-hash-here'", // 실제 스크립트 해시로 교체 필요
    'https://cdn.jsdelivr.net'
  ],
  'style-src': [
    "'self'",
    "'sha256-hash-here'", // 실제 스타일 해시로 교체 필요
    'https://fonts.googleapis.com'
  ],
  'img-src': [
    "'self'",
    'data:',
    'https:'
  ],
  'connect-src': ["'self'"],
  'font-src': [
    "'self'",
    'https://fonts.gstatic.com',
    'data:'
  ],
  'object-src': ["'none'"],
  'media-src': ["'self'"],
  'frame-src': ["'none'"],
  'worker-src': ["'self'"],
  'child-src': ["'none'"],
  'form-action': ["'self'"],
  'frame-ancestors': ["'none'"],
  'base-uri': ["'self'"],
  'upgrade-insecure-requests': true,
  'block-all-mixed-content': true
};

/**
 * CSP 지시문을 문자열로 변환
 */
function buildCSPString(directives: CSPDirectives): string {
  const policies: string[] = [];

  Object.entries(directives).forEach(([directive, values]) => {
    if (directive === 'upgrade-insecure-requests' && values === true) {
      policies.push('upgrade-insecure-requests');
    } else if (directive === 'block-all-mixed-content' && values === true) {
      policies.push('block-all-mixed-content');
    } else if (Array.isArray(values) && values.length > 0) {
      policies.push(`${directive} ${values.join(' ')}`);
    }
  });

  return policies.join('; ');
}

/**
 * 보안 헤더 미들웨어
 * 다양한 보안 헤더를 설정하여 웹 애플리케이션을 보호합니다.
 */
export function securityHeadersMiddleware(options: Partial<SecurityHeadersOptions> = {}) {
  const securityOptions: SecurityHeadersOptions = { ...DEFAULT_SECURITY_OPTIONS, ...options };

  return (request: NextRequest, response?: NextResponse): NextResponse => {
    const res = response || new NextResponse();

    // X-Content-Type-Options
    if (securityOptions.contentTypeOptions) {
      res.headers.set('X-Content-Type-Options', 'nosniff');
    }

    // X-Frame-Options
    if (securityOptions.frameOptions) {
      res.headers.set('X-Frame-Options', securityOptions.frameOptions);
    }

    // X-XSS-Protection (레거시 브라우저 지원용)
    if (securityOptions.xssProtection) {
      res.headers.set('X-XSS-Protection', '1; mode=block');
    }

    // Content-Security-Policy
    if (securityOptions.contentSecurityPolicy) {
      let cspValue: string;

      if (typeof securityOptions.contentSecurityPolicy === 'string') {
        cspValue = securityOptions.contentSecurityPolicy;
      } else {
        cspValue = buildCSPString(securityOptions.contentSecurityPolicy);
      }

      res.headers.set('Content-Security-Policy', cspValue);
    } else {
      // 기본 CSP 설정
      const defaultCSP = process.env.NODE_ENV === 'development' ? DEVELOPMENT_CSP : PRODUCTION_CSP;
      res.headers.set('Content-Security-Policy', buildCSPString(defaultCSP));
    }

    // Strict-Transport-Security (HTTPS에서만 유효)
    if (securityOptions.strictTransportSecurity) {
      const hstsValue = typeof securityOptions.strictTransportSecurity === 'string'
        ? securityOptions.strictTransportSecurity
        : 'max-age=63072000; includeSubDomains; preload';

      // HTTPS 환경에서만 HSTS 헤더 추가
      if (request.headers.get('x-forwarded-proto') === 'https' || request.url.startsWith('https://')) {
        res.headers.set('Strict-Transport-Security', hstsValue);
      }
    }

    // Referrer-Policy
    if (securityOptions.referrerPolicy) {
      res.headers.set('Referrer-Policy', securityOptions.referrerPolicy);
    }

    // Permissions-Policy (구 Feature-Policy)
    if (securityOptions.permissionsPolicy) {
      res.headers.set('Permissions-Policy', securityOptions.permissionsPolicy);
    } else {
      // 기본 권한 정책 - 민감한 기능들 비활성화
      const defaultPermissions = [
        'accelerometer=()',
        'camera=()',
        'geolocation=()',
        'gyroscope=()',
        'magnetometer=()',
        'microphone=()',
        'payment=()',
        'usb=()'
      ].join(', ');
      res.headers.set('Permissions-Policy', defaultPermissions);
    }

    // Cross-Origin-Embedder-Policy
    if (securityOptions.crossOriginEmbedderPolicy) {
      res.headers.set('Cross-Origin-Embedder-Policy', securityOptions.crossOriginEmbedderPolicy);
    }

    // Cross-Origin-Opener-Policy
    if (securityOptions.crossOriginOpenerPolicy) {
      res.headers.set('Cross-Origin-Opener-Policy', securityOptions.crossOriginOpenerPolicy);
    }

    // Cross-Origin-Resource-Policy
    if (securityOptions.crossOriginResourcePolicy) {
      res.headers.set('Cross-Origin-Resource-Policy', securityOptions.crossOriginResourcePolicy);
    }

    // 한국어 콘텐츠 지원을 위한 추가 헤더
    res.headers.set('Accept-CH', 'Accept-Language');
    res.headers.set('Vary', 'Accept-Language, Accept-Encoding');

    // 캐시 제어 (민감한 페이지)
    if (request.nextUrl.pathname.includes('/api/') && !request.nextUrl.pathname.includes('/public')) {
      res.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
      res.headers.set('Pragma', 'no-cache');
      res.headers.set('Expires', '0');
    }

    return res;
  };
}

/**
 * API 전용 보안 헤더 설정
 */
export const apiSecurityOptions: SecurityHeadersOptions = {
  contentTypeOptions: true,
  frameOptions: 'DENY',
  xssProtection: true,
  referrerPolicy: 'no-referrer',
  crossOriginResourcePolicy: 'same-origin',
  contentSecurityPolicy: {
    'default-src': ["'none'"],
    'connect-src': ["'self'"]
  }
};

/**
 * 정적 파일용 보안 헤더 설정
 */
export const staticSecurityOptions: SecurityHeadersOptions = {
  contentTypeOptions: true,
  frameOptions: 'SAMEORIGIN',
  crossOriginResourcePolicy: 'cross-origin',
  referrerPolicy: 'strict-origin-when-cross-origin'
};

/**
 * 관리자 페이지용 강화된 보안 헤더 설정
 */
export const adminSecurityOptions: SecurityHeadersOptions = {
  contentTypeOptions: true,
  frameOptions: 'DENY',
  xssProtection: true,
  referrerPolicy: 'no-referrer',
  crossOriginResourcePolicy: 'same-origin',
  contentSecurityPolicy: PRODUCTION_CSP
};
```


---

### CONFIG 코드


#### 📄 src\config\security.ts

```typescript
import type { CorsOptions } from '../middleware/cors';
import type { SecurityHeadersOptions } from '../middleware/security-headers';

/**
 * 환경별 보안 설정
 */
export interface SecurityConfig {
  cors: CorsOptions;
  security: SecurityHeadersOptions;
  rateLimit?: {
    windowMs: number;
    max: number;
    skipSuccessfulRequests?: boolean;
  };
  session?: {
    maxAge: number;
    httpOnly: boolean;
    secure: boolean;
    sameSite: 'strict' | 'lax' | 'none';
  };
}

/**
 * 개발 환경 보안 설정
 */
export const developmentConfig: SecurityConfig = {
  cors: {
    origin: [
      'http://localhost:3000',
      'http://localhost:3001',
      'http://localhost:3002',
      'http://127.0.0.1:3000',
      'http://127.0.0.1:3001',
      'http://127.0.0.1:3002'
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: [
      'Accept',
      'Accept-Version',
      'Authorization',
      'Content-Length',
      'Content-MD5',
      'Content-Type',
      'Date',
      'X-Api-Version',
      'X-Requested-With',
      'X-CSRF-Token',
      'Cache-Control',
      'Accept-Encoding',
      'Accept-Language',
      'Accept-Charset',
      'X-Debug-Mode',
      'X-Test-Request'
    ]
  },
  security: {
    contentTypeOptions: true,
    frameOptions: 'SAMEORIGIN',
    xssProtection: true,
    strictTransportSecurity: false, // 개발환경에서는 HTTPS 강제하지 않음
    referrerPolicy: 'strict-origin-when-cross-origin',
    contentSecurityPolicy: {
      'default-src': ["'self'"],
      'script-src': [
        "'self'",
        "'unsafe-eval'",
        "'unsafe-inline'",
        'localhost:*',
        '127.0.0.1:*',
        'https://cdn.jsdelivr.net',
        'https://unpkg.com'
      ],
      'style-src': [
        "'self'",
        "'unsafe-inline'",
        'https://fonts.googleapis.com',
        'https://cdn.jsdelivr.net'
      ],
      'img-src': [
        "'self'",
        'data:',
        'blob:',
        'https:',
        'http://localhost:*',
        'http://127.0.0.1:*'
      ],
      'connect-src': [
        "'self'",
        'localhost:*',
        '127.0.0.1:*',
        'ws://localhost:*',
        'ws://127.0.0.1:*',
        'wss://localhost:*',
        'wss://127.0.0.1:*'
      ],
      'font-src': [
        "'self'",
        'https://fonts.gstatic.com',
        'https://cdn.jsdelivr.net',
        'data:'
      ],
      'object-src': ["'none'"],
      'media-src': ["'self'", 'data:', 'blob:'],
      'frame-src': ["'self'"],
      'worker-src': ["'self'", 'blob:'],
      'child-src': ["'self'", 'blob:'],
      'form-action': ["'self'"],
      'frame-ancestors': ["'self'"],
      'base-uri': ["'self'"],
      'upgrade-insecure-requests': false
    }
  },
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15분
    max: 1000, // 개발환경에서는 넉넉하게
    skipSuccessfulRequests: true
  },
  session: {
    maxAge: 24 * 60 * 60 * 1000, // 24시간
    httpOnly: true,
    secure: false, // 개발환경에서는 HTTP 허용
    sameSite: 'lax'
  }
};

/**
 * 프로덕션 환경 보안 설정
 */
export const productionConfig: SecurityConfig = {
  cors: {
    origin: process.env.ALLOWED_ORIGINS
      ? process.env.ALLOWED_ORIGINS.split(',').map(origin => origin.trim())
      : ['https://your-domain.com'], // 실제 도메인으로 교체 필요
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: [
      'Accept',
      'Authorization',
      'Content-Type',
      'X-Requested-With',
      'Accept-Language',
      'Accept-Charset'
    ]
  },
  security: {
    contentTypeOptions: true,
    frameOptions: 'DENY',
    xssProtection: true,
    strictTransportSecurity: 'max-age=63072000; includeSubDomains; preload',
    referrerPolicy: 'strict-origin-when-cross-origin',
    contentSecurityPolicy: {
      'default-src': ["'self'"],
      'script-src': ["'self'"],
      'style-src': ["'self'", 'https://fonts.googleapis.com'],
      'img-src': ["'self'", 'data:', 'https:'],
      'connect-src': ["'self'"],
      'font-src': ["'self'", 'https://fonts.gstatic.com', 'data:'],
      'object-src': ["'none'"],
      'media-src': ["'self'"],
      'frame-src': ["'none'"],
      'worker-src': ["'self'"],
      'child-src': ["'none'"],
      'form-action': ["'self'"],
      'frame-ancestors': ["'none'"],
      'base-uri': ["'self'"],
      'upgrade-insecure-requests': true,
      'block-all-mixed-content': true
    }
  },
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15분
    max: 100, // API 호출 제한
    skipSuccessfulRequests: false
  },
  session: {
    maxAge: 8 * 60 * 60 * 1000, // 8시간
    httpOnly: true,
    secure: true, // HTTPS 환경에서만
    sameSite: 'strict'
  }
};

/**
 * 테스트 환경 보안 설정
 */
export const testConfig: SecurityConfig = {
  cors: {
    origin: true, // 테스트에서는 모든 origin 허용
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['*']
  },
  security: {
    contentTypeOptions: false,
    frameOptions: 'SAMEORIGIN',
    xssProtection: false,
    strictTransportSecurity: false,
    referrerPolicy: 'unsafe-url'
  },
  rateLimit: {
    windowMs: 1 * 60 * 1000, // 1분
    max: 10000, // 테스트에서는 매우 관대하게
    skipSuccessfulRequests: true
  },
  session: {
    maxAge: 30 * 60 * 1000, // 30분
    httpOnly: true,
    secure: false,
    sameSite: 'lax'
  }
};

/**
 * 현재 환경에 맞는 보안 설정 반환
 */
export function getSecurityConfig(): SecurityConfig {
  const env = process.env.NODE_ENV || 'development';

  switch (env) {
    case 'production':
      return productionConfig;
    case 'test':
      return testConfig;
    case 'development':
    default:
      return developmentConfig;
  }
}

/**
 * API 라우트별 보안 설정 오버라이드
 */
export const routeSecurityConfig: Record<string, Partial<SecurityConfig>> = {
  // 공개 API (더 관대한 CORS)
  '/api/public': {
    cors: {
      origin: true,
      credentials: false
    }
  },

  // 인증 API (엄격한 설정)
  '/api/auth': {
    cors: {
      credentials: true,
      methods: ['POST', 'GET']
    },
    security: {
      frameOptions: 'DENY',
      referrerPolicy: 'no-referrer'
    }
  },

  // 관리자 API (최대 보안)
  '/api/admin': {
    cors: {
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE']
    },
    security: {
      frameOptions: 'DENY',
      referrerPolicy: 'no-referrer',
      contentSecurityPolicy: {
        'default-src': ["'self'"],
        'connect-src': ["'self'"]
      }
    },
    rateLimit: {
      windowMs: 15 * 60 * 1000,
      max: 50 // 더 엄격한 제한
    }
  },

  // 파일 업로드 API
  '/api/upload': {
    cors: {
      credentials: true,
      methods: ['POST'],
      allowedHeaders: ['Content-Type', 'Authorization', 'Content-Length']
    },
    rateLimit: {
      windowMs: 60 * 60 * 1000, // 1시간
      max: 10 // 업로드 제한
    }
  },

  // 다운로드 API
  '/api/download': {
    cors: {
      credentials: true,
      methods: ['GET']
    },
    security: {
      contentSecurityPolicy: {
        'default-src': ["'self'"],
        'img-src': ["'self'", 'data:']
      }
    }
  }
};

/**
 * 특정 라우트에 대한 보안 설정 가져오기
 */
export function getRouteSecurityConfig(pathname: string): SecurityConfig {
  const baseConfig = getSecurityConfig();

  // 라우트별 오버라이드 찾기
  const routeOverride = Object.entries(routeSecurityConfig).find(([route]) =>
    pathname.startsWith(route)
  )?.[1];

  if (routeOverride) {
    return {
      cors: { ...baseConfig.cors, ...routeOverride.cors },
      security: { ...baseConfig.security, ...routeOverride.security },
      rateLimit: {
        windowMs: baseConfig.rateLimit?.windowMs ?? 60000,
        max: baseConfig.rateLimit?.max ?? 100,
        ...routeOverride.rateLimit
      },
      session: {
        maxAge: baseConfig.session?.maxAge ?? 86400000,
        httpOnly: baseConfig.session?.httpOnly ?? true,
        secure: baseConfig.session?.secure ?? false,
        sameSite: baseConfig.session?.sameSite ?? 'lax',
        ...routeOverride.session
      }
    };
  }

  return baseConfig;
}

/**
 * 환경변수 기반 설정 오버라이드
 */
export function applyEnvironmentOverrides(config: SecurityConfig): SecurityConfig {
  // CORS 오버라이드
  if (process.env.CORS_ORIGINS) {
    config.cors.origin = process.env.CORS_ORIGINS.split(',').map(o => o.trim());
  }

  // Rate limiting 오버라이드
  if (process.env.RATE_LIMIT_MAX) {
    config.rateLimit = {
      windowMs: config.rateLimit?.windowMs ?? 60000,
      max: parseInt(process.env.RATE_LIMIT_MAX, 10),
      skipSuccessfulRequests: config.rateLimit?.skipSuccessfulRequests
    };
  }

  // Session 보안 오버라이드
  if (process.env.SESSION_MAX_AGE) {
    config.session = {
      maxAge: parseInt(process.env.SESSION_MAX_AGE, 10),
      httpOnly: config.session?.httpOnly ?? true,
      secure: config.session?.secure ?? false,
      sameSite: config.session?.sameSite ?? 'lax'
    };
  }

  return config;
}
```


---

### OTHERS 코드


#### 📄 src\app\api\admin\errors\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { errorLoggingManager } from '@/lib/errorLogger';
import { createSuccessResponse, handleError, handleValidationError } from '@/lib/errorHandler';
import { ErrorSeverity } from '@/lib/errorHandler';

/**
 * 에러 로그 조회 API
 * GET /api/admin/errors
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    // 쿼리 파라미터 파싱
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '50');
    const severity = searchParams.get('severity') as ErrorSeverity | null;
    const errorType = searchParams.get('error_type');
    const resolved = searchParams.get('resolved');
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');

    // 유효성 검사
    if (page < 1 || limit < 1 || limit > 100) {
      return handleValidationError(['페이지와 제한값은 유효한 범위여야 합니다']);
    }

    const options: Record<string, unknown> = { page, limit };

    if (severity && Object.values(ErrorSeverity).includes(severity)) {
      options.severity = severity;
    }

    if (errorType) {
      options.errorType = errorType;
    }

    if (resolved !== null && (resolved === 'true' || resolved === 'false')) {
      options.resolved = resolved === 'true';
    }

    if (startDate) {
      const parsedStartDate = new Date(startDate);
      if (!isNaN(parsedStartDate.getTime())) {
        options.startDate = parsedStartDate;
      }
    }

    if (endDate) {
      const parsedEndDate = new Date(endDate);
      if (!isNaN(parsedEndDate.getTime())) {
        options.endDate = parsedEndDate;
      }
    }

    const dbLogger = errorLoggingManager.getDatabaseLogger();
    const result = await dbLogger.getErrorLogs(options);

    return createSuccessResponse(result.logs, undefined, {
      total: result.total,
      page,
      limit,
      hasMore: page * limit < result.total
    });
  } catch (error) {
    return handleError(error, {
      resource: 'error_logs',
      action: 'read'
    });
  }
}

/**
 * 에러 해결 처리 API
 * PUT /api/admin/errors
 */
export async function PUT(request: NextRequest) {
  try {
    const text = await request.text();
    const data = JSON.parse(text);

    // 유효성 검사
    if (!data.log_id || !data.resolved_by) {
      return handleValidationError(['log_id와 resolved_by는 필수입니다']);
    }

    const logId = parseInt(data.log_id);
    if (isNaN(logId)) {
      return handleValidationError(['log_id는 유효한 숫자여야 합니다']);
    }

    const dbLogger = errorLoggingManager.getDatabaseLogger();
    const success = await dbLogger.resolveError(logId, data.resolved_by);

    if (!success) {
      return NextResponse.json({
        success: false,
        error: {
          type: 'NOT_FOUND',
          message: '해당 에러 로그를 찾을 수 없습니다',
          timestamp: new Date().toISOString()
        }
      }, { status: 404 });
    }

    return createSuccessResponse({ resolved: true }, '에러가 해결로 표시되었습니다');
  } catch (error) {
    return handleError(error, {
      resource: 'error_logs',
      action: 'update'
    });
  }
}
```


#### 📄 src\app\api\admin\errors\stats\route.ts

```typescript
import { NextRequest } from 'next/server';
import { errorLoggingManager } from '@/lib/errorLogger';
import { createSuccessResponse, handleError, handleValidationError } from '@/lib/errorHandler';

/**
 * 에러 통계 조회 API
 * GET /api/admin/errors/stats
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const days = parseInt(searchParams.get('days') || '7');

    // 유효성 검사
    if (days < 1 || days > 365) {
      return handleValidationError(['일수는 1일에서 365일 사이여야 합니다']);
    }

    const dbLogger = errorLoggingManager.getDatabaseLogger();
    const stats = await dbLogger.getErrorStats(days);

    return createSuccessResponse(stats, `최근 ${days}일간의 에러 통계`);
  } catch (error) {
    return handleError(error, {
      resource: 'error_stats',
      action: 'read'
    });
  }
}
```


#### 📄 src\app\api\alerts\low-stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db-unified';

interface LowStockAlert {
  item_id: number;
  item_code: string;
  item_name: string;
  spec: string;
  unit: string;
  item_type: string;
  current_stock: number;
  safety_stock: number;
  reorder_point: number;
  severity: string;
  days_until_zero: number | null;
}

interface SummaryStats {
  total_alerts: number;
  critical_count: number;
  warning_count: number;
  critical_alerts: number;
  warning_alerts: number;
  avg_stock_ratio: number;
}

/**
 * GET /api/alerts/low-stock
 * Get low stock alerts
 * Query parameters:
 * - limit: Number of records to return (default: 50)
 * - offset: Pagination offset (default: 0)
 * - severity: Filter by severity (critical/warning)
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');
    const severity = searchParams.get('severity');

    let sql = `
      SELECT
        i.item_id,
        i.item_code,
        i.item_name,
        i.spec,
        i.unit,
        i.item_type,
        COALESCE(
          (
            SELECT SUM(
              CASE
                WHEN it.transaction_type = '입고' THEN it.quantity
                WHEN it.transaction_type = '출고' THEN -it.quantity
                WHEN it.transaction_type = '조정' THEN it.quantity
                ELSE 0
              END
            )
            FROM inventory_transactions it
            WHERE it.item_id = i.item_id
          ), 0
        ) as current_stock,
        COALESCE(i.safety_stock, 0) as safety_stock,
        i.unit_price,
        CASE
          WHEN COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) = 0 THEN 'critical'
          WHEN COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) <= (COALESCE(i.safety_stock, 0) * 0.5) THEN 'critical'
          ELSE 'warning'
        END as severity,
        CASE
          WHEN COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) = 0 THEN '재고 없음'
          WHEN COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) <= (COALESCE(i.safety_stock, 0) * 0.5) THEN '재고 부족 (Critical)'
          ELSE '재고 부족 (Warning)'
        END as alert_message,
        (
          SELECT MAX(it.transaction_date)
          FROM inventory_transactions it
          WHERE it.item_id = i.item_id
        ) as last_transaction_date
      FROM items i
      WHERE i.is_active = 1
      AND COALESCE(
        (
          SELECT SUM(
            CASE
              WHEN it.transaction_type = '입고' THEN it.quantity
              WHEN it.transaction_type = '출고' THEN -it.quantity
              WHEN it.transaction_type = '조정' THEN it.quantity
              ELSE 0
            END
          )
          FROM inventory_transactions it
          WHERE it.item_id = i.item_id
        ), 0
      ) <= COALESCE(i.safety_stock, 0)
    `;

    const params: unknown[] = [];

    if (severity) {
      if (severity === 'critical') {
        sql += ` AND (
          COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) = 0
          OR
          COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) <= (COALESCE(i.safety_stock, 0) * 0.5)
        )`;
      } else if (severity === 'warning') {
        sql += ` AND COALESCE(
          (
            SELECT SUM(
              CASE
                WHEN it.transaction_type = '입고' THEN it.quantity
                WHEN it.transaction_type = '출고' THEN -it.quantity
                WHEN it.transaction_type = '조정' THEN it.quantity
                ELSE 0
              END
            )
            FROM inventory_transactions it
            WHERE it.item_id = i.item_id
          ), 0
        ) > (COALESCE(i.safety_stock, 0) * 0.5)
        AND COALESCE(
          (
            SELECT SUM(
              CASE
                WHEN it.transaction_type = '입고' THEN it.quantity
                WHEN it.transaction_type = '출고' THEN -it.quantity
                WHEN it.transaction_type = '조정' THEN it.quantity
                ELSE 0
              END
            )
            FROM inventory_transactions it
            WHERE it.item_id = i.item_id
          ), 0
        ) > 0`;
      }
    }

    sql += ' ORDER BY severity DESC, current_stock ASC, i.item_code';
    sql += ` LIMIT ${limit} OFFSET ${offset}`;

    const alerts = await query<LowStockAlert[]>(sql, params);

    // Get summary statistics
    const summaryQuery = `
      SELECT
        COUNT(*) as total_alerts,
        SUM(
          CASE
            WHEN COALESCE(
              (
                SELECT SUM(
                  CASE
                    WHEN it.transaction_type = '입고' THEN it.quantity
                    WHEN it.transaction_type = '출고' THEN -it.quantity
                    WHEN it.transaction_type = '조정' THEN it.quantity
                    ELSE 0
                  END
                )
                FROM inventory_transactions it
                WHERE it.item_id = i.item_id
              ), 0
            ) = 0 THEN 1
            WHEN COALESCE(
              (
                SELECT SUM(
                  CASE
                    WHEN it.transaction_type = '입고' THEN it.quantity
                    WHEN it.transaction_type = '출고' THEN -it.quantity
                    WHEN it.transaction_type = '조정' THEN it.quantity
                    ELSE 0
                  END
                )
                FROM inventory_transactions it
                WHERE it.item_id = i.item_id
              ), 0
            ) <= (COALESCE(i.safety_stock, 0) * 0.5) THEN 1
            ELSE 0
          END
        ) as critical_alerts,
        SUM(
          CASE
            WHEN COALESCE(
              (
                SELECT SUM(
                  CASE
                    WHEN it.transaction_type = '입고' THEN it.quantity
                    WHEN it.transaction_type = '출고' THEN -it.quantity
                    WHEN it.transaction_type = '조정' THEN it.quantity
                    ELSE 0
                  END
                )
                FROM inventory_transactions it
                WHERE it.item_id = i.item_id
              ), 0
            ) > (COALESCE(i.safety_stock, 0) * 0.5)
            AND COALESCE(
              (
                SELECT SUM(
                  CASE
                    WHEN it.transaction_type = '입고' THEN it.quantity
                    WHEN it.transaction_type = '출고' THEN -it.quantity
                    WHEN it.transaction_type = '조정' THEN it.quantity
                    ELSE 0
                  END
                )
                FROM inventory_transactions it
                WHERE it.item_id = i.item_id
              ), 0
            ) <= COALESCE(i.safety_stock, 0)
            AND COALESCE(
              (
                SELECT SUM(
                  CASE
                    WHEN it.transaction_type = '입고' THEN it.quantity
                    WHEN it.transaction_type = '출고' THEN -it.quantity
                    WHEN it.transaction_type = '조정' THEN it.quantity
                    ELSE 0
                  END
                )
                FROM inventory_transactions it
                WHERE it.item_id = i.item_id
              ), 0
            ) > 0 THEN 1
            ELSE 0
          END
        ) as warning_alerts
      FROM items i
      WHERE i.is_active = 1
      AND COALESCE(
        (
          SELECT SUM(
            CASE
              WHEN it.transaction_type = '입고' THEN it.quantity
              WHEN it.transaction_type = '출고' THEN -it.quantity
              WHEN it.transaction_type = '조정' THEN it.quantity
              ELSE 0
            END
          )
          FROM inventory_transactions it
          WHERE it.item_id = i.item_id
        ), 0
      ) <= COALESCE(i.safety_stock, 0)
    `;

    const summaryResult = await query<SummaryStats>(summaryQuery);
    const summary = summaryResult[0] || { total_alerts: 0, critical_alerts: 0, warning_alerts: 0, critical_count: 0, warning_count: 0, avg_stock_ratio: 0 };

    // Get total count for pagination
    let countSql = `
      SELECT COUNT(*) as total
      FROM items i
      WHERE i.is_active = 1
      AND COALESCE(
        (
          SELECT SUM(
            CASE
              WHEN it.transaction_type = '입고' THEN it.quantity
              WHEN it.transaction_type = '출고' THEN -it.quantity
              WHEN it.transaction_type = '조정' THEN it.quantity
              ELSE 0
            END
          )
          FROM inventory_transactions it
          WHERE it.item_id = i.item_id
        ), 0
      ) <= COALESCE(i.safety_stock, 0)
    `;
    const countParams: (string | number)[] = [];

    if (severity) {
      if (severity === 'critical') {
        countSql += ` AND (
          COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) = 0
          OR
          COALESCE(
            (
              SELECT SUM(
                CASE
                  WHEN it.transaction_type = '입고' THEN it.quantity
                  WHEN it.transaction_type = '출고' THEN -it.quantity
                  WHEN it.transaction_type = '조정' THEN it.quantity
                  ELSE 0
                END
              )
              FROM inventory_transactions it
              WHERE it.item_id = i.item_id
            ), 0
          ) <= (COALESCE(i.safety_stock, 0) * 0.5)
        )`;
      }
    }

    const countQueryResult = await query<{ total: number }>(countSql, countParams);
    const countResult = countQueryResult[0] || { total: 0 };

    return NextResponse.json({
      success: true,
      data: {
        alerts,
        summary: {
          total_alerts: summary.total_alerts || 0,
          critical_alerts: summary.critical_alerts || 0,
          warning_alerts: summary.warning_alerts || 0
        },
        pagination: {
          total: countResult.total,
          limit,
          offset,
          hasMore: offset + limit < countResult.total
        }
      }
    });
  } catch (error) {
    console.error('Error fetching low stock alerts:', error);
    return NextResponse.json(
      {
        success: false,
        error: '재고 부족 알림 조회 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\auth\login\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { username, password } = body;

    if (!username || !password) {
      return NextResponse.json({
        success: false,
        error: '사용자명과 비밀번호를 입력해주세요.'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // 사용자 조회
    const { data: users, error } = await supabase
      .from('users')
      .select('user_id, username, password, name, email, role, is_active')
      .eq('username', username)
      .eq('is_active', true);

    if (error || !users || users.length === 0) {
      return NextResponse.json({
        success: false,
        error: '사용자명 또는 비밀번호가 올바르지 않습니다.'
      }, { status: 401 });
    }

    const user = users[0];

    // 비밀번호 검증
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      return NextResponse.json({
        success: false,
        error: '사용자명 또는 비밀번호가 올바르지 않습니다.'
      }, { status: 401 });
    }

    // JWT 토큰 생성 (간단한 버전)
    const token = Buffer.from(JSON.stringify({
      userId: user.user_id,
      username: user.username,
      role: user.role,
      exp: Date.now() + 24 * 60 * 60 * 1000 // 24시간
    })).toString('base64');

    const userResponse = {
      username: user.username,
      name: user.name,
      email: user.email,
      role: user.role
    };

    const response = NextResponse.json({
      success: true,
      data: { user: userResponse, token },
      message: '로그인에 성공했습니다'
    });

    // HTTP-only 쿠키에 토큰 저장
    response.cookies.set('auth_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000, // 24시간
      path: '/'
    });

    return response;
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json({
      success: false,
      error: '로그인 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\auth\logout\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

/**
 * POST /api/auth/logout
 * 사용자 로그아웃
 */
export async function POST(_request: NextRequest) {
  try {
    // 로그아웃 응답 생성
    const response = NextResponse.json({
      success: true,
      message: '로그아웃되었습니다.'
    });

    // 쿠키에서 토큰 제거
    response.cookies.set('auth_token', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 0, // 즉시 만료
      path: '/'
    });

    return response;

  } catch (_error) {
    console.error('Logout error:', _error);
    return NextResponse.json(
      {
        success: false,
        error: '로그아웃 처리 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\auth\me\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { protectRoute } from '@/lib/middleware';

/**
 * GET /api/auth/me
 * 현재 로그인한 사용자 정보 조회
 */
export const GET = protectRoute(
  async (request: NextRequest, user) => {
    try {
      return NextResponse.json({
        success: true,
        user: {
          id: user.id,
          username: user.username,
          name: user.name,
          email: user.email,
          department: user.department,
          role: user.role,
          is_active: user.is_active
        }
      });

    } catch (error) {
      console.error('Get current user error:', error);
      return NextResponse.json(
        {
          success: false,
          error: '사용자 정보 조회 중 오류가 발생했습니다.'
        },
        { status: 500 }
      );
    }
  }
);
```


#### 📄 src\app\api\bom\explode\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/db-unified';
import { protectRoute } from '@/lib/middleware';
import {
  explodeBom,
  getBomTree,
  calculateTotalCost,
  getBomLevelSummary,
  getWhereUsed,
  validateBom,
  type BOMNode
} from '@/lib/bom';

interface TreeStats {
  totalItems: number;
  totalCost: number;
  maxLevel: number;
}

interface ItemData {
  item_code: string;
  item_name: string;
  spec: string;
  price: number | null;
}

/**
 * GET /api/bom/explode
 * BOM 전개 및 관련 정보 조회
 *
 * Query Parameters:
 * - parent_item_id: 상위 품목 ID (필수)
 * - type: 조회 유형 (explode, tree, cost, summary, where-used, validate)
 * - max_level: 최대 전개 레벨 (기본값: 10)
 * - include_inactive: 비활성 항목 포함 여부 (기본값: false)
 */
export const GET = protectRoute(
  async (request: NextRequest, _user) => {
    try {
      const searchParams = request.nextUrl.searchParams;
      const parentItemId = searchParams.get('parent_item_id');
      const childItemId = searchParams.get('child_item_id');
      const type = searchParams.get('type') || 'explode';
      const maxLevel = parseInt(searchParams.get('max_level') || '10');
      const includeInactive = searchParams.get('include_inactive') === 'true';

      // WHERE-USED 조회의 경우 child_item_id 사용
      if (type === 'where-used') {
        if (!childItemId) {
          return NextResponse.json({
            success: false,
            error: 'child_item_id가 필요합니다'
          }, { status: 400 });
        }

        const whereUsedData = await getWhereUsed(null, parseInt(childItemId));

        return NextResponse.json({
          success: true,
          data: whereUsedData
        });
      }

      // 나머지 조회 유형은 parent_item_id 필요
      if (!parentItemId) {
        return NextResponse.json({
          success: false,
          error: 'parent_item_id가 필요합니다'
        }, { status: 400 });
      }

      const itemId = parseInt(parentItemId);

      switch (type) {
        case 'explode': {
          // BOM 전개 (평면 구조)
          const explodedBom = await explodeBom(null, itemId, 0, maxLevel, 1);

          // 평면 구조로 변환 (트리를 플랫하게)
          const flattenBom = (nodes: BOMNode[], result: BOMNode[] = []): BOMNode[] => {
            for (const node of nodes) {
              const { children, ...nodeData } = node;
              result.push(nodeData);
              if (children && children.length > 0) {
                flattenBom(children, result);
              }
            }
            return result;
          };

          const flatData = flattenBom(explodedBom);

          return NextResponse.json({
            success: true,
            data: flatData,
            summary: {
              total_items: flatData.length,
              max_level: Math.max(...flatData.map(item => item.level), 0),
              total_cost: flatData.reduce((sum, item) => sum + (item.total_price || 0), 0)
            }
          });
        }

        case 'tree': {
          // BOM 트리 구조
          const bomTree = await getBomTree(null, itemId, includeInactive);

          if (!bomTree) {
            return NextResponse.json({
              success: false,
              error: '품목을 찾을 수 없거나 BOM이 존재하지 않습니다'
            }, { status: 404 });
          }

          // 트리 통계 계산
          const calculateTreeStats = (node: BOMNode): TreeStats => {
            let totalItems = 1;
            let totalCost = node.total_price || 0;
            let maxLevel = node.level || 0;

            if (node.children && node.children.length > 0) {
              for (const child of node.children) {
                const childStats = calculateTreeStats(child);
                totalItems += childStats.totalItems;
                totalCost += childStats.totalCost;
                maxLevel = Math.max(maxLevel, childStats.maxLevel);
              }
            }

            return { totalItems, totalCost, maxLevel };
          };

          const stats = calculateTreeStats(bomTree);

          return NextResponse.json({
            success: true,
            data: bomTree,
            summary: {
              total_items: stats.totalItems,
              max_level: stats.maxLevel,
              total_cost: stats.totalCost
            }
          });
        }

        case 'cost': {
          // 총 원가 계산
          const totalCost = await calculateTotalCost(null, itemId);

          // 상위 품목 정보 조회
          const { data: itemData, error: itemError } = await supabaseAdmin
            .from('items')
            .select('item_code, item_name, spec, price')
            .eq('item_id', itemId)
            .single();

          if (itemError || !itemData) {
            return NextResponse.json({
              success: false,
              error: '품목을 찾을 수 없습니다'
            }, { status: 404 });
          }

          return NextResponse.json({
            success: true,
            data: {
              item: itemData,
              material_cost: totalCost,
              item_price: itemData.price || 0,
              margin: (itemData.price || 0) - totalCost,
              margin_rate: (itemData.price || 0) > 0
                ? (((itemData.price || 0) - totalCost) / (itemData.price || 0) * 100).toFixed(2) + '%'
                : '0%'
            }
          });
        }

        case 'summary': {
          // 레벨별 요약
          const levelSummary = await getBomLevelSummary(null, itemId);

          const totalSummary = levelSummary.reduce((acc, level) => ({
            total_items: acc.total_items + level.item_count,
            total_quantity: acc.total_quantity + level.total_quantity,
            total_cost: acc.total_cost + level.level_cost
          }), {
            total_items: 0,
            total_quantity: 0,
            total_cost: 0
          });

          return NextResponse.json({
            success: true,
            data: {
              levels: levelSummary,
              total: totalSummary
            }
          });
        }

        case 'validate': {
          // BOM 유효성 검사
          const validation = await validateBom(null, itemId);

          return NextResponse.json({
            success: true,
            data: validation
          });
        }

        default: {
          return NextResponse.json({
            success: false,
            error: `지원하지 않는 조회 유형입니다: ${type}`
          }, { status: 400 });
        }
      }

    } catch (error) {
      console.error('Error in BOM explode:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'BOM 처리 중 오류가 발생했습니다'
        },
        { status: 500 }
      );
    }
  },
  { resource: 'production', action: 'read' }
);

/**
 * POST /api/bom/explode
 * BOM 일괄 전개 (여러 품목 동시 조회)
 */
export const POST = protectRoute(
  async (request: NextRequest, _user) => {
    try {
      const text = await request.text();
      const body = JSON.parse(text);
      const { item_ids, type = 'explode', max_level = 10 } = body;

      if (!item_ids || !Array.isArray(item_ids) || item_ids.length === 0) {
        return NextResponse.json({
          success: false,
          error: 'item_ids 배열이 필요합니다'
        }, { status: 400 });
      }

      const results = [];

      for (const itemId of item_ids) {
        try {
          let itemResult;

          switch (type) {
            case 'explode': {
              const explodedBom = await explodeBom(null, itemId, 0, max_level, 1);
              itemResult = {
                item_id: itemId,
                success: true,
                data: explodedBom
              };
              break;
            }

            case 'cost': {
              const totalCost = await calculateTotalCost(null, itemId);
              itemResult = {
                item_id: itemId,
                success: true,
                cost: totalCost
              };
              break;
            }

            case 'validate': {
              const validation = await validateBom(null, itemId);
              itemResult = {
                item_id: itemId,
                success: true,
                validation
              };
              break;
            }

            default: {
              itemResult = {
                item_id: itemId,
                success: false,
                error: `지원하지 않는 조회 유형: ${type}`
              };
            }
          }

          results.push(itemResult);

        } catch (error) {
          results.push({
            item_id: itemId,
            success: false,
            error: `처리 실패: ${error}`
          });
        }
      }

      const successCount = results.filter(r => r.success).length;
      const failCount = results.length - successCount;

      return NextResponse.json({
        success: true,
        summary: {
          total: results.length,
          success: successCount,
          failed: failCount
        },
        data: results
      });

    } catch (error) {
      console.error('Error in batch BOM explode:', error);
      return NextResponse.json(
        {
          success: false,
          error: '일괄 BOM 처리 중 오류가 발생했습니다'
        },
        { status: 500 }
      );
    }
  },
  { resource: 'production', action: 'read' }
);
```


#### 📄 src\app\api\bom\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

/**
 * GET /api/bom
 * List BOM entries with filters
 * Query parameters:
 * - parent_item_id: Filter by parent item
 * - child_item_id: Filter by child item
 * - limit: Number of records to return (default: 100)
 * - offset: Pagination offset (default: 0)
 */
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const parentItemId = searchParams.get('parent_item_id');
    const childItemId = searchParams.get('child_item_id');
    const limit = parseInt(searchParams.get('limit') || '100');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('bom')
      .select(`
        *,
        parent_item:items!bom_parent_item_id_fkey(item_code, item_name, spec, unit),
        child_item:items!bom_child_item_id_fkey(item_code, item_name, spec, unit)
      `)
      .order('bom_id', { ascending: true });

    // Apply filters safely
    if (parentItemId) {
      query = query.eq('parent_item_id', parentItemId);
    }

    if (childItemId) {
      query = query.eq('child_item_id', childItemId);
    }

    // Apply pagination
    query = query.range(offset, offset + limit - 1);

    const { data: bomEntries, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Get total count for pagination (safe query)
    let countQuery = supabase
      .from('bom')
      .select('*', { count: 'exact', head: true });

    // Apply same filters for count
    if (parentItemId) {
      countQuery = countQuery.eq('parent_item_id', parentItemId);
    }

    if (childItemId) {
      countQuery = countQuery.eq('child_item_id', childItemId);
    }

    const { count: totalCount, error: countError } = await countQuery;

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    return NextResponse.json({
      success: true,
      data: {
        bomEntries: bomEntries || [],
        pagination: {
          total: totalCount || 0,
          limit,
          offset,
          hasMore: offset + limit < (totalCount || 0)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching BOM:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'BOM 조회에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/bom
 * Create new BOM entry
 * Body: {
 *   parent_item_id: number,
 *   child_item_id: number,
 *   quantity: number,
 *   level?: number,
 *   notes?: string
 * }
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const {
      parent_item_id,
      child_item_id,
      quantity,
      level = 1,
      notes
    } = body;

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // 필수 필드 검증
    if (!parent_item_id || !child_item_id || !quantity) {
      return NextResponse.json({
        success: false,
        error: '부모 품목, 자식 품목, 수량은 필수입니다.'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: '수량은 0보다 커야 합니다.'
      }, { status: 400 });
    }

    // Check if parent and child items exist
    const { data: parentItem, error: parentError } = await supabase
      .from('items')
      .select('item_id, item_name')
      .eq('item_id', parent_item_id)
      .single();

    if (parentError || !parentItem) {
      return NextResponse.json({
        success: false,
        error: '부모 품목을 찾을 수 없습니다.'
      }, { status: 404 });
    }

    const { data: childItem, error: childError } = await supabase
      .from('items')
      .select('item_id, item_name')
      .eq('item_id', child_item_id)
      .single();

    if (childError || !childItem) {
      return NextResponse.json({
        success: false,
        error: '자식 품목을 찾을 수 없습니다.'
      }, { status: 404 });
    }

    // Check for duplicate BOM entry
    const { data: existingBom, error: duplicateError } = await supabase
      .from('bom')
      .select('bom_id')
      .eq('parent_item_id', parent_item_id)
      .eq('child_item_id', child_item_id)
      .single();

    if (existingBom) {
      return NextResponse.json({
        success: false,
        error: '이미 존재하는 BOM 항목입니다.'
      }, { status: 400 });
    }

    // Create BOM entry using Supabase client
    const { data: bomEntry, error } = await supabase
      .from('bom')
      .insert({
        parent_item_id,
        child_item_id,
        quantity,
        level,
        notes,
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select(`
        *,
        parent_item:items!bom_parent_item_id_fkey(item_code, item_name, spec, unit),
        child_item:items!bom_child_item_id_fkey(item_code, item_name, spec, unit)
      `)
      .single();

    if (error) {
      throw new Error(`Database insert failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: 'BOM 항목이 성공적으로 등록되었습니다.',
      data: bomEntry
    });
  } catch (error) {
    console.error('Error creating BOM entry:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'BOM 등록에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * PUT /api/bom
 * Update existing BOM entry
 * Body: {
 *   bom_id: number,
 *   ... other fields to update
 * }
 */
export async function PUT(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const { bom_id, ...updateData } = body;

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    if (!bom_id) {
      return NextResponse.json({
        success: false,
        error: 'BOM ID가 필요합니다.'
      }, { status: 400 });
    }

    // Validate quantity if being updated
    if (updateData.quantity !== undefined && updateData.quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: '수량은 0보다 커야 합니다.'
      }, { status: 400 });
    }

    // Update BOM entry using Supabase client
    const { data: bomEntry, error } = await supabase
      .from('bom')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('bom_id', bom_id)
      .select(`
        *,
        parent_item:items!bom_parent_item_id_fkey(item_code, item_name, spec, unit),
        child_item:items!bom_child_item_id_fkey(item_code, item_name, spec, unit)
      `)
      .single();

    if (error) {
      throw new Error(`Database update failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: 'BOM 항목이 성공적으로 업데이트되었습니다.',
      data: bomEntry
    });
  } catch (error) {
    console.error('Error updating BOM entry:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'BOM 업데이트에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/bom
 * Delete BOM entry (soft delete)
 * Query parameter: id - BOM ID to delete
 */
export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get('id');

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'BOM ID가 필요합니다.'
      }, { status: 400 });
    }

    // Soft delete by setting is_active to false
    const { error } = await supabase
      .from('bom')
      .update({
        is_active: false,
        updated_at: new Date().toISOString()
      })
      .eq('bom_id', id);

    if (error) {
      throw new Error(`Database delete failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: 'BOM 항목이 성공적으로 삭제되었습니다.',
      data: { deleted_id: id }
    });
  } catch (error) {
    console.error('Error deleting BOM entry:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'BOM 삭제에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\companies\route.example.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db-unified';
import { Company } from '@/types/supabase';
import { protectRoute } from '@/lib/middleware';
import { withErrorHandler } from '@/middleware/error-handler';
import { createRateLimit, RATE_LIMIT_CONFIGS } from '@/middleware/rate-limit';
import { ERPError, ErrorCode, createSuccessResponse } from '@/lib/error-format';
import { buildPaginatedResponse, getPaginationFromSearchParams, parsePagination, buildPaginatedSQL } from '@/lib/pagination';

// Rate limiter for companies API
const companiesRateLimit = createRateLimit(RATE_LIMIT_CONFIGS.api);

export const GET = withErrorHandler(
  protectRoute(
    async (request: NextRequest, user) => {
      // Apply rate limiting
      const rateLimitResponse = await companiesRateLimit(request);
      if (rateLimitResponse) {
        return rateLimitResponse;
      }

      const searchParams = request.nextUrl.searchParams;
      const type = searchParams.get('type');
      const search = searchParams.get('search');

      // Get pagination parameters
      const paginationInput = getPaginationFromSearchParams(searchParams);
      const paginationParams = parsePagination(paginationInput, {
        page: 1,
        limit: 20,
        maxLimit: 100
      });

      let baseSql = `
        SELECT * FROM companies
        WHERE is_active = 1
      `;

      let countSql = `
        SELECT COUNT(*) as total FROM companies
        WHERE is_active = 1
      `;

      const params: unknown[] = [];

      if (type) {
        baseSql += ' AND company_type = ?';
        countSql += ' AND company_type = ?';
        params.push(type);
      }

      if (search) {
        baseSql += ' AND (company_name LIKE ? OR business_registration_no LIKE ? OR contact_person LIKE ? OR phone LIKE ? OR email LIKE ?)';
        countSql += ' AND (company_name LIKE ? OR business_registration_no LIKE ? OR contact_person LIKE ? OR phone LIKE ? OR email LIKE ?)';
        const searchPattern = `%${search}%`;
        params.push(searchPattern, searchPattern, searchPattern, searchPattern, searchPattern);
      }

      // Default order by company_name if no orderBy specified
      if (!paginationParams.orderBy) {
        paginationParams.orderBy = 'company_name ASC';
      }

      // Build paginated SQL
      const { dataSql } = buildPaginatedSQL(baseSql, countSql, paginationParams);

      // Execute both queries
      const [companies, countResult] = await Promise.all([
        query<Company[]>(dataSql, params),
        query<{ total: number }>(countSql, params)
      ]);

      const totalCount = countResult[0]?.total || 0;

      // Build paginated response
      const response = buildPaginatedResponse(companies, totalCount, {
        page: Math.max(1, Number(paginationInput.page) || 1),
        limit: paginationParams.limit
      });

      return NextResponse.json(
        createSuccessResponse(response, '회사 목록을 성공적으로 조회했습니다'),
        {
          headers: {
            'Content-Type': 'application/json; charset=utf-8'
          }
        }
      );
    },
    { resource: 'companies', action: 'read' }
  )
);

export const POST = withErrorHandler(
  protectRoute(
    async (request: NextRequest, user) => {
      // Apply rate limiting
      const rateLimitResponse = await companiesRateLimit(request);
      if (rateLimitResponse) {
        return rateLimitResponse;
      }

      // UTF-8 인코딩 처리를 위한 text 파싱 후 JSON 변환
      const text = await request.text();
      const body = JSON.parse(text);
      const {
        company_name,
        company_type,
        business_registration_no,
        contact_person,
        phone,
        mobile,
        email,
        address,
        payment_terms,
        contact_info,
        notes
      } = body;

      // 필수 필드 검증
      if (!company_name || !company_type) {
        throw ERPError.validation(
          '회사명과 회사유형은 필수 입력 항목입니다',
          !company_name ? 'company_name' : 'company_type',
          {
            field: !company_name ? 'company_name' : 'company_type',
            constraints: {
              required: true
            }
          }
        );
      }

      // company_type 유효성 검증 및 변환
      const typeMapping: { [key: string]: string } = {
        '고객사': '고객사',
        '공급사': '공급사',
        '협력사': '협력사',
        '기타': '기타',
        'CUSTOMER': '고객사',
        'SUPPLIER': '공급사',
        'PARTNER': '협력사',
        'OTHER': '기타'
      };

      const normalizedType = typeMapping[company_type];
      if (!normalizedType) {
        throw ERPError.validation(
          '회사유형은 고객사, 공급사, 협력사, 기타 또는 CUSTOMER, SUPPLIER, PARTNER, OTHER 중 하나여야 합니다',
          'company_type',
          {
            field: 'company_type',
            value: company_type,
            allowedValues: Object.keys(typeMapping)
          }
        );
      }

      // 중복 회사명 검증
      const existingCompany = await query<{ company_id: number }>(
        'SELECT company_id FROM companies WHERE company_name = ? AND is_active = 1',
        [company_name]
      );

      if (existingCompany.length > 0) {
        throw ERPError.duplicate('회사', 'company_name', company_name);
      }

      const sql = `
        INSERT INTO companies (
          company_name, company_type, business_registration_no,
          contact_person, phone, mobile, email, address,
          payment_terms, contact_info, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;

      const result = await query(sql, [
        company_name,
        normalizedType,
        business_registration_no || null,
        contact_person || null,
        phone || null,
        mobile || null,
        email || null,
        address || null,
        payment_terms || null,
        contact_info || null,
        notes || null
      ]);

      return NextResponse.json(
        createSuccessResponse(result, '회사가 성공적으로 생성되었습니다'),
        {
          headers: {
            'Content-Type': 'application/json; charset=utf-8'
          }
        }
      );
    },
    { resource: 'companies', action: 'create' }
  )
);

export const PUT = withErrorHandler(
  protectRoute(
    async (request: NextRequest, user) => {
      // Apply rate limiting
      const rateLimitResponse = await companiesRateLimit(request);
      if (rateLimitResponse) {
        return rateLimitResponse;
      }

      const body = await request.json();
      const { id, ...updateData } = body;

      if (!id) {
        throw ERPError.validation('회사 ID가 필요합니다', 'id');
      }

      // 회사 존재 여부 확인
      const existingCompany = await query<{ company_id: number }>(
        'SELECT company_id FROM companies WHERE company_id = ? AND is_active = 1',
        [id]
      );

      if (existingCompany.length === 0) {
        throw ERPError.notFound('회사', id, 'update');
      }

      // company_type 유효성 검증 및 변환 (포함된 경우에만)
      if (updateData.company_type) {
        const typeMapping: { [key: string]: string } = {
          '고객사': '고객사',
          '공급사': '공급사',
          '협력사': '협력사',
          '기타': '기타',
          'CUSTOMER': '고객사',
          'SUPPLIER': '공급사',
          'PARTNER': '협력사',
          'OTHER': '기타'
        };

        const normalizedType = typeMapping[updateData.company_type];
        if (!normalizedType) {
          throw ERPError.validation(
            '회사유형은 고객사, 공급사, 협력사, 기타 또는 CUSTOMER, SUPPLIER, PARTNER, OTHER 중 하나여야 합니다',
            'company_type',
            {
              field: 'company_type',
              value: updateData.company_type,
              allowedValues: Object.keys(typeMapping)
            }
          );
        }

        // 정규화된 타입으로 교체
        updateData.company_type = normalizedType;
      }

      // 회사명 중복 검증 (변경하는 경우)
      if (updateData.company_name) {
        const duplicateCompany = await query<{ company_id: number }>(
          'SELECT company_id FROM companies WHERE company_name = ? AND company_id != ? AND is_active = 1',
          [updateData.company_name, id]
        );

        if (duplicateCompany.length > 0) {
          throw ERPError.duplicate('회사', 'company_name', updateData.company_name);
        }
      }

      const updateFields = Object.keys(updateData)
        .map(key => `${key} = ?`)
        .join(', ');

      const sql = `UPDATE companies SET ${updateFields} WHERE company_id = ?`;
      const values = [...Object.values(updateData), id];

      const result = await query(sql, values);

      return NextResponse.json(
        createSuccessResponse(result, '회사가 성공적으로 수정되었습니다')
      );
    },
    { resource: 'companies', action: 'update' }
  )
);

export const DELETE = withErrorHandler(
  protectRoute(
    async (request: NextRequest, user) => {
      // Apply rate limiting
      const rateLimitResponse = await companiesRateLimit(request);
      if (rateLimitResponse) {
        return rateLimitResponse;
      }

      const searchParams = request.nextUrl.searchParams;
      const id = searchParams.get('id');

      if (!id) {
        throw ERPError.validation('회사 ID가 필요합니다', 'id');
      }

      // 회사 존재 여부 확인
      const existingCompany = await query<{ company_id: number }>(
        'SELECT company_id FROM companies WHERE company_id = ? AND is_active = 1',
        [id]
      );

      if (existingCompany.length === 0) {
        throw ERPError.notFound('회사', id, 'delete');
      }

      // 재고 거래 이력이 있는지 확인
      const hasTransactions = await query<{ count: number }>(
        'SELECT COUNT(*) as count FROM inventory_transactions WHERE company_id = ?',
        [id]
      );

      if (hasTransactions[0]?.count > 0) {
        throw ERPError.businessRule(
          '거래 이력이 있는 회사는 삭제할 수 없습니다',
          {
            rule: 'cannot_delete_company_with_transactions',
            entity: 'company',
            entityId: id,
            conflictingData: { transaction_count: hasTransactions[0].count }
          }
        );
      }

      // Soft delete
      const sql = `UPDATE companies SET is_active = 0 WHERE company_id = ?`;
      const result = await query(sql, [id]);

      return NextResponse.json(
        createSuccessResponse(result, '회사가 성공적으로 삭제되었습니다')
      );
    },
    { resource: 'companies', action: 'delete' }
  )
);
```


#### 📄 src\app\api\companies\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

/**
 * GET /api/companies
 * List companies with filters
 * Query parameters:
 * - type: Filter by company type
 * - search: Search in company name, business registration number, contact person, phone, email
 * - limit: Number of records to return (default: 20)
 * - offset: Pagination offset (default: 0)
 */
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type');
    const search = searchParams.get('search');
    const limit = parseInt(searchParams.get('limit') || '20');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('companies')
      .select('*')
      .order('company_name', { ascending: true });

    // Apply filters safely
    if (type) {
      query = query.eq('company_type', type);
    }

    if (search) {
      query = query.or(`company_name.ilike.%${search}%,business_registration_no.ilike.%${search}%,contact_person.ilike.%${search}%,phone.ilike.%${search}%,email.ilike.%${search}%`);
    }

    // Apply pagination
    query = query.range(offset, offset + limit - 1);

    const { data: companies, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Get total count for pagination (safe query)
    let countQuery = supabase
      .from('companies')
      .select('*', { count: 'exact', head: true });

    // Apply same filters for count
    if (type) {
      countQuery = countQuery.eq('company_type', type);
    }

    if (search) {
      countQuery = countQuery.or(`company_name.ilike.%${search}%,business_registration_no.ilike.%${search}%,contact_person.ilike.%${search}%,phone.ilike.%${search}%,email.ilike.%${search}%`);
    }

    const { count: totalCount, error: countError } = await countQuery;

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    return NextResponse.json({
      success: true,
      data: {
        data: companies || [],
        meta: {
          limit,
          totalCount: totalCount || 0,
          totalPages: Math.ceil((totalCount || 0) / limit),
          hasNext: offset + limit < (totalCount || 0),
          hasPrev: offset > 0
        },
        pagination: {
          limit,
          totalCount: totalCount || 0,
          totalPages: Math.ceil((totalCount || 0) / limit),
          hasNext: offset + limit < (totalCount || 0),
          hasPrev: offset > 0
        }
      }
    });
  } catch (error) {
    console.error('Error fetching companies:', error);
    return NextResponse.json(
      {
        success: false,
        error: '거래처 목록 조회에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/companies
 * Create new company
 * Body: {
 *   company_name: string,
 *   company_type: string,
 *   business_registration_no?: string,
 *   contact_person?: string,
 *   phone?: string,
 *   email?: string,
 *   address?: string,
 *   notes?: string
 * }
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const {
      company_name,
      company_type,
      business_registration_no,
      contact_person,
      phone,
      email,
      address,
      notes
    } = body;

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // 필수 필드 검증
    if (!company_name || !company_type) {
      return NextResponse.json({
        success: false,
        error: '회사명과 회사 유형은 필수입니다.'
      }, { status: 400 });
    }

    // Create company using Supabase client
    const { data: company, error } = await supabase
      .from('companies')
      .insert({
        company_name,
        company_type,
        business_registration_no,
        contact_person,
        phone,
        email,
        address,
        notes,
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Database insert failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: '거래처가 성공적으로 등록되었습니다.',
      data: company
    });
  } catch (error) {
    console.error('Error creating company:', error);
    return NextResponse.json(
      {
        success: false,
        error: '거래처 등록에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * PUT /api/companies
 * Update existing company
 * Body: {
 *   company_id: number,
 *   ... other fields to update
 * }
 */
export async function PUT(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const { company_id, ...updateData } = body;

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    if (!company_id) {
      return NextResponse.json({
        success: false,
        error: '회사 ID가 필요합니다.'
      }, { status: 400 });
    }

    // Update company using Supabase client
    const { data: company, error } = await supabase
      .from('companies')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('company_id', company_id)
      .select()
      .single();

    if (error) {
      throw new Error(`Database update failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: '거래처가 성공적으로 업데이트되었습니다.',
      data: company
    });
  } catch (error) {
    console.error('Error updating company:', error);
    return NextResponse.json(
      {
        success: false,
        error: '거래처 업데이트에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/companies
 * Delete company (soft delete)
 * Query parameter: id - Company ID to delete
 */
export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get('id');

    // Initialize Supabase client
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    if (!id) {
      return NextResponse.json({
        success: false,
        error: '회사 ID가 필요합니다.'
      }, { status: 400 });
    }

    // Soft delete by setting is_active to false
    const { error } = await supabase
      .from('companies')
      .update({
        is_active: false,
        updated_at: new Date().toISOString()
      })
      .eq('company_id', id);

    if (error) {
      throw new Error(`Database delete failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      message: '거래처가 성공적으로 삭제되었습니다.',
      data: { deleted_id: id }
    });
  } catch (error) {
    console.error('Error deleting company:', error);
    return NextResponse.json(
      {
        success: false,
        error: '거래처 삭제에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\dashboard\alerts\route.ts

```typescript
/**
 * Dashboard Alerts API Route
 * Provides alert notifications and recent activity
 */

import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
import type { Database } from '@/types/supabase';

type ItemRow = Database['public']['Tables']['items']['Row'];
type TransactionRow = Database['public']['Tables']['inventory_transactions']['Row'];
type TransactionWithItem = TransactionRow & {
  items: { item_name: string | null };
};

type LowStockStatus = '위험' | '경고' | '정상';

type LowStockItem = {
  item_id: number;
  item_code: string | null;
  item_name: string | null;
  current_stock: number;
  minimum_stock: number;
  status: LowStockStatus;
};

type RecentTransaction = {
  transaction_id: number;
  transaction_type: Database['public']['Enums']['transaction_type'] | null;
  quantity: number | null;
  transaction_date: string;
  item_name: string | null;
  status: '처리중' | '완료';
};

function calculateLowStockStatus(current: number, safety: number): LowStockStatus {
  if (safety <= 0) {
    return '정상';
  }

  const ratio = safety > 0 ? current / safety : Number.POSITIVE_INFINITY;

  if (ratio < 0.5) {
    return '위험';
  }

  if (ratio < 1) {
    return '경고';
  }

  return '정상';
}

export async function GET() {
  try {
    const { data: allItems, error: itemsError } = await supabaseAdmin
      .from('items')
      .select('item_id, item_code, item_name, current_stock, safety_stock')
      .eq('is_active', true)
      .gt('safety_stock', 0)
      .order('current_stock', { ascending: true });

    if (itemsError) {
      throw itemsError;
    }

    const safeItems = (allItems ?? []) as ItemRow[];

    const lowStockCandidates = safeItems
      .filter((item) => {
        const current = item.current_stock ?? 0;
        const safety = item.safety_stock ?? 0;
        return safety > 0 && current < safety;
      })
      .slice(0, 50)
      .map((item) => {
        const current = item.current_stock ?? 0;
        const safety = item.safety_stock ?? 0;
        const coverage = safety > 0 ? current / safety : Number.POSITIVE_INFINITY;
        const status = calculateLowStockStatus(current, safety);

        return {
          item_id: item.item_id,
          item_code: item.item_code ?? null,
          item_name: item.item_name ?? null,
          current_stock: current,
          minimum_stock: safety,
          status,
          coverage,
        };
      });

    const sortedLowStock = lowStockCandidates
      .sort((a, b) => {
        if (a.coverage !== b.coverage) {
          return a.coverage - b.coverage;
        }
        return a.current_stock - b.current_stock;
      })
      .map((candidate) => {
        const { coverage, ...rest } = candidate;
        void coverage;
        return rest;
      })
      .filter((item) => item.status === '위험' || item.status === '경고');

    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const sevenDaysAgoISO = sevenDaysAgo.toISOString();

    const { data: transactionsData, error: transactionsError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_id, transaction_type, quantity, transaction_date, item_id, items!inner(item_name)')
      .gte('transaction_date', sevenDaysAgoISO)
      .order('transaction_date', { ascending: false })
      .limit(20);

    if (transactionsError) {
      throw transactionsError;
    }

    const oneHourAgo = new Date();
    oneHourAgo.setHours(oneHourAgo.getHours() - 1);

    const recentTransactions = (transactionsData ?? [])
      .map((transaction) => transaction as TransactionWithItem)
      .map<RecentTransaction>((transaction) => {
        const transactionDate = transaction.transaction_date ?? new Date().toISOString();
        const status = new Date(transactionDate) >= oneHourAgo ? '처리중' : '완료';

        return {
          transaction_id: transaction.transaction_id,
          transaction_type: transaction.transaction_type,
          quantity: transaction.quantity,
          transaction_date: transactionDate,
          item_name: transaction.items?.item_name ?? null,
          status,
        };
      });

    const alertData = {
      lowStockItems: sortedLowStock,
      recentTransactions,
    };

    return NextResponse.json({
      success: true,
      data: alertData,
    });
  } catch (error) {
    console.error('Dashboard alerts API error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch alert data',
      },
      { status: 500 }
    );
  }
}

```


#### 📄 src\app\api\dashboard\charts\route.ts

```typescript
/**
 * Dashboard Charts API Route
 * Provides chart data for visualizations
 */

import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
import type { Database } from '@/types/supabase';

type ItemRow = Database['public']['Tables']['items']['Row'];
type InventoryTransactionRow = Database['public']['Tables']['inventory_transactions']['Row'];
type TransactionType = Database['public']['Enums']['transaction_type'];

type StockChartDatum = {
  name: string;
  현재고: number;
  안전재고: number;
  code: string;
};

type DailyAggregate = {
  date: string;
  입고: number;
  출고: number;
  조정: number;
};

type MonthlyAggregate = {
  month: string;
  입고: number;
  출고: number;
  조정: number;
};

const DAILY_RELEVANT_TYPES: ReadonlyArray<TransactionType> = ['입고', '출고', '생산입고', '생산출고'];
const MONTHLY_RELEVANT_TYPES: ReadonlyArray<TransactionType> = DAILY_RELEVANT_TYPES;

function formatKoreanDate(date: string | Date): string {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function formatKoreanMonth(date: string | Date): string {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = d.getMonth() + 1;
  return `${year}년 ${month}월`;
}

function isRelevantTransaction(type: TransactionType): boolean {
  return DAILY_RELEVANT_TYPES.includes(type);
}

function applyTransaction(quantity: number, type: TransactionType, target: DailyAggregate | MonthlyAggregate) {
  switch (type) {
    case '입고':
      target.입고 += quantity;
      break;
    case '출고':
      target.출고 += quantity;
      break;
    case '생산입고':
    case '생산출고':
      target.조정 += quantity;
      break;
    default:
      break;
  }
}

export async function GET() {
  try {
    const { data: stockItems, error: stockError } = await supabaseAdmin
      .from('items')
      .select('item_id, item_code, item_name, current_stock, safety_stock')
      .eq('is_active', true)
      .order('current_stock', { ascending: true });

    if (stockError) {
      throw new Error(`Failed to fetch stock data: ${stockError.message}`);
    }

    const safeStockItems = (stockItems ?? []) as ItemRow[];

    const filteredStockItems = safeStockItems
      .filter((item) => {
        const safetyStock = item.safety_stock ?? 0;
        const currentStock = item.current_stock ?? 0;
        return currentStock < safetyStock * 2 || safetyStock > 0;
      })
      .map((item) => {
        const safetyStock = item.safety_stock ?? 0;
        const currentStock = item.current_stock ?? 0;
        const ratio = safetyStock > 0 ? currentStock / safetyStock : Number.POSITIVE_INFINITY;
        return { ...item, ratio };
      })
      .sort((a, b) => a.ratio - b.ratio)
      .slice(0, 20);

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const thirtyDaysAgoISO = thirtyDaysAgo.toISOString();

    const { data: dailyTransactionsData, error: dailyError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_date, transaction_type, quantity')
      .gte('transaction_date', thirtyDaysAgoISO)
      .order('transaction_date', { ascending: false });

    if (dailyError) {
      throw new Error(`Failed to fetch daily transactions: ${dailyError.message}`);
    }

    const twelveMonthsAgo = new Date();
    twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);
    const twelveMonthsAgoISO = twelveMonthsAgo.toISOString();

    const { data: monthlyTransactionsData, error: monthlyError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_date, transaction_type, quantity')
      .gte('transaction_date', twelveMonthsAgoISO)
      .order('transaction_date', { ascending: false });

    if (monthlyError) {
      throw new Error(`Failed to fetch monthly transactions: ${monthlyError.message}`);
    }

    const dailyTransactions = (dailyTransactionsData ?? []) as InventoryTransactionRow[];
    const monthlyTransactions = (monthlyTransactionsData ?? []) as InventoryTransactionRow[];

    const stocks: StockChartDatum[] = filteredStockItems.map((item) => ({
      name: item.item_name ?? item.item_code ?? '미상',
      현재고: item.current_stock ?? 0,
      안전재고: item.safety_stock ?? 0,
      code: item.item_code ?? ''
    }));

    const transactionsByDate = dailyTransactions.reduce<Record<string, DailyAggregate>>((acc, transaction) => {
      const { transaction_type: type, quantity } = transaction;
      if (!type || !isRelevantTransaction(type)) {
        return acc;
      }

      const transactionDate = transaction.transaction_date ?? new Date().toISOString();
      const dateStr = formatKoreanDate(transactionDate);
      const safeQuantity = Number(quantity ?? 0);

      if (!acc[dateStr]) {
        acc[dateStr] = { date: dateStr, 입고: 0, 출고: 0, 조정: 0 };
      }

      applyTransaction(safeQuantity, type, acc[dateStr]);
      return acc;
    }, {});

    const transactions = Object.values(transactionsByDate)
      .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
      .slice(-14);

    const monthlyByMonth = monthlyTransactions.reduce<Record<string, MonthlyAggregate>>((acc, transaction) => {
      const { transaction_type: type, quantity } = transaction;
      if (!type || !MONTHLY_RELEVANT_TYPES.includes(type)) {
        return acc;
      }

      const transactionDate = transaction.transaction_date ?? new Date().toISOString();
      const monthKey = formatKoreanMonth(transactionDate);
      const safeQuantity = Number(quantity ?? 0);

      if (!acc[monthKey]) {
        acc[monthKey] = { month: monthKey, 입고: 0, 출고: 0, 조정: 0 };
      }

      applyTransaction(safeQuantity, type, acc[monthKey]);
      return acc;
    }, {});

    const monthPattern = /(?<year>\d{4})년\s+(?<month>\d{1,2})월/;

    const monthlyTrends = Object.values(monthlyByMonth)
      .sort((a, b) => {
        const aMatch = monthPattern.exec(a.month);
        const bMatch = monthPattern.exec(b.month);
        if (!aMatch || !bMatch) {
          return 0;
        }

        const aYear = Number(aMatch.groups!.year);
        const aMonth = Number(aMatch.groups!.month);
        const bYear = Number(bMatch.groups!.year);
        const bMonth = Number(bMatch.groups!.month);

        if (aYear !== bYear) {
          return aYear - bYear;
        }

        return aMonth - bMonth;
      })
      .slice(-12);

    const chartData = {
      stocks,
      transactions,
      monthlyTrends,
    };

    return NextResponse.json({
      success: true,
      data: chartData,
    });
  } catch (error) {
    console.error('Dashboard charts API error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch chart data',
      },
      { status: 500 }
    );
  }
}

```


#### 📄 src\app\api\dashboard\stats\route.ts

```typescript
/**
 * Dashboard Stats API Route
 * Provides KPI statistics and metrics
 */

import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
import { createValidatedRoute } from '@/lib/validationMiddleware';
import { calculateKPIs } from '@/utils/chartUtils';

export const GET = createValidatedRoute(
  async () => {
    try {
      const threeMonthsAgo = new Date();
      threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
      const threeMonthsAgoISO = threeMonthsAgo.toISOString();

      const [itemsResult, transactionsResult, companiesResult] = await Promise.all([
        supabaseAdmin
          .from('items')
          .select('item_id, item_code, item_name, current_stock, safety_stock, is_active')
          .eq('is_active', true),
        supabaseAdmin
          .from('inventory_transactions')
          .select('transaction_id, transaction_type, quantity, transaction_date, item_id')
          .gte('transaction_date', threeMonthsAgoISO)
          .order('transaction_date', { ascending: false }),
        supabaseAdmin
          .from('companies')
          .select('company_id, company_name, company_type, is_active')
          .eq('is_active', true),
      ]);

      if (itemsResult.error) throw itemsResult.error;
      if (transactionsResult.error) throw transactionsResult.error;
      if (companiesResult.error) throw companiesResult.error;

      const items = itemsResult.data ?? [];
      const transactions = transactionsResult.data ?? [];
      const companies = companiesResult.data ?? [];

      const kpis = calculateKPIs({
        items,
        transactions,
        companies,
      });

      const now = new Date();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      const previousMonth = currentMonth === 0 ? 11 : currentMonth - 1;
      const previousYear = currentMonth === 0 ? currentYear - 1 : currentYear;

      const currentMonthTransactions = transactions.filter((transaction) => {
        const date = new Date(transaction.transaction_date);
        return date.getMonth() === currentMonth && date.getFullYear() === currentYear;
      });

      const previousMonthTransactions = transactions.filter((transaction) => {
        const date = new Date(transaction.transaction_date);
        return date.getMonth() === previousMonth && date.getFullYear() === previousYear;
      });

      const currentVolume = currentMonthTransactions.reduce((sum, t) => sum + (t.quantity ?? 0), 0);
      const previousVolume = previousMonthTransactions.reduce((sum, t) => sum + (t.quantity ?? 0), 0);
      const volumeChange = previousVolume > 0 ? ((currentVolume - previousVolume) / previousVolume) * 100 : 0;

      const itemTrend = Math.random() * 10 - 5;
      const companyTrend = Math.random() * 6 - 3;
      const lowStockTrend = Math.random() * 8 - 4;

      const stats = {
        totalItems: kpis.totalItems,
        activeCompanies: kpis.activeCompanies,
        monthlyVolume: kpis.monthlyVolume,
        lowStockItems: kpis.lowStockItems,
        volumeChange,
        trends: {
          items: itemTrend,
          companies: companyTrend,
          volume: volumeChange,
          lowStock: lowStockTrend,
        },
      };

      return NextResponse.json({
        success: true,
        data: stats,
      });
    } catch (error) {
      console.error('Dashboard stats API error:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to fetch dashboard statistics',
        },
        { status: 500 }
      );
    }
  },
  {
    resource: 'dashboard',
    action: 'read',
    requireAuth: false,
  }
);

```


#### 📄 src\app\api\download\template\companies\route.ts

```typescript
import { NextResponse } from 'next/server';
import * as XLSX from 'xlsx';

export async function GET() {
  try {
    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();

    // Define column headers in Korean
    const headers = [
      '거래처명',
      '거래처구분',
      '사업자번호',
      '대표자',
      '연락처',
      '이메일',
      '주소',
      '메모'
    ];

    // Sample data rows
    const sampleData = [
      [
        '한국자동차부품(주)',
        '공급사',
        '123-45-67890',
        '김철수',
        '02-1234-5678',
        'contact@koreaparts.com',
        '서울시 강남구 테헤란로 123',
        '주요 브레이크 부품 공급업체'
      ],
      [
        '현대모터스',
        '고객사',
        '987-65-43210',
        '이영희',
        '031-987-6543',
        'orders@hyundaimotors.co.kr',
        '경기도 화성시 현대로 456',
        'OEM 고객사, 월 정기 주문'
      ],
      [
        '대성물류센터',
        '협력사',
        '555-44-33221',
        '박민수',
        '032-555-4433',
        'logistics@daesung.co.kr',
        '인천시 연수구 물류단지로 789',
        '물류 및 배송 협력업체'
      ]
    ];

    // Combine headers and sample data
    const worksheetData = [headers, ...sampleData];

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

    // Set column widths for better readability
    const columnWidths = [
      { wch: 20 }, // 거래처명
      { wch: 12 }, // 거래처구분
      { wch: 15 }, // 사업자번호
      { wch: 12 }, // 대표자
      { wch: 15 }, // 연락처
      { wch: 25 }, // 이메일
      { wch: 35 }, // 주소
      { wch: 25 }  // 메모
    ];
    worksheet['!cols'] = columnWidths;

    // Create a validation rules sheet
    const validationSheet = XLSX.utils.aoa_to_sheet([
      ['데이터 검증 규칙'],
      [''],
      ['거래처구분 허용값:'],
      ['- 고객사'],
      ['- 공급사'],
      ['- 협력사'],
      ['- 기타'],
      [''],
      ['주의사항:'],
      ['1. 거래처명은 필수 입력입니다'],
      ['2. 거래처구분은 위의 4가지 값 중 하나여야 합니다'],
      ['3. 사업자번호는 "000-00-00000" 형식으로 입력하세요'],
      ['4. 이메일은 올바른 이메일 형식이어야 합니다']
    ]);

    // Set column width for validation sheet
    validationSheet['!cols'] = [{ wch: 40 }];

    // Add worksheets to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, '거래처템플릿');
    XLSX.utils.book_append_sheet(workbook, validationSheet, '입력규칙');

    // Generate Excel buffer
    const excelBuffer = XLSX.write(workbook, {
      type: 'array',
      bookType: 'xlsx'
    });

    // Convert to Uint8Array to handle binary data properly
    const uint8Array = new Uint8Array(excelBuffer);

    // Set response headers for file download
    return new NextResponse(uint8Array, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': 'attachment; filename="companies_template.xlsx"; filename*=UTF-8\'\'%EA%B1%B0%EB%9E%98%EC%B2%98_%ED%85%9C%ED%94%8C%EB%A6%BF.xlsx',
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      }
    });

  } catch (error) {
    console.error('Error generating companies template:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Excel 템플릿 생성에 실패했습니다'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\download\template\items\route.ts

```typescript
import { NextResponse } from 'next/server';
import * as XLSX from 'xlsx';

export async function GET() {
  try {
    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();

    // Define column headers in Korean
    const headers = [
      '품목코드',
      '품목명',
      '차종',
      '규격',
      '타입',
      '단위',
      '단가',
      '최소재고'
    ];

    // Sample data rows
    const sampleData = [
      [
        'PT001',
        '브레이크 패드',
        '소나타',
        '250mm x 120mm x 15mm',
        '완제품',
        'EA',
        25000,
        10
      ],
      [
        'MT002',
        '엔진 마운트',
        '아반떼',
        '고무 타입 A',
        '부품',
        'EA',
        45000,
        5
      ],
      [
        'FL003',
        '에어 필터',
        '그랜저',
        '300mm x 200mm',
        '소모품',
        'EA',
        15000,
        20
      ]
    ];

    // Combine headers and sample data
    const worksheetData = [headers, ...sampleData];

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

    // Set column widths for better readability
    worksheet['!cols'] = [
      { wch: 12 }, // 품목코드
      { wch: 18 }, // 품목명
      { wch: 12 }, // 차종
      { wch: 20 }, // 규격
      { wch: 12 }, // 타입
      { wch: 8 },  // 단위
      { wch: 12 }, // 단가
      { wch: 12 }  // 최소재고
    ];

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, '품목템플릿');

    // Generate Excel buffer
    const excelBuffer = XLSX.write(workbook, {
      type: 'array',
      bookType: 'xlsx'
    });

    // Convert to Uint8Array to handle binary data properly
    const uint8Array = new Uint8Array(excelBuffer);

    // Set response headers for file download
    return new NextResponse(uint8Array, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': 'attachment; filename="items_template.xlsx"; filename*=UTF-8\'\'%ED%92%88%EB%AA%A9_%ED%85%9C%ED%94%8C%EB%A6%BF.xlsx',
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      }
    });

  } catch (error) {
    console.error('Error generating items template:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Excel 템플릿 생성에 실패했습니다'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\export\companies\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import * as XLSX from 'xlsx';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type');
    const search = searchParams.get('search');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('companies')
      .select(`
        company_id,
        company_name,
        company_type,
        business_registration_no,
        contact_person,
        phone,
        mobile,
        email,
        address,
        payment_terms,
        contact_info,
        notes,
        is_active,
        created_at,
        updated_at
      `)
      .eq('is_active', true);

    // Apply filters safely
    if (type) {
      // Support both Korean and English types
      if (type === 'CUSTOMER' || type === '고객사') {
        query = query.in('company_type', ['CUSTOMER', '고객사']);
      } else if (type === 'SUPPLIER' || type === '공급사') {
        query = query.in('company_type', ['SUPPLIER', '공급사']);
      } else {
        query = query.eq('company_type', type);
      }
    }

    if (search) {
      query = query.or(`company_name.ilike.%${search}%,contact_person.ilike.%${search}%,business_registration_no.ilike.%${search}%`);
    }

    // Apply ordering
    query = query.order('company_name', { ascending: true });

    const { data: companies, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to match expected format for Excel export
    const formattedCompanies = companies?.map((company: any) => ({
      "회사ID": company.company_id,
      "회사명": company.company_name,
      "회사구분": company.company_type === 'CUSTOMER' || company.company_type === '고객사' ? '고객사' : 
                 company.company_type === 'SUPPLIER' || company.company_type === '공급사' ? '공급사' : company.company_type,
      "사업자번호": company.business_registration_no,
      "담당자": company.contact_person,
      "전화번호": company.phone,
      "휴대폰": company.mobile,
      "이메일": company.email,
      "주소": company.address,
      "결제조건": company.payment_terms,
      "연락처정보": company.contact_info,
      "비고": company.notes,
      "상태": company.is_active ? '활성' : '비활성',
      "등록일시": new Date(company.created_at).toLocaleString('ko-KR'),
      "수정일시": new Date(company.updated_at).toLocaleString('ko-KR')
    })) || [];

    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(formattedCompanies);

    // Set column widths for better formatting
    const columnWidths = [
      { wch: 10 }, // 회사ID
      { wch: 25 }, // 회사명
      { wch: 10 }, // 회사구분
      { wch: 15 }, // 사업자번호
      { wch: 15 }, // 담당자
      { wch: 15 }, // 전화번호
      { wch: 15 }, // 휴대폰
      { wch: 25 }, // 이메일
      { wch: 30 }, // 주소
      { wch: 15 }, // 결제조건
      { wch: 20 }, // 연락처정보
      { wch: 25 }, // 비고
      { wch: 10 }, // 상태
      { wch: 18 }, // 등록일시
      { wch: 18 }  // 수정일시
    ];
    worksheet['!cols'] = columnWidths;

    // Add metadata sheet
    const metadataRows = [
      ['내보내기 정보', ''],
      ['내보낸 날짜', new Date().toLocaleString('ko-KR')],
      ['총 회사 수', companies.length],
      ['필터', ''],
      ['회사구분', type || '전체'],
      ['검색어', search || '없음'],
      ['', ''],
      ['태창 ERP 시스템', '회사 목록 내보내기']
    ];

    const metadataSheet = XLSX.utils.aoa_to_sheet(metadataRows);
    metadataSheet['!cols'] = [{ wch: 15 }, { wch: 25 }];

    // Add summary statistics
    const customerCount = companies.filter((c: any) => c['회사구분'] === '고객사').length;
    const supplierCount = companies.filter((c: any) => c['회사구분'] === '공급사').length;

    const statsRows = [
      ['통계 정보', ''],
      ['총 회사 수', companies.length],
      ['고객사 수', customerCount],
      ['공급사 수', supplierCount],
      ['기타', companies.length - customerCount - supplierCount],
      ['', ''],
      ['활성 회사', companies.filter((c: any) => c['상태'] === '활성').length],
      ['비활성 회사', companies.filter((c: any) => c['상태'] === '비활성').length]
    ];

    const statsSheet = XLSX.utils.aoa_to_sheet(statsRows);
    statsSheet['!cols'] = [{ wch: 15 }, { wch: 15 }];

    // Add sheets to workbook
    XLSX.utils.book_append_sheet(workbook, metadataSheet, '내보내기 정보');
    XLSX.utils.book_append_sheet(workbook, statsSheet, '통계');
    XLSX.utils.book_append_sheet(workbook, worksheet, '회사 목록');

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx'
    });

    // Create filename with current date
    const currentDate = new Date().toISOString().split('T')[0];
    const filename = `회사목록_${currentDate}.xlsx`;

    // Return Excel file
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${encodeURIComponent(filename)}"`,
        'Content-Length': excelBuffer.length.toString()
      }
    });

  } catch (error) {
    console.error('Error exporting companies:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to export companies to Excel'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\export\inventory\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import * as XLSX from 'xlsx';
import { mapEnglishToKorean, inventoryMapping } from '@/lib/import-map';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type');
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');
    const itemId = searchParams.get('item_id');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_date,
        transaction_type,
        quantity,
        unit_price,
        total_amount,
        from_location,
        to_location,
        warehouse_from,
        warehouse_to,
        lot_no,
        expiry_date,
        reference_no,
        reference_id,
        notes,
        created_at,
        items!left(item_code, item_name, spec, unit),
        companies!left(company_name),
        users!left(full_name)
      `);

    // Apply filters safely
    if (type) {
      query = query.eq('transaction_type', type);
    }

    if (startDate) {
      query = query.gte('transaction_date', startDate);
    }

    if (endDate) {
      query = query.lte('transaction_date', endDate);
    }

    if (itemId) {
      query = query.eq('item_id', parseInt(itemId));
    }

    // Apply ordering
    query = query
      .order('transaction_date', { ascending: false })
      .order('transaction_id', { ascending: false });

    const { data: transactions, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to match expected format for Excel export
    const formattedTransactions = transactions?.map((t: any) => ({
      "거래ID": t.transaction_id,
      "거래일시": new Date(t.transaction_date).toLocaleString('ko-KR'),
      "거래유형": t.transaction_type,
      "품목코드": t.items?.item_code,
      "품목명": t.items?.item_name,
      "규격": t.items?.spec,
      "수량": t.quantity,
      "단위": t.items?.unit,
      "단가": t.unit_price,
      "총금액": t.total_amount,
      "거래처명": t.companies?.company_name,
      "출발위치": t.from_location,
      "도착위치": t.to_location,
      "출발창고": t.warehouse_from,
      "도착창고": t.warehouse_to,
      "LOT번호": t.lot_no,
      "만료일": t.expiry_date ? new Date(t.expiry_date).toLocaleDateString('ko-KR') : '',
      "참조번호": t.reference_no,
      "참조ID": t.reference_id,
      "처리자": t.users?.full_name,
      "비고": t.notes,
      "등록일시": new Date(t.created_at).toLocaleString('ko-KR')
    })) || [];

    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(formattedTransactions);

    // Set column widths for better formatting
    const columnWidths = [
      { wch: 10 }, // 거래ID
      { wch: 18 }, // 거래일시
      { wch: 10 }, // 거래유형
      { wch: 15 }, // 품목코드
      { wch: 25 }, // 품목명
      { wch: 20 }, // 규격
      { wch: 10 }, // 수량
      { wch: 8 },  // 단위
      { wch: 12 }, // 단가
      { wch: 15 }, // 총금액
      { wch: 20 }, // 거래처명
      { wch: 15 }, // 출발위치
      { wch: 15 }, // 도착위치
      { wch: 15 }, // 출발창고
      { wch: 15 }, // 도착창고
      { wch: 15 }, // LOT번호
      { wch: 12 }, // 만료일
      { wch: 15 }, // 참조번호
      { wch: 15 }, // 참조ID
      { wch: 15 }, // 처리자
      { wch: 25 }, // 비고
      { wch: 18 }  // 등록일시
    ];
    worksheet['!cols'] = columnWidths;

    // Calculate statistics
    const totalTransactions = transactions.length;
    const transactionsByType = transactions.reduce((acc: any, t: any) => {
      const type = t['거래유형'];
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const totalQuantity = transactions.reduce((sum: any, t: any) => sum + (t['수량'] || 0), 0);
    const totalAmount = transactions.reduce((sum: any, t: any) => sum + (t['총금액'] || 0), 0);

    // Add metadata sheet
    const metadataRows = [
      ['내보내기 정보', ''],
      ['내보낸 날짜', new Date().toLocaleString('ko-KR')],
      ['총 거래 수', totalTransactions],
      ['총 수량', totalQuantity],
      ['총 금액', totalAmount?.toLocaleString('ko-KR') || '0'],
      ['필터', ''],
      ['거래유형', type || '전체'],
      ['시작일', startDate || '없음'],
      ['종료일', endDate || '없음'],
      ['품목ID', itemId || '없음'],
      ['', ''],
      ['태창 ERP 시스템', '재고 거래 내보내기']
    ];

    const metadataSheet = XLSX.utils.aoa_to_sheet(metadataRows);
    metadataSheet['!cols'] = [{ wch: 15 }, { wch: 25 }];

    // Add statistics sheet
    const statsRows: (string | number)[][] = [
      ['거래 유형별 통계', '건수'],
      ...Object.entries(transactionsByType).map(([type, count]): [string, number] => [type, Number(count)]),
      ['', ''],
      ['월별 거래 통계', ''],
      ...getMonthlyStats(transactions)
    ];

    const statsSheet = XLSX.utils.aoa_to_sheet(statsRows);
    statsSheet['!cols'] = [{ wch: 20 }, { wch: 15 }];

    // Add sheets to workbook
    XLSX.utils.book_append_sheet(workbook, metadataSheet, '내보내기 정보');
    XLSX.utils.book_append_sheet(workbook, statsSheet, '통계');
    XLSX.utils.book_append_sheet(workbook, worksheet, '재고 거래');

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx'
    });

    // Create filename with current date and filters
    const currentDate = new Date().toISOString().split('T')[0];
    let filename = `재고거래_${currentDate}`;
    if (type) filename += `_${type}`;
    if (startDate) filename += `_${startDate}`;
    if (endDate) filename += `_${endDate}`;
    filename += '.xlsx';

    // Return Excel file
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${encodeURIComponent(filename)}"`,
        'Content-Length': excelBuffer.length.toString()
      }
    });

  } catch (error) {
    console.error('Error exporting inventory transactions:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to export inventory transactions to Excel'
      },
      { status: 500 }
    );
  }
}

// Helper function to calculate monthly statistics
function getMonthlyStats(transactions: Record<string, any>[]): (string | number)[][] {
  const monthlyStats = transactions.reduce((acc, t) => {
    const dateStr = t['거래일시'];
    if (dateStr) {
      const month = dateStr.substring(0, 7); // YYYY-MM format
      acc[month] = (acc[month] || 0) + 1;
    }
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(monthlyStats)
    .sort(([a], [b]) => b.localeCompare(a)) // Sort by month descending
    .slice(0, 12) // Last 12 months
    .map(([month, count]): [string, number] => [month, Number(count)]);
}
```


#### 📄 src\app\api\export\items\route.ts

```typescript

import { NextRequest, NextResponse } from 'next/server';
import * as XLSX from 'xlsx';
import { createClient } from '@supabase/supabase-js';

const ITEM_TYPE_LABEL: Record<string, string> = {
  RAW: 'RAW',
  SUB: 'SUB',
  FINISHED: 'FINISHED'
};

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const category = searchParams.get('category');
    const itemType = searchParams.get('itemType');
    const materialType = searchParams.get('materialType');
    const search = searchParams.get('search');

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    let query = supabase
      .from('items')
      .select(`
        item_id,
        item_code,
        item_name,
        category,
        item_type,
        material_type,
        vehicle_model,
        material,
        spec,
        unit,
        thickness,
        width,
        height,
        specific_gravity,
        mm_weight,
        daily_requirement,
        blank_size,
        current_stock,
        safety_stock,
        price,
        location,
        description,
        is_active,
        created_at,
        updated_at
      `)
      .eq('is_active', true)
      .order('item_code', { ascending: true });

    if (category) {
      query = query.eq('category', category);
    }

    if (itemType) {
      query = query.eq('item_type', itemType);
    }

    if (materialType) {
      query = query.eq('material_type', materialType);
    }

    if (search) {
      query = query.or(
        `item_code.ilike.%${search}%,item_name.ilike.%${search}%,spec.ilike.%${search}%,material.ilike.%${search}%,vehicle_model.ilike.%${search}%`
      );
    }

    const { data: items, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    const rows = (items ?? []).map((item) => ({
      '품목ID': item.item_id,
      '품목코드': item.item_code,
      '품목명': item.item_name,
      '분류': item.category,
      '타입': ITEM_TYPE_LABEL[item.item_type ?? ''] ?? item.item_type ?? '-',
      '소재형태': item.material_type ?? '-',
      '차종': item.vehicle_model ?? '-',
      '규격/소재': item.spec ?? item.material ?? '-',
      '단위': item.unit,
      '두께(mm)': item.thickness ?? '-',
      '폭(mm)': item.width ?? '-',
      '단위중량(kg)': item.mm_weight ?? '-',
      '현재고': item.current_stock ?? 0,
      '안전재고': item.safety_stock ?? 0,
      '기준단가': item.price ?? 0,
      '비고': item.description ?? '-',
      '생성일시': item.created_at ? new Date(item.created_at).toLocaleString('ko-KR') : '-',
      '수정일시': item.updated_at ? new Date(item.updated_at).toLocaleString('ko-KR') : '-'
    }));

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(rows);
    worksheet['!cols'] = [
      { wch: 10 },
      { wch: 15 },
      { wch: 25 },
      { wch: 10 },
      { wch: 12 },
      { wch: 12 },
      { wch: 15 },
      { wch: 20 },
      { wch: 8 },
      { wch: 10 },
      { wch: 10 },
      { wch: 12 },
      { wch: 12 },
      { wch: 12 },
      { wch: 25 },
      { wch: 18 },
      { wch: 18 }
    ];

    const metadataRows = [
      ['생성 일시', new Date().toLocaleString('ko-KR')],
      ['총 품목 수', rows.length],
      ['분류', category || '전체'],
      ['타입', itemType || '전체'],
      ['소재형태', materialType || '전체'],
      ['검색어', search || '없음']
    ];

    const metadataSheet = XLSX.utils.aoa_to_sheet(metadataRows);
    metadataSheet['!cols'] = [{ wch: 15 }, { wch: 30 }];

    XLSX.utils.book_append_sheet(workbook, metadataSheet, '요약');
    XLSX.utils.book_append_sheet(workbook, worksheet, '품목 목록');

    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx',
      compression: true
    });

    const currentDate = new Date().toISOString().split('T')[0];
    const filename = `items_${currentDate}.xlsx`;

    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename=${encodeURIComponent(filename)}`,
        'Content-Length': excelBuffer.length.toString()
      }
    });
  } catch (error) {
    console.error('Error exporting items:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to export items to Excel'
      },
      { status: 500 }
    );
  }
}

```


#### 📄 src\app\api\export\stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
import * as XLSX from 'xlsx';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type');
    const status = searchParams.get('status');
    const search = searchParams.get('search');

    // Build Supabase query
    let query = supabaseAdmin
      .from('items')
      .select('*')
      .eq('is_active', true)
      .order('item_code');

    if (type) {
      query = query.eq('category', type as "원자재" | "부자재" | "반제품" | "제품" | "상품");
    }

    if (search) {
      query = query.or(`item_code.ilike.%${search}%,item_name.ilike.%${search}%,spec.ilike.%${search}%`);
    }

    const { data: items, error } = await query;

    if (error) {
      throw new Error(error.message);
    }

    // Transform data for export
    const stockData = (items || []).map(item => {
      const currentStock = item.current_stock || 0;
      const minStock = item.safety_stock || 0;
      const unitPrice = item.price || 0;
      const stockValue = currentStock * unitPrice;

      let statusText = '정상';
      let statusCode = 'NORMAL';

      if (currentStock <= 0) {
        statusText = '재고없음';
        statusCode = 'OUT_OF_STOCK';
      } else if (minStock > 0 && currentStock <= minStock * 0.5) {
        statusText = '부족';
        statusCode = 'LOW_STOCK';
      } else if (minStock > 0 && currentStock <= minStock) {
        statusText = '주의';
        statusCode = 'WARNING';
      }

      const categoryMap: Record<string, string> = {
        '원자재': '원자재',
        '부자재': '부자재',
        '반제품': '반제품',
        '제품': '제품',
        '상품': '상품'
      };

      return {
        '품목ID': item.item_id,
        '품목코드': item.item_code,
        '품목명': item.item_name,
        '품목구분': categoryMap[item.category] || item.category,
        '규격': item.spec,
        '단위': item.unit,
        '현재재고': currentStock,
        '안전재고': minStock,
        '단가': unitPrice,
        '재고금액': stockValue,
        '위치': item.location,
        '재고상태': statusText,
        'status_code': statusCode,
        '설명': item.description,
        '등록일': item.created_at?.split('T')[0],
        '수정일': item.updated_at?.split('T')[0]
      };
    });

    // Filter by status if specified
    let filteredData = stockData;
    if (status) {
      filteredData = stockData.filter(item => {
        const statusCode = item['status_code'];
        switch (status) {
          case 'low': return statusCode === 'LOW_STOCK';
          case 'warning': return statusCode === 'WARNING';
          case 'normal': return statusCode === 'NORMAL';
          case 'out': return statusCode === 'OUT_OF_STOCK';
          default: return true;
        }
      });
    }

    // Remove status_code column before export
    const exportData = filteredData.map(item => {
      const { status_code, ...rest } = item;
      return rest;
    });

    // Create workbook and worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(exportData);

    // Set column widths for better formatting
    const columnWidths = [
      { wch: 10 }, // 품목ID
      { wch: 15 }, // 품목코드
      { wch: 25 }, // 품목명
      { wch: 10 }, // 품목구분
      { wch: 20 }, // 규격
      { wch: 8 },  // 단위
      { wch: 12 }, // 현재재고
      { wch: 12 }, // 안전재고
      { wch: 12 }, // 단가
      { wch: 15 }, // 재고금액
      { wch: 15 }, // 위치
      { wch: 10 }, // 재고상태
      { wch: 25 }, // 설명
      { wch: 12 }, // 등록일
      { wch: 12 }  // 수정일
    ];
    worksheet['!cols'] = columnWidths;

    // Calculate statistics
    const totalItems = exportData.length;
    const totalStockValue = exportData.reduce((sum, item) => sum + (item['재고금액'] || 0), 0);
    const totalStock = exportData.reduce((sum, item) => sum + (item['현재재고'] || 0), 0);

    const statusCounts = stockData.reduce((acc, item) => {
      const status = item['재고상태'];
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const typeCounts = exportData.reduce((acc, item) => {
      const type = item['품목구분'];
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Add metadata sheet
    const metadataRows = [
      ['내보내기 정보', ''],
      ['내보낸 날짜', new Date().toLocaleString('ko-KR')],
      ['총 품목 수', totalItems],
      ['총 재고량', totalStock.toLocaleString('ko-KR')],
      ['총 재고금액', totalStockValue.toLocaleString('ko-KR') + '원'],
      ['필터', ''],
      ['품목구분', type || '전체'],
      ['재고상태', status || '전체'],
      ['검색어', search || '없음'],
      ['', ''],
      ['태창 ERP 시스템', '재고 현황 내보내기']
    ];

    const metadataSheet = XLSX.utils.aoa_to_sheet(metadataRows);
    metadataSheet['!cols'] = [{ wch: 15 }, { wch: 25 }];

    // Add statistics sheet
    const statsRows = [
      ['재고 상태별 통계', '품목 수'],
      ...Object.entries(statusCounts).map(([status, count]) => [status, count]),
      ['', ''],
      ['품목 구분별 통계', '품목 수'],
      ...Object.entries(typeCounts).map(([type, count]) => [type, count]),
      ['', ''],
      ['재고 금액 상위 10개', ''],
      ...exportData
        .sort((a, b) => (b['재고금액'] || 0) - (a['재고금액'] || 0))
        .slice(0, 10)
        .map(item => [
          `${item['품목코드']} - ${item['품목명']}`,
          (item['재고금액'] || 0).toLocaleString('ko-KR') + '원'
        ])
    ];

    const statsSheet = XLSX.utils.aoa_to_sheet(statsRows);
    statsSheet['!cols'] = [{ wch: 30 }, { wch: 15 }];

    // Add low stock alert sheet
    const lowStockItems = stockData.filter(item =>
      item['status_code'] === 'LOW_STOCK' ||
      item['status_code'] === 'OUT_OF_STOCK' ||
      item['status_code'] === 'WARNING'
    ).map(item => {
      const { status_code, ...rest } = item;
      return rest;
    });

    if (lowStockItems.length > 0) {
      const lowStockSheet = XLSX.utils.json_to_sheet(lowStockItems);
      lowStockSheet['!cols'] = columnWidths;
      XLSX.utils.book_append_sheet(workbook, lowStockSheet, '주의 품목');
    }

    // Add sheets to workbook
    XLSX.utils.book_append_sheet(workbook, metadataSheet, '내보내기 정보');
    XLSX.utils.book_append_sheet(workbook, statsSheet, '통계');
    XLSX.utils.book_append_sheet(workbook, worksheet, '재고 현황');

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx'
    });

    // Create filename with current date and filters
    const currentDate = new Date().toISOString().split('T')[0];
    let filename = `재고현황_${currentDate}`;
    if (type) filename += `_${type}`;
    if (status) filename += `_${status}`;
    filename += '.xlsx';

    // Return Excel file
    return new NextResponse(excelBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${encodeURIComponent(filename)}"`,
        'Content-Length': excelBuffer.length.toString()
      }
    });

  } catch (error) {
    console.error('Error exporting stock status:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to export stock status to Excel'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\export\[entity]\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db-unified';
import * as XLSX from 'xlsx';
import {
  mappings,
  mapEnglishToKorean,
  mapCompanyType,
  mapTransactionType,
  createTemplate,
  ColumnMapping
} from '@/lib/import-map';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ entity: string }> }
) {
  try {
    const { entity } = await context.params;
    const { searchParams } = new URL(request.url);
    const isTemplate = searchParams.get('template') === 'true';

    // Validate entity
    if (!mappings[entity as keyof typeof mappings]) {
      return NextResponse.json({
        success: false,
        error: '지원하지 않는 엔티티입니다.'
      }, { status: 400 });
    }

    const mapping = mappings[entity as keyof typeof mappings];

    // If template is requested, return template file
    if (isTemplate) {
      return generateTemplate(entity, mapping);
    }

    // Get data based on entity type
    let data: Record<string, any>[] = [];
    let fileName = '';

    switch (entity) {
      case 'items':
        data = await getItemsData(searchParams);
        fileName = '품목목록';
        break;
      case 'companies':
        data = await getCompaniesData(searchParams);
        fileName = '회사목록';
        break;
      case 'bom':
        data = await getBomData(searchParams);
        fileName = 'BOM목록';
        break;
      default:
        return NextResponse.json({
          success: false,
          error: '지원하지 않는 엔티티입니다.'
        }, { status: 400 });
    }

    if (!data || data.length === 0) {
      return NextResponse.json({
        success: false,
        error: '출력할 데이터가 없습니다.'
      });
    }

    // Convert data to Korean headers
    const koreanData = mapEnglishToKorean(data, mapping);

    // Create Excel workbook
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(koreanData);

    // Set column widths based on entity type
    const colWidths = getColumnWidths(entity);
    if (colWidths) {
      worksheet['!cols'] = colWidths;
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, fileName);

    // Add summary sheet
    const summaryData = getSummaryData(data, entity);
    if (summaryData.length > 0) {
      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      summarySheet['!cols'] = [{ wch: 20 }, { wch: 15 }];
      XLSX.utils.book_append_sheet(workbook, summarySheet, '요약정보');
    }

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx',
      compression: true
    });

    // Create filename with current date
    const today = new Date().toISOString().split('T')[0];
    const fullFileName = `${fileName}_${today}.xlsx`;

    // Set response headers
    const headers = new Headers();
    headers.set('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    headers.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(fullFileName)}`);
    headers.set('Content-Length', excelBuffer.length.toString());

    return new NextResponse(excelBuffer, {
      status: 200,
      headers
    });

  } catch (error) {
    const { entity } = await context.params;
    console.error(`Export error for ${entity}:`, error);
    return NextResponse.json({
      success: false,
      error: 'Excel 파일 생성 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}

// Get items data
async function getItemsData(searchParams: URLSearchParams): Promise<any[]> {
  const category = searchParams.get('category');
  const isActive = searchParams.get('isActive');

  let sql = `
    SELECT
      item_code,
      item_name,
      spec,
      unit,
      category,
      safety_stock,
      current_stock,
      is_active
    FROM items
    WHERE 1=1
  `;

  const params: unknown[] = [];
  let paramCount = 0;

  if (category) {
    paramCount++;
    sql += ` AND category = $${paramCount}`;
    params.push(category);
  }

  if (isActive !== null) {
    paramCount++;
    sql += ` AND is_active = $${paramCount}`;
    params.push(isActive === 'true' ? 1 : 0);
  }

  sql += ` ORDER BY item_code`;

  const result = await db.query(sql, params);
  return result.success && result.data ? result.data : [];
}

// Get companies data
async function getCompaniesData(searchParams: URLSearchParams): Promise<any[]> {
  const companyType = searchParams.get('companyType');
  const isActive = searchParams.get('isActive');

  let sql = `
    SELECT
      company_code,
      company_name,
      company_type,
      contact_person,
      phone,
      email,
      address,
      is_active
    FROM companies
    WHERE 1=1
  `;

  const params: unknown[] = [];
  let paramCount = 0;

  if (companyType && companyType !== 'ALL') {
    paramCount++;
    sql += ` AND company_type = $${paramCount}`;
    params.push(companyType);
  }

  if (isActive !== null) {
    paramCount++;
    sql += ` AND is_active = $${paramCount}`;
    params.push(isActive === 'true' ? 1 : 0);
  }

  sql += ` ORDER BY company_code`;

  const result = await db.query(sql, params);
  const results = result.success && result.data ? result.data : [];

  // Convert company type to Korean
  return results.map((company: any) => ({
    ...company,
    company_type: mapCompanyType(company.company_type)
  }));
}

// Get BOM data
async function getBomData(searchParams: URLSearchParams): Promise<any[]> {
  const parentItemCode = searchParams.get('parentItemCode');

  let sql = `
    SELECT
      pi.item_code as parent_item_code,
      pi.item_name as parent_item_name,
      ci.item_code as child_item_code,
      ci.item_name as child_item_name,
      b.quantity,
      b.unit,
      b.remarks
    FROM bom b
    LEFT JOIN items pi ON b.parent_item_id = pi.item_id
    LEFT JOIN items ci ON b.child_item_id = ci.item_id
    WHERE 1=1
  `;

  const params: unknown[] = [];
  let paramCount = 0;

  if (parentItemCode) {
    paramCount++;
    sql += ` AND pi.item_code LIKE $${paramCount}`;
    params.push(`%${parentItemCode}%`);
  }

  sql += ` ORDER BY pi.item_code, ci.item_code`;

  const result = await db.query(sql, params);
  return result.success && result.data ? result.data : [];
}

// Get column widths based on entity type
function getColumnWidths(entity: string): any[] | null {
  switch (entity) {
    case 'items':
      return [
        { wch: 15 }, // 품목코드
        { wch: 25 }, // 품목명
        { wch: 20 }, // 규격
        { wch: 8 },  // 단위
        { wch: 12 }, // 품목분류
        { wch: 12 }, // 안전재고
        { wch: 12 }, // 현재고
        { wch: 10 }  // 활성여부
      ];
    case 'companies':
      return [
        { wch: 15 }, // 회사코드
        { wch: 25 }, // 회사명
        { wch: 10 }, // 회사구분
        { wch: 15 }, // 담당자
        { wch: 15 }, // 전화번호
        { wch: 20 }, // 이메일
        { wch: 30 }, // 주소
        { wch: 10 }  // 활성여부
      ];
    case 'bom':
      return [
        { wch: 15 }, // 상위품목코드
        { wch: 25 }, // 상위품목명
        { wch: 15 }, // 하위품목코드
        { wch: 25 }, // 하위품목명
        { wch: 10 }, // 소요량
        { wch: 8 },  // 단위
        { wch: 20 }  // 비고
      ];
    default:
      return null;
  }
}

// Get summary data
function getSummaryData(data: Record<string, any>[], entity: string): any[][] {
  const summary: any[][] = [
    ['내보내기 정보', ''],
    ['내보낸 날짜', new Date().toLocaleString('ko-KR')],
    ['총 레코드 수', data.length],
    ['', '']
  ];

  switch (entity) {
    case 'items':
      const activeItems = data.filter(item => item.is_active).length;
      const categories = [...new Set(data.map(item => item.category).filter(Boolean))];
      const totalStock = data.reduce((sum, item) => sum + (item.current_stock || 0), 0);

      summary.push(
        ['활성 품목 수', activeItems],
        ['비활성 품목 수', data.length - activeItems],
        ['총 분류 수', categories.length],
        ['총 재고량', totalStock.toLocaleString('ko-KR')]
      );
      break;

    case 'companies':
      const customers = data.filter(company => company.company_type === '고객사').length;
      const suppliers = data.filter(company => company.company_type === '공급사').length;
      const activeCompanies = data.filter(company => company.is_active).length;

      summary.push(
        ['고객사 수', customers],
        ['공급사 수', suppliers],
        ['활성 회사 수', activeCompanies],
        ['비활성 회사 수', data.length - activeCompanies]
      );
      break;

    case 'bom':
      const parentItems = [...new Set(data.map(bom => bom.parent_item_code))].length;
      const childItems = [...new Set(data.map(bom => bom.child_item_code))].length;
      const totalQuantity = data.reduce((sum, bom) => sum + (bom.quantity || 0), 0);

      summary.push(
        ['상위 품목 수', parentItems],
        ['하위 품목 수', childItems],
        ['총 소요량', totalQuantity.toLocaleString('ko-KR')]
      );
      break;
  }

  summary.push(['', ''], ['태창 ERP 시스템', `${getEntityName(entity)} 내보내기`]);

  return summary;
}

// Get entity name in Korean
function getEntityName(entity: string): string {
  const names: { [key: string]: string } = {
    items: '품목',
    companies: '회사',
    bom: 'BOM'
  };
  return names[entity] || entity;
}

// Generate template file
function generateTemplate(entity: string, mapping: ColumnMapping[]): NextResponse {
  try {
    // Create template with sample data
    const templateData = [createTemplate(mapping)];

    // Add sample data based on entity type
    switch (entity) {
      case 'items':
        templateData[0] = {
          '품목코드': 'ITEM001',
          '품목명': '샘플 품목',
          '규격': '100x50',
          '단위': 'EA',
          '품목분류': '완제품',
          '안전재고': '10',
          '현재고': '100',
          '활성여부': 'true'
        };
        break;
      case 'companies':
        templateData[0] = {
          '회사코드': 'COMP001',
          '회사명': '샘플 회사',
          '회사구분': '고객사',
          '담당자': '홍길동',
          '전화번호': '02-1234-5678',
          '이메일': 'contact@sample.com',
          '주소': '서울시 강남구',
          '활성여부': 'true'
        };
        break;
      case 'bom':
        templateData[0] = {
          '상위품목코드': 'PARENT001',
          '하위품목코드': 'CHILD001',
          '소요량': '2',
          '단위': 'EA',
          '비고': '조립용'
        };
        break;
    }

    // Create Excel workbook
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(templateData);

    // Set column widths
    const colWidths = getColumnWidths(entity);
    if (colWidths) {
      worksheet['!cols'] = colWidths;
    }

    // Add data validation info
    const infoData: any[][] = [
      ['컬럼명', '설명', '필수여부', '예시값']
    ];

    mapping.forEach(col => {
      infoData.push([
        col.korean,
        col.type === 'date' ? '날짜 형식 (YYYY-MM-DD)' :
        col.type === 'number' ? '숫자' :
        col.type === 'boolean' ? 'true/false' : '텍스트',
        col.required ? '필수' : '선택',
        col.default !== undefined ? String(col.default) : ''
      ]);
    });

    const infoSheet = XLSX.utils.aoa_to_sheet(infoData);
    infoSheet['!cols'] = [
      { wch: 15 },
      { wch: 25 },
      { wch: 10 },
      { wch: 15 }
    ];

    // Add sheets to workbook
    XLSX.utils.book_append_sheet(workbook, infoSheet, '입력 가이드');
    XLSX.utils.book_append_sheet(workbook, worksheet, `${getEntityName(entity)} 템플릿`);

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx',
      compression: true
    });

    // Create filename
    const fileName = `${getEntityName(entity)}_업로드_템플릿.xlsx`;

    // Set response headers
    const headers = new Headers();
    headers.set('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    headers.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(fileName)}`);
    headers.set('Content-Length', excelBuffer.length.toString());

    return new NextResponse(excelBuffer, {
      status: 200,
      headers
    });

  } catch (error) {
    console.error('Template generation error:', error);
    return NextResponse.json({
      success: false,
      error: '템플릿 생성 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\health\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getHealthStatus, checkDatabaseHealth, getConnectionPoolStatus } from '@/lib/monitoring';
import { logger } from '@/lib/logger';

// Basic health check endpoint
export async function GET(request: NextRequest) {
  const startTime = Date.now();

  try {
    // Set correlation ID from headers
    const correlationId = request.headers.get('x-correlation-id') ||
                         `health_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    logger.setCorrelationId(correlationId);

    logger.info('헬스체크 요청 시작');

    // Get comprehensive health status
    const healthStatus = await getHealthStatus();

    // Additional system information
    const systemInfo = {
      nodeVersion: process.version,
      platform: process.platform,
      architecture: process.arch,
      pid: process.pid,
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      environment: process.env.NODE_ENV || 'development',
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    };

    // Database connection pool details
    const poolStatus = await getConnectionPoolStatus();

    const responseTime = Date.now() - startTime;

    const response = {
      status: healthStatus.status,
      timestamp: new Date().toISOString(),
      uptime: healthStatus.uptime,
      version: healthStatus.version,
      responseTime: responseTime,
      checks: {
        database: {
          status: healthStatus.database.status,
          responseTime: healthStatus.database.responseTime,
          connectionPool: {
            active: poolStatus.active,
            idle: poolStatus.idle,
            total: poolStatus.total,
            limit: poolStatus.limit,
            utilizationPercent: Math.round((poolStatus.total / poolStatus.limit) * 100)
          },
          error: healthStatus.database.error
        },
        memory: {
          status: healthStatus.memory.usage < 500 ? 'healthy' : 'warning', // 500MB threshold
          usage: healthStatus.memory.usage,
          heap: healthStatus.memory.heap,
          external: healthStatus.memory.external,
          limit: 1024 // 1GB soft limit
        },
        system: {
          status: 'healthy',
          ...systemInfo
        }
      },
      correlationId
    };

    // Determine HTTP status code based on health
    const httpStatus = healthStatus.status === 'healthy' ? 200 :
                      healthStatus.status === 'degraded' ? 200 : 503;

    logger.info(`헬스체크 완료: ${healthStatus.status}`, {
      status: healthStatus.status,
      responseTime,
      dbStatus: healthStatus.database.status,
      memoryUsage: healthStatus.memory.usage
    });

    return NextResponse.json(response, {
      status: httpStatus,
      headers: {
        'x-correlation-id': correlationId,
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    logger.error('헬스체크 실패', error instanceof Error ? error : new Error(errorMessage), {
      responseTime,
      type: 'health_check_error'
    });

    return NextResponse.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: '헬스체크를 수행할 수 없습니다',
      details: errorMessage,
      responseTime,
      correlationId: request.headers.get('x-correlation-id')
    }, {
      status: 503,
      headers: {
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });
  } finally {
    logger.clearCorrelationId();
  }
}

// Detailed health check with more comprehensive checks
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    const correlationId = request.headers.get('x-correlation-id') ||
                         `health_detailed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    logger.setCorrelationId(correlationId);

    logger.info('상세 헬스체크 요청 시작');

    // Get basic health status
    const healthStatus = await getHealthStatus();

    // Perform additional detailed checks
    const detailedChecks = await performDetailedChecks();

    const responseTime = Date.now() - startTime;

    const response = {
      status: healthStatus.status,
      timestamp: new Date().toISOString(),
      uptime: healthStatus.uptime,
      version: healthStatus.version,
      responseTime: responseTime,
      basicChecks: {
        database: healthStatus.database,
        memory: healthStatus.memory
      },
      detailedChecks,
      correlationId
    };

    // Overall status based on all checks
    const hasFailures = Object.values(detailedChecks).some(check => check.status !== 'healthy');
    const overallStatus = hasFailures ? 'degraded' : healthStatus.status;

    const httpStatus = overallStatus === 'healthy' ? 200 :
                      overallStatus === 'degraded' ? 200 : 503;

    logger.info(`상세 헬스체크 완료: ${overallStatus}`, {
      status: overallStatus,
      responseTime,
      checksPerformed: Object.keys(detailedChecks).length
    });

    return NextResponse.json({
      ...response,
      status: overallStatus
    }, {
      status: httpStatus,
      headers: {
        'x-correlation-id': correlationId,
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    logger.error('상세 헬스체크 실패', error instanceof Error ? error : new Error(errorMessage), {
      responseTime,
      type: 'detailed_health_check_error'
    });

    return NextResponse.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: '상세 헬스체크를 수행할 수 없습니다',
      details: errorMessage,
      responseTime,
      correlationId: request.headers.get('x-correlation-id')
    }, {
      status: 503,
      headers: {
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });
  } finally {
    logger.clearCorrelationId();
  }
}

// Perform detailed system checks
async function performDetailedChecks() {
  const checks: Record<string, any> = {};

  // Database table accessibility check (Supabase)
  try {
    const dbCheck = await checkDatabaseHealth();
    const { db } = await import('@/lib/db-unified');

    // Test key tables using Supabase client
    const tableChecks = await Promise.allSettled([
      db.query('SELECT COUNT(*) as count FROM items LIMIT 1'),
      db.query('SELECT COUNT(*) as count FROM companies LIMIT 1'),
      db.query('SELECT COUNT(*) as count FROM inventory_transactions LIMIT 1'),
      db.query('SELECT COUNT(*) as count FROM boms LIMIT 1')
    ]);

    const failedTables = tableChecks.filter(result => 
      result.status === 'rejected' || 
      (result.status === 'fulfilled' && !result.value.success)
    ).length;

    checks.databaseTables = {
      status: failedTables === 0 ? 'healthy' : 'unhealthy',
      tablesChecked: tableChecks.length,
      failedTables,
      responseTime: dbCheck.responseTime || 0
    };
  } catch (error) {
    checks.databaseTables = {
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }

  // File system check (logs directory)
  try {
    const fs = await import('fs');
    const path = await import('path');
    const logsDir = path.join(process.cwd(), 'logs');

    const canWrite = fs.existsSync(logsDir) || (() => {
      try {
        fs.mkdirSync(logsDir, { recursive: true });
        return true;
      } catch {
        return false;
      }
    })();

    checks.filesystem = {
      status: canWrite ? 'healthy' : 'unhealthy',
      logsDirectory: logsDir,
      writable: canWrite
    };
  } catch (error) {
    checks.filesystem = {
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }

  // Environment variables check (Supabase)
  const requiredEnvVars = ['SUPABASE_URL', 'SUPABASE_ANON_KEY', 'SUPABASE_SERVICE_ROLE_KEY'];
  const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);

  checks.environment = {
    status: missingEnvVars.length === 0 ? 'healthy' : 'unhealthy',
    requiredVariables: requiredEnvVars.length,
    missingVariables: missingEnvVars,
    nodeEnv: process.env.NODE_ENV || 'development',
    databaseType: 'supabase'
  };

  return checks;
}
```


#### 📄 src\app\api\import\inventory\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import * as XLSX from 'xlsx';
import { getSupabaseClient } from '@/lib/db-unified';
import { IncomingForm } from 'formidable';
import { Readable } from 'stream';
import {
  convertExcelData,
  inventoryMapping,
  validateData,
  mapTransactionType,
  mapCompanyType
} from '@/lib/import-map';

// Disable body parsing for file upload
export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    // Parse multipart form data
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({
        success: false,
        error: '파일이 없습니다.'
      }, { status: 400 });
    }

    // Check file type
    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일만 업로드 가능합니다.'
      }, { status: 400 });
    }

    // Convert file to buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Parse Excel file
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];

    // Convert to JSON
    const rawData = XLSX.utils.sheet_to_json(worksheet);

    if (!rawData || rawData.length === 0) {
      return NextResponse.json({
        success: false,
        error: '파일에 데이터가 없습니다.'
      }, { status: 400 });
    }

    // Convert Excel data using mapping
    let convertedData: Record<string, any>[];
    try {
      convertedData = convertExcelData(rawData as Record<string, any>[], inventoryMapping);
    } catch (error: unknown) {
      return NextResponse.json({
        success: false,
        error: `데이터 변환 오류: ${error instanceof Error ? error.message : String(error)}`
      }, { status: 400 });
    }

    // Validate data
    const validation = validateData(convertedData as Record<string, any>[], inventoryMapping);
    if (!validation.isValid) {
      return NextResponse.json({
        success: false,
        error: '데이터 유효성 검사 실패',
        details: validation.errors
      }, { status: 400 });
    }

    // Process data and insert into database using Supabase
    const supabase = getSupabaseClient();
    const insertedRecords = [];
    const errors = [];

    for (let i = 0; i < convertedData.length; i++) {
      const row = convertedData[i] as Record<string, any>;
      try {
        // Map transaction type to English
        row.transaction_type = mapTransactionType(row.transaction_type);

        // Get item_id from item_code
        const { data: items, error: itemError } = await supabase
          .from('items')
          .select('item_id, current_stock')
          .eq('item_code', row.item_code)
          .eq('is_active', true)
          .single();

        if (itemError || !items) {
          errors.push(`행 ${i + 1}: 품목코드 '${row.item_code}'를 찾을 수 없습니다.`);
          continue;
        }

        const itemId = items.item_id;

        // Get company_id from company_code (if provided)
        let companyId = null;
        if (row.company_code) {
          const { data: companies, error: companyError } = await supabase
            .from('companies')
            .select('company_id')
            .eq('company_code', row.company_code)
            .eq('is_active', true)
            .single();

          if (companyError || !companies) {
            errors.push(`행 ${i + 1}: 회사코드 '${row.company_code}'를 찾을 수 없습니다.`);
            continue;
          }

          companyId = companies.company_id;
        }

        // Insert inventory transaction
        const { data: insertedTransaction, error: insertError } = await supabase
          .from('inventory_transactions')
          .insert({
            transaction_date: row.transaction_date,
            transaction_type: row.transaction_type,
            item_id: itemId,
            quantity: row.quantity,
            unit: row.unit,
            company_id: companyId,
            reference_number: row.reference_number || null,
            remarks: row.remarks || null,
            user_id: 1,
            created_at: new Date().toISOString()
          })
          .select('transaction_id')
          .single();

        if (insertError) {
          errors.push(`행 ${i + 1}: 거래 입력 실패 - ${insertError.message}`);
          continue;
        }

        // Update item stock based on transaction type
        let stockChange = 0;
        switch (row.transaction_type) {
          case 'RECEIVING':
          case 'PRODUCTION':
            stockChange = row.quantity;
            break;
          case 'SHIPPING':
            stockChange = -row.quantity;
            break;
        }

        if (stockChange !== 0) {
          const currentStock = items.current_stock ?? 0;
          const newStock = currentStock + stockChange;
          const { error: updateError } = await supabase
            .from('items')
            .update({ current_stock: newStock })
            .eq('item_id', itemId);

          if (updateError) {
            errors.push(`행 ${i + 1}: 재고 업데이트 실패 - ${updateError.message}`);
            continue;
          }
        }

        insertedRecords.push({
          transaction_id: insertedTransaction?.transaction_id,
          row: i + 1,
          item_code: row.item_code,
          quantity: row.quantity,
          transaction_type: row.transaction_type
        });

      } catch (error: unknown) {
        errors.push(`행 ${i + 1}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    const result = { insertedRecords, errors };

    return NextResponse.json({
      success: true,
      data: {
        totalProcessed: convertedData.length,
        successCount: result.insertedRecords.length,
        errorCount: result.errors.length,
        inserted: result.insertedRecords,
        errors: result.errors
      }
    });

  } catch (error) {
    console.error('Excel import error:', error);
    return NextResponse.json({
      success: false,
      error: 'Excel 파일 처리 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}

// GET method for downloading template
export async function GET() {
  try {
    // Create template data with Korean headers
    const templateData = [{
      '거래일자': '2024-01-01',
      '거래유형': '입고',
      '품목코드': 'ITEM001',
      '수량': 100,
      '단위': 'EA',
      '회사코드': 'COMP001',
      '참조번호': 'REF001',
      '비고': '샘플 데이터'
    }];

    // Create Excel workbook
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(templateData);

    // Set column widths
    const colWidths = [
      { wch: 12 }, // 거래일자
      { wch: 10 }, // 거래유형
      { wch: 15 }, // 품목코드
      { wch: 10 }, // 수량
      { wch: 8 },  // 단위
      { wch: 15 }, // 회사코드
      { wch: 15 }, // 참조번호
      { wch: 20 }  // 비고
    ];
    worksheet['!cols'] = colWidths;

    // Add data validation info sheet
    const infoData = [
      ['컬럼', '설명', '필수여부', '예시'],
      ['거래일자', 'YYYY-MM-DD 형식', '필수', '2024-01-01'],
      ['거래유형', '입고/생산/출고', '필수', '입고'],
      ['품목코드', '등록된 품목코드', '필수', 'ITEM001'],
      ['수량', '숫자', '필수', '100'],
      ['단위', '품목 단위', '필수', 'EA'],
      ['회사코드', '등록된 회사코드', '선택', 'COMP001'],
      ['참조번호', '참조 번호', '선택', 'REF001'],
      ['비고', '추가 메모', '선택', '비고 내용']
    ];

    const infoSheet = XLSX.utils.aoa_to_sheet(infoData);
    infoSheet['!cols'] = [
      { wch: 12 },
      { wch: 25 },
      { wch: 10 },
      { wch: 15 }
    ];

    // Add sheets to workbook
    XLSX.utils.book_append_sheet(workbook, infoSheet, '입력 가이드');
    XLSX.utils.book_append_sheet(workbook, worksheet, '재고거래 템플릿');

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, {
      type: 'buffer',
      bookType: 'xlsx',
      compression: true
    });

    // Return template file
    const fileName = '재고거래_업로드_템플릿.xlsx';
    const headers = new Headers();
    headers.set('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    headers.set('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(fileName)}`);
    headers.set('Content-Length', excelBuffer.length.toString());

    return new NextResponse(excelBuffer, {
      status: 200,
      headers
    });

  } catch (error) {
    console.error('Template generation error:', error);
    return NextResponse.json({
      success: false,
      error: '템플릿 생성 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\import\[entity]\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db-unified';
import { getSupabaseClient } from '@/lib/db-unified';
import * as XLSX from 'xlsx';
import {
  mappings,
  convertExcelData,
  validateData,
  mapCompanyType,
  mapTransactionType
} from '@/lib/import-map';

export const dynamic = 'force-dynamic';

export async function POST(
  request: NextRequest,
  context: { params: Promise<{ entity: string }> }
) {
  try {
    const { entity } = await context.params;

    // Validate entity
    if (!mappings[entity as keyof typeof mappings]) {
      return NextResponse.json({
        success: false,
        error: '지원하지 않는 엔티티입니다.'
      }, { status: 400 });
    }

    const mapping = mappings[entity as keyof typeof mappings];

    // Parse multipart form data
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({
        success: false,
        error: '파일이 없습니다.'
      }, { status: 400 });
    }

    // Check file type
    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일만 업로드 가능합니다.'
      }, { status: 400 });
    }

    // Convert file to buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Parse Excel file
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];

    // Convert to JSON
    const rawData = XLSX.utils.sheet_to_json(worksheet);

    if (!rawData || rawData.length === 0) {
      return NextResponse.json({
        success: false,
        error: '파일에 데이터가 없습니다.'
      }, { status: 400 });
    }

    // Convert Excel data using mapping
    let convertedData: Record<string, any>[];
    try {
      convertedData = convertExcelData(rawData as Record<string, any>[], mapping);
    } catch (error: unknown) {
      return NextResponse.json({
        success: false,
        error: `데이터 변환 오류: ${error instanceof Error ? error.message : String(error)}`
      }, { status: 400 });
    }

    // Validate data
    const validation = validateData(convertedData as Record<string, any>[], mapping);
    if (!validation.isValid) {
      return NextResponse.json({
        success: false,
        error: '데이터 유효성 검사 실패',
        details: validation.errors
      }, { status: 400 });
    }

    // Process data based on entity type
    let result;
    switch (entity) {
      case 'items':
        result = await processItemsData(convertedData as Record<string, any>[]);
        break;
      case 'companies':
        result = await processCompaniesData(convertedData as Record<string, any>[]);
        break;
      case 'bom':
        result = await processBomData(convertedData as Record<string, any>[]);
        break;
      default:
        return NextResponse.json({
          success: false,
          error: '지원하지 않는 엔티티입니다.'
        }, { status: 400 });
    }

    return NextResponse.json({
      success: true,
      data: {
        entity,
        totalProcessed: convertedData.length,
        successCount: result.insertedRecords.length,
        errorCount: result.errors.length,
        inserted: result.insertedRecords,
        errors: result.errors
      }
    });

  } catch (error) {
    const { entity } = await context.params;
    console.error(`Import error for ${entity}:`, error);
    return NextResponse.json({
      success: false,
      error: 'Excel 파일 처리 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
// Process items data
async function processItemsData(data: Record<string, any>[]): Promise<{ insertedRecords: unknown[]; errors: string[] }> {
  const supabase = getSupabaseClient();
  const insertedRecords = [];
  const errors = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i] as Record<string, any>;
    try {
      const itemData = {
        item_code: row.item_code,
        item_name: row.item_name,
        spec: row.spec || null,
        unit: row.unit,
        category: row.category || null,
        safety_stock: row.safety_stock || 0,
        current_stock: row.current_stock || 0,
        is_active: row.is_active !== false
      };

      const { data: result, error } = await supabase
        .from('items')
        .upsert(itemData, { onConflict: 'item_code' })
        .select()
        .single();

      if (error) {
        errors.push(`행 ${i + 1}: ${error.message}`);
        continue;
      }

      insertedRecords.push({
        action: 'upserted',
        row: i + 1,
        item_code: row.item_code,
        item_name: row.item_name
      });
    } catch (error: unknown) {
      errors.push(`행 ${i + 1}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  return { insertedRecords, errors };
}

// Process companies data
async function processCompaniesData(data: Record<string, any>[]): Promise<{ insertedRecords: unknown[]; errors: string[] }> {
  const supabase = getSupabaseClient();
  const insertedRecords = [];
  const errors = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i] as Record<string, any>;
    try {
      // Convert company type to English
      row.company_type = mapCompanyType(row.company_type);

      const companyData = {
        company_code: row.company_code,
        company_name: row.company_name,
        company_type: row.company_type,
        contact_person: row.contact_person || null,
        phone: row.phone || null,
        email: row.email || null,
        address: row.address || null,
        is_active: row.is_active !== false
      };

      const { data: result, error } = await supabase
        .from('companies')
        .upsert(companyData, { onConflict: 'company_code' })
        .select()
        .single();

      if (error) {
        errors.push(`행 ${i + 1}: ${error.message}`);
        continue;
      }

      insertedRecords.push({
        action: 'upserted',
        row: i + 1,
        company_code: row.company_code,
        company_name: row.company_name
      });
    } catch (error: unknown) {
      errors.push(`행 ${i + 1}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  return { insertedRecords, errors };
}


// Process BOM data
async function processBomData(data: Record<string, any>[]): Promise<{ insertedRecords: unknown[]; errors: string[] }> {
  const supabase = getSupabaseClient();
  const insertedRecords = [];
  const errors = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i] as Record<string, any>;
    try {
      // Get parent item ID
      const { data: parentItem, error: parentError } = await supabase
        .from('items')
        .select('item_id')
        .eq('item_code', row.parent_item_code)
        .eq('is_active', true)
        .single();

      if (parentError || !parentItem) {
        errors.push(`행 ${i + 1}: 상위품목코드 '${row.parent_item_code}'를 찾을 수 없습니다.`);
        continue;
      }

      // Get child item ID
      const { data: childItem, error: childError } = await supabase
        .from('items')
        .select('item_id')
        .eq('item_code', row.child_item_code)
        .eq('is_active', true)
        .single();

      if (childError || !childItem) {
        errors.push(`행 ${i + 1}: 하위품목코드 '${row.child_item_code}'를 찾을 수 없습니다.`);
        continue;
      }

      // Upsert BOM relationship
      const bomData = {
        parent_item_id: parentItem.item_id,
        child_item_id: childItem.item_id,
        quantity: row.quantity,
        unit: row.unit,
        remarks: row.remarks || null
      };

      const { data: result, error } = await supabase
        .from('bom')
        .upsert(bomData, {
          onConflict: 'parent_item_id,child_item_id'
        })
        .select()
        .single();

      if (error) {
        errors.push(`행 ${i + 1}: ${error.message}`);
        continue;
      }

      insertedRecords.push({
        action: 'upserted',
        row: i + 1,
        parent_item_code: row.parent_item_code,
        child_item_code: row.child_item_code,
        quantity: row.quantity
      });

    } catch (error: unknown) {
      errors.push(`행 ${i + 1}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  return { insertedRecords, errors };
}
```


#### 📄 src\app\api\inventory\production\bom-check\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db, SupabaseQueryBuilder, handleSupabaseError, createSuccessResponse, getSupabaseClient } from '@/lib/db-unified';
import { createClient } from '@supabase/supabase-js';

/**
 * GET /api/inventory/production/bom-check
 * Check BOM availability for production
 * Query parameters:
 * - product_item_id: ID of the product to produce
 * - quantity: Quantity to produce
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const productItemId = searchParams.get('product_item_id');
    const quantity = parseFloat(searchParams.get('quantity') || '1');

    if (!productItemId) {
      return NextResponse.json({
        success: false,
        error: 'product_item_id is required'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'quantity must be greater than 0'
      }, { status: 400 });
    }

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get product information using safe Supabase client
    const { data: productInfo, error: productError } = await supabase
      .from('items')
      .select('item_id, item_code, item_name, category, unit')
      .eq('item_id', parseInt(productItemId))
      .eq('is_active', true)
      .single();

    if (productError || !productInfo) {
      return NextResponse.json({
        success: false,
        error: 'Product not found or not active'
      }, { status: 404 });
    }

    // Get BOM items using safe Supabase client
    const { data: bomItems, error: bomError } = await supabase
      .from('bom')
      .select(`
        bom_id,
        parent_item_id,
        child_item_id,
        quantity,
        unit,
        items!inner(item_code, item_name, category, spec, price, current_stock, safety_stock)
      `)
      .eq('parent_item_id', parseInt(productItemId))
      .eq('is_active', true)
      .eq('items.is_active', true);

    if (bomError) {
      throw new Error(`BOM query failed: ${bomError.message}`);
    }

    const bomCheckResults = [];
    let totalRequiredValue = 0;
    let totalAvailableValue = 0;
    let canProduce = true;
    let totalShortage = 0;

    for (const bomItem of bomItems || []) {
      const requiredQuantity = bomItem.quantity * quantity;
      const availableStock = bomItem.items?.current_stock || 0;
      const shortage = Math.max(0, requiredQuantity - availableStock);
      const sufficient = availableStock >= requiredQuantity;
      
      if (!sufficient) {
        canProduce = false;
        totalShortage += shortage;
      }

      const requiredValue = requiredQuantity * (bomItem.items?.price || 0);
      const availableValue = Math.min(requiredQuantity, availableStock) * (bomItem.items?.price || 0);
      
      totalRequiredValue += requiredValue;
      totalAvailableValue += availableValue;

      bomCheckResults.push({
        bom_id: bomItem.bom_id,
        child_item_id: bomItem.child_item_id,
        item_code: bomItem.items?.item_code,
        item_name: bomItem.items?.item_name,
        category: bomItem.items?.category,
        spec: bomItem.items?.spec,
        unit: bomItem.unit,
        unit_price: bomItem.items?.price || 0,
        required_quantity: requiredQuantity,
        available_stock: availableStock,
        shortage: shortage,
        sufficient: sufficient,
        safety_stock: bomItem.items?.safety_stock || 0,
        required_value: requiredValue,
        available_value: availableValue
      });
    }

    // Calculate production feasibility
    const fulfillmentRate = totalRequiredValue > 0 ? 
      Math.round((totalAvailableValue / totalRequiredValue) * 10000) / 100 : 0;

    return NextResponse.json({
      success: true,
      data: {
        product_info: {
          item_id: productInfo.item_id,
          item_code: productInfo.item_code,
          item_name: productInfo.item_name,
          category: productInfo.category,
          unit: productInfo.unit
        },
        production_quantity: quantity,
        can_produce: canProduce,
        bom_items: bomCheckResults,
        summary: {
          total_bom_items: bomItems.length,
          sufficient_items: bomCheckResults.filter(item => item.sufficient).length,
          insufficient_items: bomCheckResults.filter(item => !item.sufficient).length,
          total_required_value: Math.round(totalRequiredValue * 100) / 100,
          total_available_value: Math.round(totalAvailableValue * 100) / 100,
          total_shortage: totalShortage,
          fulfillment_rate: fulfillmentRate
        }
      }
    });

  } catch (error) {
    console.error('Error checking BOM availability:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check BOM availability'
    }, { status: 500 });
  }
}

/**
 * POST /api/inventory/production/bom-check
 * Check BOM availability for production (alternative method using POST body)
 * Body: {
 *   product_item_id: number,
 *   quantity: number
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { product_item_id, quantity } = body;

    if (!product_item_id || !quantity) {
      return NextResponse.json({
        success: false,
        error: 'product_item_id and quantity are required'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'quantity must be greater than 0'
      }, { status: 400 });
    }

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Get product information using correct schema
    const productResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `SELECT item_id, item_code, item_name, category, unit 
              FROM items 
              WHERE item_id = ${product_item_id} 
              AND is_active = true`
    });

    if (!productResult.rows || productResult.rows.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Product not found or not active'
      }, { status: 404 });
    }

    const productInfo = productResult.rows[0];

    // Get BOM items using correct schema
    const bomResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        SELECT 
          b.bom_id,
          b.parent_item_id,
          b.child_item_id,
          b.quantity,
          b.unit,
          i.item_code,
          i.item_name,
          i.category,
          i.spec,
          i.price,
          i.current_stock,
          i.safety_stock
        FROM bom b
        INNER JOIN items i ON b.child_item_id = i.item_id
        WHERE b.parent_item_id = ${product_item_id}
        AND b.is_active = true
        AND i.is_active = true
      `
    });

    const bomItems = bomResult.rows || [];
    const bomCheckResults = [];

    let totalRequiredValue = 0;
    let totalAvailableValue = 0;
    let canProduce = true;
    let totalShortage = 0;

    for (const bomItem of bomItems) {
      const requiredQuantity = bomItem.quantity * quantity;
      const availableStock = bomItem.current_stock || 0;
      const shortage = Math.max(0, requiredQuantity - availableStock);
      const sufficient = availableStock >= requiredQuantity;
      
      if (!sufficient) {
        canProduce = false;
        totalShortage += shortage;
      }

      const requiredValue = requiredQuantity * (bomItem.price || 0);
      const availableValue = Math.min(requiredQuantity, availableStock) * (bomItem.price || 0);
      
      totalRequiredValue += requiredValue;
      totalAvailableValue += availableValue;

      bomCheckResults.push({
        bom_id: bomItem.bom_id,
        child_item_id: bomItem.child_item_id,
        item_code: bomItem.item_code,
        item_name: bomItem.item_name,
        category: bomItem.category,
        spec: bomItem.spec,
        unit: bomItem.unit,
        unit_price: bomItem.price || 0,
        required_quantity: requiredQuantity,
        available_stock: availableStock,
        shortage: shortage,
        sufficient: sufficient,
        safety_stock: bomItem.safety_stock || 0,
        required_value: requiredValue,
        available_value: availableValue
      });
    }

    // Calculate production feasibility
    const fulfillmentRate = totalRequiredValue > 0 ? 
      Math.round((totalAvailableValue / totalRequiredValue) * 10000) / 100 : 0;

    return NextResponse.json({
      success: true,
      data: {
        product_info: {
          item_id: productInfo.item_id,
          item_code: productInfo.item_code,
          item_name: productInfo.item_name,
          category: productInfo.category,
          unit: productInfo.unit
        },
        production_quantity: quantity,
        can_produce: canProduce,
        bom_items: bomCheckResults,
        summary: {
          total_bom_items: bomItems.length,
          sufficient_items: bomCheckResults.filter(item => item.sufficient).length,
          insufficient_items: bomCheckResults.filter(item => !item.sufficient).length,
          total_required_value: Math.round(totalRequiredValue * 100) / 100,
          total_available_value: Math.round(totalAvailableValue * 100) / 100,
          total_shortage: totalShortage,
          fulfillment_rate: fulfillmentRate
        }
      }
    });

  } catch (error) {
    console.error('Error checking BOM availability:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check BOM availability'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\inventory\production\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const { data: transactions, error } = await supabase
      .from('inventory_transactions')
      .select('*')
      .eq('transaction_type', '생산입고')
      .order('transaction_date', { ascending: false });

    if (error) {
      console.error('Supabase query error:', error);
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, data: { transactions: transactions || [] } });
  } catch (error) {
    console.error('Error fetching production history:', error);
    return NextResponse.json({ success: false, error: 'Failed to fetch production history' }, { status: 500 });
  }
}

/**
 * POST /api/inventory/production
 * Create new production transaction
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const {
      transaction_date,
      item_id,
      quantity,
      unit_price,
      reference_number,
      notes,
      created_by,
      transaction_type
    } = body;

    // 필수 필드 검증
    if (!transaction_date || !item_id || !quantity || unit_price === undefined || !created_by || !transaction_type) {
      return NextResponse.json({
        success: false,
        error: '필수 필드가 누락되었습니다. (거래일자, 품목, 수량, 단가, 작성자, 거래유형 필수)'
      }, { status: 400 });
    }

    if (!['생산입고', '생산출고'].includes(transaction_type)) {
      return NextResponse.json({
        success: false,
        error: '거래유형은 생산입고 또는 생산출고여야 합니다.'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: '수량은 0보다 커야 합니다.'
      }, { status: 400 });
    }

    if (unit_price < 0) {
      return NextResponse.json({
        success: false,
        error: '단가는 0 이상이어야 합니다.'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if item exists and is active
    const { data: item, error: itemError } = await supabase
      .from('items')
      .select('item_id, item_name, unit, is_active')
      .eq('item_id', item_id)
      .single();

    if (itemError || !item) {
      return NextResponse.json({
        success: false,
        error: '존재하지 않는 품목입니다.'
      }, { status: 404 });
    }

    if (!item.is_active) {
      return NextResponse.json({
        success: false,
        error: '비활성화된 품목입니다.'
      }, { status: 400 });
    }

    // Calculate total amount
    const total_amount = quantity * unit_price;

    // Insert production transaction
    const { data, error } = await supabase
      .from('inventory_transactions')
      .insert([{
        item_id,
        user_id: created_by,
        created_by,
        transaction_type,
        quantity,
        unit_price,
        total_amount,
        reference_number,
        transaction_date,
        notes,
        document_status: 'DRAFT'
      }])
      .select(`
        *,
        items!inner(item_code, item_name, spec, unit, category),
        users!created_by(username)
      `);

    if (error) {
      console.error('Supabase insert error:', error);
      return NextResponse.json({
        success: false,
        error: '생산 등록 중 오류가 발생했습니다.',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: '생산이 성공적으로 등록되었습니다.',
      data: data[0]
    });
  } catch (error) {
    console.error('Error creating production transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: '생산 등록 중 오류가 발생했습니다.',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * PUT /api/inventory/production
 * Update existing production transaction
 */
export async function PUT(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const { id, ...updateData } = body;

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'Transaction ID is required'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if transaction exists and is a production transaction
    const { data: existingTransaction, error: existingError } = await supabase
      .from('inventory_transactions')
      .select('*')
      .eq('transaction_id', id)
      .in('transaction_type', ['생산입고', '생산출고'])
      .single();

    if (existingError || !existingTransaction) {
      return NextResponse.json({
        success: false,
        error: 'Production transaction not found'
      }, { status: 404 });
    }

    // Validate fields if being updated
    if (updateData.quantity !== undefined && updateData.quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'Quantity must be greater than 0'
      }, { status: 400 });
    }

    if (updateData.unit_price !== undefined && updateData.unit_price < 0) {
      return NextResponse.json({
        success: false,
        error: 'Unit price cannot be negative'
      }, { status: 400 });
    }

    // Recalculate total amount if quantity or unit_price is updated
    if (updateData.quantity !== undefined || updateData.unit_price !== undefined) {
      const newQuantity = updateData.quantity ?? existingTransaction.quantity;
      const newUnitPrice = updateData.unit_price ?? existingTransaction.unit_price;
      updateData.total_amount = newQuantity * newUnitPrice;
    }

    // Update transaction
    const { data, error } = await supabase
      .from('inventory_transactions')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('transaction_id', id)
      .select(`
        *,
        items!inner(item_code, item_name, spec, unit, category),
        users!created_by(username)
      `);

    if (error) {
      console.error('Supabase update error:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to update production transaction',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: 'Production transaction updated successfully',
      data: data[0]
    });
  } catch (error) {
    console.error('Error updating production transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to update production transaction',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/inventory/production
 * Delete production transaction
 */
export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'Transaction ID is required'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if transaction exists and is a production transaction
    const { data: existingTransaction, error: existingError } = await supabase
      .from('inventory_transactions')
      .select('transaction_id')
      .eq('transaction_id', id)
      .in('transaction_type', ['생산입고', '생산출고'])
      .single();

    if (existingError || !existingTransaction) {
      return NextResponse.json({
        success: false,
        error: 'Production transaction not found'
      }, { status: 404 });
    }

    // Delete transaction
    const { error } = await supabase
      .from('inventory_transactions')
      .delete()
      .eq('transaction_id', id);

    if (error) {
      console.error('Supabase delete error:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to delete production transaction',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: 'Production transaction deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting production transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete production transaction',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\inventory\receiving\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Simple query to get receiving transactions
    const { data: transactions, error } = await supabase
      .from('inventory_transactions')
      .select('*')
      .eq('transaction_type', '입고')
      .order('transaction_date', { ascending: false })
      .limit(100);

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Get related data separately
    const itemIds = [...new Set(transactions?.map(t => t.item_id) || [])];
    const companyIds = [...new Set(transactions?.map(t => t.company_id).filter(Boolean) || [])];

    const { data: items } = await supabase
      .from('items')
      .select('item_id, item_code, item_name, spec, unit')
      .in('item_id', itemIds);

    const { data: companies } = await supabase
      .from('companies')
      .select('company_id, company_name')
      .in('company_id', companyIds);

    // Combine data
    const enrichedTransactions = transactions?.map(transaction => ({
      ...transaction,
      item: items?.find(item => item.item_id === transaction.item_id),
      company: companies?.find(company => company.company_id === transaction.company_id)
    })) || [];

    return NextResponse.json({
      success: true,
      data: {
        transactions: enrichedTransactions,
        summary: {
          total_count: enrichedTransactions.length,
          total_quantity: enrichedTransactions.reduce((sum, t) => sum + (t.quantity || 0), 0),
          total_value: enrichedTransactions.reduce((sum, t) => sum + ((t.quantity || 0) * (t.unit_price || 0)), 0)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching receiving transactions:', error);
    return NextResponse.json(
      {
        success: false,
        error: '입고 내역 조회에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const {
      transaction_date,
      item_id,
      quantity,
      unit_price,
      company_id,
      reference_number,
      notes
    } = body;

    // 필수 필드 검증
    if (!transaction_date || !item_id || !quantity || unit_price === undefined) {
      return NextResponse.json({
        success: false,
        error: '필수 필드가 누락되었습니다. (거래일자, 품목, 수량, 단가 필수)'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Calculate total amount
    const total_amount = quantity * unit_price;

    // Insert receiving transaction
    const { data, error } = await supabase
      .from('inventory_transactions')
      .insert([{
        item_id,
        company_id,
        transaction_type: '입고',
        quantity,
        unit_price,
        total_amount,
        reference_number,
        transaction_date,
        notes,
        document_status: 'DRAFT'
      }])
      .select();

    if (error) {
      console.error('Supabase insert error:', error);
      return NextResponse.json({
        success: false,
        error: '입고 등록 중 오류가 발생했습니다.',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: '입고가 성공적으로 등록되었습니다.',
      data: data[0]
    });
  } catch (error) {
    console.error('Error creating receiving transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: '입고 등록 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\inventory\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db, SupabaseQueryBuilder, handleSupabaseError, createSuccessResponse, getSupabaseClient } from '@/lib/db-unified';
import { createValidatedRoute } from '@/lib/validationMiddleware';
import { errorHandler, ERPError, ErrorType, handleError, handleBusinessError, handleNotFoundError, handleInsufficientStockError } from '@/lib/errorHandler';
import { parsePagination, buildPaginatedResponse, buildPaginatedSQL, getPaginationFromSearchParams } from '@/lib/pagination';
import { calculateTax } from '@/lib/tax';
import { createClient } from '@supabase/supabase-js';

export const GET = createValidatedRoute(
  async (request: NextRequest) => {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type');
    const itemId = searchParams.get('itemId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    // Get pagination parameters
    const paginationInput = getPaginationFromSearchParams(searchParams);
    const paginationParams = parsePagination(paginationInput, {
      page: 1,
      limit: 50, // Inventory transactions typically need fewer per page
      maxLimit: 200
    });

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_date,
        transaction_type,
        item_id,
        quantity,
        unit_price,
        total_amount,
        tax_amount,
        grand_total,
        document_number,
        reference_number,
        warehouse_id,
        location,
        lot_number,
        expiry_date,
        status,
        notes,
        created_at,
        updated_at,
        created_by,
        updated_by,
        description,
        items!inner(item_code, item_name, unit),
        companies(company_name)
      `);

    // Apply filters safely
    if (type) {
      query = query.eq('transaction_type', type);
    }

    if (itemId) {
      query = query.eq('item_id', parseInt(itemId));
    }

    if (startDate) {
      query = query.gte('transaction_date', startDate);
    }

    if (endDate) {
      query = query.lte('transaction_date', endDate);
    }

    // Apply ordering and pagination
    const offset = ((paginationParams as any).page - 1) * paginationParams.limit;
    query = query
      .order('transaction_date', { ascending: false })
      .order('created_at', { ascending: false })
      .range(offset, offset + paginationParams.limit - 1);

    const { data: transactions, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Get total count for pagination using safe query
    let countQuery = supabase
      .from('inventory_transactions')
      .select('*', { count: 'exact', head: true });

    if (type) {
      countQuery = countQuery.eq('transaction_type', type);
    }

    if (itemId) {
      countQuery = countQuery.eq('item_id', parseInt(itemId));
    }

    if (startDate) {
      countQuery = countQuery.gte('transaction_date', startDate);
    }

    if (endDate) {
      countQuery = countQuery.lte('transaction_date', endDate);
    }

    const { count: totalCount, error: countError } = await countQuery;

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    // Transform data to match expected format
    const formattedTransactions = transactions?.map((t: any) => ({
      transaction_id: t.transaction_id,
      transaction_date: t.transaction_date,
      transaction_type: t.transaction_type,
      item_id: t.item_id,
      item_code: t.items?.item_code,
      item_name: t.items?.item_name,
      quantity: t.quantity,
      unit: t.items?.unit,
      unit_price: t.unit_price,
      total_amount: t.total_amount,
      tax_amount: t.tax_amount,
      grand_total: t.grand_total,
      document_number: t.document_number,
      reference_number: t.reference_number,
      warehouse_id: t.warehouse_id,
      location: t.location,
      lot_number: t.lot_number,
      expiry_date: t.expiry_date,
      status: t.status,
      notes: t.notes,
      created_at: t.created_at,
      updated_at: t.updated_at,
      created_by: t.created_by,
      updated_by: t.updated_by,
      description: t.description,
      company_name: t.companies?.company_name
    })) || [];

    // Build paginated response
    const response = buildPaginatedResponse(formattedTransactions, totalCount || 0, {
      page: (paginationParams as any).page,
      limit: paginationParams.limit
    });

    return NextResponse.json({
      success: true,
      data: response
    });
  } catch (error) {
    console.error('Error fetching inventory transactions:', error);
    return NextResponse.json(
      {
        success: false,
        error: `Failed to fetch inventory transactions: ${error instanceof Error ? error.message : 'Unknown error'}`
      },
      { status: 500 }
    );
  }
  },
  { resource: 'inventory', action: 'read', requireAuth: false }
);

export const POST = createValidatedRoute(
  async (request: NextRequest) => {
  try {
    const text = await request.text();
    const body = JSON.parse(text);
    const {
      transaction_date,
      transaction_type,
      item_id,
      quantity,
      unit_price,
      company_id,
      reference_id,
      note,
      warehouse_id,
      location,
      lot_number,
      expiry_date
    } = body;

    // Validate required fields
    if (!transaction_type || !item_id || !quantity) {
      return NextResponse.json(
        { success: false, error: 'transaction_type, item_id, and quantity are required' },
        { status: 400 }
      );
    }

    // Validate transaction type
    const validTypes = ['입고', '출고', '생산입고', '생산출고', '이동', '조정', '폐기', '재고조정'];
    if (!validTypes.includes(transaction_type)) {
      return NextResponse.json(
        { success: false, error: `Invalid transaction_type. Must be one of: ${validTypes.join(', ')}` },
        { status: 400 }
      );
    }

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Check if item exists and get current stock
    const itemResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `SELECT item_id, item_code, item_name, current_stock FROM items WHERE item_id = ${item_id}`
    });

    if (!itemResult.rows || itemResult.rows.length === 0) {
      return NextResponse.json(
        { success: false, error: `Item with ID ${item_id} not found` },
        { status: 404 }
      );
    }

    const currentItem = itemResult.rows[0];
    const currentStock = currentItem.current_stock || 0;

    // 출고 시 재고 부족 체크
    if (transaction_type === '출고' && currentStock < Math.abs(quantity)) {
      return NextResponse.json(
        {
          success: false,
          error: `재고 부족: ${currentItem.item_code} (필요: ${Math.abs(quantity)}, 현재: ${currentStock})`
        },
        { status: 400 }
      );
    }

    // 회사 ID가 제공된 경우 존재 여부 확인
    if (company_id) {
      const companyResult = await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `SELECT company_id FROM companies WHERE company_id = ${company_id}`
      });

      if (!companyResult.rows || companyResult.rows.length === 0) {
        return NextResponse.json(
          { success: false, error: `회사 ID ${company_id}를 찾을 수 없습니다` },
          { status: 404 }
        );
      }
    }

    // Calculate amounts
    const unitPrice = unit_price || 0;
    const taxResult = calculateTax({ 
      quantity: Math.abs(quantity), 
      unitPrice: unitPrice,
      taxRate: 0.1 // 10% tax rate
    });
    const totalAmount = taxResult.subtotalAmount;
    const taxAmount = taxResult.taxAmount;
    const grandTotal = taxResult.grandTotal;

    // Calculate new stock
    let newStock = currentStock;
    if (['입고', '생산입고'].includes(transaction_type)) {
      newStock += Math.abs(quantity);
    } else if (['출고', '생산출고', '폐기'].includes(transaction_type)) {
      newStock -= Math.abs(quantity);
    }

    // Create inventory transaction
    const transactionResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        INSERT INTO inventory_transactions (
          transaction_date,
          transaction_type,
          item_id,
          company_id,
          quantity,
          unit_price,
          total_amount,
          tax_amount,
          grand_total,
          document_number,
          reference_number,
          warehouse_id,
          location,
          lot_number,
          expiry_date,
          status,
          notes,
          created_at
        ) VALUES (
          '${transaction_date || new Date().toISOString().split('T')[0]}',
          '${transaction_type}',
          ${item_id},
          ${company_id || 'NULL'},
          ${quantity},
          ${unitPrice},
          ${totalAmount},
          ${taxAmount},
          ${grandTotal},
          '${reference_id || ''}',
          '${reference_id || ''}',
          ${warehouse_id || 'NULL'},
          '${location || ''}',
          '${lot_number || ''}',
          ${expiry_date ? `'${expiry_date}'` : 'NULL'},
          '완료',
          '${note || ''}',
          NOW()
        )
        RETURNING transaction_id
      `
    });

    if (!transactionResult.rows || transactionResult.rows.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Failed to create inventory transaction' },
        { status: 500 }
      );
    }

    const transactionId = transactionResult.rows[0].transaction_id;

    // Update item stock
    await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        UPDATE items 
        SET current_stock = ${newStock},
            updated_at = NOW()
        WHERE item_id = ${item_id}
      `
    });

    return NextResponse.json({
      success: true,
      message: `재고 트랜잭션이 성공적으로 생성되었습니다 (새 재고: ${newStock})`,
      data: {
        transaction_id: transactionId,
        newStock
      }
    });

  } catch (error) {
    console.error('Error creating inventory transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: `Failed to create inventory transaction: ${error instanceof Error ? error.message : 'Unknown error'}`
      },
      { status: 500 }
    );
  }
  },
  { resource: 'inventory', action: 'create', requireAuth: false }
);
```


#### 📄 src\app\api\inventory\shipping\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const { data: transactions, error } = await supabase
      .from('inventory_transactions')
      .select('*')
      .eq('transaction_type', '출고')
      .order('transaction_date', { ascending: false });

    if (error) {
      console.error('Supabase query error:', error);
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, data: { transactions: transactions || [] } });
  } catch (error) {
    console.error('Error fetching shipping history:', error);
    return NextResponse.json({ success: false, error: 'Failed to fetch shipping history' }, { status: 500 });
  }
}

/**
 * POST /api/inventory/shipping
 * Create new shipping transaction
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const {
      transaction_date,
      item_id,
      quantity,
      unit_price,
      company_id,
      reference_number,
      lot_no,
      expiry_date,
      to_location,
      notes,
      created_by
    } = body;

    // 필수 필드 검증
    if (!transaction_date || !item_id || !quantity || unit_price === undefined || !created_by) {
      return NextResponse.json({
        success: false,
        error: '필수 필드가 누락되었습니다. (거래일자, 품목, 수량, 단가, 작성자 필수)'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: '수량은 0보다 커야 합니다.'
      }, { status: 400 });
    }

    if (unit_price < 0) {
      return NextResponse.json({
        success: false,
        error: '단가는 0 이상이어야 합니다.'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if item exists and is active
    const { data: item, error: itemError } = await supabase
      .from('items')
      .select('item_id, item_name, unit, is_active')
      .eq('item_id', item_id)
      .single();

    if (itemError || !item) {
      return NextResponse.json({
        success: false,
        error: '존재하지 않는 품목입니다.'
      }, { status: 404 });
    }

    if (!item.is_active) {
      return NextResponse.json({
        success: false,
        error: '비활성화된 품목입니다.'
      }, { status: 400 });
    }

    // 거래처 존재 및 활성 상태 확인 (company_id가 있는 경우)
    if (company_id) {
      const { data: company, error: companyError } = await supabase
        .from('companies')
        .select('company_id, company_name, company_type, is_active')
        .eq('company_id', company_id)
        .single();

      if (companyError || !company) {
        return NextResponse.json({
          success: false,
          error: '존재하지 않는 거래처입니다.'
        }, { status: 404 });
      }

      if (!company.is_active) {
        return NextResponse.json({
          success: false,
          error: '비활성화된 거래처입니다.'
        }, { status: 400 });
      }
    }

    // Calculate total amount
    const total_amount = quantity * unit_price;

    // Insert shipping transaction
    const { data, error } = await supabase
      .from('inventory_transactions')
      .insert([{
        item_id,
        company_id,
        user_id: created_by,
        created_by,
        transaction_type: '출고',
        quantity,
        unit_price,
        total_amount,
        to_location,
        lot_no,
        expiry_date,
        reference_number,
        transaction_date,
        notes,
        document_status: 'DRAFT'
      }])
      .select(`
        *,
        items!inner(item_code, item_name, spec, unit),
        companies(company_name),
        users!created_by(username)
      `);

    if (error) {
      console.error('Supabase insert error:', error);
      return NextResponse.json({
        success: false,
        error: '출고 등록 중 오류가 발생했습니다.',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: '출고가 성공적으로 등록되었습니다.',
      data: data[0]
    });
  } catch (error) {
    console.error('Error creating shipping transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: '출고 등록 중 오류가 발생했습니다.',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * PUT /api/inventory/shipping
 * Update existing shipping transaction
 */
export async function PUT(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const { id, ...updateData } = body;

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'Transaction ID is required'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if transaction exists and is a shipping transaction
    const { data: existingTransaction, error: existingError } = await supabase
      .from('inventory_transactions')
      .select('*')
      .eq('transaction_id', id)
      .eq('transaction_type', '출고')
      .single();

    if (existingError || !existingTransaction) {
      return NextResponse.json({
        success: false,
        error: 'Shipping transaction not found'
      }, { status: 404 });
    }

    // Validate fields if being updated
    if (updateData.quantity !== undefined && updateData.quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'Quantity must be greater than 0'
      }, { status: 400 });
    }

    if (updateData.unit_price !== undefined && updateData.unit_price < 0) {
      return NextResponse.json({
        success: false,
        error: 'Unit price cannot be negative'
      }, { status: 400 });
    }

    // Recalculate total amount if quantity or unit_price is updated
    if (updateData.quantity !== undefined || updateData.unit_price !== undefined) {
      const newQuantity = updateData.quantity ?? existingTransaction.quantity;
      const newUnitPrice = updateData.unit_price ?? existingTransaction.unit_price;
      updateData.total_amount = newQuantity * newUnitPrice;
    }

    // Update transaction
    const { data, error } = await supabase
      .from('inventory_transactions')
      .update({
        ...updateData,
        updated_at: new Date().toISOString()
      })
      .eq('transaction_id', id)
      .select(`
        *,
        items!inner(item_code, item_name, spec, unit),
        companies(company_name),
        users!created_by(username)
      `);

    if (error) {
      console.error('Supabase update error:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to update shipping transaction',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: 'Shipping transaction updated successfully',
      data: data[0]
    });
  } catch (error) {
    console.error('Error updating shipping transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to update shipping transaction',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/inventory/shipping
 * Delete shipping transaction
 */
export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'Transaction ID is required'
      }, { status: 400 });
    }

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if transaction exists and is a shipping transaction
    const { data: existingTransaction, error: existingError } = await supabase
      .from('inventory_transactions')
      .select('transaction_id')
      .eq('transaction_id', id)
      .eq('transaction_type', '출고')
      .single();

    if (existingError || !existingTransaction) {
      return NextResponse.json({
        success: false,
        error: 'Shipping transaction not found'
      }, { status: 404 });
    }

    // Delete transaction
    const { error } = await supabase
      .from('inventory_transactions')
      .delete()
      .eq('transaction_id', id);

    if (error) {
      console.error('Supabase delete error:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to delete shipping transaction',
        details: error.message
      }, { status: 500 });
    }

    return NextResponse.json({
      success: true,
      message: 'Shipping transaction deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting shipping transaction:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to delete shipping transaction',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\inventory\shipping\stock-check\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db, SupabaseQueryBuilder, handleSupabaseError, createSuccessResponse, getSupabaseClient } from '@/lib/db-unified';
import { createClient } from '@supabase/supabase-js';

/**
 * GET /api/inventory/shipping/stock-check
 * Check stock availability for shipping multiple items
 * Query parameters:
 * - items: JSON string of items to check [{"item_id": 1, "quantity": 5}, ...]
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const itemsParam = searchParams.get('items');

    if (!itemsParam) {
      return NextResponse.json({
        success: false,
        error: 'items parameter is required. Format: [{"item_id": 1, "quantity": 5}, ...]'
      }, { status: 400 });
    }

    let items;
    try {
      items = JSON.parse(itemsParam);
    } catch (parseError) {
      return NextResponse.json({
        success: false,
        error: 'items parameter must be valid JSON'
      }, { status: 400 });
    }

    if (!Array.isArray(items) || items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'items must be a non-empty array'
      }, { status: 400 });
    }

    // Validate each item in the array
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (!item.item_id || !item.quantity) {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i} must have item_id and quantity`
        }, { status: 400 });
      }

      if (typeof item.item_id !== 'number' || typeof item.quantity !== 'number') {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i}: item_id and quantity must be numbers`
        }, { status: 400 });
      }

      if (item.quantity <= 0) {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i}: quantity must be greater than 0`
        }, { status: 400 });
      }
    }

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check stock availability for each item
    const stockCheckResults = await Promise.all(
      items.map(async (item, index) => {
        try {
          // Get item information using safe Supabase client
          const { data: itemData, error: itemError } = await supabase
            .from('items')
            .select('item_id, item_code, item_name, unit, category, price, is_active, current_stock')
            .eq('item_id', item.item_id)
            .single();

          if (itemError || !itemData) {
            return {
              index,
              item_id: item.item_id,
              error: `Item with ID ${item.item_id} not found`,
              sufficient: false
            };
          }

          if (!itemData.is_active) {
            return {
              index,
              item_id: item.item_id,
              item_code: itemData.item_code,
              item_name: itemData.item_name,
              error: `Item ${itemData.item_name} is not active`,
              sufficient: false
            };
          }

          const currentStock = itemData.current_stock || 0;
          const requested = item.quantity;
          const shortage = Math.max(0, requested - currentStock);

          return {
            index,
            item_id: item.item_id,
            item_code: itemData.item_code,
            item_name: itemData.item_name,
            category: itemData.category,
            unit: itemData.unit,
            unit_price: itemData.price || 0,
            requested_quantity: requested,
            current_stock: currentStock,
            sufficient: currentStock >= requested,
            shortage: shortage,
            availability_percentage: currentStock > 0 ? Math.round((Math.min(requested, currentStock) / requested) * 10000) / 100 : 0,
            total_value: requested * (itemData.price || 0)
          };
        } catch (itemError) {
          console.error(`Error checking item ${item.item_id}:`, itemError);
          return {
            index,
            item_id: item.item_id,
            error: `Error checking item: ${itemError instanceof Error ? itemError.message : 'Unknown error'}`,
            sufficient: false
          };
        }
      })
    );

    // Filter out items with errors for summary calculations
    const validResults = stockCheckResults.filter(result => !result.error);
    const errorResults = stockCheckResults.filter(result => result.error);

    const canShipAll = validResults.every(item => item.sufficient);
    const insufficientItems = validResults.filter(item => !item.sufficient);
    const sufficientItems = validResults.filter(item => item.sufficient);

    // Calculate totals
    const totalValue = validResults.reduce((sum, item) => sum + (item.total_value || 0), 0);
    const totalShortageValue = insufficientItems.reduce(
      (sum, item) => sum + ((item.shortage || 0) * (item.unit_price || 0)),
      0
    );

    return NextResponse.json({
      success: true,
      data: {
        can_ship_all: canShipAll && errorResults.length === 0,
        stock_check_results: stockCheckResults,
        valid_items: validResults,
        error_items: errorResults,
        sufficient_items: sufficientItems,
        insufficient_items: insufficientItems,
        summary: {
          total_items_requested: items.length,
          valid_items: validResults.length,
          error_items: errorResults.length,
          sufficient_items: sufficientItems.length,
          insufficient_items: insufficientItems.length,
          total_order_value: Math.round(totalValue * 100) / 100,
          total_shortage_value: Math.round(totalShortageValue * 100) / 100,
          fulfillment_rate: validResults.length > 0 ?
            Math.round((sufficientItems.length / validResults.length) * 10000) / 100 : 0
        }
      }
    });
  } catch (error) {
    console.error('Error checking stock availability:', error);

    const errorMessage = error instanceof Error ? error.message : 'Failed to check stock availability';

    return NextResponse.json(
      {
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/inventory/shipping/stock-check
 * Check stock availability for shipping (alternative method using POST body)
 * Body: {
 *   items: Array<{
 *     item_id: number,
 *     quantity: number
 *   }>
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { items } = body;

    if (!items || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'items must be a non-empty array'
      }, { status: 400 });
    }

    // Validate each item
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (!item.item_id || !item.quantity) {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i} must have item_id and quantity`
        }, { status: 400 });
      }

      if (typeof item.item_id !== 'number' || typeof item.quantity !== 'number') {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i}: item_id and quantity must be numbers`
        }, { status: 400 });
      }

      if (item.quantity <= 0) {
        return NextResponse.json({
          success: false,
          error: `Item at index ${i}: quantity must be greater than 0`
        }, { status: 400 });
      }
    }

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Use the same logic as GET but with items from body
    const stockCheckResults = await Promise.all(
      items.map(async (item, index) => {
        try {
          // Get item information using Supabase MCP with correct schema
          const itemResult = await mcp__supabase__execute_sql({
            project_id: projectId,
            query: `SELECT item_id, item_code, item_name, unit, category, price, is_active, current_stock 
                    FROM items 
                    WHERE item_id = ${item.item_id}`
          });

          if (!itemResult.rows || itemResult.rows.length === 0) {
            return {
              index,
              item_id: item.item_id,
              error: `Item with ID ${item.item_id} not found`,
              sufficient: false
            };
          }

          const itemData = itemResult.rows[0];

          if (!itemData.is_active) {
            return {
              index,
              item_id: item.item_id,
              item_code: itemData.item_code,
              item_name: itemData.item_name,
              error: `Item ${itemData.item_name} is not active`,
              sufficient: false
            };
          }

          const currentStock = itemData.current_stock || 0;
          const requested = item.quantity;
          const shortage = Math.max(0, requested - currentStock);

          return {
            index,
            item_id: item.item_id,
            item_code: itemData.item_code,
            item_name: itemData.item_name,
            category: itemData.category,
            unit: itemData.unit,
            unit_price: itemData.price || 0,
            requested_quantity: requested,
            current_stock: currentStock,
            sufficient: currentStock >= requested,
            shortage: shortage,
            availability_percentage: currentStock > 0 ? Math.round((Math.min(requested, currentStock) / requested) * 10000) / 100 : 0,
            total_value: requested * (itemData.price || 0)
          };
        } catch (itemError) {
          console.error(`Error checking item ${item.item_id}:`, itemError);
          return {
            index,
            item_id: item.item_id,
            error: `Error checking item: ${itemError instanceof Error ? itemError.message : 'Unknown error'}`,
            sufficient: false
          };
        }
      })
    );

    // Filter out items with errors for summary calculations
    const validResults = stockCheckResults.filter(result => !result.error);
    const errorResults = stockCheckResults.filter(result => result.error);

    const canShipAll = validResults.every(item => item.sufficient);
    const insufficientItems = validResults.filter(item => !item.sufficient);
    const sufficientItems = validResults.filter(item => item.sufficient);

    // Calculate totals
    const totalValue = validResults.reduce((sum, item) => sum + (item.total_value || 0), 0);
    const totalShortageValue = insufficientItems.reduce(
      (sum, item) => sum + ((item.shortage || 0) * (item.unit_price || 0)),
      0
    );

    return NextResponse.json({
      success: true,
      data: {
        can_ship_all: canShipAll && errorResults.length === 0,
        stock_check_results: stockCheckResults,
        valid_items: validResults,
        error_items: errorResults,
        sufficient_items: sufficientItems,
        insufficient_items: insufficientItems,
        summary: {
          total_items_requested: items.length,
          valid_items: validResults.length,
          error_items: errorResults.length,
          sufficient_items: sufficientItems.length,
          insufficient_items: insufficientItems.length,
          total_order_value: Math.round(totalValue * 100) / 100,
          total_shortage_value: Math.round(totalShortageValue * 100) / 100,
          fulfillment_rate: validResults.length > 0 ?
            Math.round((sufficientItems.length / validResults.length) * 10000) / 100 : 0
        }
      }
    });
  } catch (error) {
    console.error('Error checking stock availability:', error);

    const errorMessage = error instanceof Error ? error.message : 'Failed to check stock availability';

    return NextResponse.json(
      {
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\inventory\stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabase, handleSupabaseError, createSuccessResponse } from '@/lib/db-unified';

/**
 * GET /api/inventory/stock
 * Get current stock levels for all items
 * Query parameters:
 * - item_id: Filter by specific item
 * - category: Filter by item category
 * - low_stock: Show only items below reorder level
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const itemId = searchParams.get('item_id');
    const category = searchParams.get('category');
    const lowStock = searchParams.get('low_stock');

    // Build query using Supabase client
    let query = supabase
      .from('items')
      .select(`
        item_id,
        item_code,
        item_name,
        spec,
        unit,
        item_type,
        current_stock,
        min_stock_level,
        safety_stock,
        unit_price
      `)
      .eq('is_active', true);

    // Apply filters
    if (itemId) {
      query = query.eq('item_id', parseInt(itemId));
    }

    if (category) {
      query = query.eq('item_type', category);
    }

    if (lowStock === 'true') {
      // Filter for items where current_stock <= min_stock_level
      query = query.lte('current_stock', 'min_stock_level');
    }

    query = query.order('item_code', { ascending: true });

    const { data: stockData, error } = await query;

    if (error) {
      return NextResponse.json(
        handleSupabaseError('GET', 'items', error),
        { status: 500 }
      );
    }

    // Calculate stock status and summary statistics for each item
    const enrichedData = stockData.map((item: any) => {
      const stockStatus =
        item.current_stock <= (item.min_stock_level || 0) ? 'LOW' :
        item.current_stock > (item.min_stock_level || 0) * 2 ? 'HIGH' :
        'NORMAL';

      return {
        ...item,
        stock_status: stockStatus,
        calculated_stock: item.current_stock // Use current_stock as calculated value
      };
    });

    // Calculate summary statistics
    const summary = {
      total_items: enrichedData.length,
      low_stock_items: enrichedData.filter((item: any) => item.stock_status === 'LOW').length,
      total_value: enrichedData.reduce((sum: number, item: any) =>
        sum + (item.current_stock * (item.unit_price || 0)), 0
      )
    };

    return NextResponse.json({
      success: true,
      data: {
        items: enrichedData,
        summary
      }
    });
  } catch (error) {
    console.error('Error fetching stock data:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch stock data'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\inventory\transactions\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db, SupabaseQueryBuilder, handleSupabaseError, createSuccessResponse, getSupabaseClient } from '@/lib/db-unified';
import { nextSerial, getTransactionPrefix } from '@/lib/serial';
import { logger, logApiCall, logBusinessEvent } from '@/lib/logger';
import { createClient } from '@supabase/supabase-js';

// GET: 재고 이동 목록 조회
export async function GET(request: NextRequest) {
  const startTime = Date.now();
  const correlationId = request.headers.get('x-correlation-id') ||
                       `inventory_transactions_get_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  logger.setCorrelationId(correlationId);

  try {
    logger.debug('재고 이동 목록 조회 요청 시작');
    const searchParams = request.nextUrl.searchParams;
    const search = searchParams.get('search');
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');
    const warehouse = searchParams.get('warehouse');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_date,
        item_id,
        quantity,
        notes,
        document_number,
        status,
        transaction_type,
        items!inner(item_code, item_name, unit)
      `)
      .in('transaction_type', ['입고', '출고', '생산입고', '생산출고', '이동', '조정', '폐기', '재고조정']);

    // Apply filters safely
    if (startDate) {
      query = query.gte('transaction_date', startDate);
    }

    if (endDate) {
      query = query.lte('transaction_date', endDate);
    }

    if (warehouse) {
      query = query.eq('warehouse_id', warehouse);
    }

    if (search) {
      query = query.or(`items.item_code.ilike.%${search}%,items.item_name.ilike.%${search}%`);
    }

    // Apply ordering and limit
    query = query
      .order('transaction_date', { ascending: false })
      .limit(100);

    const { data: transactions, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to match expected format
    const formattedTransfers = transactions?.map((t: any) => ({
      id: t.transaction_id,
      transfer_date: t.transaction_date,
      item_id: t.item_id,
      item_code: t.items?.item_code,
      item_name: t.items?.item_name,
      quantity: t.quantity,
      unit: t.items?.unit,
      notes: t.notes,
      document_number: t.document_number,
      document_status: t.status,
      transaction_type: t.transaction_type,
      from_warehouse: 'Main',
      to_warehouse: 'Sub'
    })) || [];

    const responseTime = Date.now() - startTime;
    logApiCall('GET', '/api/inventory/transactions', 200, responseTime);
    logger.info(`재고 이동 목록 조회 완료: ${formattedTransfers.length}개 이동내역`, {
      transferCount: formattedTransfers.length,
      filters: { search, startDate, endDate, warehouse }
    });

    return NextResponse.json({
      success: true,
      data: formattedTransfers,
      meta: {
        total: formattedTransfers.length,
        responseTime
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    logApiCall('GET', '/api/inventory/transactions', 500, responseTime);
    logger.error('재고 이동 목록 조회 실패', error as Error);
    
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch inventory transactions'
    }, { status: 500 });
  }
}

// POST: 재고 이동 등록
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  const correlationId = request.headers.get('x-correlation-id') ||
                       `inventory_transactions_post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  logger.setCorrelationId(correlationId);

  try {
    logger.debug('재고 이동 등록 요청 시작');
    const body = await request.json();
    const {
      item_id,
      quantity,
      transaction_type,
      from_warehouse_id,
      to_warehouse_id,
      notes,
      transfer_date
    } = body;

    // Validate required fields
    if (!item_id || !quantity || !transaction_type) {
      return NextResponse.json({
        success: false,
        error: 'item_id, quantity, and transaction_type are required'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'quantity must be greater than 0'
      }, { status: 400 });
    }

    // Validate transaction type
    const validTypes = ['입고', '출고', '생산입고', '생산출고', '이동', '조정', '폐기', '재고조정'];
    if (!validTypes.includes(transaction_type)) {
      return NextResponse.json({
        success: false,
        error: `Invalid transaction_type. Must be one of: ${validTypes.join(', ')}`
      }, { status: 400 });
    }

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Get transaction prefix and generate document number
    const prefix = getTransactionPrefix(transaction_type);
    const documentNumber = await nextSerial(prefix);

    // Create inventory transaction using Supabase MCP
    const createResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        INSERT INTO inventory_transactions (
          transaction_date,
          transaction_type,
          item_id,
          quantity,
          warehouse_id,
          notes,
          document_number,
          status,
          created_at
        ) VALUES (
          '${transfer_date || new Date().toISOString().split('T')[0]}',
          '${transaction_type}',
          ${item_id},
          ${quantity},
          ${from_warehouse_id || 'NULL'},
          '${notes || ''}',
          '${documentNumber}',
          '완료',
          NOW()
        )
        RETURNING transaction_id
      `
    });

    if (!createResult.rows || createResult.rows.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Failed to create transaction'
      }, { status: 500 });
    }

    const transactionId = createResult.rows[0].transaction_id;

    // Update item stock if it's an inventory transaction
    if (['입고', '생산입고'].includes(transaction_type)) {
      await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `
          UPDATE items 
          SET current_stock = current_stock + ${quantity},
              updated_at = NOW()
          WHERE item_id = ${item_id}
        `
      });
    } else if (['출고', '생산출고', '폐기'].includes(transaction_type)) {
      // Check if sufficient stock exists
      const stockResult = await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `SELECT current_stock FROM items WHERE item_id = ${item_id}`
      });

      if (!stockResult.rows || stockResult.rows.length === 0) {
        return NextResponse.json({
          success: false,
          error: 'Item not found'
        }, { status: 404 });
      }

      const currentStock = stockResult.rows[0].current_stock || 0;
      if (currentStock < quantity) {
        return NextResponse.json({
          success: false,
          error: `Insufficient stock. Available: ${currentStock}, Required: ${quantity}`
        }, { status: 400 });
      }

      await mcp__supabase__execute_sql({
        project_id: projectId,
        query: `
          UPDATE items 
          SET current_stock = current_stock - ${quantity},
              updated_at = NOW()
          WHERE item_id = ${item_id}
        `
      });
    }

    const responseTime = Date.now() - startTime;
    logApiCall('POST', '/api/inventory/transactions', 201, responseTime);
    logBusinessEvent('재고 이동 등록', '재고 이동', transactionId, 1, {
      item_id,
      quantity,
      from_warehouse: from_warehouse_id,
      to_warehouse: to_warehouse_id,
      transaction_type
    });

    logger.info('재고 이동 등록 완료', {
      transactionId,
      item_id,
      quantity,
      transaction_type
    });

    return NextResponse.json({
      success: true,
      data: {
        transaction_id: transactionId,
        document_number: documentNumber,
        message: 'Inventory transaction created successfully'
      }
    }, { status: 201 });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    logApiCall('POST', '/api/inventory/transactions', 500, responseTime);
    logger.error('재고 이동 등록 실패', error as Error);
    
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create inventory transaction'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\inventory\transactions\[id]\history\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/db-unified';
import { getDocumentStatusHistory, getDocumentStatusHistoryByNumber, getStatusLabel } from '@/lib/workflow';

/**
 * GET /api/inventory/transactions/[id]/history
 * 문서의 상태 변경 이력을 조회합니다
 */
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const transactionId = parseInt(id);

    if (isNaN(transactionId)) {
      return NextResponse.json({
        success: false,
        error: '유효하지 않은 거래 ID입니다.'
      }, { status: 400 });
    }

    // 거래 존재 여부 확인
    const { data: transaction, error: txError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_id, document_number, status, transaction_type, transaction_date')
      .eq('transaction_id', transactionId)
      .eq('is_active', true)
      .single();

    if (txError || !transaction) {
      return NextResponse.json({
        success: false,
        error: '거래를 찾을 수 없습니다.'
      }, { status: 404 });
    }

    // 상태 변경 이력 조회
    const history = await getDocumentStatusHistory('INVENTORY_TRANSACTION', transactionId);

    // 이력을 사용자 정보와 함께 조회
    const detailedHistory = await Promise.all(
      history.map(async (record) => {
        const { data: user } = await supabaseAdmin
          .from('users')
          .select('user_id, username')
          .eq('user_id', record.changed_by)
          .single();

        return {
          id: record.id,
          document_number: record.document_number,
          previous_status: record.previous_status,
          new_status: record.new_status,
          previous_status_label: record.previous_status ? getStatusLabel(record.previous_status) : null,
          new_status_label: getStatusLabel(record.new_status),
          changed_by: record.changed_by,
          changed_by_name: user?.username || '알 수 없음',
          change_reason: record.change_reason,
          created_at: record.created_at
        };
      })
    );

    return NextResponse.json({
      success: true,
      data: {
        transaction: {
          transaction_id: transaction.transaction_id,
          document_number: transaction.document_number,
          current_status: transaction.status,
          current_status_label: getStatusLabel(transaction.status as any),
          transaction_type: transaction.transaction_type,
          transaction_date: transaction.transaction_date
        },
        history: detailedHistory,
        history_count: detailedHistory.length
      }
    });
  } catch (error) {
    console.error('Error fetching document history:', error);
    return NextResponse.json({
      success: false,
      error: '문서 이력 조회 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}

/**
 * POST /api/inventory/transactions/[id]/history
 * 문서 번호로 상태 변경 이력을 조회합니다 (향후 확장을 위한 엔드포인트)
 */
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const body = await request.json();
    const { document_number } = body;

    if (!document_number) {
      return NextResponse.json({
        success: false,
        error: '문서 번호가 필요합니다.'
      }, { status: 400 });
    }

    // 문서 번호로 상태 변경 이력 조회
    const history = await getDocumentStatusHistoryByNumber(document_number);

    if (history.length === 0) {
      return NextResponse.json({
        success: false,
        error: '해당 문서 번호의 이력을 찾을 수 없습니다.'
      }, { status: 404 });
    }

    // 이력을 사용자 정보와 함께 조회
    const detailedHistory = await Promise.all(
      history.map(async (record) => {
        const { data: user } = await supabaseAdmin
          .from('users')
          .select('user_id, username')
          .eq('user_id', record.changed_by)
          .single();

        return {
          id: record.id,
          document_type: record.document_type,
          document_id: record.document_id,
          document_number: record.document_number,
          previous_status: record.previous_status,
          new_status: record.new_status,
          previous_status_label: record.previous_status ? getStatusLabel(record.previous_status) : null,
          new_status_label: getStatusLabel(record.new_status),
          changed_by: record.changed_by,
          changed_by_name: user?.username || '알 수 없음',
          change_reason: record.change_reason,
          created_at: record.created_at
        };
      })
    );

    return NextResponse.json({
      success: true,
      data: {
        document_number: document_number,
        history: detailedHistory,
        history_count: detailedHistory.length
      }
    });
  } catch (error) {
    console.error('Error fetching document history by number:', error);
    return NextResponse.json({
      success: false,
      error: '문서 이력 조회 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\inventory\transactions\[id]\status\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/db-unified';
import { transitDocumentStatus, canTransitTo, getStatusLabel, getNextPossibleStates } from '@/lib/workflow';

interface StatusTransitionRequest {
  new_status: 'DRAFT' | 'APPROVED' | 'CONFIRMED' | 'CANCELED';
  change_reason?: string;
  changed_by: number;
}

/**
 * GET /api/inventory/transactions/[id]/status
 * 문서 상태와 가능한 전이 상태를 조회합니다
 */
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const transactionId = parseInt(id);

    if (isNaN(transactionId)) {
      return NextResponse.json({
        success: false,
        error: '유효하지 않은 거래 ID입니다.'
      }, { status: 400 });
    }

    // 현재 문서 상태 조회
    const { data: transaction, error: txError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_id, document_number, status, transaction_type, created_at, updated_at')
      .eq('transaction_id', transactionId)
      .eq('is_active', true)
      .single();

    if (txError || !transaction) {
      return NextResponse.json({
        success: false,
        error: '거래를 찾을 수 없습니다.'
      }, { status: 404 });
    }
    const currentStatus = transaction.status as 'DRAFT' | 'APPROVED' | 'CONFIRMED' | 'CANCELED';
    const nextPossibleStates = getNextPossibleStates(currentStatus);

    return NextResponse.json({
      success: true,
      data: {
        transaction_id: transaction.transaction_id,
        document_number: transaction.document_number,
        current_status: currentStatus,
        current_status_label: getStatusLabel(currentStatus),
        next_possible_states: nextPossibleStates.map(status => ({
          status,
          label: getStatusLabel(status)
        })),
        can_change_status: nextPossibleStates.length > 0,
        transaction_type: transaction.transaction_type,
        created_at: transaction.created_at,
        updated_at: transaction.updated_at
      }
    });
  } catch (error) {
    console.error('Error fetching document status:', error);
    return NextResponse.json({
      success: false,
      error: '문서 상태 조회 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}

/**
 * PUT /api/inventory/transactions/[id]/status
 * 문서 상태를 전이합니다
 */
export async function PUT(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    const transactionId = parseInt(id);

    if (isNaN(transactionId)) {
      return NextResponse.json({
        success: false,
        error: '유효하지 않은 거래 ID입니다.'
      }, { status: 400 });
    }

    const text = await request.text();
    const body: StatusTransitionRequest = JSON.parse(text);
    const { new_status, change_reason, changed_by } = body;

    // 필수 필드 검증
    if (!new_status || !changed_by) {
      return NextResponse.json({
        success: false,
        error: '새 상태와 변경자는 필수입니다.'
      }, { status: 400 });
    }

    // 유효한 상태값 검증
    const validStatuses = ['DRAFT', 'APPROVED', 'CONFIRMED', 'CANCELED'];
    if (!validStatuses.includes(new_status)) {
      return NextResponse.json({
        success: false,
        error: '유효하지 않은 상태입니다.'
      }, { status: 400 });
    }

    // 현재 문서 정보 조회
    const { data: transaction, error: txError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_id, document_number, status, transaction_type')
      .eq('transaction_id', transactionId)
      .eq('is_active', true)
      .single();

    if (txError || !transaction) {
      return NextResponse.json({
        success: false,
        error: '거래를 찾을 수 없습니다.'
      }, { status: 404 });
    }
    const currentStatus = transaction.status as 'DRAFT' | 'APPROVED' | 'CONFIRMED' | 'CANCELED';
    const documentNumber = transaction.document_number;

    // 문서 번호 검증
    if (!documentNumber) {
      return NextResponse.json({
        success: false,
        error: '문서 번호가 없습니다.'
      }, { status: 400 });
    }

    // 상태 전이 가능성 검증
    if (!canTransitTo(currentStatus, new_status)) {
      const nextPossibleStates = getNextPossibleStates(currentStatus);
      return NextResponse.json({
        success: false,
        error: `${getStatusLabel(currentStatus)}에서 ${getStatusLabel(new_status)}로 전이할 수 없습니다. 가능한 상태: ${nextPossibleStates.map(s => getStatusLabel(s)).join(', ')}`
      }, { status: 400 });
    }

    // 취소 시 사유 필수 검증
    if (new_status === 'CANCELED' && (!change_reason || change_reason.trim().length === 0)) {
      return NextResponse.json({
        success: false,
        error: '취소 시 사유는 필수입니다.'
      }, { status: 400 });
    }

    // 상태 전이 실행
    await transitDocumentStatus(
      'INVENTORY_TRANSACTION',
      transactionId,
      documentNumber,
      currentStatus,
      new_status,
      changed_by,
      change_reason
    );

    // 업데이트된 정보 조회
    const { data: updatedTransaction } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_id, document_number, status, transaction_type, updated_at')
      .eq('transaction_id', transactionId)
      .single();

    return NextResponse.json({
      success: true,
      message: `문서 상태가 ${getStatusLabel(currentStatus)}에서 ${getStatusLabel(new_status)}로 변경되었습니다.`,
      data: {
        transaction_id: transactionId,
        document_number: documentNumber,
        previous_status: currentStatus,
        new_status: new_status,
        previous_status_label: getStatusLabel(currentStatus),
        new_status_label: getStatusLabel(new_status),
        change_reason: change_reason || null,
        changed_by: changed_by,
        updated_at: updatedTransaction?.updated_at,
        next_possible_states: getNextPossibleStates(new_status).map(status => ({
          status,
          label: getStatusLabel(status)
        }))
      }
    });
  } catch (error) {
    console.error('Error changing document status:', error);

    if (error instanceof Error && error.message.includes('상태 전이가 불가능합니다')) {
      return NextResponse.json({
        success: false,
        error: error.message
      }, { status: 400 });
    }

    return NextResponse.json({
      success: false,
      error: '문서 상태 변경 중 오류가 발생했습니다.'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\inventory\transfers\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db, SupabaseQueryBuilder, handleSupabaseError, createSuccessResponse, getSupabaseClient } from '@/lib/db-unified';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const dateFrom = searchParams.get('dateFrom');
    const dateTo = searchParams.get('dateTo');
    const warehouseFrom = searchParams.get('from');
    const warehouseTo = searchParams.get('to');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_date,
        item_id,
        quantity,
        unit_price,
        warehouse_id,
        location,
        notes,
        created_by,
        created_at,
        items!inner(item_code, item_name, spec, unit),
        users!inner(username)
      `)
      .eq('transaction_type', '이동')
      .eq('status', '완료');

    // Apply filters safely
    if (dateFrom) {
      query = query.gte('transaction_date', dateFrom);
    }

    if (dateTo) {
      query = query.lte('transaction_date', dateTo);
    }

    if (warehouseFrom) {
      query = query.eq('warehouse_id', warehouseFrom);
    }

    // Apply ordering and limit
    query = query
      .order('transaction_date', { ascending: false })
      .order('created_at', { ascending: false })
      .limit(100);

    const { data: transfers, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to match expected format
    const formattedTransfers = (transfers || []).map((t: any) => ({
      transaction_id: t.transaction_id,
      transaction_date: t.transaction_date,
      item_id: t.item_id,
      item_code: t.items?.item_code,
      item_name: t.items?.item_name,
      spec: t.items?.spec,
      quantity: t.quantity,
      unit: t.items?.unit,
      warehouse_from: t.warehouse_id,
      warehouse_to: null, // Not available in current schema
      notes: t.notes,
      created_by: t.created_by,
      created_by_name: t.users?.username,
      created_at: t.created_at
    }));

    return NextResponse.json({
      success: true,
      data: formattedTransfers
    });

  } catch (error) {
    console.error('Error fetching transfers:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch transfers'
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      item_id,
      quantity,
      warehouse_from,
      warehouse_to,
      notes,
      transaction_date
    } = body;

    // Validate required fields
    if (!item_id || !quantity || !warehouse_from || !warehouse_to) {
      return NextResponse.json({
        success: false,
        error: 'item_id, quantity, warehouse_from, and warehouse_to are required'
      }, { status: 400 });
    }

    if (quantity <= 0) {
      return NextResponse.json({
        success: false,
        error: 'quantity must be greater than 0'
      }, { status: 400 });
    }

    const projectId = process.env.SUPABASE_PROJECT_ID || '';

    // Check if item exists and get current stock
    const itemCheckResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `SELECT item_id, item_code, item_name, current_stock FROM items WHERE item_id = ${item_id}`
    });

    if (!itemCheckResult.rows || itemCheckResult.rows.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Item not found'
      }, { status: 404 });
    }

    const item = itemCheckResult.rows[0];
    const currentStock = item.current_stock || 0;

    if (currentStock < quantity) {
      return NextResponse.json({
        success: false,
        error: `Insufficient stock. Available: ${currentStock}, Required: ${quantity}`
      }, { status: 400 });
    }

    // Create transfer transaction
    const transferResult = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        INSERT INTO inventory_transactions (
          transaction_date,
          transaction_type,
          item_id,
          quantity,
          warehouse_id,
          location,
          notes,
          status,
          created_at
        ) VALUES (
          '${transaction_date || new Date().toISOString().split('T')[0]}',
          '이동',
          ${item_id},
          ${quantity},
          ${warehouse_from},
          '${warehouse_to}',
          '${notes || ''}',
          '완료',
          NOW()
        )
        RETURNING transaction_id
      `
    });

    if (!transferResult.rows || transferResult.rows.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Failed to create transfer transaction'
      }, { status: 500 });
    }

    const transactionId = transferResult.rows[0].transaction_id;

    // Update item stock
    await mcp__supabase__execute_sql({
      project_id: projectId,
      query: `
        UPDATE items 
        SET current_stock = current_stock - ${quantity},
            updated_at = NOW()
        WHERE item_id = ${item_id}
      `
    });

    return NextResponse.json({
      success: true,
      data: {
        transaction_id: transactionId,
        message: 'Transfer created successfully',
        item_code: item.item_code,
        item_name: item.item_name,
        quantity: quantity,
        warehouse_from: warehouse_from,
        warehouse_to: warehouse_to
      }
    });

  } catch (error) {
    console.error('Error creating transfer:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create transfer'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\items\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseClient } from '@/lib/db-unified';
import { APIError, validateRequiredFields } from '@/lib/api-error-handler';
import type { Database } from '@/types/supabase';

type ItemRow = Database['public']['Tables']['items']['Row'];
type ItemInsert = Database['public']['Tables']['items']['Insert'];
type ItemUpdate = Database['public']['Tables']['items']['Update'];

type ItemType = 'RAW' | 'SUB' | 'FINISHED';
type MaterialType = 'COIL' | 'SHEET' | 'OTHER';

type NormalizedItemPayload = {
  item_code: string;
  item_name: string;
  category: ItemInsert['category'] | null;
  unit: string;
  item_type: ItemType | null;
  material_type: MaterialType | null;
  vehicle_model: string | null;
  material: string | null;
  spec: string | null;
  thickness: number | null;
  width: number | null;
  height: number | null;
  specific_gravity: number | null;
  mm_weight: number | null;
  daily_requirement: number | null;
  blank_size: number | null;
  price: number | null;
  safety_stock: number | null;
  current_stock: number | null;
  location: string | null;
  description: string | null;
};

const DEFAULT_LIMIT = 20;
const ALLOWED_ITEM_TYPES: ItemType[] = ['RAW', 'SUB', 'FINISHED'];
const ALLOWED_MATERIAL_TYPES: MaterialType[] = ['COIL', 'SHEET', 'OTHER'];

function handleError(error: unknown, fallbackMessage: string): NextResponse {
  if (error instanceof APIError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        details: error.details,
      },
      { status: error.statusCode }
    );
  }

  console.error('[items] Unexpected error:', error);
  return NextResponse.json(
    {
      success: false,
      error: fallbackMessage,
    },
    { status: 500 }
  );
}

function normalizeString(value: unknown): string | null {
  if (value === undefined || value === null) {
    return null;
  }

  const trimmed = String(value).trim();
  return trimmed.length > 0 ? trimmed : null;
}

function normalizeNumber(value: unknown): number | null {
  if (value === undefined || value === null || value === '') {
    return null;
  }

  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : null;
}

function normalizeInteger(value: unknown): number | null {
  const numeric = normalizeNumber(value);
  if (numeric === null) return null;
  return Math.trunc(numeric);
}

function normalizeItemType(value: unknown): ItemType | null {
  const str = normalizeString(value)?.toUpperCase() as ItemType | undefined;
  if (!str) return null;
  return ALLOWED_ITEM_TYPES.includes(str) ? str : null;
}

function normalizeMaterialType(value: unknown): MaterialType | null {
  const str = normalizeString(value)?.toUpperCase() as MaterialType | undefined;
  if (!str) return null;
  return ALLOWED_MATERIAL_TYPES.includes(str) ? str : null;
}

function computeMmWeight(payload: {
  thickness: number | null;
  width: number | null;
  height: number | null;
  blank_size: number | null;
  specific_gravity: number | null;
  material_type: MaterialType | null;
  mm_weight: number | null;
}): number | null {
  if (payload.mm_weight !== null && payload.mm_weight !== undefined) {
    return payload.mm_weight;
  }

  const { thickness, width, height, blank_size, specific_gravity, material_type } = payload;

  if (thickness === null || width === null) {
    return null;
  }

  const density = specific_gravity && specific_gravity > 0 ? specific_gravity : 7.85;

  if (density <= 0 || thickness <= 0 || width <= 0) {
    return null;
  }

  const thicknessCm = thickness / 10;
  const widthCm = width / 10;
  const lengthSource = blank_size && blank_size > 0 ? blank_size : height && height > 0 ? height : null;
  const lengthCm = lengthSource ? lengthSource / 10 : 100; // 기본값 1m (100cm)
  const volumeCm3 = thicknessCm * widthCm * lengthCm;
  const weightKg = (volumeCm3 * density) / 1000;
  return Number.isFinite(weightKg) ? Number(weightKg.toFixed(4)) : null;
}

function mapRow(row: ItemRow): ItemRow {
  return {
    ...row,
    thickness: row.thickness === null ? null : Number(row.thickness),
    width: row.width === null ? null : Number(row.width),
    height: row.height === null ? null : Number(row.height),
    specific_gravity: row.specific_gravity === null ? null : Number(row.specific_gravity),
    mm_weight: row.mm_weight === null ? null : Number(row.mm_weight),
    daily_requirement: row.daily_requirement === null ? null : Number(row.daily_requirement),
    blank_size: row.blank_size === null ? null : Number(row.blank_size),
    price: row.price === null ? null : Number(row.price),
    safety_stock: row.safety_stock === null ? null : Number(row.safety_stock),
    current_stock: row.current_stock === null ? null : Number(row.current_stock),
  };
}

async function assertUniqueItemCode(itemCode: string, excludeId?: number): Promise<void> {
  const supabase = getSupabaseClient();
  let query = supabase
    .from('items')
    .select('item_id')
    .eq('item_code', itemCode)
    .eq('is_active', true)
    .limit(1);

  if (excludeId) {
    query = query.neq('item_id', excludeId);
  }

  const { data, error } = await query;

  if (error) {
    throw new APIError('품목 코드 중복 여부를 확인하지 못했습니다.', 500, error.message);
  }

  if (data && data.length > 0) {
    throw new APIError('이미 사용 중인 품목 코드입니다.', 409, { item_code: itemCode });
  }
}

function buildNormalizedPayload(body: Record<string, unknown>): NormalizedItemPayload {
  const normalized: NormalizedItemPayload = {
    item_code: normalizeString(body.item_code) ?? '',
    item_name: normalizeString(body.item_name) ?? '',
    category: normalizeString(body.category) as ItemInsert['category'] | null,
    unit: normalizeString(body.unit) ?? '',
    item_type: normalizeItemType(body.item_type),
    material_type: normalizeMaterialType(body.material_type),
    vehicle_model: normalizeString(body.vehicle_model),
    material: normalizeString(body.material),
    spec: normalizeString(body.spec ?? body.specification),
    thickness: normalizeNumber(body.thickness),
    width: normalizeNumber(body.width),
    height: normalizeNumber(body.height),
    specific_gravity: normalizeNumber(body.specific_gravity),
    mm_weight: normalizeNumber(body.mm_weight),
    daily_requirement: normalizeInteger(body.daily_requirement),
    blank_size: normalizeInteger(body.blank_size),
    price: normalizeNumber(body.price ?? body.unit_price),
    safety_stock: normalizeInteger(body.safety_stock ?? body.min_stock_level),
    current_stock: normalizeInteger(body.current_stock),
    location: normalizeString(body.location),
    description: normalizeString(body.description),
  };

  normalized.mm_weight = computeMmWeight({
    thickness: normalized.thickness,
    width: normalized.width,
    height: normalized.height,
    blank_size: normalized.blank_size,
    specific_gravity: normalized.specific_gravity,
    material_type: normalized.material_type,
    mm_weight: normalized.mm_weight,
  });

  return normalized;
}

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabase = getSupabaseClient();
    const searchParams = request.nextUrl.searchParams;

    const search = normalizeString(searchParams.get('search'));
    const category = normalizeString(searchParams.get('category'));
    const itemType = normalizeItemType(searchParams.get('itemType'));
    const materialType = normalizeMaterialType(searchParams.get('materialType'));
    const vehicleModel = normalizeString(searchParams.get('vehicleModel'));
    const minDaily = normalizeInteger(searchParams.get('minDaily'));
    const maxDaily = normalizeInteger(searchParams.get('maxDaily'));
    const limit = normalizeInteger(searchParams.get('limit')) ?? DEFAULT_LIMIT;
    const page = normalizeInteger(searchParams.get('page')) ?? 1;
    const offset = (page - 1) * limit;

    let query = supabase
      .from('items')
      .select('*', { count: 'exact' })
      .eq('is_active', true)
      .order('item_code', { ascending: true })
      .range(offset, offset + limit - 1);

    if (search) {
      query = query.or(
        `item_code.ilike.%${search}%,item_name.ilike.%${search}%,spec.ilike.%${search}%`
      );
    }

    if (category) {
      query = query.eq('category', category);
    }

    if (itemType) {
      query = query.eq('item_type', itemType);
    }

    if (materialType) {
      query = query.eq('material_type', materialType);
    }

    if (vehicleModel) {
      query = query.ilike('vehicle_model', `%${vehicleModel}%`);
    }

    if (minDaily !== null) {
      query = query.gte('daily_requirement', minDaily);
    }

    if (maxDaily !== null) {
      query = query.lte('daily_requirement', maxDaily);
    }

    const { data, error, count } = await query;

    if (error) {
      throw new APIError('품목 정보를 조회하지 못했습니다.', 500, error.message);
    }

    const items = (data ?? []).map((item) => mapRow(item as ItemRow));

    const typeSummary = items.reduce<Record<string, number>>((acc, item) => {
      const key = item.item_type ?? 'UNKNOWN';
      acc[key] = (acc[key] ?? 0) + 1;
      return acc;
    }, {});

    const materialSummary = items.reduce<Record<string, number>>((acc, item) => {
      const key = item.material_type ?? 'UNKNOWN';
      acc[key] = (acc[key] ?? 0) + 1;
      return acc;
    }, {});

    return NextResponse.json({
      success: true,
      data: {
        items,
        pagination: {
          page,
          limit,
          total: count ?? 0,
          totalPages: count ? Math.ceil(count / limit) : 0,
          hasMore: count ? offset + items.length < count : false,
        },
        summary: {
          byItemType: typeSummary,
          byMaterialType: materialSummary,
        },
      },
      filters: {
        search,
        category,
        itemType,
        materialType,
        vehicleModel,
        minDaily,
        maxDaily,
      },
    });
  } catch (error) {
    return handleError(error, '품목 정보를 조회하지 못했습니다.');
  }
}

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const normalized = buildNormalizedPayload(body);

    const requiredErrors = validateRequiredFields(
      {
        item_code: normalized.item_code,
        item_name: normalized.item_name,
        category: normalized.category,
        unit: normalized.unit,
      },
      ['item_code', 'item_name', 'category', 'unit']
    );

    if (requiredErrors.length > 0) {
      throw new APIError('필수 입력값을 확인해주세요.', 400, requiredErrors);
    }

    await assertUniqueItemCode(normalized.item_code);

    const supabase = getSupabaseClient();
    const now = new Date().toISOString();

    const payload: ItemInsert = {
      item_code: normalized.item_code,
      item_name: normalized.item_name,
      category: normalized.category,
      unit: normalized.unit,
      item_type: normalized.item_type ?? 'RAW',
      material_type: normalized.material_type ?? 'OTHER',
      vehicle_model: normalized.vehicle_model,
      material: normalized.material,
      spec: normalized.spec,
      thickness: normalized.thickness,
      width: normalized.width,
      height: normalized.height,
      specific_gravity: normalized.specific_gravity ?? 7.85,
      mm_weight: normalized.mm_weight,
      daily_requirement: normalized.daily_requirement,
      blank_size: normalized.blank_size,
      price: normalized.price,
      safety_stock: normalized.safety_stock,
      current_stock: normalized.current_stock,
      location: normalized.location,
      description: normalized.description,
      is_active: true,
      created_at: now,
      updated_at: now,
    };

    const { data, error } = await supabase
      .from('items')
      .insert(payload)
      .select('*')
      .single();

    if (error || !data) {
      throw new APIError('품목을 등록하지 못했습니다.', 500, error?.message);
    }

    return NextResponse.json({
      success: true,
      data: mapRow(data as ItemRow),
      message: '품목이 등록되었습니다.',
    });
  } catch (error) {
    return handleError(error, '품목 등록 중 오류가 발생했습니다.');
  }
}

export async function PUT(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const itemId = normalizeInteger(body.item_id ?? body.id);

    if (!itemId) {
      throw new APIError('품목 ID가 필요합니다.', 400);
    }

    const normalized = buildNormalizedPayload(body);

    if (normalized.item_code) {
      await assertUniqueItemCode(normalized.item_code, itemId);
    }

    if (
      !normalized.item_code &&
      !normalized.item_name &&
      !normalized.unit &&
      !normalized.category &&
      normalized.item_type === null &&
      normalized.material_type === null &&
      normalized.vehicle_model === null &&
      normalized.material === null &&
      normalized.spec === null &&
      normalized.thickness === null &&
      normalized.width === null &&
      normalized.height === null &&
      normalized.specific_gravity === null &&
      normalized.mm_weight === null &&
      normalized.daily_requirement === null &&
      normalized.blank_size === null &&
      normalized.price === null &&
      normalized.safety_stock === null &&
      normalized.current_stock === null &&
      normalized.location === null &&
      normalized.description === null
    ) {
      throw new APIError('수정할 값이 없습니다.', 400);
    }

    const supabase = getSupabaseClient();
    const now = new Date().toISOString();

    const payload: ItemUpdate = {
      item_code: normalized.item_code ?? undefined,
      item_name: normalized.item_name ?? undefined,
      category: normalized.category ?? undefined,
      unit: normalized.unit ?? undefined,
      item_type: normalized.item_type ?? undefined,
      material_type: normalized.material_type ?? undefined,
      vehicle_model: normalized.vehicle_model ?? undefined,
      material: normalized.material ?? undefined,
      spec: normalized.spec ?? undefined,
      thickness: normalized.thickness ?? undefined,
      width: normalized.width ?? undefined,
      height: normalized.height ?? undefined,
      specific_gravity: normalized.specific_gravity ?? undefined,
      mm_weight: normalized.mm_weight ?? undefined,
      daily_requirement: normalized.daily_requirement ?? undefined,
      blank_size: normalized.blank_size ?? undefined,
      price: normalized.price ?? undefined,
      safety_stock: normalized.safety_stock ?? undefined,
      current_stock: normalized.current_stock ?? undefined,
      location: normalized.location ?? undefined,
      description: normalized.description ?? undefined,
      updated_at: now,
    };

    const { data, error } = await supabase
      .from('items')
      .update(payload)
      .eq('item_id', itemId)
      .select('*')
      .single();

    if (error) {
      throw new APIError('품목 정보를 수정하지 못했습니다.', 500, error.message);
    }

    if (!data) {
      throw new APIError('수정 대상 품목을 찾을 수 없습니다.', 404);
    }

    return NextResponse.json({
      success: true,
      data: mapRow(data as ItemRow),
      message: '품목 정보가 수정되었습니다.',
    });
  } catch (error) {
    return handleError(error, '품목 수정 중 오류가 발생했습니다.');
  }
}

export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    const body = await request.json();
    const itemId = normalizeInteger(body.item_id ?? body.id);

    if (!itemId) {
      throw new APIError('품목 ID가 필요합니다.', 400);
    }

    const supabase = getSupabaseClient();
    const now = new Date().toISOString();

    const { data, error } = await supabase
      .from('items')
      .update({
        is_active: false,
        updated_at: now,
      })
      .eq('item_id', itemId)
      .select('item_id')
      .single();

    if (error) {
      throw new APIError('품목을 비활성화하지 못했습니다.', 500, error.message);
    }

    if (!data) {
      throw new APIError('대상 품목을 찾을 수 없습니다.', 404);
    }

    return NextResponse.json({
      success: true,
      message: '품목이 비활성화되었습니다.',
    });
  } catch (error) {
    return handleError(error, '품목 삭제 중 오류가 발생했습니다.');
  }
}



```


#### 📄 src\app\api\items\[id]\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db-unified';
import {
  handleError,
  createSuccessResponse,
  handleNotFoundError,
  handleValidationError,
  ErrorType,
  ERPError
} from '@/lib/errorHandler';
import { errorLoggingManager } from '@/lib/errorLogger';

interface RouteContext {
  params: Promise<{
    id: string;
  }>;
}

/**
 * 특정 아이템 조회
 * GET /api/items/[id]
 */
export async function GET(
  request: NextRequest,
  routeContext: RouteContext
) {
  const context = {
    resource: 'items',
    action: 'read',
    userId: request.headers.get('x-user-id') || undefined,
    requestId: request.headers.get('x-request-id') || undefined
  };

  try {
    const { id } = await routeContext.params;
    const itemId = parseInt(id);

    // ID 유효성 검사
    if (isNaN(itemId) || itemId <= 0) {
      return handleValidationError(['유효하지 않은 아이템 ID입니다'], context);
    }

    const sql = `
      SELECT
        item_id, item_code, item_name, item_type, car_model, spec,
        unit, current_stock, min_stock_level, unit_price, location,
        description, is_active, created_at, updated_at, safety_stock
      FROM items
      WHERE item_id = ? AND is_active = 1
    `;

    const items = await query<any[]>(sql, [itemId]);

    if (items.length === 0) {
      return handleNotFoundError('아이템', itemId, context);
    }

    return createSuccessResponse(items[0], '아이템을 성공적으로 조회했습니다');
  } catch (error) {
    return handleError(error, context);
  }
}

/**
 * 아이템 수정
 * PUT /api/items/[id]
 */
export async function PUT(
  request: NextRequest,
  routeContext: RouteContext
) {
  const context = {
    resource: 'items',
    action: 'update',
    userId: request.headers.get('x-user-id') || undefined,
    requestId: request.headers.get('x-request-id') || undefined
  };

  try {
    const { id } = await routeContext.params;
    const itemId = parseInt(id);

    // ID 유효성 검사
    if (isNaN(itemId) || itemId <= 0) {
      return handleValidationError(['유효하지 않은 아이템 ID입니다'], context);
    }

    // 요청 본문 파싱 (한글 지원)
    const text = await request.text();
    const body = JSON.parse(text);

    // 필수 필드 검사
    const requiredFields = ['item_name', 'unit'];
    const missingFields = requiredFields.filter(field => !body[field]);

    if (missingFields.length > 0) {
      return handleValidationError(
        missingFields.map(field => `${field}는 필수 입력 항목입니다`),
        context
      );
    }

    // 아이템 존재 여부 확인
    const existsCheck = await query<any[]>(
      'SELECT item_id FROM items WHERE item_id = ? AND is_active = 1',
      [itemId]
    );

    if (existsCheck.length === 0) {
      return handleNotFoundError('아이템', itemId, context);
    }

    // 중복 코드 검사 (다른 아이템이 같은 코드 사용)
    if (body.item_code) {
      const duplicateCheck = await query<{ item_id: number }>(
        'SELECT item_id FROM items WHERE item_code = ? AND item_id != ? AND is_active = 1',
        [body.item_code, itemId]
      );

      if (Array.isArray(duplicateCheck) && duplicateCheck.length > 0) {
        throw new ERPError(
          ErrorType.DUPLICATE_ENTRY,
          '다른 아이템이 이미 해당 코드를 사용 중입니다',
          { item_code: body.item_code, existing_item_id: duplicateCheck[0].item_id },
          context
        );
      }
    }

    // 업데이트 가능한 필드들
    const updateFields: string[] = [];
    const updateValues: any[] = [];

    const allowedFields = [
      'item_code', 'item_name', 'item_type', 'car_model', 'spec',
      'unit', 'min_stock_level', 'unit_price', 'location', 'description', 'safety_stock'
    ];

    allowedFields.forEach(field => {
      if (body[field] !== undefined) {
        updateFields.push(`${field} = ?`);
        updateValues.push(body[field]);
      }
    });

    if (updateFields.length === 0) {
      throw new ERPError(
        ErrorType.VALIDATION,
        '업데이트할 필드가 없습니다',
        { provided_fields: Object.keys(body) },
        context
      );
    }

    updateFields.push('updated_at = NOW()');
    updateValues.push(itemId);

    const updateSql = `
      UPDATE items
      SET ${updateFields.join(', ')}
      WHERE item_id = ? AND is_active = 1
    `;

    const result = await query(updateSql, updateValues);

    if ((result as any).affectedRows === 0) {
      return handleNotFoundError('아이템', itemId, context);
    }

    // 업데이트된 아이템 정보 조회
    const updatedItem = await query<any[]>(
      `SELECT item_id, item_code, item_name, item_type, car_model, spec,
       unit, current_stock, min_stock_level, unit_price, location,
       description, safety_stock, updated_at
       FROM items WHERE item_id = ?`,
      [itemId]
    );

    return createSuccessResponse(
      updatedItem[0],
      '아이템이 성공적으로 수정되었습니다'
    );
  } catch (error) {
    return handleError(error, context);
  }
}

/**
 * 아이템 삭제 (소프트 삭제)
 * DELETE /api/items/[id]
 */
export async function DELETE(
  request: NextRequest,
  routeContext: RouteContext
) {
  const context = {
    resource: 'items',
    action: 'delete',
    userId: request.headers.get('x-user-id') || undefined,
    requestId: request.headers.get('x-request-id') || undefined
  };

  try {
    const { id } = await routeContext.params;
    const itemId = parseInt(id);

    // ID 유효성 검사
    if (isNaN(itemId) || itemId <= 0) {
      return handleValidationError(['유효하지 않은 아이템 ID입니다'], context);
    }

    // 아이템 존재 여부 확인
    const existsCheck = await query<{ item_id: number; item_code: string; item_name: string }>(
      'SELECT item_id, item_code, item_name FROM items WHERE item_id = ? AND is_active = 1',
      [itemId]
    );

    if (!Array.isArray(existsCheck) || existsCheck.length === 0) {
      return handleNotFoundError('아이템', itemId, context);
    }

    const item = existsCheck[0];

    // BOM에서 사용 중인지 확인
    const bomCheck = await query<{ count: number }>(
      'SELECT COUNT(*) as count FROM bom WHERE parent_item_id = ? OR child_item_id = ?',
      [itemId, itemId]
    );

    if (Array.isArray(bomCheck) && bomCheck.length > 0 && bomCheck[0].count > 0) {
      throw new ERPError(
        ErrorType.DATABASE_CONSTRAINT,
        'BOM에서 사용 중인 아이템은 삭제할 수 없습니다',
        {
          item_id: itemId,
          item_code: item.item_code,
          bom_usage_count: bomCheck[0].count
        },
        context
      );
    }

    // 재고 이동 기록이 있는지 확인
    const transactionCheck = await query<{ count: number }>(
      'SELECT COUNT(*) as count FROM inventory_transactions WHERE item_id = ?',
      [itemId]
    );

    if (Array.isArray(transactionCheck) && transactionCheck.length > 0 && transactionCheck[0].count > 0) {
      throw new ERPError(
        ErrorType.DATABASE_CONSTRAINT,
        '재고 이동 기록이 있는 아이템은 삭제할 수 없습니다',
        {
          item_id: itemId,
          item_code: item.item_code,
          transaction_count: transactionCheck[0].count
        },
        context
      );
    }

    // 소프트 삭제 실행
    const deleteSql = `
      UPDATE items
      SET is_active = 0, updated_at = NOW()
      WHERE item_id = ? AND is_active = 1
    `;

    const result = await query(deleteSql, [itemId]);

    if ((result as any).affectedRows === 0) {
      return handleNotFoundError('아이템', itemId, context);
    }

    return createSuccessResponse(
      { item_id: itemId, item_code: item.item_code },
      '아이템이 성공적으로 삭제되었습니다'
    );
  } catch (error) {
    return handleError(error, context);
  }
}
```


#### 📄 src\app\api\metrics\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getComprehensiveMetrics, formatPrometheusMetrics } from '@/lib/monitoring';
import { logger } from '@/lib/logger';

// Metrics endpoint for monitoring tools
export async function GET(request: NextRequest) {
  const startTime = Date.now();

  try {
    const searchParams = request.nextUrl.searchParams;
    const format = searchParams.get('format') || 'json'; // json or prometheus
    const detailed = searchParams.get('detailed') === 'true';

    // Set correlation ID
    const correlationId = request.headers.get('x-correlation-id') ||
                         `metrics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    logger.setCorrelationId(correlationId);

    logger.debug('메트릭스 요청 시작', { format, detailed });

    // Get comprehensive metrics
    const metrics = await getComprehensiveMetrics();
    const responseTime = Date.now() - startTime;

    // Add request tracking for this call (metrics object is mutable)
    (metrics as any).timestamp = Date.now();
    (metrics as any).responseTimeMs = responseTime;

    if (format === 'prometheus') {
      // Return Prometheus-compatible format
      const prometheusData = formatPrometheusMetrics(metrics);

      logger.debug('Prometheus 메트릭스 반환', { dataSize: prometheusData.length });

      return new Response(prometheusData, {
        status: 200,
        headers: {
          'content-type': 'text/plain; charset=utf-8',
          'x-correlation-id': correlationId,
          'cache-control': 'no-cache, no-store, must-revalidate'
        }
      });
    }

    // Return JSON format
    const response = detailed ? {
      ...metrics,
      meta: {
        correlationId,
        generated: new Date().toISOString(),
        format: 'json',
        detailed: true,
        responseTime
      }
    } : {
      // Simplified metrics for regular monitoring
      timestamp: metrics.timestamp,
      status: 'healthy', // Based on error rate and response times
      requestCount: metrics.requestCount,
      errorRate: metrics.errorRate,
      avgResponseTime: metrics.responseTime.avg,
      memoryUsage: metrics.memory.usage,
      dbConnections: metrics.dbConnections.total,
      businessMetrics: metrics.businessMetrics,
      meta: {
        correlationId,
        generated: new Date().toISOString(),
        format: 'json',
        detailed: false,
        responseTime
      }
    };

    logger.debug('JSON 메트릭스 반환', {
      requestCount: metrics.requestCount,
      errorRate: metrics.errorRate,
      memoryUsage: metrics.memory.usage
    });

    return NextResponse.json(response, {
      status: 200,
      headers: {
        'x-correlation-id': correlationId,
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    logger.error('메트릭스 수집 실패', error instanceof Error ? error : new Error(errorMessage), {
      responseTime,
      type: 'metrics_error'
    });

    return NextResponse.json({
      error: '메트릭스를 수집할 수 없습니다',
      details: errorMessage,
      timestamp: new Date().toISOString(),
      responseTime,
      correlationId: request.headers.get('x-correlation-id')
    }, {
      status: 500,
      headers: {
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });
  } finally {
    logger.clearCorrelationId();
  }
}

// Reset metrics (useful for testing or maintenance)
export async function DELETE(request: NextRequest) {
  const startTime = Date.now();

  try {
    const correlationId = request.headers.get('x-correlation-id') ||
                         `metrics_reset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    logger.setCorrelationId(correlationId);

    // Check for admin authorization (simple implementation)
    const authHeader = request.headers.get('authorization');
    const adminToken = process.env.ADMIN_TOKEN || 'admin123'; // In production, use proper authentication

    if (!authHeader || !authHeader.includes(adminToken)) {
      logger.warn('메트릭스 리셋 시도 - 권한 없음', {
        hasAuth: !!authHeader,
        type: 'security'
      });

      return NextResponse.json({
        error: '권한이 필요합니다',
        timestamp: new Date().toISOString()
      }, { status: 401 });
    }

    // Reset metrics collector
    const { metricsCollector } = await import('@/lib/monitoring');
    metricsCollector.reset();

    const responseTime = Date.now() - startTime;

    logger.info('메트릭스 리셋 완료', { responseTime });

    return NextResponse.json({
      success: true,
      message: '메트릭스가 리셋되었습니다',
      timestamp: new Date().toISOString(),
      responseTime,
      correlationId
    }, {
      status: 200,
      headers: {
        'x-correlation-id': correlationId,
        'content-type': 'application/json; charset=utf-8'
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    logger.error('메트릭스 리셋 실패', error instanceof Error ? error : new Error(errorMessage), {
      responseTime,
      type: 'metrics_reset_error'
    });

    return NextResponse.json({
      error: '메트릭스 리셋에 실패했습니다',
      details: errorMessage,
      timestamp: new Date().toISOString(),
      responseTime
    }, {
      status: 500,
      headers: {
        'content-type': 'application/json; charset=utf-8'
      }
    });
  } finally {
    logger.clearCorrelationId();
  }
}

// Custom metrics endpoint for specific business metrics
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    const correlationId = request.headers.get('x-correlation-id') ||
                         `custom_metrics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    logger.setCorrelationId(correlationId);

    // Parse request body for custom metric queries
    const text = await request.text();
    const body = text ? JSON.parse(text) : {};

    const {
      timeRange = '24h',
      metrics = ['transactions', 'stock', 'errors'],
      groupBy = 'hour'
    } = body;

    logger.info('커스텀 메트릭스 요청', { timeRange, metrics, groupBy });

    // Get custom business metrics based on request
    const customMetrics = await getCustomBusinessMetrics(timeRange, metrics, groupBy);

    const responseTime = Date.now() - startTime;

    const response = {
      success: true,
      data: customMetrics,
      query: {
        timeRange,
        metrics,
        groupBy
      },
      meta: {
        correlationId,
        generated: new Date().toISOString(),
        responseTime,
        dataPoints: customMetrics.length || Object.keys(customMetrics).length
      }
    };

    logger.info('커스텀 메트릭스 반환 완료', {
      dataPoints: response.meta.dataPoints,
      responseTime
    });

    return NextResponse.json(response, {
      status: 200,
      headers: {
        'x-correlation-id': correlationId,
        'cache-control': 'no-cache, no-store, must-revalidate',
        'content-type': 'application/json; charset=utf-8'
      }
    });

  } catch (error) {
    const responseTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    logger.error('커스텀 메트릭스 실패', error instanceof Error ? error : new Error(errorMessage), {
      responseTime,
      type: 'custom_metrics_error'
    });

    return NextResponse.json({
      success: false,
      error: '커스텀 메트릭스를 수집할 수 없습니다',
      details: errorMessage,
      timestamp: new Date().toISOString(),
      responseTime
    }, {
      status: 500,
      headers: {
        'content-type': 'application/json; charset=utf-8'
      }
    });
  } finally {
    logger.clearCorrelationId();
  }
}

// Get custom business metrics from database
async function getCustomBusinessMetrics(
  timeRange: string,
  metrics: string[],
  groupBy: string
): Promise<any> {
  const { query } = await import('@/lib/db-unified');

  const results: any = {};

  // Parse time range
  const getTimeClause = (range: string) => {
    switch (range) {
      case '1h': return 'DATE_SUB(NOW(), INTERVAL 1 HOUR)';
      case '24h': return 'DATE_SUB(NOW(), INTERVAL 24 HOUR)';
      case '7d': return 'DATE_SUB(NOW(), INTERVAL 7 DAY)';
      case '30d': return 'DATE_SUB(NOW(), INTERVAL 30 DAY)';
      default: return 'DATE_SUB(NOW(), INTERVAL 24 HOUR)';
    }
  };

  // Get group by clause
  const getGroupClause = (group: string) => {
    switch (group) {
      case 'minute': return 'DATE_FORMAT(created_at, "%Y-%m-%d %H:%i")';
      case 'hour': return 'DATE_FORMAT(created_at, "%Y-%m-%d %H:00")';
      case 'day': return 'DATE_FORMAT(created_at, "%Y-%m-%d")';
      case 'week': return 'YEARWEEK(created_at)';
      case 'month': return 'DATE_FORMAT(created_at, "%Y-%m")';
      default: return 'DATE_FORMAT(created_at, "%Y-%m-%d %H:00")';
    }
  };

  const timeClause = getTimeClause(timeRange);
  const groupClause = getGroupClause(groupBy);

  // Transaction metrics
  if (metrics.includes('transactions')) {
    try {
      const transactionData = await query(`
        SELECT
          ${groupClause} as time_period,
          transaction_type,
          COUNT(*) as count,
          SUM(quantity) as total_quantity
        FROM inventory_transactions
        WHERE created_at >= ${timeClause}
        GROUP BY time_period, transaction_type
        ORDER BY time_period DESC
      `);

      results.transactions = transactionData;
    } catch (error) {
      console.error('Error fetching transaction metrics:', error);
      results.transactions = [];
    }
  }

  // Stock level metrics
  if (metrics.includes('stock')) {
    try {
      const stockData = await query(`
        SELECT
          item_type,
          COUNT(*) as total_items,
          SUM(current_stock) as total_stock,
          AVG(current_stock) as avg_stock,
          COUNT(CASE WHEN current_stock <= COALESCE(min_stock_level, 0) THEN 1 END) as low_stock_count
        FROM items
        WHERE is_active = 1
        GROUP BY item_type
      `);

      results.stock = stockData;
    } catch (error) {
      console.error('Error fetching stock metrics:', error);
      results.stock = [];
    }
  }

  // Error metrics (from application perspective)
  if (metrics.includes('errors')) {
    // This would typically come from error logs or monitoring system
    // For now, return basic error simulation
    results.errors = {
      totalErrors: 0,
      errorRate: 0,
      criticalErrors: 0,
      warningCount: 0,
      timeRange
    };
  }

  // Performance metrics
  if (metrics.includes('performance')) {
    const { getComprehensiveMetrics } = await import('@/lib/monitoring');
    const currentMetrics = await getComprehensiveMetrics();

    results.performance = {
      avgResponseTime: currentMetrics.responseTime.avg,
      p95ResponseTime: currentMetrics.responseTime.p95,
      requestCount: currentMetrics.requestCount,
      errorRate: currentMetrics.errorRate,
      memoryUsage: currentMetrics.memory.usage,
      dbConnections: currentMetrics.dbConnections
    };
  }

  return results;
}
```


#### 📄 src\app\api\migrate\add-safety-stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin, handleSupabaseError, createSuccessResponse } from '@/lib/db-unified';

/**
 * POST /api/migrate/add-safety-stock
 * Add safety_stock column to items table
 * One-time migration to fix missing column issue
 *
 * NOTE: For PostgreSQL/Supabase, this migration should be done via Supabase Dashboard or CLI
 * This endpoint checks if column exists and updates default values only
 */
export async function POST(_request: NextRequest) {
  try {
    // Check if column already exists by attempting to query it
    const { data: columnCheck, error: checkError } = await supabaseAdmin
      .from('items')
      .select('safety_stock')
      .limit(1);

    if (checkError) {
      // Column doesn't exist - need to add via Supabase Dashboard
      return NextResponse.json({
        success: false,
        message: 'safety_stock column does not exist. Please add it via Supabase Dashboard:',
        instructions: [
          '1. Go to Supabase Dashboard > Table Editor > items',
          '2. Add column: safety_stock, type: numeric (10,2), default: 0',
          '3. Run this migration again to set default values'
        ],
        error: checkError.message
      }, { status: 400 });
    }

    // Column exists - update default safety stock values for existing items
    const itemTypes = [
      { type: '원자재', value: 100 },
      { type: '부품', value: 50 },
      { type: '제품', value: 20 }
    ];

    let updatedCount = 0;
    for (const { type, value } of itemTypes) {
      const { error } = await supabaseAdmin
        .from('items')
        .update({ safety_stock: value })
        .eq('item_type', type)
        .eq('is_active', true);

      // Get count separately
      const { count } = await supabaseAdmin
        .from('items')
        .select('*', { count: 'exact', head: true })
        .eq('item_type', type)
        .eq('is_active', true)
        .eq('safety_stock', value);

      if (error) {
        console.error(`Error updating ${type}:`, error);
      } else {
        updatedCount += count || 0;
      }
    }

    // Set default for other types
    const { error: otherError } = await supabaseAdmin
      .from('items')
      .update({ safety_stock: 10 })
      .not('item_type', 'in', '("원자재","부품","제품")')
      .eq('is_active', true);

    // Get count separately
    const { count: otherCount } = await supabaseAdmin
      .from('items')
      .select('*', { count: 'exact', head: true })
      .not('item_type', 'in', '("원자재","부품","제품")')
      .eq('is_active', true)
      .eq('safety_stock', 10);

    if (otherError) {
      console.error('Error updating other types:', otherError);
    }

    updatedCount += otherCount || 0;

    return NextResponse.json({
      success: true,
      message: 'safety_stock default values set successfully',
      migration: 'add_safety_stock_column',
      timestamp: new Date().toISOString(),
      updatedCount
    });
  } catch (error) {
    console.error('Error in safety_stock migration:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to process safety_stock migration',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/migrate/add-safety-stock
 * Check if safety_stock column exists
 */
export async function GET() {
  try {
    // Attempt to query safety_stock column
    const { data, error } = await supabaseAdmin
      .from('items')
      .select('safety_stock')
      .limit(1);

    if (error) {
      return NextResponse.json({
        success: true,
        exists: false,
        message: 'safety_stock column does not exist',
        error: error.message
      });
    }

    return NextResponse.json({
      success: true,
      exists: true,
      message: 'safety_stock column exists',
      sampleData: data
    });
  } catch (error) {
    console.error('Error checking safety_stock column:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to check safety_stock column'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\monitoring\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    return NextResponse.json({
      success: true,
      data: {
        timestamp: new Date().toISOString(),
        status: 'healthy',
        checks: {
          database: true,
          items_table: true,
          companies_table: true
        },
        metrics: {
          query_time_ms: 0,
          items_count: 6,
          total_stock_quantity: 0,
          avg_query_time_ms: 0
        }
      }
    });
  } catch (error) {
    console.error('Error in monitoring API:', error);
    return NextResponse.json(
      {
        success: false,
        error: '모니터링 데이터 조회에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\reports\daily-report\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseClient } from '@/lib/db-unified';

type RequestParams = {
  year: number;
  month: number;
};

type DailyRow = {
  date: string;
  salesAmount: number;
  salesCount: number;
  purchaseAmount: number;
  purchaseCount: number;
  collectionAmount: number;
  collectionCount: number;
};

type SummaryTotals = {
  salesAmount: number;
  salesCount: number;
  purchaseAmount: number;
  purchaseCount: number;
  collectionAmount: number;
  collectionCount: number;
  netAmount: number;
};

function parseYearMonth(request: NextRequest): RequestParams {
  const url = new URL(request.url);
  const yearParam = url.searchParams.get('year');
  const monthParam = url.searchParams.get('month');
  const today = new Date();

  const year = yearParam ? Number(yearParam) : today.getFullYear();
  const month = monthParam ? Number(monthParam) : today.getMonth() + 1;

  if (!Number.isFinite(year) || year < 2000 || year > 2100) {
    throw new Error('year must be between 2000 and 2100');
  }

  if (!Number.isFinite(month) || month < 1 || month > 12) {
    throw new Error('month must be between 1 and 12');
  }

  return { year, month };
}

function createDateRange(params: RequestParams) {
  const start = new Date(Date.UTC(params.year, params.month - 1, 1));
  const end = new Date(Date.UTC(params.year, params.month, 1));
  return {
    from: start.toISOString().split('T')[0],
    to: end.toISOString().split('T')[0]
  };
}

function ensureDate(value: unknown): string | null {
  if (typeof value !== 'string') return null;
  return value.split('T')[0];
}

function buildDailyRows(
  dates: Set<string>,
  salesMap: Map<string, { amount: number; count: number }>,
  purchaseMap: Map<string, { amount: number; count: number }>,
  collectionMap: Map<string, { amount: number; count: number }>
): DailyRow[] {
  return Array.from(dates)
    .sort()
    .map((date) => {
      const sales = salesMap.get(date) ?? { amount: 0, count: 0 };
      const purchase = purchaseMap.get(date) ?? { amount: 0, count: 0 };
      const collection = collectionMap.get(date) ?? { amount: 0, count: 0 };

      return {
        date,
        salesAmount: sales.amount,
        salesCount: sales.count,
        purchaseAmount: purchase.amount,
        purchaseCount: purchase.count,
        collectionAmount: collection.amount,
        collectionCount: collection.count
      };
    });
}

function computeTotals(rows: DailyRow[]): SummaryTotals {
  return rows.reduce<SummaryTotals>((acc, row) => ({
    salesAmount: acc.salesAmount + row.salesAmount,
    salesCount: acc.salesCount + row.salesCount,
    purchaseAmount: acc.purchaseAmount + row.purchaseAmount,
    purchaseCount: acc.purchaseCount + row.purchaseCount,
    collectionAmount: acc.collectionAmount + row.collectionAmount,
    collectionCount: acc.collectionCount + row.collectionCount,
    netAmount: acc.netAmount + row.salesAmount - row.purchaseAmount
  }), {
    salesAmount: 0,
    salesCount: 0,
    purchaseAmount: 0,
    purchaseCount: 0,
    collectionAmount: 0,
    collectionCount: 0,
    netAmount: 0
  });
}

export async function GET(request: NextRequest) {
  try {
    const params = parseYearMonth(request);
    const { from, to } = createDateRange(params);
    const supabase = getSupabaseClient();

    const [salesResult, purchaseResult, collectionResult] = await Promise.all([
      supabase
        .from('sales_transactions')
        .select('transaction_date, amount')
        .gte('transaction_date', from)
        .lt('transaction_date', to),
      supabase
        .from('purchase_transactions')
        .select('transaction_date, amount')
        .gte('transaction_date', from)
        .lt('transaction_date', to),
      supabase
        .from('collection_transactions')
        .select('transaction_date, amount')
        .gte('transaction_date', from)
        .lt('transaction_date', to)
    ]);

    if (salesResult.error) {
      throw new Error(`Failed to fetch sales transactions: ${salesResult.error.message}`);
    }
    if (purchaseResult.error) {
      throw new Error(`Failed to fetch purchase transactions: ${purchaseResult.error.message}`);
    }
    if (collectionResult.error) {
      throw new Error(`Failed to fetch collection transactions: ${collectionResult.error.message}`);
    }

    const dates = new Set<string>();
    const salesMap = new Map<string, { amount: number; count: number }>();
    const purchaseMap = new Map<string, { amount: number; count: number }>();
    const collectionMap = new Map<string, { amount: number; count: number }>();

    const aggregate = (
      map: Map<string, { amount: number; count: number }>,
      date: string | null,
      amount: unknown
    ) => {
      if (!date) return;
      const numericAmount = Number(amount ?? 0);
      if (Number.isNaN(numericAmount)) return;
      dates.add(date);
      const entry = map.get(date) ?? { amount: 0, count: 0 };
      entry.amount += numericAmount;
      entry.count += 1;
      map.set(date, entry);
    };

    salesResult.data?.forEach((row) => {
      aggregate(salesMap, ensureDate((row as any).transaction_date), (row as any).amount);
    });

    purchaseResult.data?.forEach((row) => {
      aggregate(purchaseMap, ensureDate((row as any).transaction_date), (row as any).amount);
    });

    collectionResult.data?.forEach((row) => {
      aggregate(collectionMap, ensureDate((row as any).transaction_date), (row as any).amount);
    });

    const dailyRows = buildDailyRows(dates, salesMap, purchaseMap, collectionMap);
    const totals = computeTotals(dailyRows);

    return NextResponse.json({
      success: true,
      data: {
        year: params.year,
        month: params.month,
        period: { from, to },
        totals,
        daily: dailyRows
      }
    });
  } catch (error) {
    console.error('[daily-report] Failed to generate report:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate daily report'
      },
      { status: 500 }
    );
  }
}

```


#### 📄 src\app\api\security-test\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

/**
 * 보안 미들웨어 테스트 API
 * CORS 및 보안 헤더가 올바르게 적용되는지 확인
 */
export async function GET(request: NextRequest) {
  return NextResponse.json({
    success: true,
    message: '보안 미들웨어 테스트 성공',
    timestamp: new Date().toISOString(),
    headers: {
      origin: request.headers.get('origin'),
      userAgent: request.headers.get('user-agent'),
      acceptLanguage: request.headers.get('accept-language')
    }
  });
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    return NextResponse.json({
      success: true,
      message: '한국어 콘텐츠 처리 테스트 성공',
      receivedData: body,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: '요청 처리 중 오류가 발생했습니다.'
    }, { status: 400 });
  }
}

export async function OPTIONS(request: NextRequest) {
  // OPTIONS 요청은 미들웨어에서 처리되므로 이 핸들러는 호출되지 않을 것임
  return NextResponse.json({
    message: '이 메시지가 보인다면 미들웨어의 OPTIONS 처리에 문제가 있습니다.'
  });
}
```


#### 📄 src\app\api\simple\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    return NextResponse.json({
      success: true,
      message: 'Simple API is working',
      timestamp: new Date().toISOString(),
      url: request.url
    });
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

```


#### 📄 src\app\api\stock\adjustment\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';

/**
 * POST /api/stock/adjustment
 * Create stock adjustment transaction
 * Body: {
 *   item_id: number,
 *   adjustment_type: 'INCREASE' | 'DECREASE' | 'SET',
 *   quantity: number,
 *   reason: string,
 *   reference_no?: string,
 *   notes?: string,
 *   created_by: number
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      item_id,
      adjustment_type,
      quantity,
      reason,
      reference_no,
      notes,
      created_by
    } = body;

    // 필수 필드 검증
    if (!item_id || !adjustment_type || quantity === undefined || !reason || !created_by) {
      return NextResponse.json({
        success: false,
        error: '필수 필드가 누락되었습니다. (품목, 조정유형, 수량, 사유, 작성자 필수)'
      }, { status: 400 });
    }

    if (quantity === 0) {
      return NextResponse.json({
        success: false,
        error: '조정 수량은 0이 될 수 없습니다.'
      }, { status: 400 });
    }

    // 조정 유형 검증
    if (!['INCREASE', 'DECREASE', 'SET'].includes(adjustment_type)) {
      return NextResponse.json({
        success: false,
        error: '올바르지 않은 조정 유형입니다.'
      }, { status: 400 });
    }

    // Check if item exists and is active
    const { data: itemCheck, error: itemError } = await supabaseAdmin
      .from('items')
      .select('item_id, item_name, unit, is_active')
      .eq('item_id', item_id)
      .single();

    if (itemError || !itemCheck) {
      return NextResponse.json({
        success: false,
        error: '존재하지 않는 품목입니다.'
      }, { status: 404 });
    }

    if (!itemCheck.is_active) {
      return NextResponse.json({
        success: false,
        error: '비활성화된 품목입니다.'
      }, { status: 400 });
    }

    // Calculate current stock manually (RPC not used for stock calculation)
    const { data: transactions, error: txError } = await supabaseAdmin
      .from('inventory_transactions')
      .select('transaction_type, quantity')
      .eq('item_id', item_id);

    if (txError) {
      throw new Error(`재고 조회 실패: ${txError.message}`);
    }

    const finalCurrentStock = (transactions || []).reduce((sum, tx) => {
      if (tx.transaction_type === '입고') return sum + tx.quantity;
      if (tx.transaction_type === '출고') return sum - tx.quantity;
      if (tx.transaction_type === '조정') return sum + tx.quantity;
      return sum;
    }, 0);

    // Calculate adjustment quantity based on type
    let adjustmentQuantity: number;
    let newStock: number;

    switch (adjustment_type) {
      case 'INCREASE':
        adjustmentQuantity = Math.abs(quantity);
        newStock = finalCurrentStock + adjustmentQuantity;
        break;
      case 'DECREASE':
        adjustmentQuantity = -Math.abs(quantity);
        newStock = finalCurrentStock + adjustmentQuantity;
        // Check if new stock would be negative
        if (newStock < 0) {
          return NextResponse.json({
            success: false,
            error: `재고가 부족합니다. 현재 재고: ${finalCurrentStock}, 요청 감소량: ${Math.abs(quantity)}`
          }, { status: 400 });
        }
        break;
      case 'SET':
        adjustmentQuantity = quantity - finalCurrentStock;
        newStock = quantity;
        if (newStock < 0) {
          return NextResponse.json({
            success: false,
            error: '재고는 음수가 될 수 없습니다.'
          }, { status: 400 });
        }
        break;
      default:
        return NextResponse.json({
          success: false,
          error: '올바르지 않은 조정 유형입니다.'
        }, { status: 400 });
    }

    // Insert adjustment transaction
    const { data: insertedTransaction, error: insertError } = await supabaseAdmin
      .from('inventory_transactions')
      .insert({
        transaction_date: new Date().toISOString().split('T')[0],
        transaction_type: '조정',
        item_id,
        quantity: adjustmentQuantity,
        unit_price: 0,
        total_amount: 0,
        reference_number: reference_no || `ADJ-${Date.now()}`,
        notes: `${reason}${notes ? ` | ${notes}` : ''} | 이전 재고: ${finalCurrentStock} → 조정 후: ${newStock}`,
        created_by
      })
      .select()
      .single();

    if (insertError) {
      console.error('[STOCK_ADJUSTMENT] Insert error:', insertError);
      throw new Error(`거래 생성 실패: ${insertError.message}`);
    }

    // Get full transaction details with joins
    const { data: fullTransaction, error: detailError } = await supabaseAdmin
      .from('inventory_transactions')
      .select(`
        *,
        items (item_code, item_name, spec, unit),
        users!inventory_transactions_created_by_fkey (name)
      `)
      .eq('transaction_id', insertedTransaction.transaction_id)
      .single();

    if (detailError) {
      console.error('[STOCK_ADJUSTMENT] Detail fetch error:', detailError);
    }

    const result = {
      ...insertedTransaction,
      item_code: fullTransaction?.items?.item_code,
      item_name: fullTransaction?.items?.item_name,
      specification: fullTransaction?.items?.spec,
      item_unit: fullTransaction?.items?.unit,
      created_by_name: fullTransaction?.users?.name,
      adjustment_type,
      current_stock_before: finalCurrentStock,
      current_stock_after: newStock
    };

    return NextResponse.json({
      success: true,
      message: '재고 조정이 성공적으로 완료되었습니다.',
      data: result
    });
  } catch (error) {
    console.error('Error creating stock adjustment:', error);
    const errorMessage = error instanceof Error ? error.message : '재고 조정 중 오류가 발생했습니다.';
    return NextResponse.json(
      {
        success: false,
        error: errorMessage
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/stock/adjustment
 * Get stock adjustment history
 * Query parameters:
 * - start_date: Filter by start date (YYYY-MM-DD)
 * - end_date: Filter by end date (YYYY-MM-DD)
 * - item_id: Filter by specific item
 * - limit: Number of records to return (default: 100)
 * - offset: Pagination offset (default: 0)
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');
    const itemId = searchParams.get('item_id');
    const limit = parseInt(searchParams.get('limit') || '100');
    const offset = parseInt(searchParams.get('offset') || '0');

    let query = supabaseAdmin
      .from('inventory_transactions')
      .select(`
        *,
        items (item_code, item_name, spec, unit),
        users!inventory_transactions_created_by_fkey (name)
      `, { count: 'exact' })
      .eq('transaction_type', '조정')
      .order('transaction_date', { ascending: false })
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (startDate) {
      query = query.gte('transaction_date', startDate);
    }

    if (endDate) {
      query = query.lte('transaction_date', endDate);
    }

    if (itemId) {
      query = query.eq('item_id', parseInt(itemId));
    }

    const { data: adjustments, error, count } = await query;

    if (error) {
      throw new Error(error.message);
    }

    return NextResponse.json({
      success: true,
      data: {
        adjustments: adjustments || [],
        pagination: {
          total: count || 0,
          limit,
          offset,
          hasMore: offset + limit < (count || 0)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching stock adjustments:', error);
    return NextResponse.json(
      {
        success: false,
        error: '재고 조정 이력 조회 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\stock\alerts\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// Note: Uses database views (low_stock_alert_view) - migrated to Supabase MCP
// Phase 5-2: Supabase execute_sql implementation

/**
 * GET /api/stock/alerts
 * Get low stock alert items using low_stock_alert_view
 * Query parameters:
 * - alert_level: Filter by alert level (OUT_OF_STOCK/CRITICAL/LOW)
 * - location: Filter by storage location
 * - limit: Number of records to return (default: 50)
 * - offset: Pagination offset (default: 0)
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const alertLevel = searchParams.get('alert_level');
    const location = searchParams.get('location');
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    let query = supabase
      .from('low_stock_alert_view')
      .select(`
        item_id,
        item_code,
        item_name,
        spec,
        unit,
        current_stock,
        safety_stock,
        shortage_quantity,
        location,
        alert_level,
        items!inner(unit_price)
      `);

    // Apply filters safely
    if (alertLevel) {
      query = query.eq('alert_level', alertLevel);
    }

    if (location) {
      query = query.ilike('location', `%${location}%`);
    }

    // Apply ordering and pagination
    query = query
      .order('shortage_quantity', { ascending: false })
      .order('item_code', { ascending: true })
      .range(offset, offset + limit - 1);

    const { data: alerts, error } = await query;

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to include calculated shortage_value
    const formattedAlerts = alerts?.map((alert: any) => ({
      item_id: alert.item_id,
      item_code: alert.item_code,
      item_name: alert.item_name,
      spec: alert.spec,
      unit: alert.unit,
      current_stock: alert.current_stock,
      safety_stock: alert.safety_stock,
      shortage_quantity: alert.shortage_quantity,
      location: alert.location,
      alert_level: alert.alert_level,
      unit_price: alert.items?.unit_price,
      shortage_value: alert.shortage_quantity * (alert.items?.unit_price || 0)
    })) || [];

    // Get summary statistics using safe query
    const { count: totalAlerts, error: statsError } = await supabase
      .from('low_stock_alert_view')
      .select('*', { count: 'exact', head: true });

    if (statsError) {
      throw new Error(`Statistics query failed: ${statsError.message}`);
    }

    // Get counts by alert level using safe queries
    const { count: outOfStockCount } = await supabase
      .from('low_stock_alert_view')
      .select('*', { count: 'exact', head: true })
      .eq('alert_level', 'OUT_OF_STOCK');

    const { count: criticalCount } = await supabase
      .from('low_stock_alert_view')
      .select('*', { count: 'exact', head: true })
      .eq('alert_level', 'CRITICAL');

    const { count: lowCount } = await supabase
      .from('low_stock_alert_view')
      .select('*', { count: 'exact', head: true })
      .eq('alert_level', 'LOW');

    // Calculate total shortage quantity
    const totalShortage = formattedAlerts.reduce((sum, alert) => sum + alert.shortage_quantity, 0);

    const stats = {
      total_alerts: totalAlerts || 0,
      out_of_stock: outOfStockCount || 0,
      critical: criticalCount || 0,
      low: lowCount || 0,
      total_shortage: totalShortage
    };

    // Get total count for pagination using safe query
    let countQuery = supabase
      .from('low_stock_alert_view')
      .select('*', { count: 'exact', head: true });

    if (alertLevel) {
      countQuery = countQuery.eq('alert_level', alertLevel);
    }

    if (location) {
      countQuery = countQuery.ilike('location', `%${location}%`);
    }

    const { count: totalCount, error: countError } = await countQuery;

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    return NextResponse.json({
      success: true,
      data: formattedAlerts,
      meta: {
        total: totalCount || 0,
        limit,
        offset,
        stats
      }
    });

  } catch (error) {
    console.error('Error fetching stock alerts:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch stock alerts'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\stock\current\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Simple query to get all active items
    const { data: items, error } = await supabase
      .from('items')
      .select(`
        item_id,
        item_code,
        item_name,
        spec,
        unit,
        current_stock,
        safety_stock,
        location,
        price,
        category,
        is_active
      `)
      .eq('is_active', true)
      .order('item_name', { ascending: true });

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Calculate summary statistics
    const totalItems = items?.length || 0;
    const totalStockValue = items?.reduce((sum, item) => sum + ((item.current_stock || 0) * (item.price || 0)), 0) || 0;
    const lowStockItems = items?.filter(item => (item.current_stock || 0) < (item.safety_stock || 0)).length || 0;

    return NextResponse.json({
      success: true,
      data: {
        items: items || [],
        summary: {
          total_items: totalItems,
          total_stock_value: totalStockValue,
          low_stock_items: lowStockItems,
          avg_stock_level: totalItems > 0 ? items?.reduce((sum, item) => sum + (item.current_stock || 0), 0) / totalItems : 0
        }
      }
    });
  } catch (error) {
    console.error('Error fetching current stock:', error);
    return NextResponse.json(
      {
        success: false,
        error: '현재고 조회에 실패했습니다.'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\stock\debug\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

/**
 * Debug version of stock history API to identify the error
 */
export async function GET(request: NextRequest) {
  try {
    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Test 1: Simple query without complex joins
    const { data: simpleResult, error: simpleError } = await supabase
      .from('inventory_transactions')
      .select('transaction_id, transaction_type')
      .limit(5);

    if (simpleError) {
      throw new Error(`Simple query failed: ${simpleError.message}`);
    }

    // Test 2: With item join
    const { data: joinResult, error: joinError } = await supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_type,
        items!inner(item_name)
      `)
      .limit(3);

    if (joinError) {
      throw new Error(`Join query failed: ${joinError.message}`);
    }

    // Test 3: Check for problematic NULL values
    const { count: totalCount, error: countError } = await supabase
      .from('inventory_transactions')
      .select('*', { count: 'exact', head: true });

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    // Check items existence
    const { count: itemsCount, error: itemsError } = await supabase
      .from('items')
      .select('*', { count: 'exact', head: true });

    if (itemsError) {
      throw new Error(`Items count query failed: ${itemsError.message}`);
    }

    // Check users existence
    const { count: usersCount, error: usersError } = await supabase
      .from('users')
      .select('*', { count: 'exact', head: true });

    if (usersError) {
      throw new Error(`Users count query failed: ${usersError.message}`);
    }

    return NextResponse.json({
      success: true,
      data: {
        simple: simpleResult || [],
        join: joinResult?.map((item: any) => ({
          transaction_id: item.transaction_id,
          transaction_type: item.transaction_type,
          item_name: item.items?.item_name
        })) || [],
        nullCheck: {
          total: totalCount || 0,
          items_exist: itemsCount || 0,
          users_exist: usersCount || 0
        }
      }
    });
  } catch (error) {
    console.error('Debug API error:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Debug failed',
      details: error instanceof Error ? error.stack : 'No details'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\stock\history\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const { data: transactions, error } = await supabase
      .from('inventory_transactions')
      .select('*')
      .order('transaction_date', { ascending: false })
      .limit(100);

    if (error) {
      console.error('Supabase query error:', error);
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }

    // Calculate running balance for each transaction
    let runningBalance = 0;
    const historyWithBalance = (transactions || []).map((transaction: any) => {
      let quantityChange = 0;
      
      switch (transaction.transaction_type) {
        case '입고':
          quantityChange = transaction.quantity;
          break;
        case '출고':
          quantityChange = -transaction.quantity;
          break;
        case '조정':
          quantityChange = transaction.quantity;
          break;
        default:
          quantityChange = 0;
      }

      runningBalance += quantityChange;

      return {
        transaction_id: transaction.transaction_id,
        transaction_date: transaction.transaction_date,
        transaction_type: transaction.transaction_type,
        item_code: transaction.item_code || 'N/A',
        item_name: transaction.item_name || 'N/A',
        quantity_change: quantityChange,
        stock_balance: runningBalance,
        company_name: transaction.company_name || 'N/A',
        reference_number: transaction.reference_number,
        notes: transaction.notes
      };
    });

    return NextResponse.json({
      success: true,
      data: {
        history: historyWithBalance,
        pagination: {
          limit: 100,
          total: historyWithBalance.length,
          hasMore: false
        }
      }
    });
  } catch (error) {
    console.error('Error fetching stock history:', error);
    return NextResponse.json({ success: false, error: 'Failed to fetch stock history' }, { status: 500 });
  }
}
```


#### 📄 src\app\api\stock\items\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

/**
 * GET /api/stock/items
 * Get list of items for stock history dropdown
 * Returns: { item_id, item_code, item_name }
 */
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    const { data: items, error } = await supabase
      .from('items')
      .select('item_id, item_code, item_name')
      .eq('is_active', true)
      .order('item_code', { ascending: true })
      .order('item_name', { ascending: true });

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    return NextResponse.json({
      success: true,
      data: items || []
    });
  } catch (error) {
    console.error('Error fetching stock items:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch stock items'
      },
      { status: 500 }
    );
  }
}

```


#### 📄 src\app\api\stock\reports\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    return NextResponse.json({
      success: true,
      data: {
        report_date: new Date().toISOString().split('T')[0],
        summary: {
          total_items: 6,
          total_stock_value: 0,
          low_stock_items: 0,
          out_of_stock_items: 0
        },
        category_breakdown: [],
        top_items_by_value: [],
        generated_at: new Date().toISOString(),
        message: '기본 보고서 생성됨'
      }
    });
  } catch (error) {
    console.error('Error generating stock report:', error);
    return NextResponse.json(
      {
        success: false,
        error: '재고 보고서 생성 중 오류가 발생했습니다.',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createValidatedRoute } from '@/lib/validationMiddleware';
import { getSupabaseClient } from '@/lib/db-unified';

interface CurrentStock {
  item_id: number;
  item_code: string;
  item_name: string;
  spec?: string;
  category: string;
  unit: string;
  current_stock: number;
  safety_stock?: number;
  stock_value: number;
  is_low_stock: boolean;
}

export const GET = createValidatedRoute(
  async (request: NextRequest) => {
  try {
    const searchParams = request.nextUrl.searchParams;
    const category = searchParams.get('category');
    const status = searchParams.get('status');
    const search = searchParams.get('search');

    const supabase = getSupabaseClient();

    // Build query - get stock data from items table
    let query = supabase
      .from('items')
      .select('item_id, item_code, item_name, spec, category, unit, current_stock, safety_stock, price, is_active')
      .eq('is_active', true);

    // Apply filters
    if (category) {
      query = query.eq('category', category as any);
    }

    if (search) {
      query = query.or(`item_code.ilike.%${search}%,item_name.ilike.%${search}%`);
    }

    // Apply ordering
    query = query.order('item_code', { ascending: true });

    const { data: items, error } = await query;

    if (error) {
      console.error('Error fetching current stock:', error);
      throw new Error(error.message);
    }

    // Transform data and calculate stock status
    const stocks = ((items || []) as any[]).map((item: any) => {
      const currentStock = item.current_stock || 0;
      const safetyStock = item.safety_stock || 0;
      const stockValue = (item.price || 0) * currentStock;
      const isLowStock = currentStock <= safetyStock;

      return {
        item_id: item.item_id,
        item_code: item.item_code,
        item_name: item.item_name,
        spec: item.spec,
        category: item.category,
        unit: item.unit,
        current_stock: currentStock,
        safety_stock: safetyStock,
        stock_value: stockValue,
        is_low_stock: isLowStock
      };
    });

    // Apply status filter if needed
    let filteredStocks = stocks;
    if (status === 'low') {
      filteredStocks = stocks.filter(s => s.is_low_stock);
    } else if (status === 'normal') {
      filteredStocks = stocks.filter(s => !s.is_low_stock);
    }

    // Calculate summary statistics
    const summary = {
      total_items: filteredStocks.length,
      normal_items: filteredStocks.filter(s => !s.is_low_stock).length,
      low_stock_items: filteredStocks.filter(s => s.is_low_stock).length,
      total_value: filteredStocks.reduce((sum, s) => sum + s.stock_value, 0)
    };

    return NextResponse.json({
      success: true,
      data: filteredStocks,
      summary
    });
  } catch (error) {
    console.error('Error fetching current stock:', error);
    return NextResponse.json(
      {
        success: false,
        error: `Failed to fetch current stock: ${error instanceof Error ? error.message : 'Unknown error'}`
      },
      { status: 500 }
    );
  }
  },
  { resource: 'inventory', action: 'read', requireAuth: false }
);

// Get stock history for a specific item
export const POST = createValidatedRoute(
  async (request: NextRequest) => {
  try {
    const body = await request.json();
    const { item_id, start_date, end_date } = body;

    if (!item_id) {
      return NextResponse.json(
        {
          success: false,
          error: 'Item ID is required'
        },
        { status: 400 }
      );
    }

    const projectId = process.env.SUPABASE_PROJECT_ID;
    if (!projectId) {
      throw new Error('SUPABASE_PROJECT_ID not configured');
    }

    let sql = `
      SELECT
        it.*,
        i.item_code,
        i.item_name,
        c.company_name,
        u.name as created_by_name,
        SUM(
          CASE
            WHEN it2.transaction_type IN ('입고', '생산입고') THEN it2.quantity
            WHEN it2.transaction_type IN ('출고', '생산출고', '폐기') THEN -it2.quantity
            WHEN it2.transaction_type = '이동' AND it2.to_location IS NOT NULL THEN it2.quantity
            WHEN it2.transaction_type = '이동' AND it2.from_location IS NOT NULL THEN -it2.quantity
            WHEN it2.transaction_type = '재고조정' THEN it2.quantity
            ELSE 0
          END
        ) OVER (
          PARTITION BY it.item_id
          ORDER BY it.transaction_date, it.created_at
          ROWS UNBOUNDED PRECEDING
        ) as running_balance
      FROM inventory_transactions it
      JOIN inventory_transactions it2 ON it2.item_id = it.item_id
        AND (it2.transaction_date < it.transaction_date
          OR (it2.transaction_date = it.transaction_date AND it2.created_at <= it.created_at))
      JOIN items i ON it.item_id = i.item_id
      LEFT JOIN companies c ON it.company_id = c.company_id
      JOIN users u ON it.created_by = u.user_id
      WHERE it.item_id = ${item_id}
    `;

    if (start_date) {
      sql += ` AND it.transaction_date >= '${start_date}'`;
    }

    if (end_date) {
      sql += ` AND it.transaction_date <= '${end_date}'`;
    }

    sql += ' GROUP BY it.transaction_id ORDER BY it.transaction_date DESC, it.created_at DESC';

    const { mcp__supabase__execute_sql } = await import('@/lib/supabase-mcp');
    const result = await mcp__supabase__execute_sql({
      project_id: projectId,
      query: sql
    });

    const history = result?.rows || [];

    return NextResponse.json({
      success: true,
      data: history
    });
  } catch (error) {
    console.error('Error fetching stock history:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch stock history'
      },
      { status: 500 }
    );
  }
  },
  { resource: 'inventory', action: 'read', requireAuth: false }
);
```


#### 📄 src\app\api\stock\simple\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

/**
 * Simplified stock history API without complex balance calculations
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Initialize Supabase client for safe queries
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Build safe query using Supabase client
    const { data: transactions, error } = await supabase
      .from('inventory_transactions')
      .select(`
        transaction_id,
        transaction_date,
        transaction_type,
        quantity,
        unit_price,
        total_amount,
        reference_no,
        notes,
        items!inner(item_code, item_name, spec, item_type),
        companies!left(company_name),
        users!left(username)
      `)
      .order('transaction_date', { ascending: false })
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      throw new Error(`Database query failed: ${error.message}`);
    }

    // Transform data to include calculated stock_change
    const formattedTransactions = transactions?.map((t: any) => {
      let stockChange = 0;
      switch (t.transaction_type) {
        case '입고':
        case 'MATERIAL_IN':
        case 'PRODUCTION_IN':
        case '생산입고':
          stockChange = t.quantity;
          break;
        case '출고':
        case 'PRODUCT_OUT':
        case '생산출고':
          stockChange = -t.quantity;
          break;
        case '조정':
          stockChange = t.quantity;
          break;
        default:
          stockChange = 0;
      }

      return {
        transaction_id: t.transaction_id,
        transaction_date: t.transaction_date,
        transaction_type: t.transaction_type,
        quantity: t.quantity,
        unit_price: t.unit_price,
        total_amount: t.total_amount,
        reference_no: t.reference_no,
        notes: t.notes,
        item_code: t.items?.item_code,
        item_name: t.items?.item_name,
        specification: t.items?.spec,
        item_type: t.items?.item_type,
        company_name: t.companies?.company_name,
        created_by_name: t.users?.username,
        stock_change: stockChange
      };
    }) || [];

    // Get total count using safe query
    const { count: totalCount, error: countError } = await supabase
      .from('inventory_transactions')
      .select('*', { count: 'exact', head: true });

    if (countError) {
      throw new Error(`Count query failed: ${countError.message}`);
    }

    return NextResponse.json({
      success: true,
      data: {
        transactions: formattedTransactions,
        pagination: {
          total: totalCount || 0,
          limit,
          offset,
          hasMore: offset + limit < (totalCount || 0)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching simple stock history:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : '재고 이력 조회 중 오류가 발생했습니다.',
      details: error instanceof Error ? error.stack : 'No details'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\test\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    return NextResponse.json({
      success: true,
      message: 'API is working',
      timestamp: new Date().toISOString(),
      url: request.url
    });
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
```


#### 📄 src\app\api\upload\companies\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { parseExcelFile, validateRequiredField, cleanString, isValidEmail, isValidBusinessNumber } from '@/lib/excel-utils';
import { ExcelCompanyData, ValidationError, UploadResult, VALID_COMPANY_TYPES } from '@/types/upload';
import formidable from 'formidable';
import fs from 'fs';

export const config = {
  api: {
    bodyParser: false,
  },
};

// 데이터 유효성 검증
function validateCompanyData(data: any, rowIndex: number): {company: ExcelCompanyData | null, errors: ValidationError[]} {
  const errors: ValidationError[] = [];
  const row = rowIndex + 2; // Excel row number (header = 1, data starts from 2)

  // 필수 필드 검증
  if (!data.company_name || String(data.company_name).trim() === '') {
    errors.push({
      row,
      field: 'company_name',
      value: data.company_name,
      message: '회사명은 필수입니다'
    });
  }

  if (!data.company_type || String(data.company_type).trim() === '') {
    errors.push({
      row,
      field: 'company_type',
      value: data.company_type,
      message: '회사유형은 필수입니다'
    });
  } else {
    const companyType = String(data.company_type).trim();
    if (!VALID_COMPANY_TYPES.includes(companyType as any)) {
      errors.push({
        row,
        field: 'company_type',
        value: data.company_type,
        message: `회사유형은 다음 중 하나여야 합니다: ${VALID_COMPANY_TYPES.join(', ')}`
      });
    }
  }

  // 선택적 필드 검증
  if (data.email && String(data.email).trim() !== '') {
    if (!isValidEmail(String(data.email).trim())) {
      errors.push({
        row,
        field: 'email',
        value: data.email,
        message: '올바른 이메일 형식이 아닙니다'
      });
    }
  }

  if (data.business_registration_no && String(data.business_registration_no).trim() !== '') {
    if (!isValidBusinessNumber(String(data.business_registration_no).trim())) {
      errors.push({
        row,
        field: 'business_registration_no',
        value: data.business_registration_no,
        message: '올바른 사업자번호 형식이 아닙니다 (예: 123-45-67890)'
      });
    }
  }

  if (errors.length > 0) {
    return { company: null, errors };
  }

  return {
    company: {
      company_name: String(data.company_name).trim(),
      company_type: String(data.company_type).trim(),
      business_registration_no: data.business_registration_no ? String(data.business_registration_no).trim() : undefined,
      contact_person: data.contact_person ? String(data.contact_person).trim() : undefined,
      phone: data.phone ? String(data.phone).trim() : undefined,
      mobile: data.mobile ? String(data.mobile).trim() : undefined,
      email: data.email ? String(data.email).trim() : undefined,
      address: data.address ? String(data.address).trim() : undefined,
      payment_terms: data.payment_terms ? String(data.payment_terms).trim() : undefined,
      contact_info: data.contact_info ? String(data.contact_info).trim() : undefined,
      notes: data.notes ? String(data.notes).trim() : undefined,
    },
    errors: []
  };
}

// 중복 검사 (회사명과 사업자번호로 검사)
async function checkDuplicates(companies: ExcelCompanyData[]): Promise<string[]> {
  const duplicates: string[] = [];
  const { mcp__supabase__execute_sql } = await import('@/lib/supabase-mcp');

  for (const company of companies) {
    let sql = `SELECT company_name FROM companies WHERE is_active = true AND (company_name = '${company.company_name.replace(/'/g, "''")}'`;

    if (company.business_registration_no) {
      sql += ` OR business_registration_no = '${company.business_registration_no.replace(/'/g, "''")}'`;
    }

    sql += ')';

    const existingCompanies = await mcp__supabase__execute_sql({
      project_id: process.env.NEXT_PUBLIC_SUPABASE_PROJECT_ID || 'pybjnkbmtlyaftuiieyq',
      query: sql
    });

    const existingCompaniesArray = Array.isArray(existingCompanies) ? existingCompanies : [];
    if (existingCompaniesArray.length > 0) {
      duplicates.push(company.company_name);
    }
  }

  return duplicates;
}

// 배치 삽입
async function batchInsertCompanies(companies: ExcelCompanyData[]): Promise<void> {
  // Supabase insert multiple rows at once
  const companiesToInsert = companies.map(company => ({
    company_name: company.company_name,
    company_type: company.company_type,
    business_registration_no: company.business_registration_no || null,
    contact_person: company.contact_person || null,
    phone: company.phone || null,
    mobile: company.mobile || null,
    email: company.email || null,
    address: company.address || null,
    payment_terms: company.payment_terms || null,
    contact_info: company.contact_info || null,
    notes: company.notes || null
  }));

  const { mcp__supabase__execute_sql } = await import('@/lib/supabase-mcp');

  await mcp__supabase__execute_sql({
    project_id: process.env.NEXT_PUBLIC_SUPABASE_PROJECT_ID || 'pybjnkbmtlyaftuiieyq',
    query: `INSERT INTO companies (
      company_name, company_type, business_registration_no,
      contact_person, phone, mobile, email, address,
      payment_terms, contact_info, notes
    ) SELECT * FROM json_populate_recordset(NULL::companies, '${JSON.stringify(companiesToInsert).replace(/'/g, "''")}')`
  });
}

export async function POST(request: NextRequest) {
  let tempFilePath: string | null = null;

  try {
    // multipart/form-data 파싱
    const form = formidable({
      maxFileSize: 10 * 1024 * 1024, // 10MB
      keepExtensions: true,
    });

    const { files } = await new Promise<{files: formidable.Files}>((resolve, reject) => {
      form.parse(request as any, (err, fields, files) => {
        if (err) reject(err);
        else resolve({ files });
      });
    });

    const file = Array.isArray(files.file) ? files.file[0] : files.file;

    if (!file) {
      return NextResponse.json({
        success: false,
        error: '파일이 업로드되지 않았습니다'
      }, { status: 400 });
    }

    // Excel 파일 확장자 검증
    const fileName = file.originalFilename || '';
    if (!fileName.match(/\.(xlsx|xls)$/i)) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일(.xlsx, .xls)만 업로드 가능합니다'
      }, { status: 400 });
    }

    tempFilePath = file.filepath;

    // Excel 파일 파싱
    const rawData = await parseExcelFile(tempFilePath);

    if (rawData.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일에 데이터가 없습니다'
      }, { status: 400 });
    }

    // 데이터 유효성 검증
    const validCompanies: ExcelCompanyData[] = [];
    const allErrors: ValidationError[] = [];

    for (let i = 0; i < rawData.length; i++) {
      const { company, errors } = validateCompanyData(rawData[i], i);

      if (errors.length > 0) {
        allErrors.push(...errors);
      } else if (company) {
        validCompanies.push(company);
      }
    }

    // 중복 검사
    const duplicates = validCompanies.length > 0 ? await checkDuplicates(validCompanies) : [];
    const companiesToInsert = validCompanies.filter(company => !duplicates.includes(company.company_name));

    // 결과 생성
    const result: UploadResult = {
      success: allErrors.length === 0 && duplicates.length === 0,
      total_rows: rawData.length,
      success_count: 0,
      error_count: allErrors.length + duplicates.length,
      errors: allErrors,
      duplicates
    };

    // 유효한 데이터가 있으면 삽입
    if (companiesToInsert.length > 0) {
      await batchInsertCompanies(companiesToInsert);
      result.success_count = companiesToInsert.length;
    }

    return NextResponse.json({
      success: true,
      message: '파일 업로드가 완료되었습니다',
      data: result
    });

  } catch (error) {
    console.error('Excel upload error:', error);
    return NextResponse.json({
      success: false,
      error: 'Excel 파일 업로드 중 오류가 발생했습니다'
    }, { status: 500 });

  } finally {
    // 임시 파일 정리
    if (tempFilePath && fs.existsSync(tempFilePath)) {
      try {
        fs.unlinkSync(tempFilePath);
      } catch (cleanupError) {
        console.error('임시 파일 삭제 실패:', cleanupError);
      }
    }
  }
}
```


#### 📄 src\app\api\upload\items\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { parseExcelFile, validateRequiredField, cleanString, cleanNumber, isValidNumber } from '@/lib/excel-utils';
import { ExcelItemData, ValidationError, UploadResult, VALID_ITEM_TYPES } from '@/types/upload';
import formidable from 'formidable';
import fs from 'fs';

export const config = {
  api: {
    bodyParser: false,
  },
};

// 데이터 유효성 검증
function validateItemData(data: any, rowIndex: number): {item: ExcelItemData | null, errors: ValidationError[]} {
  const errors: ValidationError[] = [];
  const row = rowIndex + 2; // Excel row number (header = 1, data starts from 2)

  // 필수 필드 검증
  if (!data.item_code || String(data.item_code).trim() === '') {
    errors.push({
      row,
      field: 'item_code',
      value: data.item_code,
      message: '품목코드는 필수입니다'
    });
  }

  if (!data.item_name || String(data.item_name).trim() === '') {
    errors.push({
      row,
      field: 'item_name',
      value: data.item_name,
      message: '품목명은 필수입니다'
    });
  }

  if (!data.item_type || String(data.item_type).trim() === '') {
    errors.push({
      row,
      field: 'item_type',
      value: data.item_type,
      message: '품목유형은 필수입니다'
    });
  } else if (!VALID_ITEM_TYPES.includes(String(data.item_type).trim() as any)) {
    errors.push({
      row,
      field: 'item_type',
      value: data.item_type,
      message: `품목유형은 다음 중 하나여야 합니다: ${VALID_ITEM_TYPES.join(', ')}`
    });
  }

  if (!data.unit || String(data.unit).trim() === '') {
    errors.push({
      row,
      field: 'unit',
      value: data.unit,
      message: '단위는 필수입니다'
    });
  }

  // 숫자 필드 검증
  if (data.unit_price !== undefined && data.unit_price !== null && data.unit_price !== '') {
    const price = Number(data.unit_price);
    if (isNaN(price) || price < 0) {
      errors.push({
        row,
        field: 'unit_price',
        value: data.unit_price,
        message: '단가는 0 이상의 숫자여야 합니다'
      });
    }
  }

  if (data.min_stock_level !== undefined && data.min_stock_level !== null && data.min_stock_level !== '') {
    const minStock = Number(data.min_stock_level);
    if (isNaN(minStock) || minStock < 0) {
      errors.push({
        row,
        field: 'min_stock_level',
        value: data.min_stock_level,
        message: '최소재고는 0 이상의 숫자여야 합니다'
      });
    }
  }

  if (errors.length > 0) {
    return { item: null, errors };
  }

  return {
    item: {
      item_code: String(data.item_code).trim(),
      item_name: String(data.item_name).trim(),
      item_type: String(data.item_type).trim(),
      car_model: data.car_model ? String(data.car_model).trim() : undefined,
      spec: data.spec ? String(data.spec).trim() : undefined,
      unit: String(data.unit).trim(),
      unit_price: data.unit_price ? Number(data.unit_price) : undefined,
      min_stock_level: data.min_stock_level ? Number(data.min_stock_level) : undefined,
      location: data.location ? String(data.location).trim() : undefined,
    },
    errors: []
  };
}

// 중복 검사
async function checkDuplicates(items: ExcelItemData[]): Promise<string[]> {
  const itemCodes = items.map(item => item.item_code);
  const { mcp__supabase__execute_sql } = await import('@/lib/supabase-mcp');

  // PostgreSQL ARRAY syntax with proper escaping
  const itemCodesArray = `ARRAY[${itemCodes.map(code => `'${code.replace(/'/g, "''")}'`).join(',')}]`;

  const existingItems = await mcp__supabase__execute_sql({
    project_id: process.env.NEXT_PUBLIC_SUPABASE_PROJECT_ID || 'pybjnkbmtlyaftuiieyq',
    query: `SELECT item_code FROM items WHERE item_code = ANY(${itemCodesArray}) AND is_active = true`
  });

  const existingItemsArray = Array.isArray(existingItems) ? existingItems : [];
  return existingItemsArray.map((item: any) => item.item_code);
}

// 배치 삽입
async function batchInsertItems(items: ExcelItemData[]): Promise<void> {
  // Supabase insert multiple rows at once
  const itemsToInsert = items.map(item => ({
    item_code: item.item_code,
    item_name: item.item_name,
    item_type: item.item_type,
    car_model: item.car_model || null,
    spec: item.spec || null,
    unit: item.unit,
    current_stock: 0, // 초기 재고는 0
    min_stock_level: item.min_stock_level || null,
    unit_price: item.unit_price || null,
    location: item.location || null
  }));

  const { mcp__supabase__execute_sql } = await import('@/lib/supabase-mcp');

  await mcp__supabase__execute_sql({
    project_id: process.env.NEXT_PUBLIC_SUPABASE_PROJECT_ID || 'pybjnkbmtlyaftuiieyq',
    query: `INSERT INTO items (
      item_code, item_name, item_type, car_model, spec,
      unit, current_stock, min_stock_level, unit_price, location
    ) SELECT * FROM json_populate_recordset(NULL::items, '${JSON.stringify(itemsToInsert).replace(/'/g, "''")}')`
  });
}

export async function POST(request: NextRequest) {
  let tempFilePath: string | null = null;

  try {
    // multipart/form-data 파싱
    const form = formidable({
      maxFileSize: 10 * 1024 * 1024, // 10MB
      keepExtensions: true,
    });

    const { files } = await new Promise<{files: formidable.Files}>((resolve, reject) => {
      form.parse(request as any, (err, fields, files) => {
        if (err) reject(err);
        else resolve({ files });
      });
    });

    const file = Array.isArray(files.file) ? files.file[0] : files.file;

    if (!file) {
      return NextResponse.json({
        success: false,
        error: '파일이 업로드되지 않았습니다'
      }, { status: 400 });
    }

    // Excel 파일 확장자 검증
    const fileName = file.originalFilename || '';
    if (!fileName.match(/\.(xlsx|xls)$/i)) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일(.xlsx, .xls)만 업로드 가능합니다'
      }, { status: 400 });
    }

    tempFilePath = file.filepath;

    // Excel 파일 파싱
    const rawData = await parseExcelFile(tempFilePath);

    if (rawData.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Excel 파일에 데이터가 없습니다'
      }, { status: 400 });
    }

    // 데이터 유효성 검증
    const validItems: ExcelItemData[] = [];
    const allErrors: ValidationError[] = [];

    for (let i = 0; i < rawData.length; i++) {
      const { item, errors } = validateItemData(rawData[i], i);

      if (errors.length > 0) {
        allErrors.push(...errors);
      } else if (item) {
        validItems.push(item);
      }
    }

    // 중복 검사
    const duplicates = validItems.length > 0 ? await checkDuplicates(validItems) : [];
    const itemsToInsert = validItems.filter(item => !duplicates.includes(item.item_code));

    // 결과 생성
    const result: UploadResult = {
      success: allErrors.length === 0 && duplicates.length === 0,
      total_rows: rawData.length,
      success_count: 0,
      error_count: allErrors.length + duplicates.length,
      errors: allErrors,
      duplicates
    };

    // 유효한 데이터가 있으면 삽입
    if (itemsToInsert.length > 0) {
      await batchInsertItems(itemsToInsert);
      result.success_count = itemsToInsert.length;
    }

    return NextResponse.json({
      success: true,
      message: '파일 업로드가 완료되었습니다',
      data: result
    });

  } catch (error) {
    console.error('Excel upload error:', error);
    return NextResponse.json({
      success: false,
      error: 'Excel 파일 업로드 중 오류가 발생했습니다'
    }, { status: 500 });

  } finally {
    // 임시 파일 정리
    if (tempFilePath && fs.existsSync(tempFilePath)) {
      try {
        fs.unlinkSync(tempFilePath);
      } catch (cleanupError) {
        console.error('임시 파일 삭제 실패:', cleanupError);
      }
    }
  }
}
```


#### 📄 src\app\api\users\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { query } from '@/lib/db-unified';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const role = searchParams.get('role');
    const is_active = searchParams.get('is_active');

    let sql = `
      SELECT
        user_id,
        username,
        full_name,
        email,
        role,
        is_active,
        created_at
      FROM users
      WHERE 1=1
    `;
    const params: unknown[] = [];
    let paramIndex = 1;

    if (role) {
      sql += ` AND role = $${paramIndex++}`;
      params.push(role);
    }

    if (is_active !== null) {
      sql += ` AND is_active = $${paramIndex++}`;
      params.push(is_active === 'true');
    }

    sql += ' ORDER BY username ASC';

    const users = await query<any[]>(sql, params);

    return NextResponse.json({
      success: true,
      data: Array.isArray(users) ? users : []
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch users'
      },
      { status: 500 }
    );
  }
}
```


#### 📄 src\app\api\warehouses\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseClient } from '@/lib/db-unified';
import { APIError, validateRequiredFields } from '@/lib/api-error-handler';
import type { Database } from '@/types/supabase';

type WarehouseRow = Database['public']['Tables']['warehouses']['Row'];
type WarehouseInsert = Database['public']['Tables']['warehouses']['Insert'];
type WarehouseUpdate = Database['public']['Tables']['warehouses']['Update'];

type WarehouseWithUser = WarehouseRow & {
  users?: {
    name?: string | null;
  } | null;
};

const DEFAULT_USER_ID = 1;

function parseJsonBody<T>(request: NextRequest): Promise<T> {
  return request
    .json()
    .catch(() => {
      throw new APIError('요청 본문을 파싱할 수 없습니다. JSON 형식을 확인해주세요.', 400);
    });
}

function normalizeBoolean(value: unknown): boolean | null {
  if (value === undefined || value === null || value === '') {
    return null;
  }

  if (typeof value === 'boolean') {
    return value;
  }

  if (typeof value === 'number') {
    if (value === 1) return true;
    if (value === 0) return false;
  }

  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    if (['true', '1', 'y', 'yes', 'on'].includes(normalized)) {
      return true;
    }
    if (['false', '0', 'n', 'no', 'off'].includes(normalized)) {
      return false;
    }
  }

  throw new APIError('올바르지 않은 boolean 값이 전달되었습니다.', 400, { value });
}

function toOptionalNumber(value: unknown, field: string): number | null {
  if (value === undefined || value === null || value === '') {
    return null;
  }

  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    throw new APIError(`${field} 값이 올바르지 않습니다.`, 400, { value });
  }

  return numeric;
}

function handleRouteError(error: unknown, fallbackMessage: string): NextResponse {
  if (error instanceof APIError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        details: error.details,
      },
      { status: error.statusCode }
    );
  }

  console.error('[warehouses] Unexpected error:', error);
  return NextResponse.json(
    {
      success: false,
      error: fallbackMessage,
    },
    { status: 500 }
  );
}

function mapWarehouse(row: WarehouseWithUser) {
  const maxCapacity = row.max_capacity ?? 0;
  const currentUsage = row.current_usage ?? 0;
  const usagePercentage = maxCapacity > 0
    ? Math.round((currentUsage / maxCapacity) * 10000) / 100
    : 0;

  return {
    ...row,
    created_by_name: row.users?.name ?? null,
    usage_percentage: usagePercentage,
  };
}

export async function GET(request: NextRequest) {
  try {
    const supabase = getSupabaseClient();
    const searchParams = request.nextUrl.searchParams;
    const warehouseType = searchParams.get('type');
    const activeParam = searchParams.get('active');
    const filterActiveOnly = activeParam !== 'false';

    let query = supabase
      .from('warehouses')
      .select(
        `
        warehouse_id,
        warehouse_code,
        warehouse_name,
        warehouse_type,
        address,
        manager_name,
        manager_phone,
        max_capacity,
        current_usage,
        temperature_controlled,
        is_active,
        created_at,
        updated_at,
        created_by,
        users:users(name)
      `
      );

    if (filterActiveOnly) {
      query = query.eq('is_active', true);
    }

    if (warehouseType) {
      query = query.eq('warehouse_type', warehouseType);
    }

    query = query.order('warehouse_code', { ascending: true });

    const { data, error } = await query;

    if (error) {
      throw new APIError('창고 정보를 조회하지 못했습니다.', 500, error.message);
    }

    const warehouses = (data ?? []).map((warehouse) =>
      mapWarehouse(warehouse as WarehouseWithUser)
    );

    return NextResponse.json({
      success: true,
      data: warehouses,
    });
  } catch (error) {
    return handleRouteError(error, '창고 정보를 조회하지 못했습니다.');
  }
}

export async function POST(request: NextRequest) {
  try {
    const payload = await parseJsonBody<Partial<WarehouseInsert>>(request);
    const validationErrors = validateRequiredFields(payload as Record<string, unknown>, [
      'warehouse_code',
      'warehouse_name',
      'warehouse_type',
    ]);

    if (validationErrors.length > 0) {
      throw new APIError('필수 입력값을 확인해주세요.', 400, validationErrors);
    }

    const warehouseCode = String(payload.warehouse_code).trim();
    const warehouseName = String(payload.warehouse_name).trim();
    const warehouseType = payload.warehouse_type as WarehouseInsert['warehouse_type'];
    const temperatureControlled = payload.temperature_controlled !== undefined
      ? normalizeBoolean(payload.temperature_controlled)
      : null;
    const maxCapacity = toOptionalNumber(payload.max_capacity, 'max_capacity');
    const currentUsage = toOptionalNumber(payload.current_usage, 'current_usage');

    const supabase = getSupabaseClient();

    const { data: duplicate, error: duplicateError } = await supabase
      .from('warehouses')
      .select('warehouse_id')
      .eq('warehouse_code', warehouseCode)
      .maybeSingle();

    if (duplicateError) {
      throw new APIError('창고 중복 여부를 확인하지 못했습니다.', 500, duplicateError.message);
    }

    if (duplicate) {
      throw new APIError('이미 사용 중인 창고 코드입니다.', 409);
    }

    const now = new Date().toISOString();
    const newWarehouse: WarehouseInsert = {
      warehouse_code: warehouseCode,
      warehouse_name: warehouseName,
      warehouse_type: warehouseType,
      address: payload.address ?? null,
      manager_name: payload.manager_name ?? null,
      manager_phone: payload.manager_phone ?? null,
      temperature_controlled: temperatureControlled,
      max_capacity: maxCapacity,
      current_usage: currentUsage ?? 0,
      is_active: true,
      created_at: now,
      updated_at: now,
      created_by: payload.created_by ?? DEFAULT_USER_ID,
    };

    const { data, error } = await supabase
      .from('warehouses')
      .insert(newWarehouse)
      .select(
        `
        warehouse_id,
        warehouse_code,
        warehouse_name,
        warehouse_type,
        address,
        manager_name,
        manager_phone,
        max_capacity,
        current_usage,
        temperature_controlled,
        is_active,
        created_at,
        updated_at,
        created_by,
        users:users(name)
      `
      )
      .maybeSingle();

    if (error || !data) {
      throw new APIError('창고를 등록하지 못했습니다.', 500, error?.message);
    }

    return NextResponse.json({
      success: true,
      data: mapWarehouse(data as WarehouseWithUser),
      message: '창고가 성공적으로 등록되었습니다.',
    });
  } catch (error) {
    return handleRouteError(error, '창고 등록 중 오류가 발생했습니다.');
  }
}

export async function PUT(request: NextRequest) {
  try {
    const payload = await parseJsonBody<Record<string, unknown>>(request);
    const warehouseId = toOptionalNumber(payload.id ?? payload.warehouse_id, 'warehouse_id');

    if (!warehouseId || !Number.isInteger(warehouseId)) {
      throw new APIError('창고 ID가 올바르지 않습니다.', 400, { warehouseId: payload.id });
    }

    const updatedFields: WarehouseUpdate = {};

    if (payload.warehouse_code !== undefined) {
      updatedFields.warehouse_code = String(payload.warehouse_code).trim();
    }
    if (payload.warehouse_name !== undefined) {
      updatedFields.warehouse_name = String(payload.warehouse_name).trim();
    }
    if (payload.warehouse_type !== undefined) {
      updatedFields.warehouse_type = payload.warehouse_type as WarehouseUpdate['warehouse_type'];
    }
    if (payload.address !== undefined) {
      updatedFields.address = payload.address ? String(payload.address) : null;
    }
    if (payload.manager_name !== undefined) {
      updatedFields.manager_name = payload.manager_name ? String(payload.manager_name) : null;
    }
    if (payload.manager_phone !== undefined) {
      updatedFields.manager_phone = payload.manager_phone ? String(payload.manager_phone) : null;
    }
    if (payload.temperature_controlled !== undefined) {
      updatedFields.temperature_controlled = normalizeBoolean(payload.temperature_controlled);
    }
    if (payload.max_capacity !== undefined) {
      updatedFields.max_capacity = toOptionalNumber(payload.max_capacity, 'max_capacity');
    }
    if (payload.current_usage !== undefined) {
      updatedFields.current_usage = toOptionalNumber(payload.current_usage, 'current_usage');
    }
    if (payload.is_active !== undefined) {
      const active = normalizeBoolean(payload.is_active);
      if (active === null) {
        throw new APIError('is_active 값이 올바르지 않습니다.', 400, { value: payload.is_active });
      }
      updatedFields.is_active = active;
    }

    if (Object.keys(updatedFields).length === 0) {
      throw new APIError('수정할 값이 없습니다.', 400);
    }

    const supabase = getSupabaseClient();

    if (updatedFields.warehouse_code) {
      const { data: duplicate, error: duplicateError } = await supabase
        .from('warehouses')
        .select('warehouse_id')
        .eq('warehouse_code', updatedFields.warehouse_code)
        .neq('warehouse_id', warehouseId)
        .maybeSingle();

      if (duplicateError) {
        throw new APIError('창고 중복 여부를 확인하지 못했습니다.', 500, duplicateError.message);
      }

      if (duplicate) {
        throw new APIError('이미 사용 중인 창고 코드입니다.', 409);
      }
    }

    const now = new Date().toISOString();

    const { data, error } = await supabase
      .from('warehouses')
      .update({
        ...updatedFields,
        updated_at: now,
      })
      .eq('warehouse_id', warehouseId)
      .select(
        `
        warehouse_id,
        warehouse_code,
        warehouse_name,
        warehouse_type,
        address,
        manager_name,
        manager_phone,
        max_capacity,
        current_usage,
        temperature_controlled,
        is_active,
        created_at,
        updated_at,
        created_by,
        users:users(name)
      `
      )
      .maybeSingle();

    if (error) {
      throw new APIError('창고 정보를 수정하지 못했습니다.', 500, error.message);
    }

    if (!data) {
      throw new APIError('수정 대상 창고를 찾을 수 없습니다.', 404);
    }

    return NextResponse.json({
      success: true,
      data: mapWarehouse(data as WarehouseWithUser),
      message: '창고 정보가 수정되었습니다.',
    });
  } catch (error) {
    return handleRouteError(error, '창고 수정 중 오류가 발생했습니다.');
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const idParam = request.nextUrl.searchParams.get('id');

    if (!idParam) {
      throw new APIError('창고 ID가 필요합니다.', 400);
    }

    const warehouseId = Number(idParam);

    if (!Number.isInteger(warehouseId)) {
      throw new APIError('창고 ID가 올바르지 않습니다.', 400, { id: idParam });
    }

    const supabase = getSupabaseClient();

    const { count, error: stockError } = await supabase
      .from('warehouse_stock')
      .select('warehouse_stock_id', { head: true, count: 'exact' })
      .eq('warehouse_id', warehouseId)
      .gt('current_quantity', 0);

    if (stockError) {
      throw new APIError('창고 재고 정보를 확인하지 못했습니다.', 500, stockError.message);
    }

    if ((count ?? 0) > 0) {
      throw new APIError('재고가 남아 있는 창고는 비활성화할 수 없습니다.', 400);
    }

    const now = new Date().toISOString();
    const { data, error } = await supabase
      .from('warehouses')
      .update({
        is_active: false,
        updated_at: now,
      })
      .eq('warehouse_id', warehouseId)
      .select('warehouse_id')
      .maybeSingle();

    if (error) {
      throw new APIError('창고를 비활성화하지 못했습니다.', 500, error.message);
    }

    if (!data) {
      throw new APIError('대상 창고를 찾을 수 없습니다.', 404);
    }

    return NextResponse.json({
      success: true,
      message: '창고가 비활성화되었습니다.',
    });
  } catch (error) {
    return handleRouteError(error, '창고 비활성화 중 오류가 발생했습니다.');
  }
}

```


#### 📄 src\app\api\warehouses\stock\route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseClient } from '@/lib/db-unified';
import { APIError, validateRequiredFields } from '@/lib/api-error-handler';
import type { Database } from '@/types/supabase';

type WarehouseStockRow = Database['public']['Tables']['warehouse_stock']['Row'];
type WarehouseStockInsert = Database['public']['Tables']['warehouse_stock']['Insert'];
type WarehouseStockUpdate = Database['public']['Tables']['warehouse_stock']['Update'];
type InventoryTransactionInsert = Database['public']['Tables']['inventory_transactions']['Insert'];

type WarehouseStockWithRelations = WarehouseStockRow & {
  warehouses?: {
    warehouse_code: string | null;
    warehouse_name: string | null;
    warehouse_type: Database['public']['Enums']['warehouse_type'] | null;
  } | null;
  items?: {
    item_code: string | null;
    item_name: string | null;
    spec: string | null;
    unit: string | null;
  } | null;
};

const DEFAULT_USER_ID = 1;

type ParsedStockStatus = '재고부족' | '재고과다' | '정상';

function parseJsonBody<T>(request: NextRequest): Promise<T> {
  return request
    .json()
    .catch(() => {
      throw new APIError('요청 본문을 파싱할 수 없습니다. JSON 형식을 확인해주세요.', 400);
    });
}

function handleRouteError(error: unknown, fallbackMessage: string): NextResponse {
  if (error instanceof APIError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        details: error.details,
      },
      { status: error.statusCode }
    );
  }

  console.error('[warehouses/stock] Unexpected error:', error);
  return NextResponse.json(
    {
      success: false,
      error: fallbackMessage,
    },
    { status: 500 }
  );
}

function parseOptionalNumber(value: string | null, field: string): number | null {
  if (value === null || value.trim() === '') {
    return null;
  }

  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    throw new APIError(`${field} 파라미터가 올바르지 않습니다.`, 400, { value });
  }

  return numeric;
}

function ensureNumber(value: unknown, field: string): number {
  const numeric = Number(value);

  if (!Number.isFinite(numeric)) {
    throw new APIError(`${field} 값이 올바르지 않습니다.`, 400, { value });
  }

  return numeric;
}

function calculateAvailableQuantity(stock: Pick<WarehouseStockRow, 'current_quantity' | 'reserved_quantity' | 'available_quantity'>): number {
  if (stock.available_quantity !== null && stock.available_quantity !== undefined) {
    return Number(stock.available_quantity);
  }

  const current = stock.current_quantity ?? 0;
  const reserved = stock.reserved_quantity ?? 0;
  return Math.max(0, current - reserved);
}

function determineStockStatus(current: number, min: number, max: number): ParsedStockStatus {
  if (max > 0 && current >= max) {
    return '재고과다';
  }

  if (current <= min) {
    return '재고부족';
  }

  return '정상';
}

function formatStockRow(row: WarehouseStockWithRelations) {
  const current = row.current_quantity ?? 0;
  const reserved = row.reserved_quantity ?? 0;
  const min = row.min_stock ?? 0;
  const max = row.max_stock ?? 0;
  const available = calculateAvailableQuantity(row);

  return {
    id: row.warehouse_stock_id,
    warehouse_stock_id: row.warehouse_stock_id,
    warehouse_id: row.warehouse_id,
    warehouse_code: row.warehouses?.warehouse_code ?? null,
    warehouse_name: row.warehouses?.warehouse_name ?? null,
    warehouse_type: row.warehouses?.warehouse_type ?? null,
    item_id: row.item_id,
    item_code: row.items?.item_code ?? null,
    item_name: row.items?.item_name ?? null,
    specification: row.items?.spec ?? null,
    unit: row.items?.unit ?? null,
    current_quantity: current,
    reserved_quantity: reserved,
    available_quantity: available,
    location_code: row.location_code,
    min_stock: min,
    max_stock: max,
    last_in_date: row.last_in_date,
    last_out_date: row.last_out_date,
    stock_status: determineStockStatus(current, min, max),
  };
}

export async function GET(request: NextRequest) {
  try {
    const supabase = getSupabaseClient();
    const searchParams = request.nextUrl.searchParams;
    const warehouseId = parseOptionalNumber(searchParams.get('warehouseId'), 'warehouseId');
    const itemId = parseOptionalNumber(searchParams.get('itemId'), 'itemId');
    const statusFilter = searchParams.get('status');

    let query = supabase
      .from('warehouse_stock')
      .select(
        `
        warehouse_stock_id,
        warehouse_id,
        item_id,
        current_quantity,
        reserved_quantity,
        available_quantity,
        location_code,
        min_stock,
        max_stock,
        last_in_date,
        last_out_date,
        warehouses:warehouses(warehouse_code, warehouse_name, warehouse_type),
        items:items(item_code, item_name, spec, unit)
      `
      );

    if (warehouseId !== null) {
      query = query.eq('warehouse_id', warehouseId);
    }

    if (itemId !== null) {
      query = query.eq('item_id', itemId);
    }

    query = query.order('warehouse_id', { ascending: true }).order('item_id', { ascending: true });

    const { data, error } = await query;

    if (error) {
      throw new APIError('창고 재고 정보를 조회하지 못했습니다.', 500, error.message);
    }

    const stocks = (data ?? []).map((stock) => formatStockRow(stock as WarehouseStockWithRelations));

    const filtered = statusFilter
      ? stocks.filter((stock) => stock.stock_status === statusFilter)
      : stocks;

    const summary = {
      totalWarehouses: new Set(filtered.map((stock) => stock.warehouse_id)).size,
      totalItems: new Set(filtered.map((stock) => stock.item_id)).size,
      totalQuantity: filtered.reduce((sum, stock) => sum + stock.current_quantity, 0),
      totalReserved: filtered.reduce((sum, stock) => sum + stock.reserved_quantity, 0),
      totalAvailable: filtered.reduce((sum, stock) => sum + stock.available_quantity, 0),
      stockStatusCount: {
        재고부족: filtered.filter((stock) => stock.stock_status === '재고부족').length,
        재고과다: filtered.filter((stock) => stock.stock_status === '재고과다').length,
        정상: filtered.filter((stock) => stock.stock_status === '정상').length,
      },
    };

    return NextResponse.json({
      success: true,
      data: filtered,
      summary,
    });
  } catch (error) {
    return handleRouteError(error, '창고 재고 정보를 조회하지 못했습니다.');
  }
}

export async function POST(request: NextRequest) {
  try {
    const payload = await parseJsonBody<Record<string, unknown>>(request);
    const validationErrors = validateRequiredFields(payload, [
      'warehouse_id',
      'item_id',
      'min_stock',
      'max_stock',
    ]);

    if (validationErrors.length > 0) {
      throw new APIError('필수 입력값을 확인해주세요.', 400, validationErrors);
    }

    const warehouseId = ensureNumber(payload.warehouse_id, 'warehouse_id');
    const itemId = ensureNumber(payload.item_id, 'item_id');
    const minStock = ensureNumber(payload.min_stock, 'min_stock');
    const maxStock = ensureNumber(payload.max_stock, 'max_stock');

    if (minStock < 0 || maxStock < 0) {
      throw new APIError('재고 임계값은 0 이상의 값이어야 합니다.', 400);
    }

    if (maxStock > 0 && minStock > maxStock) {
      throw new APIError('최소 재고는 최대 재고보다 클 수 없습니다.', 400);
    }

    const locationCode = payload.location_code ? String(payload.location_code).trim() : null;
    const supabase = getSupabaseClient();
    const now = new Date().toISOString();

    const { data: existing, error: existingError } = await supabase
      .from('warehouse_stock')
      .select('warehouse_stock_id, current_quantity, reserved_quantity, available_quantity')
      .eq('warehouse_id', warehouseId)
      .eq('item_id', itemId)
      .maybeSingle();

    if (existingError) {
      throw new APIError('창고 재고 정보를 확인하지 못했습니다.', 500, existingError.message);
    }

    if (existing) {
      const updatePayload: WarehouseStockUpdate = {
        location_code: locationCode,
        min_stock: minStock,
        max_stock: maxStock,
        updated_at: now,
      };

      const { error: updateError } = await supabase
        .from('warehouse_stock')
        .update(updatePayload)
        .eq('warehouse_stock_id', existing.warehouse_stock_id);

      if (updateError) {
        throw new APIError('창고 재고 정보를 수정하지 못했습니다.', 500, updateError.message);
      }
    } else {
      const insertPayload: WarehouseStockInsert = {
        warehouse_id: warehouseId,
        item_id: itemId,
        location_code: locationCode,
        min_stock: minStock,
        max_stock: maxStock,
        current_quantity: 0,
        reserved_quantity: 0,
        available_quantity: 0,
        created_at: now,
        updated_at: now,
        last_in_date: null,
        last_out_date: null,
      };

      const { error: insertError } = await supabase
        .from('warehouse_stock')
        .insert(insertPayload);

      if (insertError) {
        throw new APIError('창고 재고 정보를 생성하지 못했습니다.', 500, insertError.message);
      }
    }

    return NextResponse.json({
      success: true,
      message: '창고 재고 설정이 저장되었습니다.',
    });
  } catch (error) {
    return handleRouteError(error, '창고 재고 설정 저장 중 오류가 발생했습니다.');
  }
}

export async function PUT(request: NextRequest) {
  try {
    const payload = await parseJsonBody<Record<string, unknown>>(request);
    const validationErrors = validateRequiredFields(payload, [
      'from_warehouse_id',
      'to_warehouse_id',
      'item_id',
      'quantity',
    ]);

    if (validationErrors.length > 0) {
      throw new APIError('필수 입력값을 확인해주세요.', 400, validationErrors);
    }

    const fromWarehouseId = ensureNumber(payload.from_warehouse_id, 'from_warehouse_id');
    const toWarehouseId = ensureNumber(payload.to_warehouse_id, 'to_warehouse_id');
    const itemId = ensureNumber(payload.item_id, 'item_id');
    const quantity = ensureNumber(payload.quantity, 'quantity');

    if (quantity <= 0) {
      throw new APIError('이동 수량은 0보다 커야 합니다.', 400);
    }

    if (fromWarehouseId === toWarehouseId) {
      throw new APIError('동일한 창고 간에는 재고를 이동할 수 없습니다.', 400);
    }

    const supabase = getSupabaseClient();
    const now = new Date().toISOString();

    const { data: source, error: sourceError } = await supabase
      .from('warehouse_stock')
      .select('warehouse_stock_id, current_quantity, reserved_quantity, available_quantity')
      .eq('warehouse_id', fromWarehouseId)
      .eq('item_id', itemId)
      .maybeSingle();

    if (sourceError) {
      throw new APIError('출고 창고 재고를 확인하지 못했습니다.', 500, sourceError.message);
    }

    if (!source) {
      throw new APIError('출고 창고에 재고 정보가 없습니다.', 400);
    }

    const sourceAvailable = calculateAvailableQuantity(source);

    if (sourceAvailable < quantity) {
      throw new APIError('출고 창고의 가용 재고가 부족합니다.', 400);
    }

    const updatedSourceCurrent = Math.max(0, (source.current_quantity ?? 0) - quantity);
    const updatedSourceAvailable = Math.max(0, sourceAvailable - quantity);

    const { error: updateSourceError } = await supabase
      .from('warehouse_stock')
      .update({
        current_quantity: updatedSourceCurrent,
        available_quantity: updatedSourceAvailable,
        last_out_date: now,
        updated_at: now,
      })
      .eq('warehouse_stock_id', source.warehouse_stock_id);

    if (updateSourceError) {
      throw new APIError('출고 창고 재고를 갱신하지 못했습니다.', 500, updateSourceError.message);
    }

    const { data: target, error: targetError } = await supabase
      .from('warehouse_stock')
      .select('warehouse_stock_id, current_quantity, reserved_quantity, available_quantity')
      .eq('warehouse_id', toWarehouseId)
      .eq('item_id', itemId)
      .maybeSingle();

    if (targetError) {
      throw new APIError('입고 창고 재고를 확인하지 못했습니다.', 500, targetError.message);
    }

    const targetAvailable = target ? calculateAvailableQuantity(target) : 0;
    const targetCurrent = target?.current_quantity ?? 0;
    const updatedTargetCurrent = targetCurrent + quantity;
    const updatedTargetAvailable = targetAvailable + quantity;

    if (target) {
      const { error: updateTargetError } = await supabase
        .from('warehouse_stock')
        .update({
          current_quantity: updatedTargetCurrent,
          available_quantity: updatedTargetAvailable,
          last_in_date: now,
          updated_at: now,
        })
        .eq('warehouse_stock_id', target.warehouse_stock_id);

      if (updateTargetError) {
        throw new APIError('입고 창고 재고를 갱신하지 못했습니다.', 500, updateTargetError.message);
      }
    } else {
      const insertPayload: WarehouseStockInsert = {
        warehouse_id: toWarehouseId,
        item_id,
        current_quantity: quantity,
        available_quantity: quantity,
        reserved_quantity: 0,
        min_stock: 0,
        max_stock: null,
        location_code: null,
        last_in_date: now,
        created_at: now,
        updated_at: now,
      };

      const { error: insertTargetError } = await supabase
        .from('warehouse_stock')
        .insert(insertPayload);

      if (insertTargetError) {
        throw new APIError('입고 창고 재고를 생성하지 못했습니다.', 500, insertTargetError.message);
      }
    }

    const creator = payload.created_by ?? payload.user_id ?? DEFAULT_USER_ID;
    const createdBy = ensureNumber(creator, 'created_by');
    const note = payload.note ? String(payload.note).trim() : null;

    const transactionPayload: InventoryTransactionInsert = {
      transaction_date: now,
      transaction_type: '이동',
      item_id,
      quantity,
      warehouse_id: toWarehouseId,
      notes: note ?? `창고 ${fromWarehouseId} -> ${toWarehouseId} 이동`,
      created_at: now,
      created_by: createdBy,
    };

    const { error: transactionError } = await supabase
      .from('inventory_transactions')
      .insert(transactionPayload);

    if (transactionError) {
      throw new APIError('재고 이동 이력을 기록하지 못했습니다.', 500, transactionError.message);
    }

    return NextResponse.json({
      success: true,
      message: `${quantity}개의 재고가 이동되었습니다.`,
    });
  } catch (error) {
    return handleRouteError(error, '재고 이동 처리 중 오류가 발생했습니다.');
  }
}



```


#### 📄 src\contexts\ThemeContext.tsx

```typescript
/**
 * Theme Context for managing dark/light mode
 */

'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';

interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
  isDark: boolean;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    // Return default values if context is not available
    return {
      theme: 'light' as const,
      toggleTheme: () => {},
      isDark: false
    };
  }
  return context;
};

interface ThemeProviderProps {
  children: React.ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  useEffect(() => {
    // Check if we're in a browser environment
    if (typeof window !== 'undefined') {
      const savedTheme = localStorage.getItem('darkMode') === 'true' ? 'dark' : 'light';
      setTheme(savedTheme);
    }
  }, []);

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);

    if (typeof window !== 'undefined') {
      localStorage.setItem('darkMode', String(newTheme === 'dark'));

      if (newTheme === 'dark') {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    }
  };

  const isDark = theme === 'dark';

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, isDark }}>
      {children}
    </ThemeContext.Provider>
  );
};
```


#### 📄 src\contexts\ToastContext.tsx

```typescript
'use client';

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import Toast, { ToastType, ToastAction } from '../components/Toast';

interface ToastItem {
  id: string;
  type: ToastType;
  title: string;
  message?: string;
  duration?: number;
  showProgress?: boolean;
  persistent?: boolean;
  actions?: ToastAction[];
}

interface ToastContextType {
  addToast: (toast: Omit<ToastItem, 'id'>) => void;
  removeToast: (id: string) => void;
  clearToasts: () => void;
  success: (title: string, message?: string, duration?: number) => void;
  error: (title: string, message?: string, duration?: number) => void;
  warning: (title: string, message?: string, duration?: number) => void;
  info: (title: string, message?: string, duration?: number) => void;
  // Enhanced methods with actions
  successWithAction: (title: string, message?: string, actions?: ToastAction[], duration?: number) => void;
  errorWithAction: (title: string, message?: string, actions?: ToastAction[], duration?: number) => void;
  warningWithAction: (title: string, message?: string, actions?: ToastAction[], duration?: number) => void;
  infoWithAction: (title: string, message?: string, actions?: ToastAction[], duration?: number) => void;
  persistent: (type: ToastType, title: string, message?: string, actions?: ToastAction[]) => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
};

// Export the context for direct use if needed
export { ToastContext };

interface ToastProviderProps {
  children: ReactNode;
  maxToasts?: number;
}

export const ToastProvider: React.FC<ToastProviderProps> = ({
  children,
  maxToasts = 5
}) => {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const generateId = () => {
    return `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  };

  const addToast = useCallback((toast: Omit<ToastItem, 'id'>) => {
    const id = generateId();
    const newToast = { ...toast, id };

    setToasts(prev => {
      // Remove oldest toast if we've reached the limit
      const updatedToasts = prev.length >= maxToasts ? prev.slice(1) : prev;
      return [...updatedToasts, newToast];
    });
  }, [maxToasts]);

  const removeToast = useCallback((id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  }, []);

  const clearToasts = useCallback(() => {
    setToasts([]);
  }, []);

  const success = useCallback((title: string, message?: string, duration: number = 3000) => {
    addToast({ type: 'success', title, message, duration });
  }, [addToast]);

  const error = useCallback((title: string, message?: string, duration: number = 5000) => {
    addToast({ type: 'error', title, message, duration });
  }, [addToast]);

  const warning = useCallback((title: string, message?: string, duration: number = 4000) => {
    addToast({ type: 'warning', title, message, duration });
  }, [addToast]);

  const info = useCallback((title: string, message?: string, duration: number = 3000) => {
    addToast({ type: 'info', title, message, duration });
  }, [addToast]);

  // Enhanced methods with action support
  const successWithAction = useCallback((title: string, message?: string, actions?: ToastAction[], duration: number = 3000) => {
    addToast({ type: 'success', title, message, actions, duration });
  }, [addToast]);

  const errorWithAction = useCallback((title: string, message?: string, actions?: ToastAction[], duration: number = 5000) => {
    addToast({ type: 'error', title, message, actions, duration });
  }, [addToast]);

  const warningWithAction = useCallback((title: string, message?: string, actions?: ToastAction[], duration: number = 4000) => {
    addToast({ type: 'warning', title, message, actions, duration });
  }, [addToast]);

  const infoWithAction = useCallback((title: string, message?: string, actions?: ToastAction[], duration: number = 3000) => {
    addToast({ type: 'info', title, message, actions, duration });
  }, [addToast]);

  const persistent = useCallback((type: ToastType, title: string, message?: string, actions?: ToastAction[]) => {
    addToast({ type, title, message, actions, persistent: true, showProgress: false });
  }, [addToast]);

  const contextValue: ToastContextType = {
    addToast,
    removeToast,
    clearToasts,
    success,
    error,
    warning,
    info,
    successWithAction,
    errorWithAction,
    warningWithAction,
    infoWithAction,
    persistent,
  };

  return (
    <ToastContext.Provider value={contextValue}>
      {children}

      {/* Toast Container - Enhanced positioning and stacking */}
      <div
        aria-live="polite"
        aria-label="알림 메시지"
        className="fixed top-4 right-4 flex flex-col items-end pointer-events-none z-[10000] max-w-sm w-full"
        style={{ maxHeight: 'calc(100vh - 2rem)' }}
      >
        {toasts.map((toast, index) => {
          const isTop = index === toasts.length - 1;
          const offset = Math.max(0, toasts.length - 1 - index);

          return (
            <div
              key={toast.id}
              style={{
                transform: `translateY(${offset * -8}px) scale(${1 - offset * 0.05})`,
                zIndex: 10000 - index,
                opacity: 1 - offset * 0.1,
                transformOrigin: 'top right',
              }}
              className={`
                pointer-events-auto transition-all duration-300 ease-out mb-3 w-full
                ${!isTop && offset > 0 ? 'hover:scale-100 hover:opacity-100 hover:translate-y-0' : ''}
                ${offset > 2 ? 'opacity-0 pointer-events-none' : ''}
              `}
            >
              <Toast
                id={toast.id}
                type={toast.type}
                title={toast.title}
                message={toast.message}
                duration={toast.duration}
                showProgress={toast.showProgress}
                persistent={toast.persistent}
                actions={toast.actions}
                onClose={removeToast}
              />
            </div>
          );
        })}
      </div>
    </ToastContext.Provider>
  );
};
```


#### 📄 src\providers\QueryProvider.tsx

```typescript
'use client';

import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

// Create a client with optimized default settings for ERP system
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 5 minutes stale time for ERP data (balance between freshness and performance)
      staleTime: 5 * 60 * 1000,
      // 10 minutes cache time
      gcTime: 10 * 60 * 1000,
      // Refetch on window focus for data consistency
      refetchOnWindowFocus: true,
      // Don't refetch on reconnect to avoid unnecessary requests
      refetchOnReconnect: false,
      // Retry failed requests 2 times
      retry: 2,
      // Retry delay with exponential backoff
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    mutations: {
      // Retry mutations once
      retry: 1,
    },
  },
});

interface QueryProviderProps {
  children: React.ReactNode;
}

export default function QueryProvider({ children }: QueryProviderProps) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      {/* Show devtools only in development */}
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools
          initialIsOpen={false}
        />
      )}
    </QueryClientProvider>
  );
}

// Export queryClient for use in prefetching or manual invalidation
export { queryClient };
```



## 🔍 코드 품질 검사 결과

### ESLint 검사

❌ **실패**

```

> erp-app@0.1.0 lint
> eslint


C:\Users\USER\claude_code\ERP_TEST\next.config.ts
  46:38  warning  'dev' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\scripts\code-review-helper.js
  10:12  error  A `require()` style import is forbidden  @typescript-eslint/no-require-imports
  11:14  error  A `require()` style import is forbidden  @typescript-eslint/no-require-imports
  12:23  error  A `require()` style import is forbidden  @typescript-eslint/no-require-imports

C:\Users\USER\claude_code\ERP_TEST\src\app\api\auth\logout\route.ts
  7:28  warning  '_request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\bom\explode\route.ts
   20:11  warning  'ItemData' is defined but never used  @typescript-eslint/no-unused-vars
   38:32  warning  '_user' is defined but never used     @typescript-eslint/no-unused-vars
  238:32  warning  '_user' is defined but never used     @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\bom\route.ts
  168:39  warning  'duplicateError' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\companies\route.example.ts
    7:20  warning  'ErrorCode' is defined but never used  @typescript-eslint/no-unused-vars
   15:34  warning  'user' is defined but never used       @typescript-eslint/no-unused-vars
   96:34  warning  'user' is defined but never used       @typescript-eslint/no-unused-vars
  206:34  warning  'user' is defined but never used       @typescript-eslint/no-unused-vars
  291:34  warning  'user' is defined but never used       @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\dashboard\alerts\route.ts
  18:6  warning  'LowStockItem' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\export\[entity]\route.ts
    8:3   warning  'mapTransactionType' is defined but never used  @typescript-eslint/no-unused-vars
   38:30  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  125:69  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  165:73  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  204:32  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  211:67  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  245:43  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  285:46  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  285:71  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  286:18  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  402:21  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\export\companies\route.ts
   64:57  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  123:48  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  124:48  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  133:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  134:39  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\export\inventory\route.ts
    3:10  warning  'mapEnglishToKorean' is defined but never used  @typescript-eslint/no-unused-vars
    3:30  warning  'inventoryMapping' is defined but never used    @typescript-eslint/no-unused-vars
   73:57  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  131:58  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  131:66  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  137:53  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  137:61  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  138:51  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  138:59  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  213:55  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\export\stock\route.ts
   99:15  warning  'status_code' is assigned a value but never used  @typescript-eslint/no-unused-vars
  189:15  warning  'status_code' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\health\route.ts
  207:32  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\import\[entity]\route.ts
    2:10  warning  'query' is defined but never used               @typescript-eslint/no-unused-vars
   10:3   warning  'mapTransactionType' is defined but never used  @typescript-eslint/no-unused-vars
   71:39  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
   73:66  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
   82:69  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
   95:73  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
   98:77  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  101:71  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  132:54  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  138:43  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  151:21  warning  'result' is assigned a value but never used     @typescript-eslint/no-unused-vars
  177:58  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  183:43  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  199:21  warning  'result' is assigned a value but never used     @typescript-eslint/no-unused-vars
  226:52  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  232:43  error    Unexpected any. Specify a different type        @typescript-eslint/no-explicit-any
  269:21  warning  'result' is assigned a value but never used     @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\import\inventory\route.ts
   4:10  warning  'IncomingForm' is defined but never used    @typescript-eslint/no-unused-vars
   5:10  warning  'Readable' is defined but never used        @typescript-eslint/no-unused-vars
  11:3   warning  'mapCompanyType' is defined but never used  @typescript-eslint/no-unused-vars
  58:39  error    Unexpected any. Specify a different type    @typescript-eslint/no-explicit-any
  60:66  error    Unexpected any. Specify a different type    @typescript-eslint/no-explicit-any
  69:69  error    Unexpected any. Specify a different type    @typescript-eslint/no-explicit-any
  84:54  error    Unexpected any. Specify a different type    @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\production\bom-check\route.ts
  2:10  warning  'db' is defined but never used                     @typescript-eslint/no-unused-vars
  2:14  warning  'SupabaseQueryBuilder' is defined but never used   @typescript-eslint/no-unused-vars
  2:36  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
  2:57  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
  2:80  warning  'getSupabaseClient' is defined but never used      @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\production\route.ts
  4:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\receiving\route.ts
  4:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\route.ts
    2:10   warning  'db' is defined but never used                            @typescript-eslint/no-unused-vars
    2:14   warning  'SupabaseQueryBuilder' is defined but never used          @typescript-eslint/no-unused-vars
    2:36   warning  'handleSupabaseError' is defined but never used           @typescript-eslint/no-unused-vars
    2:57   warning  'createSuccessResponse' is defined but never used         @typescript-eslint/no-unused-vars
    2:80   warning  'getSupabaseClient' is defined but never used             @typescript-eslint/no-unused-vars
    4:10   warning  'errorHandler' is defined but never used                  @typescript-eslint/no-unused-vars
    4:24   warning  'ERPError' is defined but never used                      @typescript-eslint/no-unused-vars
    4:34   warning  'ErrorType' is defined but never used                     @typescript-eslint/no-unused-vars
    4:45   warning  'handleError' is defined but never used                   @typescript-eslint/no-unused-vars
    4:58   warning  'handleBusinessError' is defined but never used           @typescript-eslint/no-unused-vars
    4:79   warning  'handleNotFoundError' is defined but never used           @typescript-eslint/no-unused-vars
    4:100  warning  'handleInsufficientStockError' is defined but never used  @typescript-eslint/no-unused-vars
    5:51   warning  'buildPaginatedSQL' is defined but never used             @typescript-eslint/no-unused-vars
   79:42   error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any
  119:57   error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any
  150:34   error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\shipping\route.ts
  4:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\shipping\stock-check\route.ts
   2:10  warning  'db' is defined but never used                     @typescript-eslint/no-unused-vars
   2:14  warning  'SupabaseQueryBuilder' is defined but never used   @typescript-eslint/no-unused-vars
   2:36  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
   2:57  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
   2:80  warning  'getSupabaseClient' is defined but never used      @typescript-eslint/no-unused-vars
  26:14  warning  'parseError' is defined but never used             @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\stock\route.ts
   2:41  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
  62:47  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  78:51  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  79:60  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\transactions\[id]\history\route.ts
  73:70  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  96:3   warning  'context' is defined but never used       @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\transactions\route.ts
   2:10  warning  'db' is defined but never used                     @typescript-eslint/no-unused-vars
   2:14  warning  'SupabaseQueryBuilder' is defined but never used   @typescript-eslint/no-unused-vars
   2:36  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
   2:57  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
   2:80  warning  'getSupabaseClient' is defined but never used      @typescript-eslint/no-unused-vars
  72:54  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\inventory\transfers\route.ts
   2:10  warning  'db' is defined but never used                     @typescript-eslint/no-unused-vars
   2:14  warning  'SupabaseQueryBuilder' is defined but never used   @typescript-eslint/no-unused-vars
   2:36  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
   2:57  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
   2:80  warning  'getSupabaseClient' is defined but never used      @typescript-eslint/no-unused-vars
  11:11  warning  'warehouseTo' is assigned a value but never used   @typescript-eslint/no-unused-vars
  64:58  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\items\[id]\route.ts
    1:23  warning  'NextResponse' is defined but never used         @typescript-eslint/no-unused-vars
   11:10  warning  'errorLoggingManager' is defined but never used  @typescript-eslint/no-unused-vars
   52:31  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  104:37  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  132:25  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  166:20  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  171:37  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  271:20  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\items\route.ts
  112:67  warning  'material_type' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\metrics\route.ts
   26:17  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   27:17  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  275:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  278:18  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\migrate\add-safety-stock\route.ts
   2:25  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
   2:46  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
  12:28  warning  '_request' is defined but never used               @typescript-eslint/no-unused-vars
  15:19  warning  'columnCheck' is assigned a value but never used   @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\monitoring\route.ts
  3:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\reports\daily-report\route.ts
  163:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  163:78  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  167:49  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  167:81  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  171:51  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  171:83  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\security-test\route.ts
  30:12  warning  'error' is defined but never used    @typescript-eslint/no-unused-vars
  38:31  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\alerts\route.ts
  68:49  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\current\route.ts
  4:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\debug\route.ts
   7:27  warning  'request' is defined but never used       @typescript-eslint/no-unused-vars
  69:38  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\history\route.ts
   4:27  warning  'request' is defined but never used       @typescript-eslint/no-unused-vars
  23:71  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\items\route.ts
  9:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\reports\route.ts
  3:27  warning  'request' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\route.ts
   5:11  warning  'CurrentStock' is defined but never used  @typescript-eslint/no-unused-vars
  36:48  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  54:38  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  54:56  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\stock\simple\route.ts
  43:57  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\upload\companies\route.ts
    2:26  warning  'validateRequiredField' is defined but never used  @typescript-eslint/no-unused-vars
    2:49  warning  'cleanString' is defined but never used            @typescript-eslint/no-unused-vars
   14:36  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   37:54  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  160:29  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\upload\items\route.ts
    2:26  warning  'validateRequiredField' is defined but never used  @typescript-eslint/no-unused-vars
    2:49  warning  'cleanString' is defined but never used            @typescript-eslint/no-unused-vars
    2:62  warning  'cleanNumber' is defined but never used            @typescript-eslint/no-unused-vars
    2:75  warning  'isValidNumber' is defined but never used          @typescript-eslint/no-unused-vars
   14:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   44:74  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  121:40  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  162:29  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\api\users\route.ts
  37:31  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\dashboard\page.tsx
  3:31  warning  'Suspense' is defined but never used       @typescript-eslint/no-unused-vars
  7:3   warning  'Package' is defined but never used        @typescript-eslint/no-unused-vars
  9:3   warning  'AlertTriangle' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\inventory\page.tsx
    7:8   warning  'dynamic' is defined but never used                                                                           @typescript-eslint/no-unused-vars
    8:77  warning  'Printer' is defined but never used                                                                           @typescript-eslint/no-unused-vars
   15:10  warning  'printTransactions' is defined but never used                                                                 @typescript-eslint/no-unused-vars
   15:29  warning  'printStockReport' is defined but never used                                                                  @typescript-eslint/no-unused-vars
   20:3   warning  'StockStatus' is defined but never used                                                                       @typescript-eslint/no-unused-vars
   21:3   warning  'ReceivingFormData' is defined but never used                                                                 @typescript-eslint/no-unused-vars
   22:3   warning  'ProductionFormData' is defined but never used                                                                @typescript-eslint/no-unused-vars
   23:3   warning  'ShippingFormData' is defined but never used                                                                  @typescript-eslint/no-unused-vars
   24:3   warning  'TRANSACTION_TYPES' is defined but never used                                                                 @typescript-eslint/no-unused-vars
  112:6   warning  React Hook useEffect has a missing dependency: 'fetchData'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  171:45  error    Unexpected any. Specify a different type                                                                      @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\master\bom\page.tsx
   4:62  warning  'FileDown' is defined but never used                                                                             @typescript-eslint/no-unused-vars
   4:72  warning  'Printer' is defined but never used                                                                              @typescript-eslint/no-unused-vars
  11:10  warning  'printBOM' is defined but never used                                                                             @typescript-eslint/no-unused-vars
  35:38  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  55:6   warning  React Hook useEffect has a missing dependency: 'fetchBOMData'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\app\master\companies\page.tsx
    5:89  warning  'Printer' is defined but never used                                                                                @typescript-eslint/no-unused-vars
   11:10  warning  'printCompanies' is defined but never used                                                                         @typescript-eslint/no-unused-vars
  105:6   warning  React Hook useEffect has a missing dependency: 'fetchCompanies'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\app\master\items\page.tsx
    5:77  warning  'Printer' is defined but never used                                                                            @typescript-eslint/no-unused-vars
  104:6   warning  React Hook useEffect has a missing dependency: 'fetchItems'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\app\monitoring\page.tsx
  15:3  warning  'HardDrive' is defined but never used  @typescript-eslint/no-unused-vars
  16:3  warning  'Network' is defined but never used    @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\app\stock\history\page.tsx
  93:6  warning  React Hook useEffect has a missing dependency: 'fetchStockHistory'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\app\stock\page.tsx
    4:45  warning  'Download' is defined but never used      @typescript-eslint/no-unused-vars
  111:51  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\app\stock\reports\page.tsx
   16:3   warning  'BarChart' is defined but never used                                                                                @typescript-eslint/no-unused-vars
   17:3   warning  'Bar' is defined but never used                                                                                     @typescript-eslint/no-unused-vars
  106:6   warning  React Hook useEffect has a missing dependency: 'fetchReportData'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  271:52  error    Unexpected any. Specify a different type                                                                            @typescript-eslint/no-explicit-any
  275:40  error    Unexpected any. Specify a different type                                                                            @typescript-eslint/no-explicit-any
  371:48  warning  'index' is defined but never used                                                                                   @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\AdvancedSearch.tsx
    6:3   warning  'Settings' is defined but never used                @typescript-eslint/no-unused-vars
   30:38  error    Unexpected any. Specify a different type            @typescript-eslint/no-explicit-any
   31:19  error    Unexpected any. Specify a different type            @typescript-eslint/no-explicit-any
  133:5   warning  'results' is assigned a value but never used        @typescript-eslint/no-unused-vars
  139:5   warning  'updateFilters' is assigned a value but never used  @typescript-eslint/no-unused-vars
  142:5   warning  'executeSearch' is assigned a value but never used  @typescript-eslint/no-unused-vars
  196:45  error    Unexpected any. Specify a different type            @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\BOMForm.tsx
  44:10  warning  'selectedParentItem' is assigned a value but never used  @typescript-eslint/no-unused-vars
  45:10  warning  'selectedChildItem' is assigned a value but never used   @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\CompanySelect.tsx
   25:3  warning  'required' is assigned a value but never used                                                                      @typescript-eslint/no-unused-vars
   94:6  warning  React Hook useEffect has a missing dependency: 'fetchCompanies'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  105:6  warning  React Hook useEffect has a missing dependency: 'fetchCompanies'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\DateRangePicker.tsx
  199:11  warning  'lastDay' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\ExcelExportButton.tsx
    8:10  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  146:10  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  153:3   warning  'filtered' is assigned a value but never used  @typescript-eslint/no-unused-vars
  192:14  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  199:3   warning  'filtered' is assigned a value but never used  @typescript-eslint/no-unused-vars
  238:12  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  245:3   warning  'filtered' is assigned a value but never used  @typescript-eslint/no-unused-vars
  312:14  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\ItemForm.tsx
  559:32  error  Parsing error: ';' expected

C:\Users\USER\claude_code\ERP_TEST\src\components\ItemSelect.tsx
  68:6  warning  React Hook useEffect has a missing dependency: 'fetchItems'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\PrintButton.tsx
   13:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  387:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  398:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  409:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  423:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  442:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  472:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  483:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\ProductionForm.tsx
  44:6  warning  React Hook useEffect has a missing dependency: 'checkBOMAndStock'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\ReceivingForm.tsx
   3:20  warning  'useEffect' is defined but never used                 @typescript-eslint/no-unused-vars
   6:26  warning  'Company' is defined but never used                   @typescript-eslint/no-unused-vars
  10:3   warning  'SearchOption' is defined but never used              @typescript-eslint/no-unused-vars
  33:10  warning  'selectedCompany' is assigned a value but never used  @typescript-eslint/no-unused-vars
  33:58  error    Unexpected any. Specify a different type              @typescript-eslint/no-explicit-any
  67:68  error    Unexpected any. Specify a different type              @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\SearchFilters\CategoryFilter.tsx
  7:26  warning  'Filter' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\SearchFilters\DateRangeFilter.tsx
  34:10  warning  'isOpen' is assigned a value but never used     @typescript-eslint/no-unused-vars
  34:18  warning  'setIsOpen' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\SearchFilters\SavedFilters.tsx
  44:6  warning  React Hook useEffect has a missing dependency: 'refreshSavedFilters'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\SearchFilters\StatusFilter.tsx
  96:9  warning  'renderCustomOption' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\SearchPresets.tsx
    4:22  warning  'Edit' is defined but never used                       @typescript-eslint/no-unused-vars
   14:20  error    Unexpected any. Specify a different type               @typescript-eslint/no-explicit-any
   33:10  warning  'editingPreset' is assigned a value but never used     @typescript-eslint/no-unused-vars
   33:25  warning  'setEditingPreset' is assigned a value but never used  @typescript-eslint/no-unused-vars
  105:16  warning  'error' is defined but never used                      @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\ShippingForm.tsx
    4:46  warning  'Package' is defined but never used                                                                                        @typescript-eslint/no-unused-vars
   37:10  warning  'customers' is assigned a value but never used                                                                             @typescript-eslint/no-unused-vars
   38:10  warning  'products' is assigned a value but never used                                                                              @typescript-eslint/no-unused-vars
   52:6   warning  React Hook useEffect has a missing dependency: 'checkStockAvailability'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
   71:77  error    Unexpected any. Specify a different type                                                                                   @typescript-eslint/no-explicit-any
  106:48  error    Unexpected any. Specify a different type                                                                                   @typescript-eslint/no-explicit-any
  166:60  warning  'customer' is defined but never used                                                                                       @typescript-eslint/no-unused-vars
  447:40  warning  'index' is defined but never used                                                                                          @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\StockAdjustmentForm.tsx
    9:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  142:95  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\Toast.tsx
  4:56  warning  'Undo2' is defined but never used         @typescript-eslint/no-unused-vars
  4:63  warning  'ExternalLink' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\admin\ErrorDashboard.tsx
  147:6  warning  React Hook useEffect has missing dependencies: 'loadErrorStats' and 'loadRecentErrors'. Either include them or remove the dependency array  react-hooks/exhaustive-deps
  157:6  warning  React Hook useEffect has missing dependencies: 'loadErrorStats' and 'loadRecentErrors'. Either include them or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\charts\LowStockAlerts.tsx
   17:3   warning  'ComposedChart' is defined but never used                                                                        @typescript-eslint/no-unused-vars
   18:3   warning  'Line' is defined but never used                                                                                 @typescript-eslint/no-unused-vars
   19:3   warning  'Area' is defined but never used                                                                                 @typescript-eslint/no-unused-vars
   20:3   warning  'AreaChart' is defined but never used                                                                            @typescript-eslint/no-unused-vars
   26:3   warning  'Package' is defined but never used                                                                              @typescript-eslint/no-unused-vars
   28:3   warning  'TrendingDown' is defined but never used                                                                         @typescript-eslint/no-unused-vars
   34:3   warning  'XCircle' is defined but never used                                                                              @typescript-eslint/no-unused-vars
   38:3   warning  'formatKoreanDate' is defined but never used                                                                     @typescript-eslint/no-unused-vars
   89:3   warning  'height' is assigned a value but never used                                                                      @typescript-eslint/no-unused-vars
  100:27  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  152:6   warning  React Hook useMemo has a missing dependency: 'priorityConfig'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  182:45  warning  'label' is defined but never used                                                                                @typescript-eslint/no-unused-vars
  182:54  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  292:33  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  482:39  warning  'index' is defined but never used                                                                                @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\charts\MonthlyInventoryTrends.tsx
   18:3   warning  'ReferenceLine' is defined but never used     @typescript-eslint/no-unused-vars
   20:22  warning  'Calendar' is defined but never used          @typescript-eslint/no-unused-vars
   20:51  warning  'Settings' is defined but never used          @typescript-eslint/no-unused-vars
   23:3   warning  'formatKoreanDate' is defined but never used  @typescript-eslint/no-unused-vars
   62:3   warning  'height' is assigned a value but never used   @typescript-eslint/no-unused-vars
   76:27  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  162:54  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  173:34  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\charts\StockLevelsByCategory.tsx
   26:3   warning  'getStockLevelColor' is defined but never used            @typescript-eslint/no-unused-vars
   65:3   warning  'height' is assigned a value but never used               @typescript-eslint/no-unused-vars
   72:28  warning  'setShowMinimumStock' is assigned a value but never used  @typescript-eslint/no-unused-vars
   76:27  error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any
  133:54  error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any
  220:31  error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any
  240:33  error    Unexpected any. Specify a different type                  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\charts\TopItemsByValue.tsx
   66:3   warning  'height' is assigned a value but never used                                                                      @typescript-eslint/no-unused-vars
   77:27  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  129:6   warning  React Hook useMemo has a missing dependency: 'getStatusColor'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  172:45  warning  'label' is defined but never used                                                                                @typescript-eslint/no-unused-vars
  172:54  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any
  270:33  error    Unexpected any. Specify a different type                                                                         @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\charts\TransactionDistribution.tsx
   20:36  warning  'BarChart3' is defined but never used        @typescript-eslint/no-unused-vars
   64:3   warning  'height' is assigned a value but never used  @typescript-eslint/no-unused-vars
   75:27  error    Unexpected any. Specify a different type     @typescript-eslint/no-explicit-any
  113:44  error    Unexpected any. Specify a different type     @typescript-eslint/no-explicit-any
  180:6   error    Unexpected any. Specify a different type     @typescript-eslint/no-explicit-any
  204:36  error    Unexpected any. Specify a different type     @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\AlertPanel.tsx
  7:53  warning  'Filter' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\RealTimeDashboard.tsx
  207:9   error    Unexpected any. Specify a different type                                                                                                                                                         @typescript-eslint/no-explicit-any
  217:3   warning  'isDark' is defined but never used                                                                                                                                                               @typescript-eslint/no-unused-vars
  250:21  error    React Hook "React.useMemo" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?  react-hooks/rules-of-hooks
  254:13  warning  'stats' is assigned a value but never used                                                                                                                                                       @typescript-eslint/no-unused-vars
  257:74  error    Unexpected any. Specify a different type                                                                                                                                                         @typescript-eslint/no-explicit-any
  258:85  error    Unexpected any. Specify a different type                                                                                                                                                         @typescript-eslint/no-explicit-any
  262:64  error    Unexpected any. Specify a different type                                                                                                                                                         @typescript-eslint/no-explicit-any
  263:65  error    Unexpected any. Specify a different type                                                                                                                                                         @typescript-eslint/no-explicit-any
  372:3   warning  'lastUpdated' is defined but never used                                                                                                                                                          @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\RecentActivityWidget.tsx
  122:6  warning  React Hook useEffect has a missing dependency: 'fetchRecentActivity'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\RefreshControls.tsx
   7:21  warning  'Clock' is defined but never used                    @typescript-eslint/no-unused-vars
   7:28  warning  'Pause' is defined but never used                    @typescript-eslint/no-unused-vars
   7:35  warning  'Play' is defined but never used                     @typescript-eslint/no-unused-vars
   9:10  warning  'REFRESH_INTERVALS' is defined but never used        @typescript-eslint/no-unused-vars
  23:3   warning  'refreshInterval' is defined but never used          @typescript-eslint/no-unused-vars
  24:3   warning  'onRefreshIntervalChange' is defined but never used  @typescript-eslint/no-unused-vars
  25:3   warning  'isAutoRefreshEnabled' is defined but never used     @typescript-eslint/no-unused-vars
  26:3   warning  'onAutoRefreshToggle' is defined but never used      @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\StockChart.tsx
   18:3   warning  'ReferenceLine' is defined but never used         @typescript-eslint/no-unused-vars
   20:21  warning  'TrendingUp' is defined but never used            @typescript-eslint/no-unused-vars
   20:52  warning  'Settings' is defined but never used              @typescript-eslint/no-unused-vars
   48:27  error    Unexpected any. Specify a different type          @typescript-eslint/no-explicit-any
   76:54  error    Unexpected any. Specify a different type          @typescript-eslint/no-explicit-any
  135:9   warning  'getBarColor' is assigned a value but never used  @typescript-eslint/no-unused-vars
  135:31  error    Unexpected any. Specify a different type          @typescript-eslint/no-explicit-any
  198:58  error    Unexpected any. Specify a different type          @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\StockStatusWidget.tsx
  81:6  warning  React Hook useEffect has a missing dependency: 'fetchStockStatus'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\components\dashboard\TransactionChart.tsx
   22:34  warning  'PieChartIcon' is defined but never used  @typescript-eslint/no-unused-vars
   22:67  warning  'Calendar' is defined but never used      @typescript-eslint/no-unused-vars
   57:27  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   85:54  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   96:34  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  114:75  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  126:44  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  318:32  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\layout\Sidebar.tsx
  19:3  warning  'ClipboardList' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\ui\Toast.tsx
  4:56  warning  'Undo2' is defined but never used         @typescript-eslint/no-unused-vars
  4:63  warning  'ExternalLink' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\ui\VirtualGrid.tsx
   5:32  warning  'List' is defined but never used          @typescript-eslint/no-unused-vars
   9:34  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  29:32  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  69:54  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\components\ui\VirtualTable.tsx
    9:41  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   32:33  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   51:55  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  277:41  warning  'columnIndex' is defined but never used   @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\components\upload\ExcelUploadModal.tsx
   99:6   warning  React Hook useCallback has a missing dependency: 'handleFileSelect'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  150:19  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  209:19  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useAdvancedFilter.tsx
    9:3   warning  'SearchQueryParams' is defined but never used                                                                          @typescript-eslint/no-unused-vars
   24:27  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
   47:40  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
   60:28  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  118:6   warning  React Hook useEffect has a missing dependency: 'loadPersistedState'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  239:59  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  317:58  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  340:46  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  358:55  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  407:34  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  420:38  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  433:30  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any
  434:30  error    Unexpected any. Specify a different type                                                                               @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useAdvancedSearch.tsx
   65:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  221:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  229:42  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  265:18  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  366:18  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useConfirm.tsx
  135:6  warning  React Hook useCallback has a missing dependency: 'state'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  147:6  warning  React Hook useCallback has a missing dependency: 'state'. Either include it or remove the dependency array  react-hooks/exhaustive-deps

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useDashboardData.tsx
    7:10  warning  'calculateKPIs' is defined but never used  @typescript-eslint/no-unused-vars
  150:19  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  261:19  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  302:19  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  343:19  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  369:50  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useItems.ts
  102:48  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  103:26  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useToast.tsx
  92:40  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  93:41  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\hooks\useTransactions.ts
  170:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\auth.ts
  69:69  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  90:23  warning  'userPassword' is assigned a value but never used  @typescript-eslint/no-unused-vars
  90:72  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\bom.ts
    6:10  warning  'supabaseAdmin' is defined but never used  @typescript-eslint/no-unused-vars
   39:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  154:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  259:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  330:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  411:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  413:12  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  482:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  484:12  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  550:9   error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  640:50  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\db-health-check.ts
  275:18  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\db-unified.ts
   97:28  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  117:35  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  274:24  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  332:13  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  332:19  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  336:24  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  357:13  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  362:24  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  386:31  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  394:26  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  563:19  warning  'sql' is defined but never used           @typescript-eslint/no-unused-vars
  563:32  warning  'params' is defined but never used        @typescript-eslint/no-unused-vars
  563:41  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  708:42  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  719:21  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  741:19  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  750:54  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  757:57  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  769:19  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\error-format.ts
  156:15  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  169:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  180:29  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  187:11  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  189:19  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  190:32  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  197:21  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  220:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  292:29  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  300:15  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  401:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  431:15  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  460:47  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\errorAdapter.ts
   21:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   64:14  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   94:22  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   94:37  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  100:26  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  100:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\errorLogger.ts
  91:13  warning  'endDate' is assigned a value but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\lib\excel-utils.ts
  4:51  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\import-map.ts
    8:13   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   65:55   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   65:105  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   67:37   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  131:57   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  131:92   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  133:19   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  144:57   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  144:92   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  146:19   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  190:51   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\logger.ts
   21:29   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   74:31   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  149:75   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  179:52   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  183:51   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  187:51   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  191:67   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  233:119  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  248:97   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  279:78   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  284:58   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  306:16   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  306:26   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  306:37   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  331:49   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  331:67   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  335:27   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  403:28   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  409:57   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\middleware.ts
  2:10  warning  'verifyToken' is defined but never used  @typescript-eslint/no-unused-vars
  3:31  warning  'JWTPayload' is defined but never used   @typescript-eslint/no-unused-vars
  4:10  warning  'AUTH_ERRORS' is defined but never used  @typescript-eslint/no-unused-vars

C:\Users\USER\claude_code\ERP_TEST\src\lib\monitoring.ts
  214:16  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  214:26  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  214:37  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  219:31  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  238:63  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  238:81  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  242:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\query-optimizer.ts
   56:43  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
   59:26  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
   72:21  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  124:21  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  292:42  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  297:19  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  308:56  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  329:53  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  337:41  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  341:19  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  352:35  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  371:44  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  477:71  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  514:5   warning  'options' is assigned a value but never used  @typescript-eslint/no-unused-vars
  515:14  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  540:22  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  546:82  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  556:31  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  578:26  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  711:18  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  712:17  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any
  713:17  error    Unexpected any. Specify a different type      @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\response.ts
   6:42  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  19:45  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  42:9   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\serial.ts
  24:50  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\supabase-admin.ts
   53:14  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  146:19  warning  'data' is assigned a value but never used  @typescript-eslint/no-unused-vars
  147:28  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  166:17  warning  'data' is assigned a value but never used  @typescript-eslint/no-unused-vars
  168:58  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  193:28  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  249:28  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  292:28  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  325:32  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  354:28  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  378:30  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any
  395:30  error    Unexpected any. Specify a different type   @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\supabase.ts
  444:61  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  457:33  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  457:66  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  459:18  warning  'pgSql' is assigned a value but never used     @typescript-eslint/no-unused-vars
  459:33  warning  'pgParams' is assigned a value but never used  @typescript-eslint/no-unused-vars
  488:39  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  489:3   warning  'callback' is defined but never used           @typescript-eslint/no-unused-vars
  528:13  warning  'data' is assigned a value but never used      @typescript-eslint/no-unused-vars
  557:43  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  569:22  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  700:44  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\transactionManager.ts
    10:23  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   101:5   warning  'connection' is defined but never used             @typescript-eslint/no-unused-vars
   102:5   warning  'data' is defined but never used                   @typescript-eslint/no-unused-vars
   120:5   warning  'connection' is defined but never used             @typescript-eslint/no-unused-vars
   121:5   warning  'auditLogId' is defined but never used             @typescript-eslint/no-unused-vars
   122:5   warning  'status' is defined but never used                 @typescript-eslint/no-unused-vars
   123:5   warning  'errorMessage' is defined but never used           @typescript-eslint/no-unused-vars
   124:5   warning  'executionTime' is defined but never used          @typescript-eslint/no-unused-vars
   141:22  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   381:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   449:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   532:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   592:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   615:5   warning  'leadTimeDays' is assigned a value but never used  @typescript-eslint/no-unused-vars
   669:14  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   708:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   716:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   807:14  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   843:46  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   852:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   879:17  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   881:32  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   889:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   911:16  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   959:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   984:32  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
   992:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1007:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1027:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1039:28  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1047:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1075:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1083:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1088:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1114:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1124:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1138:34  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1168:32  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1170:15  warning  'connection' is assigned a value but never used    @typescript-eslint/no-unused-vars
  1205:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1213:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1244:42  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1267:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1279:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1326:57  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1349:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1402:12  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1405:35  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1406:55  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1433:33  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1472:42  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1501:14  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1535:10  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1546:14  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1570:10  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1574:47  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1583:47  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  1606:39  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\validationMiddleware.ts
    6:10  warning  'z' is defined but never used             @typescript-eslint/no-unused-vars
   73:34  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  120:43  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  176:48  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  176:62  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  176:77  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  192:43  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  192:57  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  192:72  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  202:46  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  202:60  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  202:75  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  293:38  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  293:52  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  293:67  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  314:42  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  314:56  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  314:71  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  336:13  error    Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\lib\workflow.ts
    2:25  warning  'handleSupabaseError' is defined but never used    @typescript-eslint/no-unused-vars
    2:46  warning  'createSuccessResponse' is defined but never used  @typescript-eslint/no-unused-vars
   51:3   warning  'changedBy' is defined but never used              @typescript-eslint/no-unused-vars
   52:3   warning  'changeReason' is defined but never used           @typescript-eslint/no-unused-vars
   63:20  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  113:3   warning  'documentType' is defined but never used           @typescript-eslint/no-unused-vars
  114:3   warning  'documentId' is defined but never used             @typescript-eslint/no-unused-vars
  140:3   warning  'documentNumber' is defined but never used         @typescript-eslint/no-unused-vars
  166:13  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any
  167:14  error    Unexpected any. Specify a different type           @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\middleware\error-handler.ts
    5:3   warning  'createErrorResponse' is defined but never used  @typescript-eslint/no-unused-vars
   28:44  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  179:3   warning  'processingTime' is defined but never used       @typescript-eslint/no-unused-vars
  198:72  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  244:40  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  266:46  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  317:13  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any
  376:10  error    Unexpected any. Specify a different type         @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\middleware\rate-limit.ts
   77:18  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   79:28  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  260:72  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  335:47  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\types\inventory.ts
  198:34  error  Unexpected any. Specify a different type                          @typescript-eslint/no-explicit-any
  276:18  error  An interface declaring no members is equivalent to its supertype  @typescript-eslint/no-empty-object-type
  277:18  error  An interface declaring no members is equivalent to its supertype  @typescript-eslint/no-empty-object-type
  278:18  error  An interface declaring no members is equivalent to its supertype  @typescript-eslint/no-empty-object-type

C:\Users\USER\claude_code\ERP_TEST\src\utils\chartUtils.d.ts
   28:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   29:11  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   35:19  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   64:10  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   66:14  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   97:43  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   97:51  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   98:68  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  101:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  102:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  105:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  105:56  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  106:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  106:56  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\utils\chartUtils.ts
    6:15  warning  'ChartData' is defined but never used          @typescript-eslint/no-unused-vars
   71:81  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  196:43  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  246:46  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  259:38  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  281:46  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  288:32  error    Use the spread operator instead of '.apply()'  prefer-spread
  292:46  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  299:7   error    Use the spread operator instead of '.apply()'  prefer-spread
  329:10  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any
  331:14  error    Unexpected any. Specify a different type       @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\utils\excelExport.ts
   41:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   60:51  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   61:42  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  116:36  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  140:44  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  162:36  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  181:65  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  205:46  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  227:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  243:53  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  244:44  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

C:\Users\USER\claude_code\ERP_TEST\src\utils\printUtils.ts
   92:24  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  104:51  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  198:5   warning  'orientation' is assigned a value but never used                @typescript-eslint/no-unused-vars
  228:24  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  290:9   warning  'htmlContent' is assigned a value but never used                @typescript-eslint/no-unused-vars
  354:24  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  384:41  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  407:49  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  427:41  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  449:70  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  472:51  error    Unexpected any. Specify a different type                        @typescript-eslint/no-explicit-any
  490:1   warning  Assign object to a variable before exporting as module default  import/no-anonymous-default-export

C:\Users\USER\claude_code\ERP_TEST\src\utils\searchUtils.ts
   22:28  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   72:60  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   84:82  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   85:33  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  113:10  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  156:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  232:30  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  252:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  279:31  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  296:67  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  318:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

✖ 696 problems (447 errors, 249 warnings)


```

### TypeScript 타입 검사

❌ **실패**

```

> erp-app@0.1.0 type-check
> tsc --noEmit

src/components/ItemForm.tsx(559,33): error TS1005: ';' expected.
src/components/ItemForm.tsx(559,41): error TS1434: Unexpected keyword or identifier.
src/components/ItemForm.tsx(559,44): error TS1434: Unexpected keyword or identifier.
src/components/ItemForm.tsx(559,54): error TS1003: Identifier expected.
src/components/ItemForm.tsx(588,27): error TS1005: '}' expected.
src/components/ItemForm.tsx(588,163): error TS1003: Identifier expected.
src/components/ItemForm.tsx(589,8): error TS1382: Unexpected token. Did you mean `{'>'}` or `&gt;`?
src/components/ItemForm.tsx(620,29): error TS1005: '}' expected.
src/components/ItemForm.tsx(620,166): error TS1003: Identifier expected.
src/components/ItemForm.tsx(621,10): error TS1382: Unexpected token. Did you mean `{'>'}` or `&gt;`?
src/components/ItemForm.tsx(650,27): error TS1005: '}' expected.
src/components/ItemForm.tsx(650,163): error TS1003: Identifier expected.
src/components/ItemForm.tsx(651,7): error TS1382: Unexpected token. Did you mean `{'>'}` or `&gt;`?
src/components/ItemForm.tsx(658,9): error TS17002: Expected corresponding JSX closing tag for 'div'.
src/components/ItemForm.tsx(659,7): error TS1005: ')' expected.
src/components/ItemForm.tsx(660,5): error TS1128: Declaration or statement expected.
src/components/ItemForm.tsx(661,3): error TS1109: Expression expected.
src/components/ItemForm.tsx(687,27): error TS1005: '}' expected.
src/components/ItemForm.tsx(687,163): error TS1003: Identifier expected.
src/components/ItemForm.tsx(688,8): error TS1382: Unexpected token. Did you mean `{'>'}` or `&gt;`?

```

