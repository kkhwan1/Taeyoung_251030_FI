# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## SuperClaude Framework Integration

This project uses the **SuperClaude framework** configured in `C:\Users\USER\.claude\`:

- **Entry Point**: `@C:\Users\USER\.claude\CLAUDE.md`
- **Core Commands**: `/build`, `/analyze`, `/improve`, `/implement`, `/test`
- **Key Flags**: `--seq`, `--c7`, `--magic`, `--play`, `--uc`, `--think`, `--persona-*`
- **MCP Servers**: Context7 (docs), Sequential (analysis), Magic (UI), Playwright (testing)
- **11 Personas**: Auto-activation based on task context (architect, frontend, backend, security, performance, analyzer, qa, refactorer, devops, mentor, scribe)

**Full Documentation**: See `C:\Users\USER\.claude\` for complete COMMANDS.md, FLAGS.md, PERSONAS.md, MCP.md, and MODES.md reference.

### Project-Specific Agents & Commands

#### Available Agents

**`erp-specialist`** - Korean automotive ERP specialist (`.claudeCode/agents/erp-specialist.md`)
- **Expertise**: Next.js 15, React 19, Supabase PostgreSQL, Korean language handling
- **Use Cases**: ERP features with Korean data, inventory transactions (입고/생산/출고), BOM operations, Excel integration
- **Example**: `Use erp-specialist agent to implement 입고 transaction API with proper Korean encoding`

**`fullstack-developer`** - Complete stack development (`~/.claude-code-templates/agents/fullstack-developer.md`)
- **Expertise**: React/Next.js, TypeScript, Node.js/Express, PostgreSQL, Authentication
- **Use Cases**: End-to-end feature implementation, API integration, authentication
- **Example**: `Use fullstack-developer for implementing user authentication system`

#### Custom Commands

**`/erp:build`** - ERP-specific build and deployment
- Validates Korean character encoding, checks Supabase connection, generates types, performs production build
- Usage: `/erp:build --env production`

**`/erp:migrate`** - Database migration management
- Applies migrations, generates TypeScript types, validates safety, supports rollback
- Usage: `/erp:migrate --check` or `/erp:migrate --apply`

**`/erp:test`** - Comprehensive ERP testing suite
- API endpoint tests with Korean data, Excel functionality, inventory logic, encoding validation
- Usage: `/erp:test --coverage` or `/erp:test --api`

### Essential SuperClaude Commands for ERP

#### `/build` - Build ERP Features
```bash
# Build with validation
/build --focus quality --validate

# Build dashboard with UI optimization
/build @src/components/dashboard --persona-frontend --magic

# Build API with database integration
/build @src/app/api --persona-backend --seq --c7
```

#### `/implement` - Implement New Features
```bash
# Implement with type specification
/implement "입고 처리 API 엔드포인트" --type api --persona-backend

# Implement UI component
/implement "재고 현황 차트" --type component --magic --c7

# Implement with validation
/implement "품목 엑셀 업로드" --focus quality --validate
```

#### `/analyze` - Analyze Codebase
```bash
# Performance analysis
/analyze --focus performance --think-hard --seq

# Quality analysis
/analyze @src/app/api --focus quality --uc

# Security analysis
/analyze --focus security --persona-security --ultrathink
```

**Thinking Depth**: `--think` (4K tokens) → `--think-hard` (10K tokens) → `--ultrathink` (32K tokens)

#### `/improve` - Enhance Code Quality
```bash
# Performance improvement
/improve @src/lib/db-unified.ts --focus performance --seq

# Accessibility improvement
/improve @src/components/dashboard --focus accessibility --magic

# Iterative improvement
/improve @src --loop --iterations 3
```

#### `/test` - Testing Workflows
```bash
# E2E testing
/test --type e2e --play

# API testing with Korean data
/test @src/app/api --focus quality --persona-qa

# Comprehensive testing
/test --all --coverage --validate
```

### MCP Server Usage

#### Context7 - Documentation & Patterns
**When**: External library questions, framework patterns, best practices
**Use**: `--c7` flag or auto-activates on import statements
```bash
# Get framework patterns
/analyze --c7 "Supabase real-time subscriptions"
/implement --c7 "Next.js 15 API route with Korean text"
```

#### Sequential - Complex Analysis
**When**: Complex debugging, business logic design, systematic analysis
**Use**: `--seq` flag or auto-activates with `--think` flags
```bash
# Multi-step analysis
/analyze @src/app/api/bom --seq --think-hard
/troubleshoot "Korean characters corrupted" --seq
```

#### Magic - UI Component Generation
**When**: React components, dashboard widgets, design system
**Use**: `--magic` flag or auto-activates for UI work
```bash
# Generate UI components
/implement "KPI 카드 컴포넌트" --magic --persona-frontend
/build "가상 스크롤링 품목 테이블" --magic --c7
```

#### Playwright - E2E Testing & Automation
**When**: End-to-end testing, browser automation, performance monitoring
**Use**: `--play` flag or auto-activates for testing
```bash
# E2E testing
/test "품목 엑셀 업로드 E2E" --play
/test @src/components/dashboard --play --focus performance
```

### Persona Auto-Activation

**Backend Operations** → `--persona-backend` (API routes, database, Supabase)
**Frontend Development** → `--persona-frontend` (React components, UI design, accessibility)
**Korean Documentation** → `--persona-scribe=ko` (README, comments, commit messages)
**Performance Optimization** → `--persona-performance` (bottleneck identification, optimization)
**Security Analysis** → `--persona-security` (threat modeling, vulnerability assessment)
**Code Quality** → `--persona-refactorer` (technical debt, code simplification)
**Quality Assurance** → `--persona-qa` (comprehensive testing, edge cases)

### Common ERP Task Patterns

**Korean Data**: `/analyze @src/app/api --think --seq --persona-scribe=ko`
**Dashboard**: `/build @src/components/dashboard --magic --c7 --persona-frontend`
**Database**: `/analyze @src/lib/db-unified.ts --seq --c7 --think-hard`
**Performance**: `/analyze --focus performance --persona-performance --ultrathink`
**Security**: `/analyze --focus security --persona-security --validate`
**Excel**: `/implement "품목 엑셀 업로드" --c7 --validate --persona-backend`

### Integration Best Practices

1. **Start Simple, Scale Up**: Begin with basic analysis, add `--think` for depth, use `--ultrathink` for complex issues
2. **Combine Complementary Tools**: Use `--c7 --seq` for documentation + implementation, `--magic --persona-frontend` for UI + accessibility
3. **Use Project Context**: Leverage `erp-specialist` for Korean ERP work, `fullstack-developer` for end-to-end features
4. **Optimize Performance**: Use `--uc` for large operations, disable unused MCP servers with `--no-magic --no-play`
5. **Quality Gates**: Always `--validate` critical paths, use `--loop` for iterative improvement, `--safe-mode` for production

## Global AI Agents Integration (27 Specialized Experts)

### Agent Discovery System

**Location**: `C:\Users\USER\.claude\agents\` (27 agents)

**Auto-Selection Algorithm**:
- **Keyword Matching** (40%): Task keywords vs agent expertise
- **Context Relevance** (30%): Project context vs agent capabilities
- **Historical Success** (20%): Past performance on similar tasks
- **Tool Availability** (10%): Required tools accessible
- **Confidence Threshold**: ≥75% for automatic activation

### ERP-Critical Agents (Top 5)

#### 1. `supabase-schema-architect` ⭐⭐⭐ (Supabase 특화!)
- **Expertise**: Supabase PostgreSQL, RLS policies, migrations, schema design
- **Keywords**: Supabase, PostgreSQL, RLS, migration, schema design
- **Confidence**: 91%
- **Use Cases**:
```bash
/design --agent supabase-schema-architect "inventory_transactions RLS 정책"
/plan --agent supabase-schema-architect "재고 스키마 확장"
/analyze --agent supabase-schema-architect @src/lib/db-unified.ts
```

#### 2. `database-optimizer` ⭐⭐⭐ (쿼리 최적화)
- **Expertise**: Query optimization, indexing strategies, N+1 problems
- **Keywords**: query, performance, index, optimization, slow query
- **Confidence**: 89%
- **Use Cases**:
```bash
/improve --agent database-optimizer @src/lib/db-unified.ts --focus performance
/analyze --agent database-optimizer "재고 조회 쿼리 성능 개선"
```

#### 3. `backend-architect` ⭐⭐⭐ (API 설계)
- **Expertise**: RESTful APIs, microservices, scalability, system architecture
- **Keywords**: API, server, microservices, architecture, scalability
- **Confidence**: 90%
- **Use Cases**:
```bash
/design --agent backend-architect "재고 관리 REST API 엔드포인트"
/analyze --agent backend-architect --focus scalability @src/app/api
```

#### 4. `frontend-developer` ⭐⭐⭐ (React 컴포넌트)
- **Expertise**: React/Vue/Angular, responsive design, accessibility, performance
- **Keywords**: component, UI, responsive, accessibility, CSS, Tailwind
- **Confidence**: 92%
- **Use Cases**:
```bash
/implement --agent frontend-developer "재고 현황 대시보드 컴포넌트"
/build --agent frontend-developer @src/components/dashboard --focus accessibility
```

#### 5. `code-reviewer` ⭐⭐⭐ (코드 품질)
- **Expertise**: Code quality, best practices, refactoring, clean code
- **Keywords**: review, quality, best practices, refactor, clean code
- **Confidence**: 90%
- **Use Cases**:
```bash
/improve --agent code-reviewer @src/app/api --focus quality
/analyze --agent code-reviewer @src/lib --focus maintainability
```

### Additional Available Agents (22 agents)

| Agent | Category | Expertise | ERP 활용도 |
|-------|---------|-----------|----------|
| `database-architect` | Backend | Schema design, data modeling, normalization | ⭐⭐ 권장 |
| `database-optimization` | Backend | Execution plan analysis, query tuning | ⭐⭐ 권장 |
| `database-admin` | Backend | Backup, replication, monitoring | ⭐ 선택 |
| `web-accessibility-checker` | Frontend | WCAG compliance, screen reader compatibility | ⭐⭐ 권장 |
| `architect-reviewer` | Quality | SOLID principles, design patterns | ⭐⭐ 권장 |
| `dependency-manager` | Quality | npm packages, vulnerabilities, licenses | ⭐⭐ 권장 |
| `documentation-expert` | Docs | API docs, README, technical writing | ⭐⭐ 권장 |
| `technical-writer` | Docs | Tutorials, user guides, instructions | ⭐⭐ 권장 |
| `business-analyst` | Business | KPI tracking, metrics, BI | ⭐⭐ 권장 |
| `product-strategist` | Business | Product strategy, roadmap, market analysis | ⭐ 선택 |
| `competitive-intelligence-analyst` | Business | Competitor analysis, industry trends | ⭐ 선택 |
| `content-marketer` | Marketing | Content marketing, SEO, blog | - |
| `marketing-attribution-analyst` | Marketing | Attribution, campaign tracking, ROI | - |
| `mcp-expert` | Expert | MCP server integration | ⭐⭐ 권장 |
| `command-expert` | Expert | CLI commands, terminal automation | ⭐ 선택 |
| `task-decomposition-expert` | Expert | Complex task breakdown, workflow design | ⭐⭐ 권장 |
| `query-clarifier` | Expert | Query analysis, requirement clarification | ⭐ 선택 |
| `search-specialist` | Expert | Web search, research, information gathering | ⭐ 선택 |
| `computer-vision-engineer` | Expert | Image analysis, OCR, object detection | - |
| `hackathon-ai-strategist` | Expert | Hackathon strategy, ideation | - |
| `url-link-extractor` | Expert | URL extraction, link cataloging | - |
| `url-context-validator` | Expert | URL validation, link checking | - |

### ERP-Specific Agent Selection

**Database Operations**: `supabase-schema-architect` → `database-optimizer` → `database-architect`
**API Development**: `backend-architect` → `code-reviewer` → `documentation-expert`
**UI Development**: `frontend-developer` → `web-accessibility-checker` → `documentation-expert`
**Performance**: `database-optimizer` → `frontend-developer` → `database-optimization`
**Documentation**: `technical-writer` → `documentation-expert` → `--persona-scribe=ko`
**Business Analysis**: `business-analyst` → `product-strategist` → `competitive-intelligence-analyst`

### Multi-Agent Workflows

**Full-Stack Feature** (4 stages):
```bash
/design --agent supabase-schema-architect "데이터베이스 스키마"
/design --agent backend-architect "REST API 엔드포인트"
/implement --agent frontend-developer "사용자 인터페이스"
/improve --agent code-reviewer "전체 기능 품질 검토"
```

**Performance Optimization** (3 stages):
```bash
/analyze --agent database-optimizer --focus performance
/improve --agent database-optimization "느린 쿼리 개선"
/analyze --agent frontend-developer --focus performance @src/components
```

**Security & Quality Audit** (3 stages):
```bash
/analyze --agent dependency-manager --security
/analyze --agent code-reviewer --focus security @src/app/api
/analyze --agent web-accessibility-checker @src/components
```

### Agent Usage Best Practices

**✅ Do**: Specify explicit agents (`--agent supabase-schema-architect`), use domain experts (database-* for DB work), provide sufficient context (file paths + goals)

**❌ Don't**: Use generic agents when specialists exist, attempt complex work without agents, use UI agents for database work

### Integration with SuperClaude

**Agents + Personas**: `--agent database-optimizer @src/lib --persona-backend`
**Agents + MCP**: `--agent supabase-schema-architect "스키마" --c7 --seq`
**Agents + Flags**: `--agent database-optimizer @src/lib --think-hard --loop`

## Project Overview

Korean automotive parts manufacturing ERP system (태창 ERP 시스템) built with Next.js 15.5.3, React 19.1.0, and TypeScript. Cloud-native system using Supabase PostgreSQL for master data management, inventory transactions, and real-time dashboard capabilities.

## Development Commands

### Essential Commands
```bash
npm run dev              # Start development server (port 5000)
npm run dev:safe         # Windows-optimized start with cleanup
npm run build            # Production build with Turbopack
npm run start            # Start production server
npm run lint             # Run ESLint
npm run type-check       # TypeScript type checking
npm run restart          # Windows: Clean restart with port cleanup
```

### Database Commands
```bash
# No local database setup needed! All operations through Supabase cloud.
npm run db:check-schema  # Validate database schema
npm run db:check-data    # Show table structures and data counts
npm run migrate:up       # Apply migrations
npm run migrate:down     # Rollback migrations
npm run seed:all         # Seed all data
npm run db:types         # Generate TypeScript types from database
```

### Testing Commands
```bash
npm run test             # Run all tests
npm run test:watch       # Watch mode
npm run test:coverage    # Generate coverage report
npm run test:api         # API endpoint tests only
npm run test:security    # Security testing
```

### Windows Port Management
```bash
npm run port:check       # Check if port 5000 is available
npm run port:kill        # Kill process using port 5000
```

## High-Level Architecture

### Database Layer (Supabase PostgreSQL)

**Cloud-Native Architecture**: Fully serverless PostgreSQL database managed by Supabase.

**Primary Database Library** (`src/lib/db-unified.ts`)

This is the **actual** database layer consolidating all Supabase operations. The file provides:

1. **Three Supabase Client Types**:
```typescript
// Browser client for client-side operations
export const createSupabaseBrowserClient = () =>
  createBrowserClient<Database>(supabaseUrl!, supabaseAnonKey!);

// Standard client with session persistence
export const supabase: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl!,
  supabaseAnonKey!,
  {
    auth: { persistSession: true, autoRefreshToken: true },
    db: { schema: 'public' }
  }
);

// Admin client (bypasses RLS) - server-side only!
export const supabaseAdmin: SupabaseClient<Database> = createClient<Database>(
  supabaseUrl!,
  supabaseServiceRole || supabaseAnonKey!,
  {
    auth: { persistSession: false, autoRefreshToken: false }
  }
);

// Factory function for consistent client access
export function getSupabaseClient(): SupabaseClient<Database> {
  if (!clientInstance) {
    clientInstance = supabaseAdmin;
  }
  return clientInstance;
}
```

2. **Centralized Error Handling**:
```typescript
// Standardized error response format
export function handleSupabaseError(
  operation: string,
  table: string,
  error: PostgrestError | Error | any
): SupabaseResponse<never> {
  const errorMessage = error?.message || String(error);
  console.error(`[Supabase] ${table}.${operation} failed:`, {
    message: errorMessage,
    code: error?.code,
    details: error?.details,
    hint: error?.hint,
  });
  return { success: false, error: errorMessage };
}

// Standardized success response
export function createSuccessResponse<T>(
  data: T,
  count?: number
): SupabaseResponse<T> {
  return {
    success: true,
    data,
    ...(count !== undefined && { count }),
  };
}

// Async error wrapper
export async function tryCatchWrapper<T>(
  operation: string,
  asyncFn: () => Promise<SupabaseResponse<T>>
): Promise<SupabaseResponse<T>> {
  try {
    return await asyncFn();
  } catch (error) {
    return handleException(operation, error);
  }
}
```

3. **SupabaseQueryBuilder Pattern** (eliminates 60% code duplication):
```typescript
export class SupabaseQueryBuilder {
  async select<T>(table: string, options: QueryOptions = {}): Promise<SupabaseResponse<T[]>> {
    // Generic SELECT with pagination, filters, search
  }

  async insert<T>(table: string, values: any | any[]): Promise<SupabaseResponse<T>> {
    // Generic INSERT with single or bulk operations
  }

  async update<T>(table: string, id: number, values: any): Promise<SupabaseResponse<T>> {
    // Generic UPDATE by ID
  }

  async delete(table: string, id: number, softDelete: boolean = true): Promise<SupabaseResponse<any>> {
    // Generic DELETE with soft delete support (is_active = false)
  }
}

// Usage example
const queryBuilder = new SupabaseQueryBuilder();
const result = await queryBuilder.select('items', {
  filters: { is_active: true },
  search: { field: 'item_name', value: '부품' },
  pagination: { page: 1, limit: 20 },
  orderBy: { field: 'item_name', ascending: true }
});
```

4. **Domain-Specific Helpers**:
```typescript
export const db = {
  items: {
    getAll: async (options) => { /* ... */ },
    getById: async (id) => { /* ... */ },
    checkDuplicateCode: async (itemCode) => { /* ... */ },
    create: async (item) => { /* ... */ },
    update: async (id, item) => { /* ... */ },
    delete: async (id) => { /* ... */ }
  },
  companies: { /* similar CRUD operations */ },
  transactions: { /* transaction-specific operations */ },
  bom: { /* BOM-specific operations */ }
};

// Usage in API routes
import { db } from '@/lib/db-unified';
const items = await db.items.getAll({ filters: { is_active: true } });
```

**Supabase MCP Server** (`src/lib/supabase-mcp.ts`)
- Complex SQL queries via Model Context Protocol
- Multi-table JOINs and aggregations
- Window functions and advanced PostgreSQL features
- Use when Supabase client isn't sufficient

### API Architecture (`src/app/api/`)

**Route Organization**:
- `/api/items` - Item master data CRUD
- `/api/companies` - Company master data with bilingual support
- `/api/bom` - Bill of Materials with multi-level support
- `/api/inventory/*` - Transaction processing (receiving/production/shipping)
- `/api/stock/*` - Stock queries, history, and adjustments
- `/api/dashboard/*` - Real-time stats, charts, and alerts
- `/api/upload/*` - Excel template upload processing
- `/api/download/template/*` - Excel template downloads
- `/api/export/*` - Data export to Excel with Korean headers

**Consistent Response Format**:
```typescript
{
  success: boolean;
  data?: any;
  error?: string;
  pagination?: { page, limit, totalPages, totalCount }
}
```

**Error Handling** (`src/lib/errorHandler.ts`)
- Centralized error types: `DATABASE`, `VALIDATION`, `BUSINESS`, `AUTHENTICATION`, `AUTHORIZATION`, `NOT_FOUND`
- Structured error responses with correlation IDs

**Validation Middleware** (`src/lib/validationMiddleware.ts`)
- `createValidatedRoute()`: Wraps API routes with validation
- Schema validation using Zod (`src/lib/validation.ts`)

**Pagination System** (`src/lib/pagination.ts`)
- Consistent pagination across all list endpoints
- Default page size: 20, max: 100

### Frontend Component Architecture

**Layout System** (`src/components/layout/`)
- `MainLayout`: Responsive sidebar, dark mode toggle, Korean localization
- `Sidebar`: Navigation with active route highlighting
- `Header`: App title, user info, dark mode controls

**Form Components**: Reusable forms with modal wrapper, validation, Toast integration

**State Management**: React hooks, native fetch, React Query for server state caching

**UI Components** (`src/components/ui/`)
- `VirtualTable`, `VirtualGrid`: Performance-optimized large datasets
- `Toast`: Context-based notifications
- `LoadingSpinner`, `Skeleton`: Loading states
- Dark mode support across all components

**Dashboard System** (`src/components/dashboard/`)
- `RealTimeDashboard`: Configurable auto-refresh (1/5/10/15/30 min)
- `KPICards`: Metrics with trend indicators
- `StockChart`, `TransactionChart`: Chart.js and Recharts integration
- `AlertPanel`: Low stock and system alerts

**Excel Integration** (`src/lib/excel-utils.ts`)
- XLSX (SheetJS) for Excel file processing
- Template-based uploads with validation
- Export with Korean column headers

## Phase 1 & 2: Complete ERP System (Production Ready)

### Phase 1: Sales/Purchase/Collections/Payments (95% Complete)

**Status**: Production ready with 8,500+ lines across 12 API routes, 4 export APIs, 4 UI pages.

### Critical Korean Text Handling Pattern

**ALL POST/PUT APIs MUST use this pattern** for proper UTF-8 encoding:
```typescript
// ✅ CORRECT - Prevents Korean character corruption
const text = await request.text();
const data = JSON.parse(text);

// ❌ WRONG - Causes Korean character issues
const data = await request.json();
```

**Verification**: Lines confirmed in:
- `src/app/api/purchase-transactions/[id]/route.ts:91-93`
- `src/app/api/companies/route.example.ts:103-105`
- All Phase 1 API routes use this pattern

### Auto Payment Status Calculation

**Sales Transactions** - Auto-computed from `collected_amount`:
```typescript
if (collected_amount === 0) payment_status = 'PENDING';
else if (collected_amount < total_amount) payment_status = 'PARTIAL';
else payment_status = 'COMPLETED';
```

**Purchase Transactions** - Auto-computed from `paid_amount`:
```typescript
if (paid_amount === 0) payment_status = 'PENDING';
else if (paid_amount < total_amount) payment_status = 'PARTIAL';
else payment_status = 'COMPLETED';
```

**Database Trigger**: Status updates automatically on collection/payment insert.

### Three-Sheet Excel Export Pattern

**All 4 export APIs** (sales, purchases, collections, payments) use this pattern:
```typescript
import * as XLSX from 'xlsx';

// Sheet 1: Metadata
const metadataSheet = XLSX.utils.aoa_to_sheet([
  ['내보내기 정보', ''],
  ['내보낸 날짜', new Date().toLocaleString('ko-KR')],
  ['총 레코드 수', data.length]
]);

// Sheet 2: Statistics
const statsSheet = XLSX.utils.aoa_to_sheet([
  ['통계 항목', '값'],
  ['총 금액', totalAmount.toLocaleString('ko-KR')],
  // ... more stats
]);

// Sheet 3: Data with Korean headers
const koreanData = data.map(row => ({
  '거래ID': row.transaction_id,
  '거래번호': row.transaction_no,
  '고객사명': row.customer?.company_name || ''
  // ... more columns
}));
const worksheet = XLSX.utils.json_to_sheet(koreanData);

// Assemble workbook
XLSX.utils.book_append_sheet(workbook, metadataSheet, '내보내기 정보');
XLSX.utils.book_append_sheet(workbook, statsSheet, '통계');
XLSX.utils.book_append_sheet(workbook, worksheet, '거래 내역');
```

**Files**: `src/app/api/export/sales/route.ts`, `export/purchases/route.ts`, `export/collections/route.ts`, `export/payments/route.ts`

### Bilingual Company Type Mapping

Automatic mapping between Korean and English for company types:
```typescript
const typeMapping: { [key: string]: string } = {
  '고객사': '고객사',
  '공급사': '공급사',
  '협력사': '협력사',
  '기타': '기타',
  'CUSTOMER': '고객사',
  'SUPPLIER': '공급사',
  'PARTNER': '협력사',
  'OTHER': '기타'
};

const normalizedType = typeMapping[company_type];
```

**File**: `src/app/api/companies/route.example.ts:135-144`

### Phase 2: Accounting Module (100% Complete)

**Status**: Production ready with 1,865 lines of test code (100% API coverage)

#### Database Schema Extensions

**companies Table Additions**:
```sql
company_category VARCHAR(50)
  CHECK (company_category IN ('협력업체-원자재', '협력업체-외주', '소모품업체', '기타'))
business_info JSONB  -- {business_type, business_item, main_products}
```

**Indexes**:
```sql
CREATE INDEX idx_companies_category ON companies(company_category) WHERE is_active = true;
CREATE INDEX idx_companies_business_info ON companies USING gin(business_info);
```

**PostgreSQL Views** (2 views for accounting aggregations):
- `v_monthly_accounting` - Monthly company-wise aggregations with sales/purchases/collections/payments
- `v_category_monthly_summary` - Monthly category-wise aggregations for business analytics

#### API Endpoints (5 total)

**New Accounting APIs** (3):
- `/api/accounting/monthly` - GET: Monthly accounting aggregations query with date range filtering
- `/api/accounting/summary` - GET: Overall accounting summary statistics with category breakdowns
- `/api/accounting/category` - GET: Category-wise monthly aggregations for dashboard analytics

**Extended APIs** (2):
- `/api/companies` (POST/PUT) - Added `company_category` and `business_info` JSONB support with validation

#### Auto company_code Generation

```typescript
const prefixMap: Record<string, string> = {
  '고객사': 'CUS',
  '공급사': 'SUP',
  '협력사': 'PAR',
  '기타': 'OTH'
};
// Generates: CUS001, CUS002, SUP001, SUP002, etc.
// File: src/app/api/companies/route.ts:175-202
```

#### business_info JSONB Structure

```typescript
business_info: {
  business_type?: string;      // 업종 (예: 제조업, 무역업)
  business_item?: string;      // 업태 (예: 철강, 기계)
  main_products?: string;      // 주요 취급 품목
}
```

**Query Pattern**:
```typescript
// Search within JSONB fields
await supabase
  .from('companies')
  .select('*')
  .contains('business_info', { business_type: '제조업' });

// GIN index optimized for fast JSONB queries
```

#### Test Coverage

**1,865 lines across 4 test suites**:
- `src/__tests__/api/accounting.test.ts` (383 lines) - API integration tests with Korean data
- `src/__tests__/lib/korean-encoding.test.ts` (499 lines) - UTF-8 encoding validation
- `src/__tests__/performance/accounting.test.ts` (459 lines) - Performance benchmarks
- `src/__tests__/database/phase2-views.test.ts` (524 lines) - PostgreSQL view validation

**Coverage**: 100% for Phase 2 APIs (5/5 endpoints tested)

#### Performance Metrics
- Accounting API response: ~180ms (complex aggregations with JOINs)
- Database views: <200ms (materialized view candidates)
- JSONB queries: <150ms (GIN index optimized)
- POST /api/companies: Initial ~1.8s, subsequent ~800ms (auto-increment query caching)

#### Bug Fixes & Improvements

**Bug 1 - payment_terms Column Error** (FIXED):
- **Location**: `src/app/api/companies/route.ts`
- **Issue**: Undefined column in INSERT statement causing SQL errors
- **Fix**: Removed from 3 locations: JSDoc (line 122), destructuring (line 146), INSERT (line 189)

**Bug 2 - company_code Auto-Generation** (IMPLEMENTED):
- **Location**: `src/app/api/companies/route.ts:175-202`
- **Feature**: Prefix-based generation with automatic incrementing per company type
- **Logic**: Queries max existing code per prefix, increments, pads to 3 digits

**Improvement - Korean Encoding Robustness**:
- **Test Suite**: 499-line dedicated test suite for Korean character handling
- **Validation**: Confirms `request.text()` + `JSON.parse()` pattern prevents corruption
- **Coverage**: All Phase 2 POST/PUT endpoints validated

## Key Technical Patterns

### Database Query Patterns

#### Simple Queries (Supabase Client via db-unified.ts)
```typescript
import { getSupabaseClient } from '@/lib/db-unified';
const supabase = getSupabaseClient();

// Select with filtering
const { data, error } = await supabase
  .from('items')
  .select('*')
  .eq('is_active', true)
  .order('item_name');

// Insert
const { data, error } = await supabase
  .from('items')
  .insert({ item_name: '부품A', spec: 'SPEC-001' })
  .select()
  .single();
```

#### Complex Queries (Supabase MCP)
```typescript
import { mcp__supabase__execute_sql } from '@/lib/supabase-mcp';

const result = await mcp__supabase__execute_sql({
  project_id: process.env.SUPABASE_PROJECT_ID!,
  query: `
    SELECT i.item_id, i.item_name, i.current_stock,
           c.company_name as supplier_name
    FROM items i
    LEFT JOIN companies c ON i.supplier_id = c.company_id
    WHERE i.is_active = true
    ORDER BY i.item_name
  `
});
```

#### Using SupabaseQueryBuilder
```typescript
import { SupabaseQueryBuilder } from '@/lib/db-unified';
const queryBuilder = new SupabaseQueryBuilder();

// Select with dynamic options
const result = await queryBuilder.select('items', {
  filters: { is_active: true, category: 'Parts' },
  search: { field: 'item_name', value: '부품' },
  pagination: { page: 1, limit: 20 },
  orderBy: { field: 'item_name', ascending: true }
});

// Insert with automatic success/error handling
const insertResult = await queryBuilder.insert('items', {
  item_name: '신규부품',
  item_code: 'NEW001',
  is_active: true
});
```

#### Using Domain Helpers
```typescript
import { db } from '@/lib/db-unified';

// Get all items with filters
const items = await db.items.getAll({
  filters: { is_active: true },
  orderBy: { field: 'item_name', ascending: true }
});

// Create new item
const newItem = await db.items.create({
  item_name: '신규부품',
  item_code: 'NEW001'
});

// Check for duplicate
const isDuplicate = await db.items.checkDuplicateCode('NEW001');
```

#### Transaction Pattern
```typescript
// PostgreSQL transactions with Supabase
const { data, error } = await supabase.rpc('create_production_transaction', {
  p_item_id: itemId,
  p_quantity: quantity,
  p_reference_no: referenceNo
});
```

### Validated Route Pattern
```typescript
export const POST = createValidatedRoute(
  async (request) => {
    const { body } = getValidatedData(request);
    return createSuccessResponse(result);
  },
  {
    bodySchema: ItemCreateSchema,
    resource: 'items',
    action: 'create',
    requireAuth: false
  }
);
```

### Dynamic Query Building
```typescript
import { getSupabaseClient } from '@/lib/db-unified';
const supabase = getSupabaseClient();

let query = supabase
  .from('items')
  .select('*, supplier:companies!supplier_id(company_name)')
  .eq('is_active', true);

if (search) query = query.ilike('item_name', `%${search}%`);
if (category) query = query.eq('category', category);
if (minStock !== undefined) query = query.gte('current_stock', minStock);

query = query.order('item_name').range(offset, offset + limit - 1);
const { data, error } = await query;
```

## Critical Configuration

### Supabase Configuration

**Environment Variables Required:**
```env
NEXT_PUBLIC_SUPABASE_URL=https://your-project-ref.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
SUPABASE_PROJECT_ID=your-project-id
NEXT_PUBLIC_API_URL=http://localhost:5000
JWT_SECRET=your-jwt-secret
SESSION_SECRET=your-session-secret
```

**Getting Credentials**:
1. Go to [Supabase Dashboard](https://supabase.com/dashboard)
2. Select your project → Settings → API
3. Copy: Project URL, anon public key, service_role key, Project ID

**Security Notes**:
- Never commit `.env` files to version control
- `SUPABASE_SERVICE_ROLE_KEY` bypasses RLS - server-side only!
- `NEXT_PUBLIC_*` variables exposed to browser - no secrets!

### Windows Development Issues

**Port Conflicts**: Use `npm run restart` for clean restarts with automatic port cleanup

**File System Error -4094**: Webpack caching disabled, polling enabled, use `npm run dev:safe` for stable starts

**Polling Configuration**: Pre-configured in `next.config.ts` (poll: 5000ms, aggregateTimeout: 2000ms)

## Testing Strategy

- Unit tests: `src/__tests__/lib/` - Utility and helper functions
- API tests: `src/__tests__/api/` - Endpoint integration tests
- Setup: `src/__tests__/setup.js` - Test environment configuration
- Coverage Target: >80% for critical business logic

## Security Considerations

- **SQL Injection Prevention**: All queries use prepared statements
- **XSS Protection**: React's built-in escaping + sanitization
- **CSRF**: NextJS built-in protection for same-origin requests
- **Input Validation**: Server-side Zod schema validation on all endpoints
- **Authentication**: Planned but not yet implemented (all routes set `requireAuth: false`)
- **Soft Deletes**: Use `is_active = 0` for audit trail preservation

## Performance Optimization

### Database Performance
- Connection Pooling: Supabase automatic pooling with pgBouncer
- Indexes: PostgreSQL indexes on frequently queried columns
- Query Optimization: Use db-unified.ts helpers for common patterns, MCP for complex JOINs
- Real-time Subscriptions: WebSocket connections for live updates
- SupabaseQueryBuilder: Eliminates 60% code duplication with reusable patterns

### Frontend Performance
- Virtual Scrolling: `@tanstack/react-virtual` for large datasets (>100 rows)
- Lazy Loading: Components lazy-load to reduce initial bundle
- Code Splitting: Automatic route-based splitting with Next.js 15
- Caching: React Query for server state with stale-while-revalidate
- Real-time Updates: Dashboard configurable refresh to balance freshness vs. load

## Main Application Routes

- `/` - Real-time dashboard with KPIs, charts, and alerts
- `/master/items` - Item management with Excel upload/export
- `/master/companies` - Company management with bilingual support
- `/master/bom` - Bill of Materials with multi-level viewing
- `/inventory` - Inventory transactions (tabbed: receiving/production/shipping)
- `/stock` - Stock status, history, and adjustment system

## Implementation Status

- **Completion**: 97% - Production ready (Phase 1: 95%, Phase 2: 100%)
- **System Score**: 97/100
- **Database**: ✅ Supabase PostgreSQL cloud-native + JSONB + Views
- **Phase 1**: ✅ Sales/Purchase/Collections/Payments (8,500+ lines, 12 APIs, 4 exports)
- **Phase 2**: ✅ Accounting Module (5 APIs, 2 PostgreSQL views, 1,865 test lines, 100% coverage)
- **Core Features**: ✅ Master data, inventory, BOM, Excel, real-time dashboard, accounting
- **API Layer**: ✅ All CRUD endpoints with validation + accounting aggregations
- **Performance**: ✅ Virtual scrolling, caching, optimized queries, JSONB indexing
- **Pending**: Authentication/RBAC system, advanced reporting, document attachments

## Supabase Best Practices

### When to Use Supabase Client vs MCP

**Use Supabase Client** (`src/lib/db-unified.ts`) for:
- Simple CRUD operations (select, insert, update, delete)
- Single table queries with basic filtering
- Real-time subscriptions
- Client-side operations with RLS
- Operations needing type safety from generated types
- Using SupabaseQueryBuilder for reusable patterns
- Using domain helpers (db.items, db.companies, etc.)

**Use Supabase MCP** (`src/lib/supabase-mcp.ts`) for:
- Complex multi-table JOINs
- Aggregations with GROUP BY, window functions
- Custom SQL with CTEs (Common Table Expressions)
- Bulk operations requiring raw SQL performance
- Advanced PostgreSQL features (arrays, JSONB, full-text search)

### PostgreSQL-Specific Features

**JSONB Support**:
```typescript
const { data } = await supabase
  .from('items')
  .select('metadata')
  .contains('metadata', { category: 'electronics' });
```

**Array Operations**:
```typescript
const { data } = await supabase
  .from('items')
  .select('*')
  .contains('tags', ['important', 'urgent']);
```

**Full-Text Search**:
```typescript
const { data } = await supabase
  .from('items')
  .select('*')
  .textSearch('item_name', 'motor & gear');
```

### Row Level Security (RLS)

When authentication is implemented, enable RLS policies:
```sql
CREATE POLICY "Users can view active items"
  ON items FOR SELECT
  USING (is_active = true);

CREATE POLICY "Admin can manage all items"
  ON items FOR ALL
  USING (auth.jwt() ->> 'role' = 'admin');
```

## Path Aliases

TypeScript path mapping configured in `tsconfig.json`:
```typescript
"@/*": ["./src/*"]
```

Use `@/lib/db-unified` instead of relative paths for cleaner imports.
